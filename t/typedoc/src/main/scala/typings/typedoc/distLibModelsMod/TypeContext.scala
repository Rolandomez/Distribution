package typings.typedoc.distLibModelsMod

import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object TypeContext {
  
  @JSImport("typedoc/dist/lib/models", "TypeContext.arrayElement")
  @js.native
  val arrayElement: typings.typedoc.typedocStrings.arrayElement = js.native
  
  @JSImport("typedoc/dist/lib/models", "TypeContext.conditionalCheck")
  @js.native
  val conditionalCheck: typings.typedoc.typedocStrings.conditionalCheck = js.native
  
  @JSImport("typedoc/dist/lib/models", "TypeContext.conditionalExtends")
  @js.native
  val conditionalExtends: typings.typedoc.typedocStrings.conditionalExtends = js.native
  
  @JSImport("typedoc/dist/lib/models", "TypeContext.conditionalFalse")
  @js.native
  val conditionalFalse: typings.typedoc.typedocStrings.conditionalFalse = js.native
  
  @JSImport("typedoc/dist/lib/models", "TypeContext.conditionalTrue")
  @js.native
  val conditionalTrue: typings.typedoc.typedocStrings.conditionalTrue = js.native
  
  @JSImport("typedoc/dist/lib/models", "TypeContext.indexedAccessElement")
  @js.native
  val indexedAccessElement: typings.typedoc.typedocStrings.indexedAccessElement = js.native
  
  @JSImport("typedoc/dist/lib/models", "TypeContext.indexedIndex")
  @js.native
  val indexedIndex: typings.typedoc.typedocStrings.indexedIndex = js.native
  
  @JSImport("typedoc/dist/lib/models", "TypeContext.indexedObject")
  @js.native
  val indexedObject: typings.typedoc.typedocStrings.indexedObject = js.native
  
  @JSImport("typedoc/dist/lib/models", "TypeContext.inferredConstraint")
  @js.native
  val inferredConstraint: typings.typedoc.typedocStrings.inferredConstraint = js.native
  
  @JSImport("typedoc/dist/lib/models", "TypeContext.intersectionElement")
  @js.native
  val intersectionElement: typings.typedoc.typedocStrings.intersectionElement = js.native
  
  @JSImport("typedoc/dist/lib/models", "TypeContext.mappedName")
  @js.native
  val mappedName: typings.typedoc.typedocStrings.mappedName = js.native
  
  @JSImport("typedoc/dist/lib/models", "TypeContext.mappedParameter")
  @js.native
  val mappedParameter: typings.typedoc.typedocStrings.mappedParameter = js.native
  
  @JSImport("typedoc/dist/lib/models", "TypeContext.mappedTemplate")
  @js.native
  val mappedTemplate: typings.typedoc.typedocStrings.mappedTemplate = js.native
  
  @JSImport("typedoc/dist/lib/models", "TypeContext.none")
  @js.native
  val none: typings.typedoc.typedocStrings.none = js.native
  
  @JSImport("typedoc/dist/lib/models", "TypeContext.optionalElement")
  @js.native
  val optionalElement: typings.typedoc.typedocStrings.optionalElement = js.native
  
  @JSImport("typedoc/dist/lib/models", "TypeContext.predicateTarget")
  @js.native
  val predicateTarget: typings.typedoc.typedocStrings.predicateTarget = js.native
  
  @JSImport("typedoc/dist/lib/models", "TypeContext.queryTypeTarget")
  @js.native
  val queryTypeTarget: typings.typedoc.typedocStrings.queryTypeTarget = js.native
  
  @JSImport("typedoc/dist/lib/models", "TypeContext.referenceTypeArgument")
  @js.native
  val referenceTypeArgument: typings.typedoc.typedocStrings.referenceTypeArgument = js.native
  
  @JSImport("typedoc/dist/lib/models", "TypeContext.restElement")
  @js.native
  val restElement: typings.typedoc.typedocStrings.restElement = js.native
  
  @JSImport("typedoc/dist/lib/models", "TypeContext.templateLiteralElement")
  @js.native
  val templateLiteralElement: typings.typedoc.typedocStrings.templateLiteralElement = js.native
  
  @JSImport("typedoc/dist/lib/models", "TypeContext.tupleElement")
  @js.native
  val tupleElement: typings.typedoc.typedocStrings.tupleElement = js.native
  
  @JSImport("typedoc/dist/lib/models", "TypeContext.typeOperatorTarget")
  @js.native
  val typeOperatorTarget: typings.typedoc.typedocStrings.typeOperatorTarget = js.native
  
  @JSImport("typedoc/dist/lib/models", "TypeContext.unionElement")
  @js.native
  val unionElement: typings.typedoc.typedocStrings.unionElement = js.native
}
