package typings.three

import typings.three.threeStrings.abs
import typings.three.threeStrings.acos
import typings.three.threeStrings.asin
import typings.three.threeStrings.atan
import typings.three.threeStrings.atan2
import typings.three.threeStrings.ceil
import typings.three.threeStrings.clamp
import typings.three.threeStrings.cos
import typings.three.threeStrings.cross
import typings.three.threeStrings.dFdx
import typings.three.threeStrings.dFdy
import typings.three.threeStrings.degrees
import typings.three.threeStrings.distance
import typings.three.threeStrings.dot
import typings.three.threeStrings.exp
import typings.three.threeStrings.exp2
import typings.three.threeStrings.faceforward
import typings.three.threeStrings.floor
import typings.three.threeStrings.fract
import typings.three.threeStrings.inversesqrt
import typings.three.threeStrings.invert
import typings.three.threeStrings.length
import typings.three.threeStrings.log
import typings.three.threeStrings.log2
import typings.three.threeStrings.max
import typings.three.threeStrings.min
import typings.three.threeStrings.mix
import typings.three.threeStrings.negate
import typings.three.threeStrings.normalize
import typings.three.threeStrings.pow
import typings.three.threeStrings.radians
import typings.three.threeStrings.reflect
import typings.three.threeStrings.refract
import typings.three.threeStrings.round
import typings.three.threeStrings.saturate
import typings.three.threeStrings.sign
import typings.three.threeStrings.sin
import typings.three.threeStrings.smoothstep
import typings.three.threeStrings.sqrt
import typings.three.threeStrings.step
import typings.three.threeStrings.tan
import typings.three.threeStrings.transformDirection
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object mathNodeMod {
  
  @JSImport("three/examples/jsm/nodes/math/MathNode", JSImport.Default)
  @js.native
  open class default protected () extends MathNode {
    def this(method: MathNodeMethod1, aNode: typings.three.nodeMod.default) = this()
    def this(
      method: MathNodeMethod2,
      aNode: typings.three.nodeMod.default,
      bNode: typings.three.nodeMod.default
    ) = this()
    def this(
      method: MathNodeMethod3,
      aNode: typings.three.nodeMod.default,
      bNode: typings.three.nodeMod.default,
      cNode: typings.three.nodeMod.default
    ) = this()
  }
  /* static members */
  object default {
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", JSImport.Default)
    @js.native
    val ^ : js.Any = js.native
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.ABS")
    @js.native
    def ABS: abs = js.native
    inline def ABS_=(x: abs): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ABS")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.ACOS")
    @js.native
    def ACOS: acos = js.native
    inline def ACOS_=(x: acos): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ACOS")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.ASIN")
    @js.native
    def ASIN: asin = js.native
    inline def ASIN_=(x: asin): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ASIN")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.ATAN")
    @js.native
    def ATAN: atan = js.native
    
    // 2 inputs
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.ATAN2")
    @js.native
    def ATAN2: atan2 = js.native
    inline def ATAN2_=(x: atan2): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ATAN2")(x.asInstanceOf[js.Any])
    
    inline def ATAN_=(x: atan): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ATAN")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.CEIL")
    @js.native
    def CEIL: ceil = js.native
    inline def CEIL_=(x: ceil): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CEIL")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.CLAMP")
    @js.native
    def CLAMP: clamp = js.native
    inline def CLAMP_=(x: clamp): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CLAMP")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.COS")
    @js.native
    def COS: cos = js.native
    inline def COS_=(x: cos): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("COS")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.CROSS")
    @js.native
    def CROSS: cross = js.native
    inline def CROSS_=(x: cross): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CROSS")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.DEGREES")
    @js.native
    def DEGREES: degrees = js.native
    inline def DEGREES_=(x: degrees): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DEGREES")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.DFDX")
    @js.native
    def DFDX: dFdx = js.native
    inline def DFDX_=(x: dFdx): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DFDX")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.DFDY")
    @js.native
    def DFDY: dFdy = js.native
    inline def DFDY_=(x: dFdy): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DFDY")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.DISTANCE")
    @js.native
    def DISTANCE: distance = js.native
    inline def DISTANCE_=(x: distance): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DISTANCE")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.DOT")
    @js.native
    def DOT: dot = js.native
    inline def DOT_=(x: dot): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DOT")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.EXP")
    @js.native
    def EXP: exp = js.native
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.EXP2")
    @js.native
    def EXP2: exp2 = js.native
    inline def EXP2_=(x: exp2): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("EXP2")(x.asInstanceOf[js.Any])
    
    inline def EXP_=(x: exp): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("EXP")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.FACEFORWARD")
    @js.native
    def FACEFORWARD: faceforward = js.native
    inline def FACEFORWARD_=(x: faceforward): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FACEFORWARD")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.FLOOR")
    @js.native
    def FLOOR: floor = js.native
    inline def FLOOR_=(x: floor): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FLOOR")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.FRACT")
    @js.native
    def FRACT: fract = js.native
    inline def FRACT_=(x: fract): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FRACT")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.INVERSE_SQRT")
    @js.native
    def INVERSE_SQRT: inversesqrt = js.native
    inline def INVERSE_SQRT_=(x: inversesqrt): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("INVERSE_SQRT")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.INVERT")
    @js.native
    def INVERT: invert = js.native
    inline def INVERT_=(x: invert): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("INVERT")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.LENGTH")
    @js.native
    def LENGTH: length = js.native
    inline def LENGTH_=(x: length): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("LENGTH")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.LOG")
    @js.native
    def LOG: log = js.native
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.LOG2")
    @js.native
    def LOG2: log2 = js.native
    inline def LOG2_=(x: log2): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("LOG2")(x.asInstanceOf[js.Any])
    
    inline def LOG_=(x: log): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("LOG")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.MAX")
    @js.native
    def MAX: max = js.native
    inline def MAX_=(x: max): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MAX")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.MIN")
    @js.native
    def MIN: min = js.native
    inline def MIN_=(x: min): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MIN")(x.asInstanceOf[js.Any])
    
    // 3 inputs
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.MIX")
    @js.native
    def MIX: mix = js.native
    inline def MIX_=(x: mix): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MIX")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.MOD")
    @js.native
    def MOD: typings.three.threeStrings.mod = js.native
    inline def MOD_=(x: typings.three.threeStrings.mod): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MOD")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.NEGATE")
    @js.native
    def NEGATE: negate = js.native
    inline def NEGATE_=(x: negate): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NEGATE")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.NORMALIZE")
    @js.native
    def NORMALIZE: normalize = js.native
    inline def NORMALIZE_=(x: normalize): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NORMALIZE")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.POW")
    @js.native
    def POW: pow = js.native
    inline def POW_=(x: pow): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("POW")(x.asInstanceOf[js.Any])
    
    // 1 input
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.RADIANS")
    @js.native
    def RADIANS: radians = js.native
    inline def RADIANS_=(x: radians): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("RADIANS")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.REFLECT")
    @js.native
    def REFLECT: reflect = js.native
    inline def REFLECT_=(x: reflect): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("REFLECT")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.REFRACT")
    @js.native
    def REFRACT: refract = js.native
    inline def REFRACT_=(x: refract): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("REFRACT")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.ROUND")
    @js.native
    def ROUND: round = js.native
    inline def ROUND_=(x: round): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ROUND")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.SATURATE")
    @js.native
    def SATURATE: saturate = js.native
    inline def SATURATE_=(x: saturate): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SATURATE")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.SIGN")
    @js.native
    def SIGN: sign = js.native
    inline def SIGN_=(x: sign): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SIGN")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.SIN")
    @js.native
    def SIN: sin = js.native
    inline def SIN_=(x: sin): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SIN")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.SMOOTHSTEP")
    @js.native
    def SMOOTHSTEP: smoothstep = js.native
    inline def SMOOTHSTEP_=(x: smoothstep): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SMOOTHSTEP")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.SQRT")
    @js.native
    def SQRT: sqrt = js.native
    inline def SQRT_=(x: sqrt): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SQRT")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.STEP")
    @js.native
    def STEP: step = js.native
    inline def STEP_=(x: step): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("STEP")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.TAN")
    @js.native
    def TAN: tan = js.native
    inline def TAN_=(x: tan): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("TAN")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.TRANSFORM_DIRECTION")
    @js.native
    def TRANSFORM_DIRECTION: transformDirection = js.native
    inline def TRANSFORM_DIRECTION_=(x: transformDirection): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("TRANSFORM_DIRECTION")(x.asInstanceOf[js.Any])
  }
  
  @js.native
  trait MathNode
    extends typings.three.tempNodeMod.default {
    
    var aNode: typings.three.nodeMod.default = js.native
    
    var bNode: typings.three.nodeMod.default | Null = js.native
    
    var cNode: typings.three.nodeMod.default | Null = js.native
    
    var method: MathNodeMethod = js.native
  }
  
  type MathNodeMethod = MathNodeMethod1 | MathNodeMethod2 | MathNodeMethod3
  
  type MathNodeMethod1 = /* import warning: ResolveTypeQueries.resolve Couldn't resolve typeof MathNode.RADIANS */ Any
  
  type MathNodeMethod2 = /* import warning: ResolveTypeQueries.resolve Couldn't resolve typeof MathNode.ATAN2 */ Any
  
  type MathNodeMethod3 = /* import warning: ResolveTypeQueries.resolve Couldn't resolve typeof MathNode.MIX */ Any
}
