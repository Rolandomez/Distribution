package typings.bufbuildProtobuf.distTypesGoogleProtobufDescriptorPbMod

import typings.bufbuildProtobuf.anon.PartialBinaryReadOptions
import typings.bufbuildProtobuf.anon.PartialJsonReadOptions
import typings.bufbuildProtobuf.anon.PartialMessageFileOptions
import typings.bufbuildProtobuf.anon.PlainMessageFileOptionsCcEnableArenas
import typings.bufbuildProtobuf.distTypesFieldListMod.FieldList
import typings.bufbuildProtobuf.distTypesJsonFormatMod.JsonValue
import typings.bufbuildProtobuf.distTypesMessageMod.Message
import typings.bufbuildProtobuf.distTypesPrivateProtoRuntimeMod.ProtoRuntime
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

@JSImport("@bufbuild/protobuf/dist/types/google/protobuf/descriptor_pb", "FileOptions")
@js.native
open class FileOptions () extends Message[FileOptions] {
  def this(data: PartialMessageFileOptions) = this()
  
  /**
    * Enables the use of arenas for the proto messages in this file. This applies
    * only to generated classes for C++.
    *
    * @generated from field: optional bool cc_enable_arenas = 31 [default = true];
    */
  var ccEnableArenas: js.UndefOr[Boolean] = js.native
  
  /**
    * Should generic services be generated in each language?  "Generic" services
    * are not specific to any particular RPC system.  They are generated by the
    * main code generators in each language (without additional plugins).
    * Generic services were the only kind of service generation supported by
    * early versions of google.protobuf.
    *
    * Generic services are now considered deprecated in favor of using plugins
    * that generate code specific to your particular RPC system.  Therefore,
    * these default to false.  Old code which depends on generic services should
    * explicitly set them to true.
    *
    * @generated from field: optional bool cc_generic_services = 16 [default = false];
    */
  var ccGenericServices: js.UndefOr[Boolean] = js.native
  
  /**
    * Namespace for generated classes; defaults to the package.
    *
    * @generated from field: optional string csharp_namespace = 37;
    */
  var csharpNamespace: js.UndefOr[String] = js.native
  
  /**
    * Is this file deprecated?
    * Depending on the target platform, this can emit Deprecated annotations
    * for everything in the file, or it will be completely ignored; in the very
    * least, this is a formalization for deprecating files.
    *
    * @generated from field: optional bool deprecated = 23 [default = false];
    */
  var deprecated: js.UndefOr[Boolean] = js.native
  
  /**
    * Sets the Go package where structs generated from this .proto will be
    * placed. If omitted, the Go package will be derived from the following:
    *   - The basename of the package import path, if provided.
    *   - Otherwise, the package statement in the .proto file, if present.
    *   - Otherwise, the basename of the .proto file, without extension.
    *
    * @generated from field: optional string go_package = 11;
    */
  var goPackage: js.UndefOr[String] = js.native
  
  /**
    * This option does nothing.
    *
    * @generated from field: optional bool java_generate_equals_and_hash = 20 [deprecated = true];
    * @deprecated
    */
  var javaGenerateEqualsAndHash: js.UndefOr[Boolean] = js.native
  
  /**
    * @generated from field: optional bool java_generic_services = 17 [default = false];
    */
  var javaGenericServices: js.UndefOr[Boolean] = js.native
  
  /**
    * If enabled, then the Java code generator will generate a separate .java
    * file for each top-level message, enum, and service defined in the .proto
    * file.  Thus, these types will *not* be nested inside the wrapper class
    * named by java_outer_classname.  However, the wrapper class will still be
    * generated to contain the file's getDescriptor() method as well as any
    * top-level extensions defined in the file.
    *
    * @generated from field: optional bool java_multiple_files = 10 [default = false];
    */
  var javaMultipleFiles: js.UndefOr[Boolean] = js.native
  
  /**
    * Controls the name of the wrapper Java class generated for the .proto file.
    * That class will always contain the .proto file's getDescriptor() method as
    * well as any top-level extensions defined in the .proto file.
    * If java_multiple_files is disabled, then all the other classes from the
    * .proto file will be nested inside the single wrapper outer class.
    *
    * @generated from field: optional string java_outer_classname = 8;
    */
  var javaOuterClassname: js.UndefOr[String] = js.native
  
  /**
    * Sets the Java package where classes generated from this .proto will be
    * placed.  By default, the proto package is used, but this is often
    * inappropriate because proto packages do not normally start with backwards
    * domain names.
    *
    * @generated from field: optional string java_package = 1;
    */
  var javaPackage: js.UndefOr[String] = js.native
  
  /**
    * If set true, then the Java2 code generator will generate code that
    * throws an exception whenever an attempt is made to assign a non-UTF-8
    * byte sequence to a string field.
    * Message reflection will do the same.
    * However, an extension field still accepts non-UTF-8 byte sequences.
    * This option has no effect on when used with the lite runtime.
    *
    * @generated from field: optional bool java_string_check_utf8 = 27 [default = false];
    */
  var javaStringCheckUtf8: js.UndefOr[Boolean] = js.native
  
  /**
    * Sets the objective c class prefix which is prepended to all objective c
    * generated classes from this .proto. There is no default.
    *
    * @generated from field: optional string objc_class_prefix = 36;
    */
  var objcClassPrefix: js.UndefOr[String] = js.native
  
  /**
    * @generated from field: optional google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];
    */
  var optimizeFor: js.UndefOr[FileOptionsOptimizeMode] = js.native
  
  /**
    * Sets the php class prefix which is prepended to all php generated classes
    * from this .proto. Default is empty.
    *
    * @generated from field: optional string php_class_prefix = 40;
    */
  var phpClassPrefix: js.UndefOr[String] = js.native
  
  /**
    * @generated from field: optional bool php_generic_services = 42 [default = false];
    */
  var phpGenericServices: js.UndefOr[Boolean] = js.native
  
  /**
    * Use this option to change the namespace of php generated metadata classes.
    * Default is empty. When this option is empty, the proto file name will be
    * used for determining the namespace.
    *
    * @generated from field: optional string php_metadata_namespace = 44;
    */
  var phpMetadataNamespace: js.UndefOr[String] = js.native
  
  /**
    * Use this option to change the namespace of php generated classes. Default
    * is empty. When this option is empty, the package name will be used for
    * determining the namespace.
    *
    * @generated from field: optional string php_namespace = 41;
    */
  var phpNamespace: js.UndefOr[String] = js.native
  
  /**
    * @generated from field: optional bool py_generic_services = 18 [default = false];
    */
  var pyGenericServices: js.UndefOr[Boolean] = js.native
  
  /**
    * Use this option to change the package of ruby generated classes. Default
    * is empty. When this option is not set, the package name will be used for
    * determining the ruby package.
    *
    * @generated from field: optional string ruby_package = 45;
    */
  var rubyPackage: js.UndefOr[String] = js.native
  
  /**
    * By default Swift generators will take the proto package and CamelCase it
    * replacing '.' with underscore and use that to prefix the types/symbols
    * defined. When this options is provided, they will use this value instead
    * to prefix the types/symbols defined.
    *
    * @generated from field: optional string swift_prefix = 39;
    */
  var swiftPrefix: js.UndefOr[String] = js.native
  
  /**
    * The parser stores options it doesn't recognize here.
    * See the documentation for the "Options" section above.
    *
    * @generated from field: repeated google.protobuf.UninterpretedOption uninterpreted_option = 999;
    */
  var uninterpretedOption: js.Array[UninterpretedOption] = js.native
}
/* static members */
object FileOptions {
  
  @JSImport("@bufbuild/protobuf/dist/types/google/protobuf/descriptor_pb", "FileOptions")
  @js.native
  val ^ : js.Any = js.native
  
  inline def equals(): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("equals")().asInstanceOf[Boolean]
  inline def equals(a: Unit, b: PlainMessageFileOptionsCcEnableArenas): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("equals")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[Boolean]
  inline def equals(a: Unit, b: FileOptions): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("equals")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[Boolean]
  inline def equals(a: PlainMessageFileOptionsCcEnableArenas): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("equals")(a.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  inline def equals(a: PlainMessageFileOptionsCcEnableArenas, b: PlainMessageFileOptionsCcEnableArenas): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("equals")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[Boolean]
  inline def equals(a: PlainMessageFileOptionsCcEnableArenas, b: FileOptions): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("equals")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[Boolean]
  inline def equals(a: FileOptions): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("equals")(a.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  inline def equals(a: FileOptions, b: PlainMessageFileOptionsCcEnableArenas): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("equals")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[Boolean]
  inline def equals(a: FileOptions, b: FileOptions): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("equals")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[Boolean]
  
  @JSImport("@bufbuild/protobuf/dist/types/google/protobuf/descriptor_pb", "FileOptions.fields")
  @js.native
  val fields: FieldList = js.native
  
  inline def fromBinary(bytes: js.typedarray.Uint8Array): FileOptions = ^.asInstanceOf[js.Dynamic].applyDynamic("fromBinary")(bytes.asInstanceOf[js.Any]).asInstanceOf[FileOptions]
  inline def fromBinary(bytes: js.typedarray.Uint8Array, options: PartialBinaryReadOptions): FileOptions = (^.asInstanceOf[js.Dynamic].applyDynamic("fromBinary")(bytes.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[FileOptions]
  
  inline def fromJson(jsonValue: JsonValue): FileOptions = ^.asInstanceOf[js.Dynamic].applyDynamic("fromJson")(jsonValue.asInstanceOf[js.Any]).asInstanceOf[FileOptions]
  inline def fromJson(jsonValue: JsonValue, options: PartialJsonReadOptions): FileOptions = (^.asInstanceOf[js.Dynamic].applyDynamic("fromJson")(jsonValue.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[FileOptions]
  
  inline def fromJsonString(jsonString: String): FileOptions = ^.asInstanceOf[js.Dynamic].applyDynamic("fromJsonString")(jsonString.asInstanceOf[js.Any]).asInstanceOf[FileOptions]
  inline def fromJsonString(jsonString: String, options: PartialJsonReadOptions): FileOptions = (^.asInstanceOf[js.Dynamic].applyDynamic("fromJsonString")(jsonString.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[FileOptions]
  
  @JSImport("@bufbuild/protobuf/dist/types/google/protobuf/descriptor_pb", "FileOptions.runtime")
  @js.native
  val runtime: ProtoRuntime = js.native
  
  @JSImport("@bufbuild/protobuf/dist/types/google/protobuf/descriptor_pb", "FileOptions.typeName")
  @js.native
  val typeName: /* "google.protobuf.FileOptions" */ String = js.native
}
