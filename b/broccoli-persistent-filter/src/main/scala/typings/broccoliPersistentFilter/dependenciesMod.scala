package typings.broccoliPersistentFilter

import typings.broccoliPersistentFilter.broccoliPersistentFilterStrings.external
import typings.broccoliPersistentFilter.broccoliPersistentFilterStrings.hash
import typings.broccoliPersistentFilter.broccoliPersistentFilterStrings.local
import typings.broccoliPersistentFilter.broccoliPersistentFilterStrings.stat
import typings.broccoliPersistentFilter.fsHashDiffMod.FSHashTree
import typings.fsMerger.anon.At
import typings.fsTreeDiff.entryMod.default
import typings.node.anon.StatSyncOptionsbigintbool
import typings.node.anon.StatSyncOptionsbigintfals
import typings.node.anon.StatSyncOptionsbigintfalsBigint
import typings.node.anon.StatSyncOptionsbiginttrue
import typings.node.anon.StatSyncOptionsbiginttrueBigint
import typings.node.bufferMod.global.Buffer
import typings.node.fsMod.BigIntStats
import typings.node.fsMod.PathLike
import typings.node.fsMod.PathOrFileDescriptor
import typings.node.fsMod.StatSyncFn
import typings.node.fsMod.StatSyncOptions
import typings.node.fsMod.Stats
import typings.std.Map
import typings.std.Record
import typings.std.Set
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object dependenciesMod {
  
  @JSImport("broccoli-persistent-filter/lib/dependencies", JSImport.Namespace)
  @js.native
  open class ^ protected ()
    extends StObject
       with Dependencies {
    /**
      * Creates an instance of Dependencies.
      * @param rootDir The root directory containing the files that
      *   have dependencies. Relative paths are resolved against this directory.
      * @param options options is used to pass the custom fs opertations implementations
      */
    def this(rootFS: FSFacade, inputEncoding: String) = this()
  }
  @JSImport("broccoli-persistent-filter/lib/dependencies", JSImport.Namespace)
  @js.native
  val ^ : js.Any = js.native
  
  /* static member */
  @JSImport("broccoli-persistent-filter/lib/dependencies", "__LOCAL_ROOT")
  @js.native
  def __LOCAL_ROOT: js.Symbol = js.native
  inline def __LOCAL_ROOT_=(x: js.Symbol): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("__LOCAL_ROOT")(x.asInstanceOf[js.Any])
  
  /**
    * Deserialize from JSON data returned from the `serialize` method.
    *
    * @param dependencyData {ReturnType<Dependencies['serialize']>}
    * @param [newRootDir] {string | undefined}
    * @param customFS {typeof fs}. A customFS method to support fs facade change in broccoli-plugin.
    * @return {Dependencies};
    */
  /* static member */
  inline def deserialize(dependencyData: SerializedDependencies, customFS: FSFacade, inputEncoding: String): Dependencies = (^.asInstanceOf[js.Dynamic].applyDynamic("deserialize")(dependencyData.asInstanceOf[js.Any], customFS.asInstanceOf[js.Any], inputEncoding.asInstanceOf[js.Any])).asInstanceOf[Dependencies]
  
  @js.native
  trait Dependencies extends StObject {
    
    def _getDepsForRoot(dir: String): Set[String] = js.native
    def _getDepsForRoot(dir: js.Symbol): Set[String] = js.native
    
    /**
      * Map of filesystem roots to unique dependencies on that filesystem. This
      * property is only populated once `seal()` is called. This allows us to
      * build an FSTree (which requires relative paths) per filesystem root.
      */
    /* private */ var allDependencies: Any = js.native
    
    /**
      * Get the dependency state and save it.
      * Dependencies must be sealed.
      * @returns {this}
      */
    def captureDependencyState(): this.type = js.native
    
    /**
      * Return a new, unsealed Dependencies that includes all the files and their
      * dependencies except for the files provided (and their dependencies) are
      * omitted.
      *
      * Note: this doesn't include the stat entries for the existing dependencies.
      *
      * @param files {Array<string>}
      * @returns {Dependencies}
      */
    def copyWithout(files: js.Array[String]): Dependencies = js.native
    
    def countAll(): Double = js.native
    
    /**
      * Counts the number of unique dependencies.
      *
      * @returns {number}
      */
    def countUnique(): Double = js.native
    
    /**
      * Tracks dependencies on a per file basis.
      *
      * The key is a relative path.
      *
      * The value is:
      *   - an absolute path if the Path tag is EXTERNAL_PATH.
      *   - an relative path if the Path tag is LOCAL_PATH.
      **/
    /* private */ var dependencyMap: Any = js.native
    
    /**
      * Maps dependencies to the local files that depend on them.
      * Keys that are relative are relative to the local tree. Absolute paths are
      * external to the local tree.
      * Values are paths relative to the local tree.
      */
    var dependentsMap: Map[String, js.Array[String]] = js.native
    
    /**
      * Map of filesystem roots to FSTrees, capturing the state of all
      * dependencies.
      */
    /* private */ var fsTrees: Any = js.native
    
    /**
      * Compute dependencies state as fsTrees.
      * @returns {Map<string, FSTree<Entry> | FSHashTree>} an fs tree per filesystem root.
      */
    def getDependencyState(): Map[String | js.Symbol, typings.fsTreeDiff.mod.^[default] | FSHashTree] = js.native
    
    /**
      * Returns the dependent files which have had a dependency change
      * since the last call to this method.
      * @returns {Array<string>} relative paths to the files that had a dependency change.
      */
    def getInvalidatedFiles(): js.Array[String] = js.native
    
    var inputEncoding: String = js.native
    
    /**
      * The root directory containing the files that have dependencies. Relative
      * paths are resolved against this directory.
      */
    /* private */ var rootFS: Any = js.native
    
    /**
      * Seals the dependencies. No more dependencies can be added once this is
      * called.
      * @return {this}
      */
    def seal(): this.type = js.native
    
    /**
      * Tracks whether new dependencies can be added.
      **/
    /* private */ var `sealed`: Any = js.native
    
    /**
      * Serialize to a simple, JSON-friendly object containing only the
      * data necessary for deserializing.
      *
      * This object is serializable so it can be put into the persistent cache and
      * used to invalidate files during the next build in a new process.
      * @return {{rootDir: string, dependencies: {[k: string]: string[]}, fsTrees: Array<{fsRoot: string, entries: Array<{relativePath: string} & ({type: 'stat', size: number, mtime: number, mode: number} | {type: 'hash', hash: string})>}>}}
      */
    def serialize(): SerializedDependencies = js.native
    
    /**
      * Set the dependencies for the file specified by `filePath`.
      *
      * @param filePath {string} relative path of the file that has dependencies.
      * @param dependencies {Array<string>} absolute or relative paths the file
      *   depends on. Relative paths are resolved relative to the directory
      *   containing the file that depends on them.
      */
    def setDependencies(filePath: String, dependencies: js.Array[String]): Unit = js.native
    
    def unseal(): Unit = js.native
  }
  
  /* Inlined std.Pick<{readonly unlinkSync (path : node.fs.PathLike): void,   WriteStream :new (): node.fs.WriteStream, readonly truncateSync (path : node.fs.PathLike): void, readonly truncateSync (path : node.fs.PathLike): void, readonly truncateSync (path : node.fs.PathLike, len : number): void, readonly fchownSync (fd : number, uid : number, gid : number): void,  readonly writev :{readonly ^ (fd : number, buffers : std.ReadonlyArray<std.ArrayBufferView>, cb : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, bytesWritten : number, buffers : std.Array<std.ArrayBufferView>): void): void, readonly ^ (fd : number, buffers : std.ReadonlyArray<std.ArrayBufferView>, position : number, cb : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, bytesWritten : number, buffers : std.Array<std.ArrayBufferView>): void): void}, readonly mkdtempSync (prefix : string): string, readonly mkdtempSync (prefix : string, options : node.fs.EncodingOption): string, readonly mkdtempSync (prefix : string, options : node.fs.BufferEncodingOption): node.buffer.<global>.Buffer, readonly mkdtempSync (prefix : string): string | node.buffer.<global>.Buffer, readonly mkdtempSync (prefix : string, options : node.fs.EncodingOption): string | node.buffer.<global>.Buffer, readonly chmodSync (path : node.fs.PathLike, mode : node.fs.Mode): void,  readonly appendFile :{readonly ^ (path : node.fs.PathOrFileDescriptor, data : string, options : node.fs.WriteFileOptions, callback : node.fs.NoParamCallback): void, readonly ^ (path : node.fs.PathOrFileDescriptor, data : std.Uint8Array, options : node.fs.WriteFileOptions, callback : node.fs.NoParamCallback): void, readonly ^ (file : node.fs.PathOrFileDescriptor, data : string, callback : node.fs.NoParamCallback): void, readonly ^ (file : node.fs.PathOrFileDescriptor, data : std.Uint8Array, callback : node.fs.NoParamCallback): void},  readonly lchmod :{readonly ^ (path : node.fs.PathLike, mode : node.fs.Mode, callback : node.fs.NoParamCallback): void},  readonly fchmod :{readonly ^ (fd : number, mode : node.fs.Mode, callback : node.fs.NoParamCallback): void},  readonly truncate :{readonly ^ (path : node.fs.PathLike, len : number, callback : node.fs.NoParamCallback): void, readonly ^ (path : node.fs.PathLike, len : undefined, callback : node.fs.NoParamCallback): void, readonly ^ (path : node.fs.PathLike, len : null, callback : node.fs.NoParamCallback): void, readonly ^ (path : node.fs.PathLike, callback : node.fs.NoParamCallback): void}, readonly fdatasyncSync (fd : number): void, readonly fchmodSync (fd : number, mode : node.fs.Mode): void,   ReadStream :new (): node.fs.ReadStream,  readonly promises :{readonly appendFile (path : node.fs.PathLike, data : string): std.Promise<void>, readonly appendFile (path : node.fs/promises.FileHandle, data : string): std.Promise<void>, readonly appendFile (path : node.fs.PathLike, data : std.Uint8Array): std.Promise<void>, readonly appendFile (path : node.fs/promises.FileHandle, data : std.Uint8Array): std.Promise<void>, readonly appendFile (path : node.fs.PathLike, data : string): std.Promise<void>, readonly appendFile (path : node.fs/promises.FileHandle, data : string): std.Promise<void>, readonly appendFile (path : node.fs.PathLike, data : std.Uint8Array): std.Promise<void>, readonly appendFile (path : node.fs/promises.FileHandle, data : std.Uint8Array): std.Promise<void>, readonly appendFile (path : node.fs.PathLike, data : string, options : node.fs.ObjectEncodingOptions & node.fs/promises.FlagAndOpenMode): std.Promise<void>, readonly appendFile (path : node.fs/promises.FileHandle, data : string, options : node.fs.ObjectEncodingOptions & node.fs/promises.FlagAndOpenMode): std.Promise<void>, readonly appendFile (path : node.fs.PathLike, data : std.Uint8Array, options : node.fs.ObjectEncodingOptions & node.fs/promises.FlagAndOpenMode): std.Promise<void>, readonly appendFile (path : node.fs/promises.FileHandle, data : std.Uint8Array, options : node.fs.ObjectEncodingOptions & node.fs/promises.FlagAndOpenMode): std.Promise<void>, readonly appendFile (path : node.fs.PathLike, data : string, options : node.buffer.<global>.BufferEncoding): std.Promise<void>, readonly appendFile (path : node.fs/promises.FileHandle, data : string, options : node.buffer.<global>.BufferEncoding): std.Promise<void>, readonly appendFile (path : node.fs.PathLike, data : std.Uint8Array, options : node.buffer.<global>.BufferEncoding): std.Promise<void>, readonly appendFile (path : node.fs/promises.FileHandle, data : std.Uint8Array, options : node.buffer.<global>.BufferEncoding): std.Promise<void>, readonly lchmod (path : node.fs.PathLike, mode : node.fs.Mode): std.Promise<void>, readonly truncate (path : node.fs.PathLike): std.Promise<void>, readonly truncate (path : node.fs.PathLike, len : number): std.Promise<void>, readonly chmod (path : node.fs.PathLike, mode : node.fs.Mode): std.Promise<void>, readonly lstat (path : node.fs.PathLike): std.Promise<node.node:fs.Stats>, readonly lstat (path : node.fs.PathLike, opts : node.anon.StatOptionsbigintfalseund): std.Promise<node.node:fs.Stats>, readonly lstat (path : node.fs.PathLike, opts : node.anon.StatOptionsbiginttrue): std.Promise<node.fs.BigIntStats>, readonly lstat (path : node.fs.PathLike): std.Promise<node.node:fs.Stats | node.fs.BigIntStats>, readonly lstat (path : node.fs.PathLike, opts : node.fs.StatOptions): std.Promise<node.node:fs.Stats | node.fs.BigIntStats>, readonly readFile (path : node.fs.PathLike): std.Promise<node.buffer.<global>.Buffer>, readonly readFile (path : node.fs/promises.FileHandle): std.Promise<node.buffer.<global>.Buffer>, readonly readFile (path : node.fs.PathLike): std.Promise<node.buffer.<global>.Buffer>, readonly readFile (path : node.fs/promises.FileHandle): std.Promise<node.buffer.<global>.Buffer>, readonly readFile (path : node.fs.PathLike, options : node.anon.encodingnullundefinedflag): std.Promise<node.buffer.<global>.Buffer>, readonly readFile (path : node.fs/promises.FileHandle, options : node.anon.encodingnullundefinedflag): std.Promise<node.buffer.<global>.Buffer>, readonly readFile (path : node.fs.PathLike, options : node.anon.encodingBufferEncodingfla): std.Promise<string>, readonly readFile (path : node.fs/promises.FileHandle, options : node.anon.encodingBufferEncodingfla): std.Promise<string>, readonly readFile (path : node.fs.PathLike, options : node.buffer.<global>.BufferEncoding): std.Promise<string>, readonly readFile (path : node.fs/promises.FileHandle, options : node.buffer.<global>.BufferEncoding): std.Promise<string>, readonly readFile (path : node.fs.PathLike): std.Promise<string | node.buffer.<global>.Buffer>, readonly readFile (path : node.fs/promises.FileHandle): std.Promise<string | node.buffer.<global>.Buffer>, readonly readFile (path : node.fs.PathLike): std.Promise<string | node.buffer.<global>.Buffer>, readonly readFile (path : node.fs/promises.FileHandle): std.Promise<string | node.buffer.<global>.Buffer>, readonly readFile (path : node.fs.PathLike, options : node.anon.ObjectEncodingOptionsAbor): std.Promise<string | node.buffer.<global>.Buffer>, readonly readFile (path : node.fs/promises.FileHandle, options : node.anon.ObjectEncodingOptionsAbor): std.Promise<string | node.buffer.<global>.Buffer>, readonly readFile (path : node.fs.PathLike, options : node.buffer.<global>.BufferEncoding): std.Promise<string | node.buffer.<global>.Buffer>, readonly readFile (path : node.fs/promises.FileHandle, options : node.buffer.<global>.BufferEncoding): std.Promise<string | node.buffer.<global>.Buffer>, readonly opendir (path : node.fs.PathLike): std.Promise<node.node:fs.Dir>, readonly opendir (path : node.fs.PathLike, options : node.fs.OpenDirOptions): std.Promise<node.node:fs.Dir>, readonly lutimes (path : node.fs.PathLike, atime : node.fs.TimeLike, mtime : node.fs.TimeLike): std.Promise<void>, readonly link (existingPath : node.fs.PathLike, newPath : node.fs.PathLike): std.Promise<void>, readonly writeFile (file : node.fs.PathLike, data : string): std.Promise<void>, readonly writeFile (file : node.fs/promises.FileHandle, data : string): std.Promise<void>, readonly writeFile (file : node.fs.PathLike, data : std.ArrayBufferView): std.Promise<void>, readonly writeFile (file : node.fs/promises.FileHandle, data : std.ArrayBufferView): std.Promise<void>, readonly writeFile (file : node.fs.PathLike, data : std.Iterable<string | std.ArrayBufferView>): std.Promise<void>, readonly writeFile (file : node.fs/promises.FileHandle, data : std.Iterable<string | std.ArrayBufferView>): std.Promise<void>, readonly writeFile (file : node.fs.PathLike, data : std.AsyncIterable<string | std.ArrayBufferView>): std.Promise<void>, readonly writeFile (file : node.fs/promises.FileHandle, data : std.AsyncIterable<string | std.ArrayBufferView>): std.Promise<void>, readonly writeFile (file : node.fs.PathLike, data : node.node:stream.Stream): std.Promise<void>, readonly writeFile (file : node.fs/promises.FileHandle, data : node.node:stream.Stream): std.Promise<void>, readonly writeFile (file : node.fs.PathLike, data : string): std.Promise<void>, readonly writeFile (file : node.fs/promises.FileHandle, data : string): std.Promise<void>, readonly writeFile (file : node.fs.PathLike, data : std.ArrayBufferView): std.Promise<void>, readonly writeFile (file : node.fs/promises.FileHandle, data : std.ArrayBufferView): std.Promise<void>, readonly writeFile (file : node.fs.PathLike, data : std.Iterable<string | std.ArrayBufferView>): std.Promise<void>, readonly writeFile (file : node.fs/promises.FileHandle, data : std.Iterable<string | std.ArrayBufferView>): std.Promise<void>, readonly writeFile (file : node.fs.PathLike, data : std.AsyncIterable<string | std.ArrayBufferView>): std.Promise<void>, readonly writeFile (file : node.fs/promises.FileHandle, data : std.AsyncIterable<string | std.ArrayBufferView>): std.Promise<void>, readonly writeFile (file : node.fs.PathLike, data : node.node:stream.Stream): std.Promise<void>, readonly writeFile (file : node.fs/promises.FileHandle, data : node.node:stream.Stream): std.Promise<void>, readonly writeFile (file : node.fs.PathLike, data : string, options : node.anon.ObjectEncodingOptionsmode): std.Promise<void>, readonly writeFile (file : node.fs/promises.FileHandle, data : string, options : node.anon.ObjectEncodingOptionsmode): std.Promise<void>, readonly writeFile (file : node.fs.PathLike, data : std.ArrayBufferView, options : node.anon.ObjectEncodingOptionsmode): std.Promise<void>, readonly writeFile (file : node.fs/promises.FileHandle, data : std.ArrayBufferView, options : node.anon.ObjectEncodingOptionsmode): std.Promise<void>, readonly writeFile (file : node.fs.PathLike, data : std.Iterable<string | std.ArrayBufferView>, options : node.anon.ObjectEncodingOptionsmode): std.Promise<void>, readonly writeFile (file : node.fs/promises.FileHandle, data : std.Iterable<string | std.ArrayBufferView>, options : node.anon.ObjectEncodingOptionsmode): std.Promise<void>, readonly writeFile (file : node.fs.PathLike, data : std.AsyncIterable<string | std.ArrayBufferView>, options : node.anon.ObjectEncodingOptionsmode): std.Promise<void>, readonly writeFile (file : node.fs/promises.FileHandle, data : std.AsyncIterable<string | std.ArrayBufferView>, options : node.anon.ObjectEncodingOptionsmode): std.Promise<void>, readonly writeFile (file : node.fs.PathLike, data : node.node:stream.Stream, options : node.anon.ObjectEncodingOptionsmode): std.Promise<void>, readonly writeFile (file : node.fs/promises.FileHandle, data : node.node:stream.Stream, options : node.anon.ObjectEncodingOptionsmode): std.Promise<void>, readonly writeFile (file : node.fs.PathLike, data : string, options : node.buffer.<global>.BufferEncoding): std.Promise<void>, readonly writeFile (file : node.fs/promises.FileHandle, data : string, options : node.buffer.<global>.BufferEncoding): std.Promise<void>, readonly writeFile (file : node.fs.PathLike, data : std.ArrayBufferView, options : node.buffer.<global>.BufferEncoding): std.Promise<void>, readonly writeFile (file : node.fs/promises.FileHandle, data : std.ArrayBufferView, options : node.buffer.<global>.BufferEncoding): std.Promise<void>, readonly writeFile (file : node.fs.PathLike, data : std.Iterable<string | std.ArrayBufferView>, options : node.buffer.<global>.BufferEncoding): std.Promise<void>, readonly writeFile (file : node.fs/promises.FileHandle, data : std.Iterable<string | std.ArrayBufferView>, options : node.buffer.<global>.BufferEncoding): std.Promise<void>, readonly writeFile (file : node.fs.PathLike, data : std.AsyncIterable<string | std.ArrayBufferView>, options : node.buffer.<global>.BufferEncoding): std.Promise<void>, readonly writeFile (file : node.fs/promises.FileHandle, data : std.AsyncIterable<string | std.ArrayBufferView>, options : node.buffer.<global>.BufferEncoding): std.Promise<void>, readonly writeFile (file : node.fs.PathLike, data : node.node:stream.Stream, options : node.buffer.<global>.BufferEncoding): std.Promise<void>, readonly writeFile (file : node.fs/promises.FileHandle, data : node.node:stream.Stream, options : node.buffer.<global>.BufferEncoding): std.Promise<void>, readonly readlink (path : node.fs.PathLike): std.Promise<string>, readonly readlink (path : node.fs.PathLike): std.Promise<string>, readonly readlink (path : node.fs.PathLike, options : node.fs.ObjectEncodingOptions): std.Promise<string>, readonly readlink (path : node.fs.PathLike, options : node.buffer.<global>.BufferEncoding): std.Promise<string>, readonly readlink (path : node.fs.PathLike, options : node.fs.BufferEncodingOption): std.Promise<node.buffer.<global>.Buffer>, readonly readlink (path : node.fs.PathLike): std.Promise<string | node.buffer.<global>.Buffer>, readonly readlink (path : node.fs.PathLike): std.Promise<string | node.buffer.<global>.Buffer>, readonly readlink (path : node.fs.PathLike, options : node.fs.ObjectEncodingOptions): std.Promise<string | node.buffer.<global>.Buffer>, readonly readlink (path : node.fs.PathLike, options : string): std.Promise<string | node.buffer.<global>.Buffer>, readonly rm (path : node.fs.PathLike): std.Promise<void>, readonly rm (path : node.fs.PathLike, options : node.fs.RmOptions): std.Promise<void>, readonly stat (path : node.fs.PathLike): std.Promise<node.node:fs.Stats>, readonly stat (path : node.fs.PathLike, opts : node.anon.StatOptionsbigintfalseund): std.Promise<node.node:fs.Stats>, readonly stat (path : node.fs.PathLike, opts : node.anon.StatOptionsbiginttrue): std.Promise<node.fs.BigIntStats>, readonly stat (path : node.fs.PathLike): std.Promise<node.node:fs.Stats | node.fs.BigIntStats>, readonly stat (path : node.fs.PathLike, opts : node.fs.StatOptions): std.Promise<node.node:fs.Stats | node.fs.BigIntStats>, readonly access (path : node.fs.PathLike): std.Promise<void>, readonly access (path : node.fs.PathLike, mode : number): std.Promise<void>,  readonly constants :{ readonly O_RDONLY :number,  readonly O_DIRECT :number,  readonly UV_FS_O_FILEMAP :number,  readonly S_IXGRP :number,  readonly S_IFMT :number,  readonly S_IFLNK :number,  readonly S_IFREG :number,  readonly O_NOCTTY :number,  readonly S_IFIFO :number,  readonly O_NOFOLLOW :number,  readonly O_WRONLY :number,  readonly S_IFBLK :number,  readonly COPYFILE_EXCL :number,  readonly S_IRGRP :number,  readonly O_APPEND :number,  readonly S_IRWXU :number,  readonly COPYFILE_FICLONE_FORCE :number,  readonly S_IFSOCK :number,  readonly S_IWOTH :number,  readonly O_NONBLOCK :number,  readonly O_RDWR :number,  readonly S_IWGRP :number,  readonly S_IFCHR :number,  readonly S_IRWXO :number,  readonly O_NOATIME :number,  readonly O_EXCL :number,  readonly S_IWUSR :number,  readonly S_IXUSR :number,  readonly F_OK :number,  readonly X_OK :number,  readonly COPYFILE_FICLONE :number,  readonly O_SYMLINK :number,  readonly O_DSYNC :number,  readonly O_TRUNC :number,  readonly S_IRUSR :number,  readonly O_SYNC :number,  readonly R_OK :number,  readonly S_IXOTH :number,  readonly S_IROTH :number,  readonly O_DIRECTORY :number,  readonly S_IRWXG :number,  readonly S_IFDIR :number,  readonly O_CREAT :number,  readonly W_OK :number}, readonly symlink (target : node.fs.PathLike, path : node.fs.PathLike): std.Promise<void>, readonly symlink (target : node.fs.PathLike, path : node.fs.PathLike): std.Promise<void>, readonly symlink (target : node.fs.PathLike, path : node.fs.PathLike, type : string): std.Promise<void>, readonly lchown (path : node.fs.PathLike, uid : number, gid : number): std.Promise<void>, readonly utimes (path : node.fs.PathLike, atime : node.fs.TimeLike, mtime : node.fs.TimeLike): std.Promise<void>, readonly mkdir (path : node.fs.PathLike, options : node.anon.MakeDirectoryOptionsrecur): std.Promise<string | undefined>, readonly mkdir (path : node.fs.PathLike): std.Promise<void>, readonly mkdir (path : node.fs.PathLike): std.Promise<void>, readonly mkdir (path : node.fs.PathLike, options : node.fs.Mode): std.Promise<void>, readonly mkdir (path : node.fs.PathLike, options : node.anon.MakeDirectoryOptionsrecurMode): std.Promise<void>, readonly mkdir (path : node.fs.PathLike): std.Promise<string | undefined>, readonly mkdir (path : node.fs.PathLike): std.Promise<string | undefined>, readonly mkdir (path : node.fs.PathLike, options : node.fs.Mode): std.Promise<string | undefined>, readonly mkdir (path : node.fs.PathLike, options : node.fs.MakeDirectoryOptions): std.Promise<string | undefined>, readonly rename (oldPath : node.fs.PathLike, newPath : node.fs.PathLike): std.Promise<void>, readonly open (path : node.fs.PathLike): std.Promise<node.fs/promises.FileHandle>, readonly open (path : node.fs.PathLike, flags : string): std.Promise<node.fs/promises.FileHandle>, readonly open (path : node.fs.PathLike, flags : number): std.Promise<node.fs/promises.FileHandle>, readonly open (path : node.fs.PathLike, flags : string, mode : node.fs.Mode): std.Promise<node.fs/promises.FileHandle>, readonly open (path : node.fs.PathLike, flags : number, mode : node.fs.Mode): std.Promise<node.fs/promises.FileHandle>, readonly open (path : node.fs.PathLike, flags : undefined, mode : node.fs.Mode): std.Promise<node.fs/promises.FileHandle>, readonly rmdir (path : node.fs.PathLike): std.Promise<void>, readonly rmdir (path : node.fs.PathLike, options : node.fs.RmDirOptions): std.Promise<void>, readonly unlink (path : node.fs.PathLike): std.Promise<void>, readonly chown (path : node.fs.PathLike, uid : number, gid : number): std.Promise<void>, readonly cp (source : string, destination : string): std.Promise<void>, readonly cp (source : std.URL, destination : string): std.Promise<void>, readonly cp (source : string, destination : std.URL): std.Promise<void>, readonly cp (source : std.URL, destination : std.URL): std.Promise<void>, readonly cp (source : string, destination : string, opts : node.fs.CopyOptions): std.Promise<void>, readonly cp (source : std.URL, destination : string, opts : node.fs.CopyOptions): std.Promise<void>, readonly cp (source : string, destination : std.URL, opts : node.fs.CopyOptions): std.Promise<void>, readonly cp (source : std.URL, destination : std.URL, opts : node.fs.CopyOptions): std.Promise<void>, readonly copyFile (src : node.fs.PathLike, dest : node.fs.PathLike): std.Promise<void>, readonly copyFile (src : node.fs.PathLike, dest : node.fs.PathLike, mode : number): std.Promise<void>, readonly realpath (path : node.fs.PathLike): std.Promise<string>, readonly realpath (path : node.fs.PathLike): std.Promise<string>, readonly realpath (path : node.fs.PathLike, options : node.fs.ObjectEncodingOptions): std.Promise<string>, readonly realpath (path : node.fs.PathLike, options : node.buffer.<global>.BufferEncoding): std.Promise<string>, readonly realpath (path : node.fs.PathLike, options : node.fs.BufferEncodingOption): std.Promise<node.buffer.<global>.Buffer>, readonly realpath (path : node.fs.PathLike): std.Promise<string | node.buffer.<global>.Buffer>, readonly realpath (path : node.fs.PathLike): std.Promise<string | node.buffer.<global>.Buffer>, readonly realpath (path : node.fs.PathLike, options : node.fs.ObjectEncodingOptions): std.Promise<string | node.buffer.<global>.Buffer>, readonly realpath (path : node.fs.PathLike, options : node.buffer.<global>.BufferEncoding): std.Promise<string | node.buffer.<global>.Buffer>, readonly readdir (path : node.fs.PathLike): std.Promise<std.Array<string>>, readonly readdir (path : node.fs.PathLike): std.Promise<std.Array<string>>, readonly readdir (path : node.fs.PathLike, options : node.anon.ObjectEncodingOptionswith): std.Promise<std.Array<string>>, readonly readdir (path : node.fs.PathLike, options : node.buffer.<global>.BufferEncoding): std.Promise<std.Array<string>>, readonly readdir (path : node.fs.PathLike, options : node.anon.Encoding): std.Promise<std.Array<node.buffer.<global>.Buffer>>, readonly readdir (path : node.fs.PathLike, options : 'buffer'): std.Promise<std.Array<node.buffer.<global>.Buffer>>, readonly readdir (path : node.fs.PathLike): std.Promise<std.Array<string> | std.Array<node.buffer.<global>.Buffer>>, readonly readdir (path : node.fs.PathLike): std.Promise<std.Array<string> | std.Array<node.buffer.<global>.Buffer>>, readonly readdir (path : node.fs.PathLike, options : node.anon.ObjectEncodingOptionswith): std.Promise<std.Array<string> | std.Array<node.buffer.<global>.Buffer>>, readonly readdir (path : node.fs.PathLike, options : node.buffer.<global>.BufferEncoding): std.Promise<std.Array<string> | std.Array<node.buffer.<global>.Buffer>>, readonly readdir (path : node.fs.PathLike, options : node.anon.ObjectEncodingOptionswithEncoding): std.Promise<std.Array<node.node:fs.Dirent>>, readonly watch (filename : node.fs.PathLike, options : node.anon.WatchOptionsencodingbuffe): std.AsyncIterable<node.fs/promises.FileChangeInfo<node.buffer.<global>.Buffer>>, readonly watch (filename : node.fs.PathLike, options : 'buffer'): std.AsyncIterable<node.fs/promises.FileChangeInfo<node.buffer.<global>.Buffer>>, readonly watch (filename : node.fs.PathLike): std.AsyncIterable<node.fs/promises.FileChangeInfo<string>>, readonly watch (filename : node.fs.PathLike, options : node.fs.WatchOptions): std.AsyncIterable<node.fs/promises.FileChangeInfo<string>>, readonly watch (filename : node.fs.PathLike, options : node.buffer.<global>.BufferEncoding): std.AsyncIterable<node.fs/promises.FileChangeInfo<string>>, readonly watch (filename : node.fs.PathLike, options : node.fs.WatchOptions): std.AsyncIterable<node.fs/promises.FileChangeInfo<string>> | std.AsyncIterable<node.fs/promises.FileChangeInfo<node.buffer.<global>.Buffer>>, readonly watch (filename : node.fs.PathLike, options : string): std.AsyncIterable<node.fs/promises.FileChangeInfo<string>> | std.AsyncIterable<node.fs/promises.FileChangeInfo<node.buffer.<global>.Buffer>>, readonly mkdtemp (prefix : string): std.Promise<string>, readonly mkdtemp (prefix : string): std.Promise<string>, readonly mkdtemp (prefix : string, options : node.fs.ObjectEncodingOptions): std.Promise<string>, readonly mkdtemp (prefix : string, options : node.buffer.<global>.BufferEncoding): std.Promise<string>, readonly mkdtemp (prefix : string, options : node.fs.BufferEncodingOption): std.Promise<node.buffer.<global>.Buffer>, readonly mkdtemp (prefix : string): std.Promise<string | node.buffer.<global>.Buffer>, readonly mkdtemp (prefix : string): std.Promise<string | node.buffer.<global>.Buffer>, readonly mkdtemp (prefix : string, options : node.fs.ObjectEncodingOptions): std.Promise<string | node.buffer.<global>.Buffer>, readonly mkdtemp (prefix : string, options : node.buffer.<global>.BufferEncoding): std.Promise<string | node.buffer.<global>.Buffer>}, readonly lchmodSync (path : node.fs.PathLike, mode : node.fs.Mode): void, readonly cpSync (source : string, destination : string): void, readonly cpSync (source : node.node:url.URL, destination : string): void, readonly cpSync (source : string, destination : node.node:url.URL): void, readonly cpSync (source : node.node:url.URL, destination : node.node:url.URL): void, readonly cpSync (source : string, destination : string, opts : node.fs.CopySyncOptions): void, readonly cpSync (source : node.node:url.URL, destination : string, opts : node.fs.CopySyncOptions): void, readonly cpSync (source : string, destination : node.node:url.URL, opts : node.fs.CopySyncOptions): void, readonly cpSync (source : node.node:url.URL, destination : node.node:url.URL, opts : node.fs.CopySyncOptions): void,  readonly chmod :{readonly ^ (path : node.fs.PathLike, mode : node.fs.Mode, callback : node.fs.NoParamCallback): void},  readonly lstat :{readonly ^ (path : node.fs.PathLike, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, stats : node.fs.Stats): void): void, readonly ^ (path : node.fs.PathLike, options : node.anon.StatOptionsbigintfalseund, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, stats : node.fs.Stats): void): void, readonly ^ (path : node.fs.PathLike, options : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, stats : node.fs.Stats): void): void, readonly ^ (path : node.fs.PathLike, options : node.anon.StatOptionsbiginttrue, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, stats : node.fs.BigIntStats): void): void, readonly ^ (path : node.fs.PathLike, options : node.fs.StatOptions, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, stats : node.fs.Stats | node.fs.BigIntStats): void): void, readonly ^ (path : node.fs.PathLike, options : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, stats : node.fs.Stats | node.fs.BigIntStats): void): void},  readonly readFile :{readonly ^ (path : node.fs.PathOrFileDescriptor, options : node.anon.encodingnullundefinedflagEncoding, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, data : node.buffer.<global>.Buffer): void): void, readonly ^ (path : node.fs.PathOrFileDescriptor, options : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, data : node.buffer.<global>.Buffer): void): void, readonly ^ (path : node.fs.PathOrFileDescriptor, options : null, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, data : node.buffer.<global>.Buffer): void): void, readonly ^ (path : node.fs.PathOrFileDescriptor, options : node.anon.encodingBufferEncodingflaEncoding, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, data : string): void): void, readonly ^ (path : node.fs.PathOrFileDescriptor, options : node.buffer.<global>.BufferEncoding, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, data : string): void): void, readonly ^ (path : node.fs.PathOrFileDescriptor, options : node.anon.ObjectEncodingOptionsflag, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, data : string | node.buffer.<global>.Buffer): void): void, readonly ^ (path : node.fs.PathOrFileDescriptor, options : node.buffer.<global>.BufferEncoding, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, data : string | node.buffer.<global>.Buffer): void): void, readonly ^ (path : node.fs.PathOrFileDescriptor, options : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, data : string | node.buffer.<global>.Buffer): void): void, readonly ^ (path : node.fs.PathOrFileDescriptor, options : null, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, data : string | node.buffer.<global>.Buffer): void): void, readonly ^ (path : node.fs.PathOrFileDescriptor, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, data : node.buffer.<global>.Buffer): void): void},  readonly exists :{readonly ^ (path : node.fs.PathLike, callback : (exists : boolean): void): void}, readonly copyFileSync (src : node.fs.PathLike, dest : node.fs.PathLike): void, readonly copyFileSync (src : node.fs.PathLike, dest : node.fs.PathLike, mode : number): void,  readonly opendir :{readonly ^ (path : node.fs.PathLike, cb : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, dir : node.fs.Dir): void): void, readonly ^ (path : node.fs.PathLike, options : node.fs.OpenDirOptions, cb : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, dir : node.fs.Dir): void): void}, readonly ftruncateSync (fd : number): void, readonly ftruncateSync (fd : number): void, readonly ftruncateSync (fd : number, len : number): void, readonly appendFileSync (path : node.fs.PathOrFileDescriptor, data : string): void, readonly appendFileSync (path : node.fs.PathOrFileDescriptor, data : std.Uint8Array): void, readonly appendFileSync (path : node.fs.PathOrFileDescriptor, data : string, options : node.fs.WriteFileOptions): void, readonly appendFileSync (path : node.fs.PathOrFileDescriptor, data : std.Uint8Array, options : node.fs.WriteFileOptions): void,  readonly close :{readonly ^ (fd : number): void, readonly ^ (fd : number, callback : node.fs.NoParamCallback): void},  readonly statSync :node.fs.StatSyncFn,  readonly lutimes :{readonly ^ (path : node.fs.PathLike, atime : node.fs.TimeLike, mtime : node.fs.TimeLike, callback : node.fs.NoParamCallback): void}, readonly accessSync (path : node.fs.PathLike): void, readonly accessSync (path : node.fs.PathLike, mode : number): void, readonly symlinkSync (target : node.fs.PathLike, path : node.fs.PathLike): void, readonly symlinkSync (target : node.fs.PathLike, path : node.fs.PathLike): void, readonly symlinkSync (target : node.fs.PathLike, path : node.fs.PathLike, type : node.fs.symlink.Type): void,  readonly fstat :{readonly ^ (fd : number, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, stats : node.fs.Stats): void): void, readonly ^ (fd : number, options : node.anon.StatOptionsbigintfalseund, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, stats : node.fs.Stats): void): void, readonly ^ (fd : number, options : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, stats : node.fs.Stats): void): void, readonly ^ (fd : number, options : node.anon.StatOptionsbiginttrue, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, stats : node.fs.BigIntStats): void): void, readonly ^ (fd : number, options : node.fs.StatOptions, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, stats : node.fs.Stats | node.fs.BigIntStats): void): void, readonly ^ (fd : number, options : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, stats : node.fs.Stats | node.fs.BigIntStats): void): void},  readonly link :{readonly ^ (existingPath : node.fs.PathLike, newPath : node.fs.PathLike, callback : node.fs.NoParamCallback): void},  readonly realpathSync :{readonly native (path : node.fs.PathLike): string, readonly native (path : node.fs.PathLike, options : node.fs.EncodingOption): string, readonly native (path : node.fs.PathLike, options : node.fs.BufferEncodingOption): node.buffer.<global>.Buffer, readonly native (path : node.fs.PathLike): string | node.buffer.<global>.Buffer, readonly native (path : node.fs.PathLike, options : node.fs.EncodingOption): string | node.buffer.<global>.Buffer, readonly ^ (path : node.fs.PathLike): string, readonly ^ (path : node.fs.PathLike, options : node.fs.EncodingOption): string, readonly ^ (path : node.fs.PathLike, options : node.fs.BufferEncodingOption): node.buffer.<global>.Buffer, readonly ^ (path : node.fs.PathLike): string | node.buffer.<global>.Buffer, readonly ^ (path : node.fs.PathLike, options : node.fs.EncodingOption): string | node.buffer.<global>.Buffer},  readonly writeFile :{readonly ^ (file : node.fs.PathOrFileDescriptor, data : string, options : node.fs.WriteFileOptions, callback : node.fs.NoParamCallback): void, readonly ^ (file : node.fs.PathOrFileDescriptor, data : std.ArrayBufferView, options : node.fs.WriteFileOptions, callback : node.fs.NoParamCallback): void, readonly ^ (path : node.fs.PathOrFileDescriptor, data : string, callback : node.fs.NoParamCallback): void, readonly ^ (path : node.fs.PathOrFileDescriptor, data : std.ArrayBufferView, callback : node.fs.NoParamCallback): void},  readonly readlink :{readonly ^ (path : node.fs.PathLike, options : node.fs.EncodingOption, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, linkString : string): void): void, readonly ^ (path : node.fs.PathLike, options : node.fs.BufferEncodingOption, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, linkString : node.buffer.<global>.Buffer): void): void, readonly ^ (path : node.fs.PathLike, options : node.fs.EncodingOption, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, linkString : string | node.buffer.<global>.Buffer): void): void, readonly ^ (path : node.fs.PathLike, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, linkString : string): void): void}, readonly writevSync (fd : number, buffers : std.ReadonlyArray<std.ArrayBufferView>): number, readonly writevSync (fd : number, buffers : std.ReadonlyArray<std.ArrayBufferView>, position : number): number, readonly createWriteStream (path : node.fs.PathLike): node.fs.WriteStream, readonly createWriteStream (path : node.fs.PathLike, options : node.buffer.<global>.BufferEncoding): node.fs.WriteStream, readonly createWriteStream (path : node.fs.PathLike, options : node.fs.StreamOptions): node.fs.WriteStream,   Stats :new (): node.fs.Stats,  readonly rm :{readonly ^ (path : node.fs.PathLike, callback : node.fs.NoParamCallback): void, readonly ^ (path : node.fs.PathLike, options : node.fs.RmOptions, callback : node.fs.NoParamCallback): void}, readonly readSync (fd : number, buffer : std.ArrayBufferView, offset : number, length : number): number, readonly readSync (fd : number, buffer : std.ArrayBufferView, offset : number, length : number, position : node.fs.ReadPosition): number, readonly readSync (fd : number, buffer : std.ArrayBufferView): number, readonly readSync (fd : number, buffer : std.ArrayBufferView, opts : node.fs.ReadSyncOptions): number, readonly readFileSync (path : node.fs.PathOrFileDescriptor): node.buffer.<global>.Buffer, readonly readFileSync (path : node.fs.PathOrFileDescriptor): node.buffer.<global>.Buffer, readonly readFileSync (path : node.fs.PathOrFileDescriptor, options : node.anon.Flag): node.buffer.<global>.Buffer, readonly readFileSync (path : node.fs.PathOrFileDescriptor, options : node.anon.EncodingFlag): string, readonly readFileSync (path : node.fs.PathOrFileDescriptor, options : node.buffer.<global>.BufferEncoding): string, readonly readFileSync (path : node.fs.PathOrFileDescriptor): string | node.buffer.<global>.Buffer, readonly readFileSync (path : node.fs.PathOrFileDescriptor): string | node.buffer.<global>.Buffer, readonly readFileSync (path : node.fs.PathOrFileDescriptor, options : node.anon.ObjectEncodingOptionsflagEncoding): string | node.buffer.<global>.Buffer, readonly readFileSync (path : node.fs.PathOrFileDescriptor, options : node.buffer.<global>.BufferEncoding): string | node.buffer.<global>.Buffer,  readonly stat :{readonly ^ (path : node.fs.PathLike, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, stats : node.fs.Stats): void): void, readonly ^ (path : node.fs.PathLike, options : node.anon.StatOptionsbigintfalseund, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, stats : node.fs.Stats): void): void, readonly ^ (path : node.fs.PathLike, options : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, stats : node.fs.Stats): void): void, readonly ^ (path : node.fs.PathLike, options : node.anon.StatOptionsbiginttrue, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, stats : node.fs.BigIntStats): void): void, readonly ^ (path : node.fs.PathLike, options : node.fs.StatOptions, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, stats : node.fs.Stats | node.fs.BigIntStats): void): void, readonly ^ (path : node.fs.PathLike, options : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, stats : node.fs.Stats | node.fs.BigIntStats): void): void}, readonly unwatchFile (filename : node.fs.PathLike): void, readonly unwatchFile (filename : node.fs.PathLike, listener : (curr : node.fs.Stats, prev : node.fs.Stats): void): void,  readonly readv :{readonly ^ (fd : number, buffers : std.ReadonlyArray<std.ArrayBufferView>, cb : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, bytesRead : number, buffers : std.Array<std.ArrayBufferView>): void): void, readonly ^ (fd : number, buffers : std.ReadonlyArray<std.ArrayBufferView>, position : number, cb : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, bytesRead : number, buffers : std.Array<std.ArrayBufferView>): void): void},  readonly access :{readonly ^ (path : node.fs.PathLike, mode : number, callback : node.fs.NoParamCallback): void, readonly ^ (path : node.fs.PathLike, mode : undefined, callback : node.fs.NoParamCallback): void, readonly ^ (path : node.fs.PathLike, callback : node.fs.NoParamCallback): void},  readonly constants :{ readonly O_RDONLY :number,  readonly O_DIRECT :number,  readonly UV_FS_O_FILEMAP :number,  readonly S_IXGRP :number,  readonly S_IFMT :number,  readonly S_IFLNK :number,  readonly S_IFREG :number,  readonly O_NOCTTY :number,  readonly S_IFIFO :number,  readonly O_NOFOLLOW :number,  readonly O_WRONLY :number,  readonly S_IFBLK :number,  readonly COPYFILE_EXCL :number,  readonly S_IRGRP :number,  readonly O_APPEND :number,  readonly S_IRWXU :number,  readonly COPYFILE_FICLONE_FORCE :number,  readonly S_IFSOCK :number,  readonly S_IWOTH :number,  readonly O_NONBLOCK :number,  readonly O_RDWR :number,  readonly S_IWGRP :number,  readonly S_IFCHR :number,  readonly S_IRWXO :number,  readonly O_NOATIME :number,  readonly O_EXCL :number,  readonly S_IWUSR :number,  readonly S_IXUSR :number,  readonly F_OK :number,  readonly X_OK :number,  readonly COPYFILE_FICLONE :number,  readonly O_SYMLINK :number,  readonly O_DSYNC :number,  readonly O_TRUNC :number,  readonly S_IRUSR :number,  readonly O_SYNC :number,  readonly R_OK :number,  readonly S_IXOTH :number,  readonly S_IROTH :number,  readonly O_DIRECTORY :number,  readonly S_IRWXG :number,  readonly S_IFDIR :number,  readonly O_CREAT :number,  readonly W_OK :number},  readonly symlink :{readonly ^ (target : node.fs.PathLike, path : node.fs.PathLike, type : node.fs.symlink.Type, callback : node.fs.NoParamCallback): void, readonly ^ (target : node.fs.PathLike, path : node.fs.PathLike, type : undefined, callback : node.fs.NoParamCallback): void, readonly ^ (target : node.fs.PathLike, path : node.fs.PathLike, type : null, callback : node.fs.NoParamCallback): void, readonly ^ (target : node.fs.PathLike, path : node.fs.PathLike, callback : node.fs.NoParamCallback): void},  readonly lchown :{readonly ^ (path : node.fs.PathLike, uid : number, gid : number, callback : node.fs.NoParamCallback): void}, readonly chownSync (path : node.fs.PathLike, uid : number, gid : number): void,  readonly utimes :{readonly ^ (path : node.fs.PathLike, atime : node.fs.TimeLike, mtime : node.fs.TimeLike, callback : node.fs.NoParamCallback): void}, readonly lchownSync (path : node.fs.PathLike, uid : number, gid : number): void, readonly closeSync (fd : number): void, readonly opendirSync (path : node.fs.PathLike): node.fs.Dir, readonly opendirSync (path : node.fs.PathLike, options : node.fs.OpenDirOptions): node.fs.Dir, readonly readvSync (fd : number, buffers : std.ReadonlyArray<std.ArrayBufferView>): number, readonly readvSync (fd : number, buffers : std.ReadonlyArray<std.ArrayBufferView>, position : number): number, readonly watchFile (filename : node.fs.PathLike, options : node.anon.WatchFileOptionsbigintfal, listener : (curr : node.fs.Stats, prev : node.fs.Stats): void): node.fs.StatWatcher, readonly watchFile (filename : node.fs.PathLike, options : undefined, listener : (curr : node.fs.Stats, prev : node.fs.Stats): void): node.fs.StatWatcher, readonly watchFile (filename : node.fs.PathLike, options : node.anon.WatchFileOptionsbiginttru, listener : (curr : node.fs.BigIntStats, prev : node.fs.BigIntStats): void): node.fs.StatWatcher, readonly watchFile (filename : node.fs.PathLike, options : undefined, listener : (curr : node.fs.BigIntStats, prev : node.fs.BigIntStats): void): node.fs.StatWatcher, readonly watchFile (filename : node.fs.PathLike, listener : (curr : node.fs.Stats, prev : node.fs.Stats): void): node.fs.StatWatcher,  readonly mkdir :{readonly ^ (path : node.fs.PathLike, options : node.anon.MakeDirectoryOptionsrecur, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, path : string | undefined): void): void, readonly ^ (path : node.fs.PathLike, options : node.fs.Mode, callback : node.fs.NoParamCallback): void, readonly ^ (path : node.fs.PathLike, options : node.anon.MakeDirectoryOptionsrecurMode, callback : node.fs.NoParamCallback): void, readonly ^ (path : node.fs.PathLike, options : null, callback : node.fs.NoParamCallback): void, readonly ^ (path : node.fs.PathLike, options : undefined, callback : node.fs.NoParamCallback): void, readonly ^ (path : node.fs.PathLike, options : node.fs.Mode, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, path : string | undefined): void): void, readonly ^ (path : node.fs.PathLike, options : node.fs.MakeDirectoryOptions, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, path : string | undefined): void): void, readonly ^ (path : node.fs.PathLike, options : null, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, path : string | undefined): void): void, readonly ^ (path : node.fs.PathLike, options : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, path : string | undefined): void): void, readonly ^ (path : node.fs.PathLike, callback : node.fs.NoParamCallback): void}, readonly lutimesSync (path : node.fs.PathLike, atime : node.fs.TimeLike, mtime : node.fs.TimeLike): void,  readonly rename :{readonly ^ (oldPath : node.fs.PathLike, newPath : node.fs.PathLike, callback : node.fs.NoParamCallback): void},   Dirent :new (): node.fs.Dirent, readonly fstatSync (fd : number): node.fs.Stats, readonly fstatSync (fd : number, options : node.anon.StatOptionsbigintfalseund): node.fs.Stats, readonly fstatSync (fd : number, options : node.anon.StatOptionsbiginttrue): node.fs.BigIntStats, readonly fstatSync (fd : number): node.fs.Stats | node.fs.BigIntStats, readonly fstatSync (fd : number, options : node.fs.StatOptions): node.fs.Stats | node.fs.BigIntStats,  readonly open :{readonly ^ (path : node.fs.PathLike, flags : node.fs.OpenMode, mode : node.fs.Mode, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, fd : number): void): void, readonly ^ (path : node.fs.PathLike, flags : undefined, mode : node.fs.Mode, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, fd : number): void): void, readonly ^ (path : node.fs.PathLike, flags : node.fs.OpenMode, mode : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, fd : number): void): void, readonly ^ (path : node.fs.PathLike, flags : undefined, mode : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, fd : number): void): void, readonly ^ (path : node.fs.PathLike, flags : node.fs.OpenMode, mode : null, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, fd : number): void): void, readonly ^ (path : node.fs.PathLike, flags : undefined, mode : null, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, fd : number): void): void, readonly ^ (path : node.fs.PathLike, flags : node.fs.OpenMode, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, fd : number): void): void, readonly ^ (path : node.fs.PathLike, flags : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, fd : number): void): void, readonly ^ (path : node.fs.PathLike, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, fd : number): void): void},  readonly fdatasync :{readonly ^ (fd : number, callback : node.fs.NoParamCallback): void}, readonly createReadStream (path : node.fs.PathLike): node.fs.ReadStream, readonly createReadStream (path : node.fs.PathLike, options : node.buffer.<global>.BufferEncoding): node.fs.ReadStream, readonly createReadStream (path : node.fs.PathLike, options : node.fs.ReadStreamOptions): node.fs.ReadStream, readonly fsyncSync (fd : number): void,  readonly ftruncate :{readonly ^ (fd : number, len : number, callback : node.fs.NoParamCallback): void, readonly ^ (fd : number, len : undefined, callback : node.fs.NoParamCallback): void, readonly ^ (fd : number, len : null, callback : node.fs.NoParamCallback): void, readonly ^ (fd : number, callback : node.fs.NoParamCallback): void},  readonly rmdir :{readonly ^ (path : node.fs.PathLike, callback : node.fs.NoParamCallback): void, readonly ^ (path : node.fs.PathLike, options : node.fs.RmDirOptions, callback : node.fs.NoParamCallback): void},  readonly lstatSync :node.fs.StatSyncFn,  readonly read :{readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : number, length : number, position : node.fs.ReadPosition, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, bytesRead : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : number, length : number, position : null, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, bytesRead : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, options : node.fs.ReadAsyncOptions<TBuffer>, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, bytesRead : number, buffer : TBuffer): void): void, readonly ^ (fd : number, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, bytesRead : number, buffer : std.ArrayBufferView): void): void},   Dir :new (): node.fs.Dir, readonly writeSync (fd : number, buffer : std.ArrayBufferView): number, readonly writeSync (fd : number, buffer : std.ArrayBufferView): number, readonly writeSync (fd : number, buffer : std.ArrayBufferView): number, readonly writeSync (fd : number, buffer : std.ArrayBufferView): number, readonly writeSync (fd : number, buffer : std.ArrayBufferView): number, readonly writeSync (fd : number, buffer : std.ArrayBufferView): number, readonly writeSync (fd : number, buffer : std.ArrayBufferView): number, readonly writeSync (fd : number, buffer : std.ArrayBufferView): number, readonly writeSync (fd : number, buffer : std.ArrayBufferView, offset : number): number, readonly writeSync (fd : number, buffer : std.ArrayBufferView, offset : number): number, readonly writeSync (fd : number, buffer : std.ArrayBufferView, offset : number): number, readonly writeSync (fd : number, buffer : std.ArrayBufferView, offset : number): number, readonly writeSync (fd : number, buffer : std.ArrayBufferView, offset : number, length : number): number, readonly writeSync (fd : number, buffer : std.ArrayBufferView, offset : null, length : number): number, readonly writeSync (fd : number, buffer : std.ArrayBufferView, offset : undefined, length : number): number, readonly writeSync (fd : number, buffer : std.ArrayBufferView, offset : number, length : number): number, readonly writeSync (fd : number, buffer : std.ArrayBufferView, offset : null, length : number): number, readonly writeSync (fd : number, buffer : std.ArrayBufferView, offset : undefined, length : number): number, readonly writeSync (fd : number, buffer : std.ArrayBufferView, offset : number, length : number, position : number): number, readonly writeSync (fd : number, buffer : std.ArrayBufferView, offset : null, length : number, position : number): number, readonly writeSync (fd : number, buffer : std.ArrayBufferView, offset : undefined, length : number, position : number): number, readonly writeSync (fd : number, buffer : std.ArrayBufferView, offset : number, length : null, position : number): number, readonly writeSync (fd : number, buffer : std.ArrayBufferView, offset : null, length : null, position : number): number, readonly writeSync (fd : number, buffer : std.ArrayBufferView, offset : undefined, length : null, position : number): number, readonly writeSync (fd : number, buffer : std.ArrayBufferView, offset : number, length : undefined, position : number): number, readonly writeSync (fd : number, buffer : std.ArrayBufferView, offset : null, length : undefined, position : number): number, readonly writeSync (fd : number, buffer : std.ArrayBufferView, offset : undefined, length : undefined, position : number): number, readonly writeSync (fd : number, string : string): number, readonly writeSync (fd : number, string : string): number, readonly writeSync (fd : number, string : string): number, readonly writeSync (fd : number, string : string): number, readonly writeSync (fd : number, string : string, position : number): number, readonly writeSync (fd : number, string : string, position : number): number, readonly writeSync (fd : number, string : string, position : number, encoding : node.buffer.<global>.BufferEncoding): number, readonly writeSync (fd : number, string : string, position : null, encoding : node.buffer.<global>.BufferEncoding): number, readonly writeSync (fd : number, string : string, position : undefined, encoding : node.buffer.<global>.BufferEncoding): number, readonly rmdirSync (path : node.fs.PathLike): void, readonly rmdirSync (path : node.fs.PathLike, options : node.fs.RmDirOptions): void, readonly utimesSync (path : node.fs.PathLike, atime : node.fs.TimeLike, mtime : node.fs.TimeLike): void,  readonly fsync :{readonly ^ (fd : number, callback : node.fs.NoParamCallback): void}, readonly rmSync (path : node.fs.PathLike): void, readonly rmSync (path : node.fs.PathLike, options : node.fs.RmOptions): void, readonly linkSync (existingPath : node.fs.PathLike, newPath : node.fs.PathLike): void, readonly mkdirSync (path : node.fs.PathLike, options : node.anon.MakeDirectoryOptionsrecur): string | undefined, readonly mkdirSync (path : node.fs.PathLike): void, readonly mkdirSync (path : node.fs.PathLike): void, readonly mkdirSync (path : node.fs.PathLike, options : node.fs.Mode): void, readonly mkdirSync (path : node.fs.PathLike, options : node.anon.MakeDirectoryOptionsrecurMode): void, readonly mkdirSync (path : node.fs.PathLike): string | undefined, readonly mkdirSync (path : node.fs.PathLike): string | undefined, readonly mkdirSync (path : node.fs.PathLike, options : node.fs.Mode): string | undefined, readonly mkdirSync (path : node.fs.PathLike, options : node.fs.MakeDirectoryOptions): string | undefined,  readonly unlink :{readonly ^ (path : node.fs.PathLike, callback : node.fs.NoParamCallback): void},  readonly chown :{readonly ^ (path : node.fs.PathLike, uid : number, gid : number, callback : node.fs.NoParamCallback): void},  readonly futimes :{readonly ^ (fd : number, atime : node.fs.TimeLike, mtime : node.fs.TimeLike, callback : node.fs.NoParamCallback): void}, readonly renameSync (oldPath : node.fs.PathLike, newPath : node.fs.PathLike): void, readonly cp (source : string, destination : string, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null): void): void, readonly cp (source : node.node:url.URL, destination : string, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null): void): void, readonly cp (source : string, destination : node.node:url.URL, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null): void): void, readonly cp (source : node.node:url.URL, destination : node.node:url.URL, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null): void): void, readonly cp (source : string, destination : string, opts : node.fs.CopyOptions, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null): void): void, readonly cp (source : node.node:url.URL, destination : string, opts : node.fs.CopyOptions, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null): void): void, readonly cp (source : string, destination : node.node:url.URL, opts : node.fs.CopyOptions, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null): void): void, readonly cp (source : node.node:url.URL, destination : node.node:url.URL, opts : node.fs.CopyOptions, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null): void): void,  readonly copyFile :{readonly ^ (src : node.fs.PathLike, dest : node.fs.PathLike, callback : node.fs.NoParamCallback): void, readonly ^ (src : node.fs.PathLike, dest : node.fs.PathLike, mode : number, callback : node.fs.NoParamCallback): void}, readonly openSync (path : node.fs.PathLike, flags : node.fs.OpenMode): number, readonly openSync (path : node.fs.PathLike, flags : node.fs.OpenMode): number, readonly openSync (path : node.fs.PathLike, flags : node.fs.OpenMode, mode : node.fs.Mode): number,  readonly write :{readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : number, length : number, position : number, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : undefined, length : number, position : number, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : null, length : number, position : number, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : number, length : undefined, position : number, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : undefined, length : undefined, position : number, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : null, length : undefined, position : number, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : number, length : null, position : number, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : undefined, length : null, position : number, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : null, length : null, position : number, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : number, length : number, position : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : undefined, length : number, position : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : null, length : number, position : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : number, length : undefined, position : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : undefined, length : undefined, position : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : null, length : undefined, position : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : number, length : null, position : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : undefined, length : null, position : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : null, length : null, position : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : number, length : number, position : null, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : undefined, length : number, position : null, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : null, length : number, position : null, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : number, length : undefined, position : null, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : undefined, length : undefined, position : null, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : null, length : undefined, position : null, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : number, length : null, position : null, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : undefined, length : null, position : null, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : null, length : null, position : null, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : number, length : number, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : undefined, length : number, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : null, length : number, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : number, length : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : undefined, length : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : null, length : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : number, length : null, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : undefined, length : null, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : null, length : null, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : number, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, offset : null, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ <TBuffer extends std.ArrayBufferView>(fd : number, buffer : TBuffer, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, buffer : TBuffer): void): void, readonly ^ (fd : number, string : string, position : number, encoding : node.buffer.<global>.BufferEncoding, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, str : string): void): void, readonly ^ (fd : number, string : string, position : undefined, encoding : node.buffer.<global>.BufferEncoding, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, str : string): void): void, readonly ^ (fd : number, string : string, position : null, encoding : node.buffer.<global>.BufferEncoding, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, str : string): void): void, readonly ^ (fd : number, string : string, position : number, encoding : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, str : string): void): void, readonly ^ (fd : number, string : string, position : undefined, encoding : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, str : string): void): void, readonly ^ (fd : number, string : string, position : null, encoding : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, str : string): void): void, readonly ^ (fd : number, string : string, position : number, encoding : null, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, str : string): void): void, readonly ^ (fd : number, string : string, position : undefined, encoding : null, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, str : string): void): void, readonly ^ (fd : number, string : string, position : null, encoding : null, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, str : string): void): void, readonly ^ (fd : number, string : string, position : number, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, str : string): void): void, readonly ^ (fd : number, string : string, position : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, str : string): void): void, readonly ^ (fd : number, string : string, position : null, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, str : string): void): void, readonly ^ (fd : number, string : string, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, written : number, str : string): void): void},  readonly fchown :{readonly ^ (fd : number, uid : number, gid : number, callback : node.fs.NoParamCallback): void}, readonly writeFileSync (file : node.fs.PathOrFileDescriptor, data : string): void, readonly writeFileSync (file : node.fs.PathOrFileDescriptor, data : std.ArrayBufferView): void, readonly writeFileSync (file : node.fs.PathOrFileDescriptor, data : string, options : node.fs.WriteFileOptions): void, readonly writeFileSync (file : node.fs.PathOrFileDescriptor, data : std.ArrayBufferView, options : node.fs.WriteFileOptions): void, readonly readdirSync (path : node.fs.PathLike): std.Array<string>, readonly readdirSync (path : node.fs.PathLike): std.Array<string>, readonly readdirSync (path : node.fs.PathLike, options : node.anon.WithFileTypes): std.Array<string>, readonly readdirSync (path : node.fs.PathLike, options : node.buffer.<global>.BufferEncoding): std.Array<string>, readonly readdirSync (path : node.fs.PathLike, options : node.anon.Encoding): std.Array<node.buffer.<global>.Buffer>, readonly readdirSync (path : node.fs.PathLike, options : 'buffer'): std.Array<node.buffer.<global>.Buffer>, readonly readdirSync (path : node.fs.PathLike): std.Array<string> | std.Array<node.buffer.<global>.Buffer>, readonly readdirSync (path : node.fs.PathLike): std.Array<string> | std.Array<node.buffer.<global>.Buffer>, readonly readdirSync (path : node.fs.PathLike, options : node.anon.ObjectEncodingOptionswith): std.Array<string> | std.Array<node.buffer.<global>.Buffer>, readonly readdirSync (path : node.fs.PathLike, options : node.buffer.<global>.BufferEncoding): std.Array<string> | std.Array<node.buffer.<global>.Buffer>, readonly readdirSync (path : node.fs.PathLike, options : node.anon.ObjectEncodingOptionswithEncoding): std.Array<node.fs.Dirent>, readonly readlinkSync (path : node.fs.PathLike): string, readonly readlinkSync (path : node.fs.PathLike, options : node.fs.EncodingOption): string, readonly readlinkSync (path : node.fs.PathLike, options : node.fs.BufferEncodingOption): node.buffer.<global>.Buffer, readonly readlinkSync (path : node.fs.PathLike): string | node.buffer.<global>.Buffer, readonly readlinkSync (path : node.fs.PathLike, options : node.fs.EncodingOption): string | node.buffer.<global>.Buffer,  readonly realpath :{readonly native (path : node.fs.PathLike, options : node.fs.EncodingOption, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, resolvedPath : string): void): void, readonly native (path : node.fs.PathLike, options : node.fs.BufferEncodingOption, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, resolvedPath : node.buffer.<global>.Buffer): void): void, readonly native (path : node.fs.PathLike, options : node.fs.EncodingOption, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, resolvedPath : string | node.buffer.<global>.Buffer): void): void, readonly native (path : node.fs.PathLike, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, resolvedPath : string): void): void, readonly ^ (path : node.fs.PathLike, options : node.fs.EncodingOption, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, resolvedPath : string): void): void, readonly ^ (path : node.fs.PathLike, options : node.fs.BufferEncodingOption, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, resolvedPath : node.buffer.<global>.Buffer): void): void, readonly ^ (path : node.fs.PathLike, options : node.fs.EncodingOption, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, resolvedPath : string | node.buffer.<global>.Buffer): void): void, readonly ^ (path : node.fs.PathLike, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, resolvedPath : string): void): void}, readonly existsSync (path : node.fs.PathLike): boolean, readonly futimesSync (fd : number, atime : node.fs.TimeLike, mtime : node.fs.TimeLike): void,  readonly readdir :{readonly ^ (path : node.fs.PathLike, options : node.anon.WithFileTypes, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, files : std.Array<string>): void): void, readonly ^ (path : node.fs.PathLike, options : node.buffer.<global>.BufferEncoding, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, files : std.Array<string>): void): void, readonly ^ (path : node.fs.PathLike, options : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, files : std.Array<string>): void): void, readonly ^ (path : node.fs.PathLike, options : null, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, files : std.Array<string>): void): void, readonly ^ (path : node.fs.PathLike, options : node.anon.Encoding, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, files : std.Array<node.buffer.<global>.Buffer>): void): void, readonly ^ (path : node.fs.PathLike, options : 'buffer', callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, files : std.Array<node.buffer.<global>.Buffer>): void): void, readonly ^ (path : node.fs.PathLike, options : node.anon.ObjectEncodingOptionswith, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, files : std.Array<string> | std.Array<node.buffer.<global>.Buffer>): void): void, readonly ^ (path : node.fs.PathLike, options : node.buffer.<global>.BufferEncoding, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, files : std.Array<string> | std.Array<node.buffer.<global>.Buffer>): void): void, readonly ^ (path : node.fs.PathLike, options : undefined, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, files : std.Array<string> | std.Array<node.buffer.<global>.Buffer>): void): void, readonly ^ (path : node.fs.PathLike, options : null, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, files : std.Array<string> | std.Array<node.buffer.<global>.Buffer>): void): void, readonly ^ (path : node.fs.PathLike, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, files : std.Array<string>): void): void, readonly ^ (path : node.fs.PathLike, options : node.anon.ObjectEncodingOptionswithEncoding, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, files : std.Array<node.fs.Dirent>): void): void}, readonly watch (filename : node.fs.PathLike, options : node.anon.WatchOptionsencodingbuffe): node.fs.FSWatcher, readonly watch (filename : node.fs.PathLike, options : 'buffer'): node.fs.FSWatcher, readonly watch (filename : node.fs.PathLike, options : node.anon.WatchOptionsencodingbuffe, listener : node.fs.WatchListener<node.buffer.<global>.Buffer>): node.fs.FSWatcher, readonly watch (filename : node.fs.PathLike, options : 'buffer', listener : node.fs.WatchListener<node.buffer.<global>.Buffer>): node.fs.FSWatcher, readonly watch (filename : node.fs.PathLike): node.fs.FSWatcher, readonly watch (filename : node.fs.PathLike): node.fs.FSWatcher, readonly watch (filename : node.fs.PathLike, options : node.fs.WatchOptions): node.fs.FSWatcher, readonly watch (filename : node.fs.PathLike, options : node.buffer.<global>.BufferEncoding): node.fs.FSWatcher, readonly watch (filename : node.fs.PathLike, options : node.fs.WatchOptions, listener : node.fs.WatchListener<string>): node.fs.FSWatcher, readonly watch (filename : node.fs.PathLike, options : node.buffer.<global>.BufferEncoding, listener : node.fs.WatchListener<string>): node.fs.FSWatcher, readonly watch (filename : node.fs.PathLike, options : null, listener : node.fs.WatchListener<string>): node.fs.FSWatcher, readonly watch (filename : node.fs.PathLike, options : undefined, listener : node.fs.WatchListener<string>): node.fs.FSWatcher, readonly watch (filename : node.fs.PathLike, options : node.fs.WatchOptions): node.fs.FSWatcher, readonly watch (filename : node.fs.PathLike, options : string): node.fs.FSWatcher, readonly watch (filename : node.fs.PathLike, options : node.fs.WatchOptions, listener : node.fs.WatchListener<string | node.buffer.<global>.Buffer>): node.fs.FSWatcher, readonly watch (filename : node.fs.PathLike, options : string, listener : node.fs.WatchListener<string | node.buffer.<global>.Buffer>): node.fs.FSWatcher, readonly watch (filename : node.fs.PathLike): node.fs.FSWatcher, readonly watch (filename : node.fs.PathLike, listener : node.fs.WatchListener<string>): node.fs.FSWatcher,  readonly mkdtemp :{readonly ^ (prefix : string, options : node.fs.EncodingOption, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, folder : string): void): void, readonly ^ (prefix : string, options : node.anon.2, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, folder : node.buffer.<global>.Buffer): void): void, readonly ^ (prefix : string, options : 'buffer', callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, folder : node.buffer.<global>.Buffer): void): void, readonly ^ (prefix : string, options : node.fs.EncodingOption, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, folder : string | node.buffer.<global>.Buffer): void): void, readonly ^ (prefix : string, callback : (err : / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify NodeJS.ErrnoException * / any | null, folder : string): void): void}}, 'existsSync' | 'readFileSync' | 'statSync'> & std.Pick<fs-merger.fs-merger.FS, 'relativePathTo'> */
  trait FSFacade extends StObject {
    
    def existsSync(path: PathLike): Boolean
    @JSName("existsSync")
    var existsSync_Original: js.Function1[/* path */ PathLike, Boolean]
    
    def readFileSync(path: PathOrFileDescriptor): Buffer
    @JSName("readFileSync")
    var readFileSync_Original: js.Function1[/* path */ PathOrFileDescriptor, Buffer]
    
    def relativePathTo(absolutePath: String): At | Null
    @JSName("relativePathTo")
    var relativePathTo_Original: js.Function1[/* absolutePath */ String, At | Null]
    
    def statSync(path: PathLike): js.UndefOr[Stats]
    def statSync(path: PathLike, options: Unit): Stats
    def statSync(path: PathLike, options: StatSyncOptionsbigintbool): Stats | BigIntStats
    def statSync(path: PathLike, options: StatSyncOptionsbigintfals): js.UndefOr[Stats]
    def statSync(path: PathLike, options: StatSyncOptionsbigintfalsBigint): Stats
    def statSync(path: PathLike, options: StatSyncOptionsbiginttrue): js.UndefOr[BigIntStats]
    def statSync(path: PathLike, options: StatSyncOptionsbiginttrueBigint): BigIntStats
    def statSync(path: PathLike, options: StatSyncOptions): js.UndefOr[Stats | BigIntStats]
    @JSName("statSync")
    var statSync_Original: StatSyncFn
    @JSName("statSync")
    def statSync_Stats(path: PathLike): Stats
  }
  object FSFacade {
    
    inline def apply(
      existsSync: /* path */ PathLike => Boolean,
      readFileSync: /* path */ PathOrFileDescriptor => Buffer,
      relativePathTo: /* absolutePath */ String => At | Null,
      statSync: StatSyncFn
    ): FSFacade = {
      val __obj = js.Dynamic.literal(existsSync = js.Any.fromFunction1(existsSync), readFileSync = js.Any.fromFunction1(readFileSync), relativePathTo = js.Any.fromFunction1(relativePathTo), statSync = statSync.asInstanceOf[js.Any])
      __obj.asInstanceOf[FSFacade]
    }
    
    extension [Self <: FSFacade](x: Self) {
      
      inline def setExistsSync(value: /* path */ PathLike => Boolean): Self = StObject.set(x, "existsSync", js.Any.fromFunction1(value))
      
      inline def setReadFileSync(value: /* path */ PathOrFileDescriptor => Buffer): Self = StObject.set(x, "readFileSync", js.Any.fromFunction1(value))
      
      inline def setRelativePathTo(value: /* absolutePath */ String => At | Null): Self = StObject.set(x, "relativePathTo", js.Any.fromFunction1(value))
      
      inline def setStatSync(value: StatSyncFn): Self = StObject.set(x, "statSync", value.asInstanceOf[js.Any])
    }
  }
  
  trait Options extends StObject {
    
    var fs: FSFacade
  }
  object Options {
    
    inline def apply(fs: FSFacade): Options = {
      val __obj = js.Dynamic.literal(fs = fs.asInstanceOf[js.Any])
      __obj.asInstanceOf[Options]
    }
    
    extension [Self <: Options](x: Self) {
      
      inline def setFs(value: FSFacade): Self = StObject.set(x, "fs", value.asInstanceOf[js.Any])
    }
  }
  
  trait SerializedDependencies extends StObject {
    
    var dependencies: Record[String, js.Array[String]]
    
    var fsTrees: js.Array[SerializedTree]
  }
  object SerializedDependencies {
    
    inline def apply(dependencies: Record[String, js.Array[String]], fsTrees: js.Array[SerializedTree]): SerializedDependencies = {
      val __obj = js.Dynamic.literal(dependencies = dependencies.asInstanceOf[js.Any], fsTrees = fsTrees.asInstanceOf[js.Any])
      __obj.asInstanceOf[SerializedDependencies]
    }
    
    extension [Self <: SerializedDependencies](x: Self) {
      
      inline def setDependencies(value: Record[String, js.Array[String]]): Self = StObject.set(x, "dependencies", value.asInstanceOf[js.Any])
      
      inline def setFsTrees(value: js.Array[SerializedTree]): Self = StObject.set(x, "fsTrees", value.asInstanceOf[js.Any])
      
      inline def setFsTreesVarargs(value: SerializedTree*): Self = StObject.set(x, "fsTrees", js.Array(value*))
    }
  }
  
  type SerializedEntry = (SerializedStatEntry & SerializedTreeEntry) | (SerializedHashEntry & SerializedTreeEntry)
  
  trait SerializedExternalRoot
    extends StObject
       with SerializedRoot {
    
    var rootDir: String
    
    var `type`: external
  }
  object SerializedExternalRoot {
    
    inline def apply(rootDir: String): SerializedExternalRoot = {
      val __obj = js.Dynamic.literal(rootDir = rootDir.asInstanceOf[js.Any])
      __obj.updateDynamic("type")("external")
      __obj.asInstanceOf[SerializedExternalRoot]
    }
    
    extension [Self <: SerializedExternalRoot](x: Self) {
      
      inline def setRootDir(value: String): Self = StObject.set(x, "rootDir", value.asInstanceOf[js.Any])
      
      inline def setType(value: external): Self = StObject.set(x, "type", value.asInstanceOf[js.Any])
    }
  }
  
  trait SerializedHashEntry extends StObject {
    
    var hash: String
    
    var `type`: hash
  }
  object SerializedHashEntry {
    
    inline def apply(hash: String): SerializedHashEntry = {
      val __obj = js.Dynamic.literal(hash = hash.asInstanceOf[js.Any])
      __obj.updateDynamic("type")("hash")
      __obj.asInstanceOf[SerializedHashEntry]
    }
    
    extension [Self <: SerializedHashEntry](x: Self) {
      
      inline def setHash(value: String): Self = StObject.set(x, "hash", value.asInstanceOf[js.Any])
      
      inline def setType(value: hash): Self = StObject.set(x, "type", value.asInstanceOf[js.Any])
    }
  }
  
  trait SerializedLocalRoot
    extends StObject
       with SerializedRoot {
    
    var `type`: local
  }
  object SerializedLocalRoot {
    
    inline def apply(): SerializedLocalRoot = {
      val __obj = js.Dynamic.literal()
      __obj.updateDynamic("type")("local")
      __obj.asInstanceOf[SerializedLocalRoot]
    }
    
    extension [Self <: SerializedLocalRoot](x: Self) {
      
      inline def setType(value: local): Self = StObject.set(x, "type", value.asInstanceOf[js.Any])
    }
  }
  
  /* Rewritten from type alias, can be one of: 
    - typings.broccoliPersistentFilter.dependenciesMod.SerializedExternalRoot
    - typings.broccoliPersistentFilter.dependenciesMod.SerializedLocalRoot
  */
  trait SerializedRoot extends StObject
  object SerializedRoot {
    
    inline def SerializedExternalRoot(rootDir: String): typings.broccoliPersistentFilter.dependenciesMod.SerializedExternalRoot = {
      val __obj = js.Dynamic.literal(rootDir = rootDir.asInstanceOf[js.Any])
      __obj.updateDynamic("type")("external")
      __obj.asInstanceOf[typings.broccoliPersistentFilter.dependenciesMod.SerializedExternalRoot]
    }
    
    inline def SerializedLocalRoot(): typings.broccoliPersistentFilter.dependenciesMod.SerializedLocalRoot = {
      val __obj = js.Dynamic.literal()
      __obj.updateDynamic("type")("local")
      __obj.asInstanceOf[typings.broccoliPersistentFilter.dependenciesMod.SerializedLocalRoot]
    }
  }
  
  trait SerializedStatEntry extends StObject {
    
    var mode: Double
    
    var mtime: Double
    
    var size: Double
    
    var `type`: stat
  }
  object SerializedStatEntry {
    
    inline def apply(mode: Double, mtime: Double, size: Double): SerializedStatEntry = {
      val __obj = js.Dynamic.literal(mode = mode.asInstanceOf[js.Any], mtime = mtime.asInstanceOf[js.Any], size = size.asInstanceOf[js.Any])
      __obj.updateDynamic("type")("stat")
      __obj.asInstanceOf[SerializedStatEntry]
    }
    
    extension [Self <: SerializedStatEntry](x: Self) {
      
      inline def setMode(value: Double): Self = StObject.set(x, "mode", value.asInstanceOf[js.Any])
      
      inline def setMtime(value: Double): Self = StObject.set(x, "mtime", value.asInstanceOf[js.Any])
      
      inline def setSize(value: Double): Self = StObject.set(x, "size", value.asInstanceOf[js.Any])
      
      inline def setType(value: stat): Self = StObject.set(x, "type", value.asInstanceOf[js.Any])
    }
  }
  
  trait SerializedTree extends StObject {
    
    var entries: js.Array[SerializedEntry]
    
    var fsRoot: SerializedRoot
  }
  object SerializedTree {
    
    inline def apply(entries: js.Array[SerializedEntry], fsRoot: SerializedRoot): SerializedTree = {
      val __obj = js.Dynamic.literal(entries = entries.asInstanceOf[js.Any], fsRoot = fsRoot.asInstanceOf[js.Any])
      __obj.asInstanceOf[SerializedTree]
    }
    
    extension [Self <: SerializedTree](x: Self) {
      
      inline def setEntries(value: js.Array[SerializedEntry]): Self = StObject.set(x, "entries", value.asInstanceOf[js.Any])
      
      inline def setEntriesVarargs(value: SerializedEntry*): Self = StObject.set(x, "entries", js.Array(value*))
      
      inline def setFsRoot(value: SerializedRoot): Self = StObject.set(x, "fsRoot", value.asInstanceOf[js.Any])
    }
  }
  
  trait SerializedTreeEntry extends StObject {
    
    var relativePath: String
  }
  object SerializedTreeEntry {
    
    inline def apply(relativePath: String): SerializedTreeEntry = {
      val __obj = js.Dynamic.literal(relativePath = relativePath.asInstanceOf[js.Any])
      __obj.asInstanceOf[SerializedTreeEntry]
    }
    
    extension [Self <: SerializedTreeEntry](x: Self) {
      
      inline def setRelativePath(value: String): Self = StObject.set(x, "relativePath", value.asInstanceOf[js.Any])
    }
  }
}
