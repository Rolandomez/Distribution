package typings.babelTraverse

import org.scalablytyped.runtime.StringDictionary
import typings.babelTraverse.anon.AllowInsertArrow
import typings.babelTraverse.anon.BlockHoist
import typings.babelTraverse.anon.Confident
import typings.babelTraverse.anon.Container
import typings.babelTraverse.anon.FnCall
import typings.babelTraverse.anon.Identifier
import typings.babelTraverse.anon.NoGlobals
import typings.babelTraverse.anon.Type
import typings.babelTraverse.anon.Typeofcache
import typings.babelTraverse.anon.Typeofvisitors
import typings.babelTraverse.anon.`0`
import typings.babelTraverse.anon.`100`
import typings.babelTraverse.anon.`101`
import typings.babelTraverse.anon.`102`
import typings.babelTraverse.anon.`103`
import typings.babelTraverse.anon.`104`
import typings.babelTraverse.anon.`105`
import typings.babelTraverse.anon.`106`
import typings.babelTraverse.anon.`107`
import typings.babelTraverse.anon.`108`
import typings.babelTraverse.anon.`109`
import typings.babelTraverse.anon.`10`
import typings.babelTraverse.anon.`110`
import typings.babelTraverse.anon.`111`
import typings.babelTraverse.anon.`112`
import typings.babelTraverse.anon.`113`
import typings.babelTraverse.anon.`114`
import typings.babelTraverse.anon.`115`
import typings.babelTraverse.anon.`116`
import typings.babelTraverse.anon.`117`
import typings.babelTraverse.anon.`118`
import typings.babelTraverse.anon.`119`
import typings.babelTraverse.anon.`11`
import typings.babelTraverse.anon.`120`
import typings.babelTraverse.anon.`121`
import typings.babelTraverse.anon.`122`
import typings.babelTraverse.anon.`123`
import typings.babelTraverse.anon.`124`
import typings.babelTraverse.anon.`125`
import typings.babelTraverse.anon.`126`
import typings.babelTraverse.anon.`127`
import typings.babelTraverse.anon.`128`
import typings.babelTraverse.anon.`129`
import typings.babelTraverse.anon.`12`
import typings.babelTraverse.anon.`130`
import typings.babelTraverse.anon.`131`
import typings.babelTraverse.anon.`132`
import typings.babelTraverse.anon.`133`
import typings.babelTraverse.anon.`134`
import typings.babelTraverse.anon.`135`
import typings.babelTraverse.anon.`136`
import typings.babelTraverse.anon.`137`
import typings.babelTraverse.anon.`138`
import typings.babelTraverse.anon.`139`
import typings.babelTraverse.anon.`13`
import typings.babelTraverse.anon.`140`
import typings.babelTraverse.anon.`141`
import typings.babelTraverse.anon.`142`
import typings.babelTraverse.anon.`143`
import typings.babelTraverse.anon.`144`
import typings.babelTraverse.anon.`145`
import typings.babelTraverse.anon.`146`
import typings.babelTraverse.anon.`147`
import typings.babelTraverse.anon.`148`
import typings.babelTraverse.anon.`149`
import typings.babelTraverse.anon.`14`
import typings.babelTraverse.anon.`150`
import typings.babelTraverse.anon.`151`
import typings.babelTraverse.anon.`152`
import typings.babelTraverse.anon.`153`
import typings.babelTraverse.anon.`154`
import typings.babelTraverse.anon.`155`
import typings.babelTraverse.anon.`156`
import typings.babelTraverse.anon.`157`
import typings.babelTraverse.anon.`158`
import typings.babelTraverse.anon.`159`
import typings.babelTraverse.anon.`15`
import typings.babelTraverse.anon.`160`
import typings.babelTraverse.anon.`161`
import typings.babelTraverse.anon.`162`
import typings.babelTraverse.anon.`163`
import typings.babelTraverse.anon.`164`
import typings.babelTraverse.anon.`165`
import typings.babelTraverse.anon.`166`
import typings.babelTraverse.anon.`167`
import typings.babelTraverse.anon.`168`
import typings.babelTraverse.anon.`169`
import typings.babelTraverse.anon.`16`
import typings.babelTraverse.anon.`170`
import typings.babelTraverse.anon.`171`
import typings.babelTraverse.anon.`172`
import typings.babelTraverse.anon.`173`
import typings.babelTraverse.anon.`174`
import typings.babelTraverse.anon.`175`
import typings.babelTraverse.anon.`176`
import typings.babelTraverse.anon.`177`
import typings.babelTraverse.anon.`178`
import typings.babelTraverse.anon.`179`
import typings.babelTraverse.anon.`17`
import typings.babelTraverse.anon.`180`
import typings.babelTraverse.anon.`181`
import typings.babelTraverse.anon.`182`
import typings.babelTraverse.anon.`183`
import typings.babelTraverse.anon.`184`
import typings.babelTraverse.anon.`185`
import typings.babelTraverse.anon.`186`
import typings.babelTraverse.anon.`187`
import typings.babelTraverse.anon.`188`
import typings.babelTraverse.anon.`189`
import typings.babelTraverse.anon.`18`
import typings.babelTraverse.anon.`190`
import typings.babelTraverse.anon.`191`
import typings.babelTraverse.anon.`192`
import typings.babelTraverse.anon.`193`
import typings.babelTraverse.anon.`194`
import typings.babelTraverse.anon.`195`
import typings.babelTraverse.anon.`196`
import typings.babelTraverse.anon.`197`
import typings.babelTraverse.anon.`198`
import typings.babelTraverse.anon.`199`
import typings.babelTraverse.anon.`19`
import typings.babelTraverse.anon.`1`
import typings.babelTraverse.anon.`200`
import typings.babelTraverse.anon.`201`
import typings.babelTraverse.anon.`202`
import typings.babelTraverse.anon.`203`
import typings.babelTraverse.anon.`204`
import typings.babelTraverse.anon.`205`
import typings.babelTraverse.anon.`206`
import typings.babelTraverse.anon.`207`
import typings.babelTraverse.anon.`208`
import typings.babelTraverse.anon.`209`
import typings.babelTraverse.anon.`20`
import typings.babelTraverse.anon.`210`
import typings.babelTraverse.anon.`211`
import typings.babelTraverse.anon.`212`
import typings.babelTraverse.anon.`213`
import typings.babelTraverse.anon.`214`
import typings.babelTraverse.anon.`215`
import typings.babelTraverse.anon.`216`
import typings.babelTraverse.anon.`217`
import typings.babelTraverse.anon.`218`
import typings.babelTraverse.anon.`219`
import typings.babelTraverse.anon.`21`
import typings.babelTraverse.anon.`220`
import typings.babelTraverse.anon.`221`
import typings.babelTraverse.anon.`222`
import typings.babelTraverse.anon.`223`
import typings.babelTraverse.anon.`224`
import typings.babelTraverse.anon.`225`
import typings.babelTraverse.anon.`226`
import typings.babelTraverse.anon.`227`
import typings.babelTraverse.anon.`228`
import typings.babelTraverse.anon.`229`
import typings.babelTraverse.anon.`22`
import typings.babelTraverse.anon.`230`
import typings.babelTraverse.anon.`231`
import typings.babelTraverse.anon.`232`
import typings.babelTraverse.anon.`233`
import typings.babelTraverse.anon.`234`
import typings.babelTraverse.anon.`235`
import typings.babelTraverse.anon.`236`
import typings.babelTraverse.anon.`237`
import typings.babelTraverse.anon.`238`
import typings.babelTraverse.anon.`239`
import typings.babelTraverse.anon.`23`
import typings.babelTraverse.anon.`240`
import typings.babelTraverse.anon.`241`
import typings.babelTraverse.anon.`242`
import typings.babelTraverse.anon.`243`
import typings.babelTraverse.anon.`244`
import typings.babelTraverse.anon.`245`
import typings.babelTraverse.anon.`246`
import typings.babelTraverse.anon.`247`
import typings.babelTraverse.anon.`24`
import typings.babelTraverse.anon.`25`
import typings.babelTraverse.anon.`26`
import typings.babelTraverse.anon.`27`
import typings.babelTraverse.anon.`28`
import typings.babelTraverse.anon.`29`
import typings.babelTraverse.anon.`2`
import typings.babelTraverse.anon.`30`
import typings.babelTraverse.anon.`31`
import typings.babelTraverse.anon.`32`
import typings.babelTraverse.anon.`33`
import typings.babelTraverse.anon.`34`
import typings.babelTraverse.anon.`35`
import typings.babelTraverse.anon.`36`
import typings.babelTraverse.anon.`37`
import typings.babelTraverse.anon.`38`
import typings.babelTraverse.anon.`39`
import typings.babelTraverse.anon.`3`
import typings.babelTraverse.anon.`40`
import typings.babelTraverse.anon.`41`
import typings.babelTraverse.anon.`42`
import typings.babelTraverse.anon.`43`
import typings.babelTraverse.anon.`44`
import typings.babelTraverse.anon.`45`
import typings.babelTraverse.anon.`46`
import typings.babelTraverse.anon.`47`
import typings.babelTraverse.anon.`48`
import typings.babelTraverse.anon.`49`
import typings.babelTraverse.anon.`4`
import typings.babelTraverse.anon.`50`
import typings.babelTraverse.anon.`51`
import typings.babelTraverse.anon.`52`
import typings.babelTraverse.anon.`53`
import typings.babelTraverse.anon.`54`
import typings.babelTraverse.anon.`55`
import typings.babelTraverse.anon.`56`
import typings.babelTraverse.anon.`57`
import typings.babelTraverse.anon.`58`
import typings.babelTraverse.anon.`59`
import typings.babelTraverse.anon.`5`
import typings.babelTraverse.anon.`60`
import typings.babelTraverse.anon.`61`
import typings.babelTraverse.anon.`62`
import typings.babelTraverse.anon.`63`
import typings.babelTraverse.anon.`64`
import typings.babelTraverse.anon.`65`
import typings.babelTraverse.anon.`66`
import typings.babelTraverse.anon.`67`
import typings.babelTraverse.anon.`68`
import typings.babelTraverse.anon.`69`
import typings.babelTraverse.anon.`6`
import typings.babelTraverse.anon.`70`
import typings.babelTraverse.anon.`71`
import typings.babelTraverse.anon.`72`
import typings.babelTraverse.anon.`73`
import typings.babelTraverse.anon.`74`
import typings.babelTraverse.anon.`75`
import typings.babelTraverse.anon.`76`
import typings.babelTraverse.anon.`77`
import typings.babelTraverse.anon.`78`
import typings.babelTraverse.anon.`79`
import typings.babelTraverse.anon.`7`
import typings.babelTraverse.anon.`80`
import typings.babelTraverse.anon.`81`
import typings.babelTraverse.anon.`82`
import typings.babelTraverse.anon.`83`
import typings.babelTraverse.anon.`84`
import typings.babelTraverse.anon.`85`
import typings.babelTraverse.anon.`86`
import typings.babelTraverse.anon.`87`
import typings.babelTraverse.anon.`88`
import typings.babelTraverse.anon.`89`
import typings.babelTraverse.anon.`8`
import typings.babelTraverse.anon.`90`
import typings.babelTraverse.anon.`91`
import typings.babelTraverse.anon.`92`
import typings.babelTraverse.anon.`93`
import typings.babelTraverse.anon.`94`
import typings.babelTraverse.anon.`95`
import typings.babelTraverse.anon.`96`
import typings.babelTraverse.anon.`97`
import typings.babelTraverse.anon.`98`
import typings.babelTraverse.anon.`99`
import typings.babelTraverse.anon.`9`
import typings.babelTraverse.babelTraverseBooleans.`false`
import typings.babelTraverse.babelTraverseBooleans.`true`
import typings.babelTraverse.babelTraverseStrings.var_
import typings.babelTypes.mod.Accessor
import typings.babelTypes.mod.ArrayExpression_
import typings.babelTypes.mod.ArrowFunctionExpression_
import typings.babelTypes.mod.Binary
import typings.babelTypes.mod.Block
import typings.babelTypes.mod.BlockParent
import typings.babelTypes.mod.CallExpression_
import typings.babelTypes.mod.Class
import typings.babelTypes.mod.Comment
import typings.babelTypes.mod.CommentTypeShorthand
import typings.babelTypes.mod.CompletionStatement
import typings.babelTypes.mod.Conditional
import typings.babelTypes.mod.Declaration
import typings.babelTypes.mod.EnumBody
import typings.babelTypes.mod.EnumMember
import typings.babelTypes.mod.ExistsTypeAnnotation_
import typings.babelTypes.mod.ExportDeclaration
import typings.babelTypes.mod.Expression
import typings.babelTypes.mod.ExpressionWrapper
import typings.babelTypes.mod.Flow
import typings.babelTypes.mod.FlowBaseAnnotation
import typings.babelTypes.mod.FlowDeclaration
import typings.babelTypes.mod.FlowPredicate
import typings.babelTypes.mod.FlowType
import typings.babelTypes.mod.For
import typings.babelTypes.mod.ForOfStatement_
import typings.babelTypes.mod.ForXStatement
import typings.babelTypes.mod.Function
import typings.babelTypes.mod.FunctionParent
import typings.babelTypes.mod.Identifier_
import typings.babelTypes.mod.Immutable
import typings.babelTypes.mod.ImportDeclaration_
import typings.babelTypes.mod.ImportOrExportDeclaration
import typings.babelTypes.mod.ImportSpecifier_
import typings.babelTypes.mod.JSX
import typings.babelTypes.mod.JSXIdentifier_
import typings.babelTypes.mod.LVal
import typings.babelTypes.mod.LabeledStatement_
import typings.babelTypes.mod.Literal
import typings.babelTypes.mod.Loop
import typings.babelTypes.mod.MemberExpression_
import typings.babelTypes.mod.Method
import typings.babelTypes.mod.Miscellaneous
import typings.babelTypes.mod.ModuleDeclaration
import typings.babelTypes.mod.ModuleSpecifier
import typings.babelTypes.mod.Node
import typings.babelTypes.mod.NumberLiteralTypeAnnotation_
import typings.babelTypes.mod.ObjectMember
import typings.babelTypes.mod.Pattern
import typings.babelTypes.mod.PatternLike
import typings.babelTypes.mod.Private
import typings.babelTypes.mod.PrivateName_
import typings.babelTypes.mod.Property
import typings.babelTypes.mod.Pureish
import typings.babelTypes.mod.RestElement_
import typings.babelTypes.mod.Scopable
import typings.babelTypes.mod.Standardized
import typings.babelTypes.mod.Statement
import typings.babelTypes.mod.TSBaseType
import typings.babelTypes.mod.TSEntityName
import typings.babelTypes.mod.TSType
import typings.babelTypes.mod.TSTypeElement
import typings.babelTypes.mod.Terminatorless
import typings.babelTypes.mod.TypeScript
import typings.babelTypes.mod.UnaryExpression_
import typings.babelTypes.mod.UnaryLike
import typings.babelTypes.mod.UserWhitespacable
import typings.babelTypes.mod.VariableDeclaration_
import typings.babelTypes.mod.While
import typings.std.ErrorConstructor
import typings.std.Exclude
import typings.std.Extract
import typings.std.Map
import typings.std.Record
import typings.std.WeakMap
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object mod {
  
  object default {
    
    inline def apply(parent: Node): Unit = ^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any]).asInstanceOf[Unit]
    inline def apply(parent: Node, opts: Unit, scope: Unit, state: Any): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply(parent: Node, opts: Unit, scope: Unit, state: Any, parentPath: NodePath[Node]): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply(parent: Node, opts: Unit, scope: Unit, state: Unit, parentPath: NodePath[Node]): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply(parent: Node, opts: Unit, scope: Scope): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply(parent: Node, opts: Unit, scope: Scope, state: Any): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply(parent: Node, opts: Unit, scope: Scope, state: Any, parentPath: NodePath[Node]): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply(parent: Node, opts: Unit, scope: Scope, state: Unit, parentPath: NodePath[Node]): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply(parent: Node, opts: TraverseOptions[Node]): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply(parent: Node, opts: TraverseOptions[Node], scope: Unit, state: Any): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply(parent: Node, opts: TraverseOptions[Node], scope: Unit, state: Any, parentPath: NodePath[Node]): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply(parent: Node, opts: TraverseOptions[Node], scope: Unit, state: Unit, parentPath: NodePath[Node]): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply(parent: Node, opts: TraverseOptions[Node], scope: Scope): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply(parent: Node, opts: TraverseOptions[Node], scope: Scope, state: Any): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply(parent: Node, opts: TraverseOptions[Node], scope: Scope, state: Any, parentPath: NodePath[Node]): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply(parent: Node, opts: TraverseOptions[Node], scope: Scope, state: Unit, parentPath: NodePath[Node]): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
    
    @JSImport("@babel/traverse", JSImport.Default)
    @js.native
    val ^ : js.Any = js.native
    
    @JSImport("@babel/traverse", "default.cache")
    @js.native
    def cache: Typeofcache = js.native
    inline def cache_=(x: Typeofcache): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("cache")(x.asInstanceOf[js.Any])
    
    inline def cheap(node: Node, enter: js.Function1[/* node */ Node, Unit]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cheap")(node.asInstanceOf[js.Any], enter.asInstanceOf[js.Any])).asInstanceOf[Unit]
    
    inline def clearNode(node: Node): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("clearNode")(node.asInstanceOf[js.Any]).asInstanceOf[Unit]
    inline def clearNode(
      node: Node,
      opts: /* import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify RemovePropertiesOptions */ Any
    ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("clearNode")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[Unit]
    
    @JSImport("@babel/traverse", "default.explode")
    @js.native
    def explode: FnCall = js.native
    inline def explode[S](visitor: Visitor[S]): /* import warning: importer.ImportType#apply Failed type conversion: {[ Type in std.Exclude<@babel/types.@babel/types.Node, / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify t.DeprecatedAliases * / any>['type'] ]:? @babel/traverse.@babel/traverse.VisitNodeObject<S, std.Extract<@babel/types.@babel/types.Node, {  type :Type}>>} */ js.Any = ^.asInstanceOf[js.Dynamic].applyDynamic("explode")(visitor.asInstanceOf[js.Any]).asInstanceOf[/* import warning: importer.ImportType#apply Failed type conversion: {[ Type in std.Exclude<@babel/types.@babel/types.Node, / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify t.DeprecatedAliases * / any>['type'] ]:? @babel/traverse.@babel/traverse.VisitNodeObject<S, std.Extract<@babel/types.@babel/types.Node, {  type :Type}>>} */ js.Any]
    inline def explode_=(x: FnCall): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("explode")(x.asInstanceOf[js.Any])
    
    inline def hasType(
      tree: Node,
      `type`: /* import warning: LimitUnionLength.leaveTypeRef Was union type with length 249, starting with typings.babelTraverse.babelTraverseStrings.ClassAccessorProperty, typings.babelTraverse.babelTraverseStrings.AnyTypeAnnotation, typings.babelTraverse.babelTraverseStrings.ArgumentPlaceholder */ Any
    ): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("hasType")(tree.asInstanceOf[js.Any], `type`.asInstanceOf[js.Any])).asInstanceOf[Boolean]
    inline def hasType(
      tree: Node,
      `type`: /* import warning: LimitUnionLength.leaveTypeRef Was union type with length 249, starting with typings.babelTraverse.babelTraverseStrings.ClassAccessorProperty, typings.babelTraverse.babelTraverseStrings.AnyTypeAnnotation, typings.babelTraverse.babelTraverseStrings.ArgumentPlaceholder */ Any,
      denylistTypes: js.Array[String]
    ): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("hasType")(tree.asInstanceOf[js.Any], `type`.asInstanceOf[js.Any], denylistTypes.asInstanceOf[js.Any])).asInstanceOf[Boolean]
    
    inline def node(node: Node, opts: TraverseOptions[Node]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def node(node: Node, opts: TraverseOptions[Node], scope: Unit, state: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def node(
      node: Node,
      opts: TraverseOptions[Node],
      scope: Unit,
      state: Any,
      path: Unit,
      skipKeys: Record[String, Boolean]
    ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], path.asInstanceOf[js.Any], skipKeys.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def node(node: Node, opts: TraverseOptions[Node], scope: Unit, state: Any, path: NodePath[Node]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], path.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def node(
      node: Node,
      opts: TraverseOptions[Node],
      scope: Unit,
      state: Any,
      path: NodePath[Node],
      skipKeys: Record[String, Boolean]
    ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], path.asInstanceOf[js.Any], skipKeys.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def node(
      node: Node,
      opts: TraverseOptions[Node],
      scope: Unit,
      state: Unit,
      path: Unit,
      skipKeys: Record[String, Boolean]
    ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], path.asInstanceOf[js.Any], skipKeys.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def node(node: Node, opts: TraverseOptions[Node], scope: Unit, state: Unit, path: NodePath[Node]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], path.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def node(
      node: Node,
      opts: TraverseOptions[Node],
      scope: Unit,
      state: Unit,
      path: NodePath[Node],
      skipKeys: Record[String, Boolean]
    ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], path.asInstanceOf[js.Any], skipKeys.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def node(node: Node, opts: TraverseOptions[Node], scope: Scope): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def node(node: Node, opts: TraverseOptions[Node], scope: Scope, state: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def node(
      node: Node,
      opts: TraverseOptions[Node],
      scope: Scope,
      state: Any,
      path: Unit,
      skipKeys: Record[String, Boolean]
    ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], path.asInstanceOf[js.Any], skipKeys.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def node(node: Node, opts: TraverseOptions[Node], scope: Scope, state: Any, path: NodePath[Node]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], path.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def node(
      node: Node,
      opts: TraverseOptions[Node],
      scope: Scope,
      state: Any,
      path: NodePath[Node],
      skipKeys: Record[String, Boolean]
    ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], path.asInstanceOf[js.Any], skipKeys.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def node(
      node: Node,
      opts: TraverseOptions[Node],
      scope: Scope,
      state: Unit,
      path: Unit,
      skipKeys: Record[String, Boolean]
    ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], path.asInstanceOf[js.Any], skipKeys.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def node(node: Node, opts: TraverseOptions[Node], scope: Scope, state: Unit, path: NodePath[Node]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], path.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def node(
      node: Node,
      opts: TraverseOptions[Node],
      scope: Scope,
      state: Unit,
      path: NodePath[Node],
      skipKeys: Record[String, Boolean]
    ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], path.asInstanceOf[js.Any], skipKeys.asInstanceOf[js.Any])).asInstanceOf[Unit]
    
    inline def removeProperties(tree: Node): Node = ^.asInstanceOf[js.Dynamic].applyDynamic("removeProperties")(tree.asInstanceOf[js.Any]).asInstanceOf[Node]
    inline def removeProperties(
      tree: Node,
      opts: /* import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify RemovePropertiesOptions */ Any
    ): Node = (^.asInstanceOf[js.Dynamic].applyDynamic("removeProperties")(tree.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[Node]
    
    @JSImport("@babel/traverse", "default.verify")
    @js.native
    def verify: js.Function1[/* visitor */ Visitor[Any], Unit] = js.native
    inline def verify(visitor: Visitor[Any]): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("verify")(visitor.asInstanceOf[js.Any]).asInstanceOf[Unit]
    inline def verify_=(x: js.Function1[/* visitor */ Visitor[Any], Unit]): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("verify")(x.asInstanceOf[js.Any])
    
    @JSImport("@babel/traverse", "default.visitors")
    @js.native
    def visitors: Typeofvisitors = js.native
    inline def visitors_=(x: Typeofvisitors): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("visitors")(x.asInstanceOf[js.Any])
  }
  
  @JSImport("@babel/traverse", "Binding")
  @js.native
  open class Binding protected () extends StObject {
    def this(opts: Identifier) = this()
    
    def clearValue(): Unit = js.native
    
    var constant: Boolean = js.native
    
    var constantViolations: js.Array[NodePath[Node]] = js.native
    
    def deopValue(): Unit = js.native
    
    /** Decrement the amount of references to this binding. */
    def dereference(): Unit = js.native
    
    var hasDeoptedValue: Boolean = js.native
    
    var hasValue: Boolean = js.native
    
    var identifier: Identifier_ = js.native
    
    var kind: BindingKind = js.native
    
    var path: NodePath[Node] = js.native
    
    /** Register a constant violation with the provided `path`. */
    def reassign(path: NodePath[Node]): Unit = js.native
    
    /** Increment the amount of references to this binding. */
    def reference(path: NodePath[Node]): Unit = js.native
    
    var referencePaths: js.Array[NodePath[Node]] = js.native
    
    var referenced: Boolean = js.native
    
    var references: Double = js.native
    
    var scope: Scope = js.native
    
    def setValue(value: Any): Unit = js.native
    
    var value: Any = js.native
  }
  
  @JSImport("@babel/traverse", "Hub")
  @js.native
  open class Hub ()
    extends StObject
       with HubInterface {
    
    /* CompleteClass */
    override def addHelper(name: String): Any = js.native
    
    def buildError(node: Node, msg: String): js.Error = js.native
    /* CompleteClass */
    override def buildError(node: Node, msg: String, Error: ErrorConstructor): js.Error = js.native
    
    /* CompleteClass */
    override def getCode(): js.UndefOr[String] = js.native
    
    /* CompleteClass */
    override def getScope(): js.UndefOr[Scope] = js.native
  }
  
  @JSImport("@babel/traverse", "NodePath")
  @js.native
  open class NodePath[T] protected () extends StObject {
    def this(hub: HubInterface, parent: Node) = this()
    
    def addComment(`type`: CommentTypeShorthand, content: String): Unit = js.native
    def addComment(`type`: CommentTypeShorthand, content: String, line: Boolean): Unit = js.native
    
    /** Give node `comments` of the specified `type`. */
    def addComments(`type`: CommentTypeShorthand, comments: js.Array[Comment]): Unit = js.native
    
    /**
      * Convert a given arrow function into a normal ES5 function expression.
      */
    def arrowFunctionToExpression(): NodePath[(Exclude[Function, Method | ArrowFunctionExpression_]) | CallExpression_] = js.native
    def arrowFunctionToExpression(param0: AllowInsertArrow): NodePath[(Exclude[Function, Method | ArrowFunctionExpression_]) | CallExpression_] = js.native
    
    /** @deprecated Use `arrowFunctionToExpression` */
    def arrowFunctionToShadowed(): Unit = js.native
    
    //#endregion
    //#region ------------------------- assertXXX -------------------------
    def assertAccessor(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Accessor))),IArray())))*/ Boolean = js.native
    def assertAccessor(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Accessor))),IArray())))*/ Boolean = js.native
    
    def assertAnyTypeAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(AnyTypeAnnotation))),IArray())))*/ Boolean = js.native
    def assertAnyTypeAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(AnyTypeAnnotation))),IArray())))*/ Boolean = js.native
    
    def assertArgumentPlaceholder(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ArgumentPlaceholder))),IArray())))*/ Boolean = js.native
    def assertArgumentPlaceholder(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ArgumentPlaceholder))),IArray())))*/ Boolean = js.native
    
    def assertArrayExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ArrayExpression))),IArray())))*/ Boolean = js.native
    def assertArrayExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ArrayExpression))),IArray())))*/ Boolean = js.native
    
    def assertArrayPattern(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ArrayPattern))),IArray())))*/ Boolean = js.native
    def assertArrayPattern(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ArrayPattern))),IArray())))*/ Boolean = js.native
    
    def assertArrayTypeAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ArrayTypeAnnotation))),IArray())))*/ Boolean = js.native
    def assertArrayTypeAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ArrayTypeAnnotation))),IArray())))*/ Boolean = js.native
    
    def assertArrowFunctionExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ArrowFunctionExpression))),IArray())))*/ Boolean = js.native
    def assertArrowFunctionExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ArrowFunctionExpression))),IArray())))*/ Boolean = js.native
    
    def assertAssignmentExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(AssignmentExpression))),IArray())))*/ Boolean = js.native
    def assertAssignmentExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(AssignmentExpression))),IArray())))*/ Boolean = js.native
    
    def assertAssignmentPattern(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(AssignmentPattern))),IArray())))*/ Boolean = js.native
    def assertAssignmentPattern(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(AssignmentPattern))),IArray())))*/ Boolean = js.native
    
    def assertAwaitExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(AwaitExpression))),IArray())))*/ Boolean = js.native
    def assertAwaitExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(AwaitExpression))),IArray())))*/ Boolean = js.native
    
    def assertBigIntLiteral(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(BigIntLiteral))),IArray())))*/ Boolean = js.native
    def assertBigIntLiteral(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(BigIntLiteral))),IArray())))*/ Boolean = js.native
    
    def assertBinary(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Binary))),IArray())))*/ Boolean = js.native
    def assertBinary(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Binary))),IArray())))*/ Boolean = js.native
    
    def assertBinaryExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(BinaryExpression))),IArray())))*/ Boolean = js.native
    def assertBinaryExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(BinaryExpression))),IArray())))*/ Boolean = js.native
    
    def assertBindExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(BindExpression))),IArray())))*/ Boolean = js.native
    def assertBindExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(BindExpression))),IArray())))*/ Boolean = js.native
    
    def assertBlock(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Block))),IArray())))*/ Boolean = js.native
    def assertBlock(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Block))),IArray())))*/ Boolean = js.native
    
    def assertBlockParent(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(BlockParent))),IArray())))*/ Boolean = js.native
    def assertBlockParent(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(BlockParent))),IArray())))*/ Boolean = js.native
    
    def assertBlockStatement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(BlockStatement))),IArray())))*/ Boolean = js.native
    def assertBlockStatement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(BlockStatement))),IArray())))*/ Boolean = js.native
    
    def assertBooleanLiteral(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(BooleanLiteral))),IArray())))*/ Boolean = js.native
    def assertBooleanLiteral(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(BooleanLiteral))),IArray())))*/ Boolean = js.native
    
    def assertBooleanLiteralTypeAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(BooleanLiteralTypeAnnotation))),IArray())))*/ Boolean = js.native
    def assertBooleanLiteralTypeAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(BooleanLiteralTypeAnnotation))),IArray())))*/ Boolean = js.native
    
    def assertBooleanTypeAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(BooleanTypeAnnotation))),IArray())))*/ Boolean = js.native
    def assertBooleanTypeAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(BooleanTypeAnnotation))),IArray())))*/ Boolean = js.native
    
    def assertBreakStatement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(BreakStatement))),IArray())))*/ Boolean = js.native
    def assertBreakStatement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(BreakStatement))),IArray())))*/ Boolean = js.native
    
    def assertCallExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(CallExpression))),IArray())))*/ Boolean = js.native
    def assertCallExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(CallExpression))),IArray())))*/ Boolean = js.native
    
    def assertCatchClause(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(CatchClause))),IArray())))*/ Boolean = js.native
    def assertCatchClause(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(CatchClause))),IArray())))*/ Boolean = js.native
    
    def assertClass(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Class))),IArray())))*/ Boolean = js.native
    def assertClass(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Class))),IArray())))*/ Boolean = js.native
    
    def assertClassAccessorProperty(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ClassAccessorProperty))),IArray())))*/ Boolean = js.native
    def assertClassAccessorProperty(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ClassAccessorProperty))),IArray())))*/ Boolean = js.native
    
    def assertClassBody(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ClassBody))),IArray())))*/ Boolean = js.native
    def assertClassBody(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ClassBody))),IArray())))*/ Boolean = js.native
    
    def assertClassDeclaration(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ClassDeclaration))),IArray())))*/ Boolean = js.native
    def assertClassDeclaration(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ClassDeclaration))),IArray())))*/ Boolean = js.native
    
    def assertClassExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ClassExpression))),IArray())))*/ Boolean = js.native
    def assertClassExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ClassExpression))),IArray())))*/ Boolean = js.native
    
    def assertClassImplements(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ClassImplements))),IArray())))*/ Boolean = js.native
    def assertClassImplements(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ClassImplements))),IArray())))*/ Boolean = js.native
    
    def assertClassMethod(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ClassMethod))),IArray())))*/ Boolean = js.native
    def assertClassMethod(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ClassMethod))),IArray())))*/ Boolean = js.native
    
    def assertClassPrivateMethod(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ClassPrivateMethod))),IArray())))*/ Boolean = js.native
    def assertClassPrivateMethod(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ClassPrivateMethod))),IArray())))*/ Boolean = js.native
    
    def assertClassPrivateProperty(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ClassPrivateProperty))),IArray())))*/ Boolean = js.native
    def assertClassPrivateProperty(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ClassPrivateProperty))),IArray())))*/ Boolean = js.native
    
    def assertClassProperty(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ClassProperty))),IArray())))*/ Boolean = js.native
    def assertClassProperty(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ClassProperty))),IArray())))*/ Boolean = js.native
    
    def assertCompletionStatement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(CompletionStatement))),IArray())))*/ Boolean = js.native
    def assertCompletionStatement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(CompletionStatement))),IArray())))*/ Boolean = js.native
    
    def assertConditional(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Conditional))),IArray())))*/ Boolean = js.native
    def assertConditional(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Conditional))),IArray())))*/ Boolean = js.native
    
    def assertConditionalExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ConditionalExpression))),IArray())))*/ Boolean = js.native
    def assertConditionalExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ConditionalExpression))),IArray())))*/ Boolean = js.native
    
    def assertContinueStatement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ContinueStatement))),IArray())))*/ Boolean = js.native
    def assertContinueStatement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ContinueStatement))),IArray())))*/ Boolean = js.native
    
    def assertDebuggerStatement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DebuggerStatement))),IArray())))*/ Boolean = js.native
    def assertDebuggerStatement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DebuggerStatement))),IArray())))*/ Boolean = js.native
    
    def assertDecimalLiteral(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DecimalLiteral))),IArray())))*/ Boolean = js.native
    def assertDecimalLiteral(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DecimalLiteral))),IArray())))*/ Boolean = js.native
    
    def assertDeclaration(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Declaration))),IArray())))*/ Boolean = js.native
    def assertDeclaration(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Declaration))),IArray())))*/ Boolean = js.native
    
    def assertDeclareClass(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DeclareClass))),IArray())))*/ Boolean = js.native
    def assertDeclareClass(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DeclareClass))),IArray())))*/ Boolean = js.native
    
    def assertDeclareExportAllDeclaration(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DeclareExportAllDeclaration))),IArray())))*/ Boolean = js.native
    def assertDeclareExportAllDeclaration(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DeclareExportAllDeclaration))),IArray())))*/ Boolean = js.native
    
    def assertDeclareExportDeclaration(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DeclareExportDeclaration))),IArray())))*/ Boolean = js.native
    def assertDeclareExportDeclaration(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DeclareExportDeclaration))),IArray())))*/ Boolean = js.native
    
    def assertDeclareFunction(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DeclareFunction))),IArray())))*/ Boolean = js.native
    def assertDeclareFunction(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DeclareFunction))),IArray())))*/ Boolean = js.native
    
    def assertDeclareInterface(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DeclareInterface))),IArray())))*/ Boolean = js.native
    def assertDeclareInterface(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DeclareInterface))),IArray())))*/ Boolean = js.native
    
    def assertDeclareModule(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DeclareModule))),IArray())))*/ Boolean = js.native
    def assertDeclareModule(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DeclareModule))),IArray())))*/ Boolean = js.native
    
    def assertDeclareModuleExports(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DeclareModuleExports))),IArray())))*/ Boolean = js.native
    def assertDeclareModuleExports(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DeclareModuleExports))),IArray())))*/ Boolean = js.native
    
    def assertDeclareOpaqueType(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DeclareOpaqueType))),IArray())))*/ Boolean = js.native
    def assertDeclareOpaqueType(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DeclareOpaqueType))),IArray())))*/ Boolean = js.native
    
    def assertDeclareTypeAlias(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DeclareTypeAlias))),IArray())))*/ Boolean = js.native
    def assertDeclareTypeAlias(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DeclareTypeAlias))),IArray())))*/ Boolean = js.native
    
    def assertDeclareVariable(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DeclareVariable))),IArray())))*/ Boolean = js.native
    def assertDeclareVariable(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DeclareVariable))),IArray())))*/ Boolean = js.native
    
    def assertDeclaredPredicate(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DeclaredPredicate))),IArray())))*/ Boolean = js.native
    def assertDeclaredPredicate(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DeclaredPredicate))),IArray())))*/ Boolean = js.native
    
    def assertDecorator(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Decorator))),IArray())))*/ Boolean = js.native
    def assertDecorator(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Decorator))),IArray())))*/ Boolean = js.native
    
    def assertDirective(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Directive))),IArray())))*/ Boolean = js.native
    def assertDirective(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Directive))),IArray())))*/ Boolean = js.native
    
    def assertDirectiveLiteral(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DirectiveLiteral))),IArray())))*/ Boolean = js.native
    def assertDirectiveLiteral(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DirectiveLiteral))),IArray())))*/ Boolean = js.native
    
    def assertDoExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DoExpression))),IArray())))*/ Boolean = js.native
    def assertDoExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DoExpression))),IArray())))*/ Boolean = js.native
    
    def assertDoWhileStatement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DoWhileStatement))),IArray())))*/ Boolean = js.native
    def assertDoWhileStatement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(DoWhileStatement))),IArray())))*/ Boolean = js.native
    
    def assertEmptyStatement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(EmptyStatement))),IArray())))*/ Boolean = js.native
    def assertEmptyStatement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(EmptyStatement))),IArray())))*/ Boolean = js.native
    
    def assertEmptyTypeAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(EmptyTypeAnnotation))),IArray())))*/ Boolean = js.native
    def assertEmptyTypeAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(EmptyTypeAnnotation))),IArray())))*/ Boolean = js.native
    
    def assertEnumBody(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(EnumBody))),IArray())))*/ Boolean = js.native
    def assertEnumBody(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(EnumBody))),IArray())))*/ Boolean = js.native
    
    def assertEnumBooleanBody(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(EnumBooleanBody))),IArray())))*/ Boolean = js.native
    def assertEnumBooleanBody(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(EnumBooleanBody))),IArray())))*/ Boolean = js.native
    
    def assertEnumBooleanMember(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(EnumBooleanMember))),IArray())))*/ Boolean = js.native
    def assertEnumBooleanMember(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(EnumBooleanMember))),IArray())))*/ Boolean = js.native
    
    def assertEnumDeclaration(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(EnumDeclaration))),IArray())))*/ Boolean = js.native
    def assertEnumDeclaration(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(EnumDeclaration))),IArray())))*/ Boolean = js.native
    
    def assertEnumDefaultedMember(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(EnumDefaultedMember))),IArray())))*/ Boolean = js.native
    def assertEnumDefaultedMember(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(EnumDefaultedMember))),IArray())))*/ Boolean = js.native
    
    def assertEnumMember(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(EnumMember))),IArray())))*/ Boolean = js.native
    def assertEnumMember(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(EnumMember))),IArray())))*/ Boolean = js.native
    
    def assertEnumNumberBody(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(EnumNumberBody))),IArray())))*/ Boolean = js.native
    def assertEnumNumberBody(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(EnumNumberBody))),IArray())))*/ Boolean = js.native
    
    def assertEnumNumberMember(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(EnumNumberMember))),IArray())))*/ Boolean = js.native
    def assertEnumNumberMember(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(EnumNumberMember))),IArray())))*/ Boolean = js.native
    
    def assertEnumStringBody(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(EnumStringBody))),IArray())))*/ Boolean = js.native
    def assertEnumStringBody(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(EnumStringBody))),IArray())))*/ Boolean = js.native
    
    def assertEnumStringMember(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(EnumStringMember))),IArray())))*/ Boolean = js.native
    def assertEnumStringMember(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(EnumStringMember))),IArray())))*/ Boolean = js.native
    
    def assertEnumSymbolBody(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(EnumSymbolBody))),IArray())))*/ Boolean = js.native
    def assertEnumSymbolBody(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(EnumSymbolBody))),IArray())))*/ Boolean = js.native
    
    def assertExistsTypeAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ExistsTypeAnnotation))),IArray())))*/ Boolean = js.native
    def assertExistsTypeAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ExistsTypeAnnotation))),IArray())))*/ Boolean = js.native
    
    def assertExportAllDeclaration(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ExportAllDeclaration))),IArray())))*/ Boolean = js.native
    def assertExportAllDeclaration(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ExportAllDeclaration))),IArray())))*/ Boolean = js.native
    
    def assertExportDeclaration(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ExportDeclaration))),IArray())))*/ Boolean = js.native
    def assertExportDeclaration(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ExportDeclaration))),IArray())))*/ Boolean = js.native
    
    def assertExportDefaultDeclaration(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ExportDefaultDeclaration))),IArray())))*/ Boolean = js.native
    def assertExportDefaultDeclaration(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ExportDefaultDeclaration))),IArray())))*/ Boolean = js.native
    
    def assertExportDefaultSpecifier(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ExportDefaultSpecifier))),IArray())))*/ Boolean = js.native
    def assertExportDefaultSpecifier(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ExportDefaultSpecifier))),IArray())))*/ Boolean = js.native
    
    def assertExportNamedDeclaration(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ExportNamedDeclaration))),IArray())))*/ Boolean = js.native
    def assertExportNamedDeclaration(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ExportNamedDeclaration))),IArray())))*/ Boolean = js.native
    
    def assertExportNamespaceSpecifier(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ExportNamespaceSpecifier))),IArray())))*/ Boolean = js.native
    def assertExportNamespaceSpecifier(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ExportNamespaceSpecifier))),IArray())))*/ Boolean = js.native
    
    def assertExportSpecifier(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ExportSpecifier))),IArray())))*/ Boolean = js.native
    def assertExportSpecifier(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ExportSpecifier))),IArray())))*/ Boolean = js.native
    
    def assertExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Expression))),IArray())))*/ Boolean = js.native
    def assertExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Expression))),IArray())))*/ Boolean = js.native
    
    def assertExpressionStatement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ExpressionStatement))),IArray())))*/ Boolean = js.native
    def assertExpressionStatement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ExpressionStatement))),IArray())))*/ Boolean = js.native
    
    def assertExpressionWrapper(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ExpressionWrapper))),IArray())))*/ Boolean = js.native
    def assertExpressionWrapper(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ExpressionWrapper))),IArray())))*/ Boolean = js.native
    
    def assertFile(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(File))),IArray())))*/ Boolean = js.native
    def assertFile(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(File))),IArray())))*/ Boolean = js.native
    
    def assertFlow(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Flow))),IArray())))*/ Boolean = js.native
    def assertFlow(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Flow))),IArray())))*/ Boolean = js.native
    
    def assertFlowBaseAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(FlowBaseAnnotation))),IArray())))*/ Boolean = js.native
    def assertFlowBaseAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(FlowBaseAnnotation))),IArray())))*/ Boolean = js.native
    
    def assertFlowDeclaration(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(FlowDeclaration))),IArray())))*/ Boolean = js.native
    def assertFlowDeclaration(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(FlowDeclaration))),IArray())))*/ Boolean = js.native
    
    def assertFlowPredicate(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(FlowPredicate))),IArray())))*/ Boolean = js.native
    def assertFlowPredicate(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(FlowPredicate))),IArray())))*/ Boolean = js.native
    
    def assertFlowType(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(FlowType))),IArray())))*/ Boolean = js.native
    def assertFlowType(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(FlowType))),IArray())))*/ Boolean = js.native
    
    def assertFor(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(For))),IArray())))*/ Boolean = js.native
    def assertFor(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(For))),IArray())))*/ Boolean = js.native
    
    def assertForInStatement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ForInStatement))),IArray())))*/ Boolean = js.native
    def assertForInStatement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ForInStatement))),IArray())))*/ Boolean = js.native
    
    def assertForOfStatement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ForOfStatement))),IArray())))*/ Boolean = js.native
    def assertForOfStatement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ForOfStatement))),IArray())))*/ Boolean = js.native
    
    def assertForStatement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ForStatement))),IArray())))*/ Boolean = js.native
    def assertForStatement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ForStatement))),IArray())))*/ Boolean = js.native
    
    def assertForXStatement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ForXStatement))),IArray())))*/ Boolean = js.native
    def assertForXStatement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ForXStatement))),IArray())))*/ Boolean = js.native
    
    def assertFunction(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Function))),IArray())))*/ Boolean = js.native
    def assertFunction(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Function))),IArray())))*/ Boolean = js.native
    
    def assertFunctionDeclaration(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(FunctionDeclaration))),IArray())))*/ Boolean = js.native
    def assertFunctionDeclaration(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(FunctionDeclaration))),IArray())))*/ Boolean = js.native
    
    def assertFunctionExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(FunctionExpression))),IArray())))*/ Boolean = js.native
    def assertFunctionExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(FunctionExpression))),IArray())))*/ Boolean = js.native
    
    def assertFunctionParent(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(FunctionParent))),IArray())))*/ Boolean = js.native
    def assertFunctionParent(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(FunctionParent))),IArray())))*/ Boolean = js.native
    
    def assertFunctionTypeAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(FunctionTypeAnnotation))),IArray())))*/ Boolean = js.native
    def assertFunctionTypeAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(FunctionTypeAnnotation))),IArray())))*/ Boolean = js.native
    
    def assertFunctionTypeParam(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(FunctionTypeParam))),IArray())))*/ Boolean = js.native
    def assertFunctionTypeParam(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(FunctionTypeParam))),IArray())))*/ Boolean = js.native
    
    def assertGenericTypeAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(GenericTypeAnnotation))),IArray())))*/ Boolean = js.native
    def assertGenericTypeAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(GenericTypeAnnotation))),IArray())))*/ Boolean = js.native
    
    def assertIdentifier(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Identifier))),IArray())))*/ Boolean = js.native
    def assertIdentifier(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Identifier))),IArray())))*/ Boolean = js.native
    
    def assertIfStatement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(IfStatement))),IArray())))*/ Boolean = js.native
    def assertIfStatement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(IfStatement))),IArray())))*/ Boolean = js.native
    
    def assertImmutable(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Immutable))),IArray())))*/ Boolean = js.native
    def assertImmutable(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Immutable))),IArray())))*/ Boolean = js.native
    
    def assertImport(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Import))),IArray())))*/ Boolean = js.native
    def assertImport(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Import))),IArray())))*/ Boolean = js.native
    
    def assertImportAttribute(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ImportAttribute))),IArray())))*/ Boolean = js.native
    def assertImportAttribute(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ImportAttribute))),IArray())))*/ Boolean = js.native
    
    def assertImportDeclaration(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ImportDeclaration))),IArray())))*/ Boolean = js.native
    def assertImportDeclaration(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ImportDeclaration))),IArray())))*/ Boolean = js.native
    
    def assertImportDefaultSpecifier(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ImportDefaultSpecifier))),IArray())))*/ Boolean = js.native
    def assertImportDefaultSpecifier(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ImportDefaultSpecifier))),IArray())))*/ Boolean = js.native
    
    def assertImportNamespaceSpecifier(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ImportNamespaceSpecifier))),IArray())))*/ Boolean = js.native
    def assertImportNamespaceSpecifier(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ImportNamespaceSpecifier))),IArray())))*/ Boolean = js.native
    
    def assertImportSpecifier(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ImportSpecifier))),IArray())))*/ Boolean = js.native
    def assertImportSpecifier(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ImportSpecifier))),IArray())))*/ Boolean = js.native
    
    def assertIndexedAccessType(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(IndexedAccessType))),IArray())))*/ Boolean = js.native
    def assertIndexedAccessType(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(IndexedAccessType))),IArray())))*/ Boolean = js.native
    
    def assertInferredPredicate(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(InferredPredicate))),IArray())))*/ Boolean = js.native
    def assertInferredPredicate(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(InferredPredicate))),IArray())))*/ Boolean = js.native
    
    def assertInterfaceDeclaration(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(InterfaceDeclaration))),IArray())))*/ Boolean = js.native
    def assertInterfaceDeclaration(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(InterfaceDeclaration))),IArray())))*/ Boolean = js.native
    
    def assertInterfaceExtends(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(InterfaceExtends))),IArray())))*/ Boolean = js.native
    def assertInterfaceExtends(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(InterfaceExtends))),IArray())))*/ Boolean = js.native
    
    def assertInterfaceTypeAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(InterfaceTypeAnnotation))),IArray())))*/ Boolean = js.native
    def assertInterfaceTypeAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(InterfaceTypeAnnotation))),IArray())))*/ Boolean = js.native
    
    def assertInterpreterDirective(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(InterpreterDirective))),IArray())))*/ Boolean = js.native
    def assertInterpreterDirective(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(InterpreterDirective))),IArray())))*/ Boolean = js.native
    
    def assertIntersectionTypeAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(IntersectionTypeAnnotation))),IArray())))*/ Boolean = js.native
    def assertIntersectionTypeAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(IntersectionTypeAnnotation))),IArray())))*/ Boolean = js.native
    
    def assertJSX(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSX))),IArray())))*/ Boolean = js.native
    def assertJSX(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSX))),IArray())))*/ Boolean = js.native
    
    def assertJSXAttribute(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXAttribute))),IArray())))*/ Boolean = js.native
    def assertJSXAttribute(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXAttribute))),IArray())))*/ Boolean = js.native
    
    def assertJSXClosingElement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXClosingElement))),IArray())))*/ Boolean = js.native
    def assertJSXClosingElement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXClosingElement))),IArray())))*/ Boolean = js.native
    
    def assertJSXClosingFragment(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXClosingFragment))),IArray())))*/ Boolean = js.native
    def assertJSXClosingFragment(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXClosingFragment))),IArray())))*/ Boolean = js.native
    
    def assertJSXElement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXElement))),IArray())))*/ Boolean = js.native
    def assertJSXElement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXElement))),IArray())))*/ Boolean = js.native
    
    def assertJSXEmptyExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXEmptyExpression))),IArray())))*/ Boolean = js.native
    def assertJSXEmptyExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXEmptyExpression))),IArray())))*/ Boolean = js.native
    
    def assertJSXExpressionContainer(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXExpressionContainer))),IArray())))*/ Boolean = js.native
    def assertJSXExpressionContainer(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXExpressionContainer))),IArray())))*/ Boolean = js.native
    
    def assertJSXFragment(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXFragment))),IArray())))*/ Boolean = js.native
    def assertJSXFragment(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXFragment))),IArray())))*/ Boolean = js.native
    
    def assertJSXIdentifier(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXIdentifier))),IArray())))*/ Boolean = js.native
    def assertJSXIdentifier(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXIdentifier))),IArray())))*/ Boolean = js.native
    
    def assertJSXMemberExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXMemberExpression))),IArray())))*/ Boolean = js.native
    def assertJSXMemberExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXMemberExpression))),IArray())))*/ Boolean = js.native
    
    def assertJSXNamespacedName(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXNamespacedName))),IArray())))*/ Boolean = js.native
    def assertJSXNamespacedName(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXNamespacedName))),IArray())))*/ Boolean = js.native
    
    def assertJSXOpeningElement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXOpeningElement))),IArray())))*/ Boolean = js.native
    def assertJSXOpeningElement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXOpeningElement))),IArray())))*/ Boolean = js.native
    
    def assertJSXOpeningFragment(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXOpeningFragment))),IArray())))*/ Boolean = js.native
    def assertJSXOpeningFragment(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXOpeningFragment))),IArray())))*/ Boolean = js.native
    
    def assertJSXSpreadAttribute(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXSpreadAttribute))),IArray())))*/ Boolean = js.native
    def assertJSXSpreadAttribute(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXSpreadAttribute))),IArray())))*/ Boolean = js.native
    
    def assertJSXSpreadChild(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXSpreadChild))),IArray())))*/ Boolean = js.native
    def assertJSXSpreadChild(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXSpreadChild))),IArray())))*/ Boolean = js.native
    
    def assertJSXText(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXText))),IArray())))*/ Boolean = js.native
    def assertJSXText(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(JSXText))),IArray())))*/ Boolean = js.native
    
    def assertLVal(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(LVal))),IArray())))*/ Boolean = js.native
    def assertLVal(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(LVal))),IArray())))*/ Boolean = js.native
    
    def assertLabeledStatement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(LabeledStatement))),IArray())))*/ Boolean = js.native
    def assertLabeledStatement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(LabeledStatement))),IArray())))*/ Boolean = js.native
    
    def assertLiteral(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Literal))),IArray())))*/ Boolean = js.native
    def assertLiteral(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Literal))),IArray())))*/ Boolean = js.native
    
    def assertLogicalExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(LogicalExpression))),IArray())))*/ Boolean = js.native
    def assertLogicalExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(LogicalExpression))),IArray())))*/ Boolean = js.native
    
    def assertLoop(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Loop))),IArray())))*/ Boolean = js.native
    def assertLoop(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Loop))),IArray())))*/ Boolean = js.native
    
    def assertMemberExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(MemberExpression))),IArray())))*/ Boolean = js.native
    def assertMemberExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(MemberExpression))),IArray())))*/ Boolean = js.native
    
    def assertMetaProperty(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(MetaProperty))),IArray())))*/ Boolean = js.native
    def assertMetaProperty(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(MetaProperty))),IArray())))*/ Boolean = js.native
    
    def assertMethod(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Method))),IArray())))*/ Boolean = js.native
    def assertMethod(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Method))),IArray())))*/ Boolean = js.native
    
    def assertMiscellaneous(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Miscellaneous))),IArray())))*/ Boolean = js.native
    def assertMiscellaneous(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Miscellaneous))),IArray())))*/ Boolean = js.native
    
    def assertMixedTypeAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(MixedTypeAnnotation))),IArray())))*/ Boolean = js.native
    def assertMixedTypeAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(MixedTypeAnnotation))),IArray())))*/ Boolean = js.native
    
    def assertModuleDeclaration(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ModuleDeclaration))),IArray())))*/ Boolean = js.native
    def assertModuleDeclaration(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ModuleDeclaration))),IArray())))*/ Boolean = js.native
    
    def assertModuleExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ModuleExpression))),IArray())))*/ Boolean = js.native
    def assertModuleExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ModuleExpression))),IArray())))*/ Boolean = js.native
    
    def assertModuleSpecifier(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ModuleSpecifier))),IArray())))*/ Boolean = js.native
    def assertModuleSpecifier(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ModuleSpecifier))),IArray())))*/ Boolean = js.native
    
    def assertNewExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(NewExpression))),IArray())))*/ Boolean = js.native
    def assertNewExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(NewExpression))),IArray())))*/ Boolean = js.native
    
    def assertNoop(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Noop))),IArray())))*/ Boolean = js.native
    def assertNoop(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Noop))),IArray())))*/ Boolean = js.native
    
    def assertNullLiteral(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(NullLiteral))),IArray())))*/ Boolean = js.native
    def assertNullLiteral(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(NullLiteral))),IArray())))*/ Boolean = js.native
    
    def assertNullLiteralTypeAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(NullLiteralTypeAnnotation))),IArray())))*/ Boolean = js.native
    def assertNullLiteralTypeAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(NullLiteralTypeAnnotation))),IArray())))*/ Boolean = js.native
    
    def assertNullableTypeAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(NullableTypeAnnotation))),IArray())))*/ Boolean = js.native
    def assertNullableTypeAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(NullableTypeAnnotation))),IArray())))*/ Boolean = js.native
    
    /** @deprecated Use `assertNumericLiteral` */
    def assertNumberLiteral(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(NumberLiteral))),IArray())))*/ Boolean = js.native
    def assertNumberLiteral(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(NumberLiteral))),IArray())))*/ Boolean = js.native
    
    def assertNumberLiteralTypeAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(NumberLiteralTypeAnnotation))),IArray())))*/ Boolean = js.native
    def assertNumberLiteralTypeAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(NumberLiteralTypeAnnotation))),IArray())))*/ Boolean = js.native
    
    def assertNumberTypeAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(NumberTypeAnnotation))),IArray())))*/ Boolean = js.native
    def assertNumberTypeAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(NumberTypeAnnotation))),IArray())))*/ Boolean = js.native
    
    def assertNumericLiteral(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(NumericLiteral))),IArray())))*/ Boolean = js.native
    def assertNumericLiteral(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(NumericLiteral))),IArray())))*/ Boolean = js.native
    
    def assertObjectExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ObjectExpression))),IArray())))*/ Boolean = js.native
    def assertObjectExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ObjectExpression))),IArray())))*/ Boolean = js.native
    
    def assertObjectMember(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ObjectMember))),IArray())))*/ Boolean = js.native
    def assertObjectMember(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ObjectMember))),IArray())))*/ Boolean = js.native
    
    def assertObjectMethod(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ObjectMethod))),IArray())))*/ Boolean = js.native
    def assertObjectMethod(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ObjectMethod))),IArray())))*/ Boolean = js.native
    
    def assertObjectPattern(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ObjectPattern))),IArray())))*/ Boolean = js.native
    def assertObjectPattern(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ObjectPattern))),IArray())))*/ Boolean = js.native
    
    def assertObjectProperty(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ObjectProperty))),IArray())))*/ Boolean = js.native
    def assertObjectProperty(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ObjectProperty))),IArray())))*/ Boolean = js.native
    
    def assertObjectTypeAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ObjectTypeAnnotation))),IArray())))*/ Boolean = js.native
    def assertObjectTypeAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ObjectTypeAnnotation))),IArray())))*/ Boolean = js.native
    
    def assertObjectTypeCallProperty(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ObjectTypeCallProperty))),IArray())))*/ Boolean = js.native
    def assertObjectTypeCallProperty(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ObjectTypeCallProperty))),IArray())))*/ Boolean = js.native
    
    def assertObjectTypeIndexer(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ObjectTypeIndexer))),IArray())))*/ Boolean = js.native
    def assertObjectTypeIndexer(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ObjectTypeIndexer))),IArray())))*/ Boolean = js.native
    
    def assertObjectTypeInternalSlot(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ObjectTypeInternalSlot))),IArray())))*/ Boolean = js.native
    def assertObjectTypeInternalSlot(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ObjectTypeInternalSlot))),IArray())))*/ Boolean = js.native
    
    def assertObjectTypeProperty(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ObjectTypeProperty))),IArray())))*/ Boolean = js.native
    def assertObjectTypeProperty(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ObjectTypeProperty))),IArray())))*/ Boolean = js.native
    
    def assertObjectTypeSpreadProperty(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ObjectTypeSpreadProperty))),IArray())))*/ Boolean = js.native
    def assertObjectTypeSpreadProperty(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ObjectTypeSpreadProperty))),IArray())))*/ Boolean = js.native
    
    def assertOpaqueType(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(OpaqueType))),IArray())))*/ Boolean = js.native
    def assertOpaqueType(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(OpaqueType))),IArray())))*/ Boolean = js.native
    
    def assertOptionalCallExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(OptionalCallExpression))),IArray())))*/ Boolean = js.native
    def assertOptionalCallExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(OptionalCallExpression))),IArray())))*/ Boolean = js.native
    
    def assertOptionalIndexedAccessType(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(OptionalIndexedAccessType))),IArray())))*/ Boolean = js.native
    def assertOptionalIndexedAccessType(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(OptionalIndexedAccessType))),IArray())))*/ Boolean = js.native
    
    def assertOptionalMemberExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(OptionalMemberExpression))),IArray())))*/ Boolean = js.native
    def assertOptionalMemberExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(OptionalMemberExpression))),IArray())))*/ Boolean = js.native
    
    def assertParenthesizedExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ParenthesizedExpression))),IArray())))*/ Boolean = js.native
    def assertParenthesizedExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ParenthesizedExpression))),IArray())))*/ Boolean = js.native
    
    def assertPattern(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Pattern))),IArray())))*/ Boolean = js.native
    def assertPattern(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Pattern))),IArray())))*/ Boolean = js.native
    
    def assertPatternLike(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(PatternLike))),IArray())))*/ Boolean = js.native
    def assertPatternLike(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(PatternLike))),IArray())))*/ Boolean = js.native
    
    def assertPipelineBareFunction(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(PipelineBareFunction))),IArray())))*/ Boolean = js.native
    def assertPipelineBareFunction(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(PipelineBareFunction))),IArray())))*/ Boolean = js.native
    
    def assertPipelinePrimaryTopicReference(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(PipelinePrimaryTopicReference))),IArray())))*/ Boolean = js.native
    def assertPipelinePrimaryTopicReference(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(PipelinePrimaryTopicReference))),IArray())))*/ Boolean = js.native
    
    def assertPipelineTopicExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(PipelineTopicExpression))),IArray())))*/ Boolean = js.native
    def assertPipelineTopicExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(PipelineTopicExpression))),IArray())))*/ Boolean = js.native
    
    def assertPlaceholder(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Placeholder))),IArray())))*/ Boolean = js.native
    def assertPlaceholder(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Placeholder))),IArray())))*/ Boolean = js.native
    
    def assertPrivate(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Private))),IArray())))*/ Boolean = js.native
    def assertPrivate(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Private))),IArray())))*/ Boolean = js.native
    
    def assertPrivateName(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(PrivateName))),IArray())))*/ Boolean = js.native
    def assertPrivateName(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(PrivateName))),IArray())))*/ Boolean = js.native
    
    def assertProgram(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Program))),IArray())))*/ Boolean = js.native
    def assertProgram(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Program))),IArray())))*/ Boolean = js.native
    
    def assertProperty(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Property))),IArray())))*/ Boolean = js.native
    def assertProperty(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Property))),IArray())))*/ Boolean = js.native
    
    def assertPureish(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Pureish))),IArray())))*/ Boolean = js.native
    def assertPureish(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Pureish))),IArray())))*/ Boolean = js.native
    
    def assertQualifiedTypeIdentifier(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(QualifiedTypeIdentifier))),IArray())))*/ Boolean = js.native
    def assertQualifiedTypeIdentifier(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(QualifiedTypeIdentifier))),IArray())))*/ Boolean = js.native
    
    def assertRecordExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(RecordExpression))),IArray())))*/ Boolean = js.native
    def assertRecordExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(RecordExpression))),IArray())))*/ Boolean = js.native
    
    def assertRegExpLiteral(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(RegExpLiteral))),IArray())))*/ Boolean = js.native
    def assertRegExpLiteral(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(RegExpLiteral))),IArray())))*/ Boolean = js.native
    
    /** @deprecated Use `assertRegExpLiteral` */
    def assertRegexLiteral(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(RegexLiteral))),IArray())))*/ Boolean = js.native
    def assertRegexLiteral(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(RegexLiteral))),IArray())))*/ Boolean = js.native
    
    def assertRestElement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(RestElement))),IArray())))*/ Boolean = js.native
    def assertRestElement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(RestElement))),IArray())))*/ Boolean = js.native
    
    /** @deprecated Use `assertRestElement` */
    def assertRestProperty(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(RestProperty))),IArray())))*/ Boolean = js.native
    def assertRestProperty(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(RestProperty))),IArray())))*/ Boolean = js.native
    
    def assertReturnStatement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ReturnStatement))),IArray())))*/ Boolean = js.native
    def assertReturnStatement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ReturnStatement))),IArray())))*/ Boolean = js.native
    
    def assertScopable(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Scopable))),IArray())))*/ Boolean = js.native
    def assertScopable(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Scopable))),IArray())))*/ Boolean = js.native
    
    def assertSequenceExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(SequenceExpression))),IArray())))*/ Boolean = js.native
    def assertSequenceExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(SequenceExpression))),IArray())))*/ Boolean = js.native
    
    def assertSpreadElement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(SpreadElement))),IArray())))*/ Boolean = js.native
    def assertSpreadElement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(SpreadElement))),IArray())))*/ Boolean = js.native
    
    /** @deprecated Use `assertSpreadElement` */
    def assertSpreadProperty(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(SpreadProperty))),IArray())))*/ Boolean = js.native
    def assertSpreadProperty(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(SpreadProperty))),IArray())))*/ Boolean = js.native
    
    def assertStandardized(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Standardized))),IArray())))*/ Boolean = js.native
    def assertStandardized(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Standardized))),IArray())))*/ Boolean = js.native
    
    def assertStatement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Statement))),IArray())))*/ Boolean = js.native
    def assertStatement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Statement))),IArray())))*/ Boolean = js.native
    
    def assertStaticBlock(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(StaticBlock))),IArray())))*/ Boolean = js.native
    def assertStaticBlock(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(StaticBlock))),IArray())))*/ Boolean = js.native
    
    def assertStringLiteral(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(StringLiteral))),IArray())))*/ Boolean = js.native
    def assertStringLiteral(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(StringLiteral))),IArray())))*/ Boolean = js.native
    
    def assertStringLiteralTypeAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(StringLiteralTypeAnnotation))),IArray())))*/ Boolean = js.native
    def assertStringLiteralTypeAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(StringLiteralTypeAnnotation))),IArray())))*/ Boolean = js.native
    
    def assertStringTypeAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(StringTypeAnnotation))),IArray())))*/ Boolean = js.native
    def assertStringTypeAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(StringTypeAnnotation))),IArray())))*/ Boolean = js.native
    
    def assertSuper(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Super))),IArray())))*/ Boolean = js.native
    def assertSuper(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Super))),IArray())))*/ Boolean = js.native
    
    def assertSwitchCase(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(SwitchCase))),IArray())))*/ Boolean = js.native
    def assertSwitchCase(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(SwitchCase))),IArray())))*/ Boolean = js.native
    
    def assertSwitchStatement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(SwitchStatement))),IArray())))*/ Boolean = js.native
    def assertSwitchStatement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(SwitchStatement))),IArray())))*/ Boolean = js.native
    
    def assertSymbolTypeAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(SymbolTypeAnnotation))),IArray())))*/ Boolean = js.native
    def assertSymbolTypeAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(SymbolTypeAnnotation))),IArray())))*/ Boolean = js.native
    
    def assertTSAnyKeyword(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSAnyKeyword))),IArray())))*/ Boolean = js.native
    def assertTSAnyKeyword(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSAnyKeyword))),IArray())))*/ Boolean = js.native
    
    def assertTSArrayType(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSArrayType))),IArray())))*/ Boolean = js.native
    def assertTSArrayType(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSArrayType))),IArray())))*/ Boolean = js.native
    
    def assertTSAsExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSAsExpression))),IArray())))*/ Boolean = js.native
    def assertTSAsExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSAsExpression))),IArray())))*/ Boolean = js.native
    
    def assertTSBaseType(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSBaseType))),IArray())))*/ Boolean = js.native
    def assertTSBaseType(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSBaseType))),IArray())))*/ Boolean = js.native
    
    def assertTSBigIntKeyword(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSBigIntKeyword))),IArray())))*/ Boolean = js.native
    def assertTSBigIntKeyword(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSBigIntKeyword))),IArray())))*/ Boolean = js.native
    
    def assertTSBooleanKeyword(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSBooleanKeyword))),IArray())))*/ Boolean = js.native
    def assertTSBooleanKeyword(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSBooleanKeyword))),IArray())))*/ Boolean = js.native
    
    def assertTSCallSignatureDeclaration(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSCallSignatureDeclaration))),IArray())))*/ Boolean = js.native
    def assertTSCallSignatureDeclaration(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSCallSignatureDeclaration))),IArray())))*/ Boolean = js.native
    
    def assertTSConditionalType(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSConditionalType))),IArray())))*/ Boolean = js.native
    def assertTSConditionalType(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSConditionalType))),IArray())))*/ Boolean = js.native
    
    def assertTSConstructSignatureDeclaration(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSConstructSignatureDeclaration))),IArray())))*/ Boolean = js.native
    def assertTSConstructSignatureDeclaration(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSConstructSignatureDeclaration))),IArray())))*/ Boolean = js.native
    
    def assertTSConstructorType(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSConstructorType))),IArray())))*/ Boolean = js.native
    def assertTSConstructorType(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSConstructorType))),IArray())))*/ Boolean = js.native
    
    def assertTSDeclareFunction(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSDeclareFunction))),IArray())))*/ Boolean = js.native
    def assertTSDeclareFunction(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSDeclareFunction))),IArray())))*/ Boolean = js.native
    
    def assertTSDeclareMethod(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSDeclareMethod))),IArray())))*/ Boolean = js.native
    def assertTSDeclareMethod(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSDeclareMethod))),IArray())))*/ Boolean = js.native
    
    def assertTSEntityName(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSEntityName))),IArray())))*/ Boolean = js.native
    def assertTSEntityName(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSEntityName))),IArray())))*/ Boolean = js.native
    
    def assertTSEnumDeclaration(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSEnumDeclaration))),IArray())))*/ Boolean = js.native
    def assertTSEnumDeclaration(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSEnumDeclaration))),IArray())))*/ Boolean = js.native
    
    def assertTSEnumMember(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSEnumMember))),IArray())))*/ Boolean = js.native
    def assertTSEnumMember(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSEnumMember))),IArray())))*/ Boolean = js.native
    
    def assertTSExportAssignment(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSExportAssignment))),IArray())))*/ Boolean = js.native
    def assertTSExportAssignment(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSExportAssignment))),IArray())))*/ Boolean = js.native
    
    def assertTSExpressionWithTypeArguments(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSExpressionWithTypeArguments))),IArray())))*/ Boolean = js.native
    def assertTSExpressionWithTypeArguments(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSExpressionWithTypeArguments))),IArray())))*/ Boolean = js.native
    
    def assertTSExternalModuleReference(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSExternalModuleReference))),IArray())))*/ Boolean = js.native
    def assertTSExternalModuleReference(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSExternalModuleReference))),IArray())))*/ Boolean = js.native
    
    def assertTSFunctionType(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSFunctionType))),IArray())))*/ Boolean = js.native
    def assertTSFunctionType(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSFunctionType))),IArray())))*/ Boolean = js.native
    
    def assertTSImportEqualsDeclaration(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSImportEqualsDeclaration))),IArray())))*/ Boolean = js.native
    def assertTSImportEqualsDeclaration(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSImportEqualsDeclaration))),IArray())))*/ Boolean = js.native
    
    def assertTSImportType(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSImportType))),IArray())))*/ Boolean = js.native
    def assertTSImportType(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSImportType))),IArray())))*/ Boolean = js.native
    
    def assertTSIndexSignature(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSIndexSignature))),IArray())))*/ Boolean = js.native
    def assertTSIndexSignature(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSIndexSignature))),IArray())))*/ Boolean = js.native
    
    def assertTSIndexedAccessType(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSIndexedAccessType))),IArray())))*/ Boolean = js.native
    def assertTSIndexedAccessType(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSIndexedAccessType))),IArray())))*/ Boolean = js.native
    
    def assertTSInferType(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSInferType))),IArray())))*/ Boolean = js.native
    def assertTSInferType(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSInferType))),IArray())))*/ Boolean = js.native
    
    def assertTSInstantiationExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSInstantiationExpression))),IArray())))*/ Boolean = js.native
    def assertTSInstantiationExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSInstantiationExpression))),IArray())))*/ Boolean = js.native
    
    def assertTSInterfaceBody(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSInterfaceBody))),IArray())))*/ Boolean = js.native
    def assertTSInterfaceBody(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSInterfaceBody))),IArray())))*/ Boolean = js.native
    
    def assertTSInterfaceDeclaration(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSInterfaceDeclaration))),IArray())))*/ Boolean = js.native
    def assertTSInterfaceDeclaration(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSInterfaceDeclaration))),IArray())))*/ Boolean = js.native
    
    def assertTSIntersectionType(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSIntersectionType))),IArray())))*/ Boolean = js.native
    def assertTSIntersectionType(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSIntersectionType))),IArray())))*/ Boolean = js.native
    
    def assertTSIntrinsicKeyword(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSIntrinsicKeyword))),IArray())))*/ Boolean = js.native
    def assertTSIntrinsicKeyword(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSIntrinsicKeyword))),IArray())))*/ Boolean = js.native
    
    def assertTSLiteralType(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSLiteralType))),IArray())))*/ Boolean = js.native
    def assertTSLiteralType(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSLiteralType))),IArray())))*/ Boolean = js.native
    
    def assertTSMappedType(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSMappedType))),IArray())))*/ Boolean = js.native
    def assertTSMappedType(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSMappedType))),IArray())))*/ Boolean = js.native
    
    def assertTSMethodSignature(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSMethodSignature))),IArray())))*/ Boolean = js.native
    def assertTSMethodSignature(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSMethodSignature))),IArray())))*/ Boolean = js.native
    
    def assertTSModuleBlock(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSModuleBlock))),IArray())))*/ Boolean = js.native
    def assertTSModuleBlock(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSModuleBlock))),IArray())))*/ Boolean = js.native
    
    def assertTSModuleDeclaration(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSModuleDeclaration))),IArray())))*/ Boolean = js.native
    def assertTSModuleDeclaration(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSModuleDeclaration))),IArray())))*/ Boolean = js.native
    
    def assertTSNamedTupleMember(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSNamedTupleMember))),IArray())))*/ Boolean = js.native
    def assertTSNamedTupleMember(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSNamedTupleMember))),IArray())))*/ Boolean = js.native
    
    def assertTSNamespaceExportDeclaration(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSNamespaceExportDeclaration))),IArray())))*/ Boolean = js.native
    def assertTSNamespaceExportDeclaration(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSNamespaceExportDeclaration))),IArray())))*/ Boolean = js.native
    
    def assertTSNeverKeyword(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSNeverKeyword))),IArray())))*/ Boolean = js.native
    def assertTSNeverKeyword(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSNeverKeyword))),IArray())))*/ Boolean = js.native
    
    def assertTSNonNullExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSNonNullExpression))),IArray())))*/ Boolean = js.native
    def assertTSNonNullExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSNonNullExpression))),IArray())))*/ Boolean = js.native
    
    def assertTSNullKeyword(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSNullKeyword))),IArray())))*/ Boolean = js.native
    def assertTSNullKeyword(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSNullKeyword))),IArray())))*/ Boolean = js.native
    
    def assertTSNumberKeyword(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSNumberKeyword))),IArray())))*/ Boolean = js.native
    def assertTSNumberKeyword(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSNumberKeyword))),IArray())))*/ Boolean = js.native
    
    def assertTSObjectKeyword(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSObjectKeyword))),IArray())))*/ Boolean = js.native
    def assertTSObjectKeyword(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSObjectKeyword))),IArray())))*/ Boolean = js.native
    
    def assertTSOptionalType(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSOptionalType))),IArray())))*/ Boolean = js.native
    def assertTSOptionalType(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSOptionalType))),IArray())))*/ Boolean = js.native
    
    def assertTSParameterProperty(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSParameterProperty))),IArray())))*/ Boolean = js.native
    def assertTSParameterProperty(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSParameterProperty))),IArray())))*/ Boolean = js.native
    
    def assertTSParenthesizedType(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSParenthesizedType))),IArray())))*/ Boolean = js.native
    def assertTSParenthesizedType(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSParenthesizedType))),IArray())))*/ Boolean = js.native
    
    def assertTSPropertySignature(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSPropertySignature))),IArray())))*/ Boolean = js.native
    def assertTSPropertySignature(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSPropertySignature))),IArray())))*/ Boolean = js.native
    
    def assertTSQualifiedName(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSQualifiedName))),IArray())))*/ Boolean = js.native
    def assertTSQualifiedName(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSQualifiedName))),IArray())))*/ Boolean = js.native
    
    def assertTSRestType(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSRestType))),IArray())))*/ Boolean = js.native
    def assertTSRestType(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSRestType))),IArray())))*/ Boolean = js.native
    
    def assertTSSatisfiesExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSSatisfiesExpression))),IArray())))*/ Boolean = js.native
    def assertTSSatisfiesExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSSatisfiesExpression))),IArray())))*/ Boolean = js.native
    
    def assertTSStringKeyword(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSStringKeyword))),IArray())))*/ Boolean = js.native
    def assertTSStringKeyword(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSStringKeyword))),IArray())))*/ Boolean = js.native
    
    def assertTSSymbolKeyword(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSSymbolKeyword))),IArray())))*/ Boolean = js.native
    def assertTSSymbolKeyword(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSSymbolKeyword))),IArray())))*/ Boolean = js.native
    
    def assertTSThisType(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSThisType))),IArray())))*/ Boolean = js.native
    def assertTSThisType(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSThisType))),IArray())))*/ Boolean = js.native
    
    def assertTSTupleType(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSTupleType))),IArray())))*/ Boolean = js.native
    def assertTSTupleType(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSTupleType))),IArray())))*/ Boolean = js.native
    
    def assertTSType(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSType))),IArray())))*/ Boolean = js.native
    def assertTSType(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSType))),IArray())))*/ Boolean = js.native
    
    def assertTSTypeAliasDeclaration(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSTypeAliasDeclaration))),IArray())))*/ Boolean = js.native
    def assertTSTypeAliasDeclaration(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSTypeAliasDeclaration))),IArray())))*/ Boolean = js.native
    
    def assertTSTypeAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSTypeAnnotation))),IArray())))*/ Boolean = js.native
    def assertTSTypeAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSTypeAnnotation))),IArray())))*/ Boolean = js.native
    
    def assertTSTypeAssertion(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSTypeAssertion))),IArray())))*/ Boolean = js.native
    def assertTSTypeAssertion(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSTypeAssertion))),IArray())))*/ Boolean = js.native
    
    def assertTSTypeElement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSTypeElement))),IArray())))*/ Boolean = js.native
    def assertTSTypeElement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSTypeElement))),IArray())))*/ Boolean = js.native
    
    def assertTSTypeLiteral(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSTypeLiteral))),IArray())))*/ Boolean = js.native
    def assertTSTypeLiteral(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSTypeLiteral))),IArray())))*/ Boolean = js.native
    
    def assertTSTypeOperator(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSTypeOperator))),IArray())))*/ Boolean = js.native
    def assertTSTypeOperator(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSTypeOperator))),IArray())))*/ Boolean = js.native
    
    def assertTSTypeParameter(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSTypeParameter))),IArray())))*/ Boolean = js.native
    def assertTSTypeParameter(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSTypeParameter))),IArray())))*/ Boolean = js.native
    
    def assertTSTypeParameterDeclaration(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSTypeParameterDeclaration))),IArray())))*/ Boolean = js.native
    def assertTSTypeParameterDeclaration(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSTypeParameterDeclaration))),IArray())))*/ Boolean = js.native
    
    def assertTSTypeParameterInstantiation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSTypeParameterInstantiation))),IArray())))*/ Boolean = js.native
    def assertTSTypeParameterInstantiation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSTypeParameterInstantiation))),IArray())))*/ Boolean = js.native
    
    def assertTSTypePredicate(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSTypePredicate))),IArray())))*/ Boolean = js.native
    def assertTSTypePredicate(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSTypePredicate))),IArray())))*/ Boolean = js.native
    
    def assertTSTypeQuery(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSTypeQuery))),IArray())))*/ Boolean = js.native
    def assertTSTypeQuery(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSTypeQuery))),IArray())))*/ Boolean = js.native
    
    def assertTSTypeReference(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSTypeReference))),IArray())))*/ Boolean = js.native
    def assertTSTypeReference(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSTypeReference))),IArray())))*/ Boolean = js.native
    
    def assertTSUndefinedKeyword(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSUndefinedKeyword))),IArray())))*/ Boolean = js.native
    def assertTSUndefinedKeyword(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSUndefinedKeyword))),IArray())))*/ Boolean = js.native
    
    def assertTSUnionType(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSUnionType))),IArray())))*/ Boolean = js.native
    def assertTSUnionType(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSUnionType))),IArray())))*/ Boolean = js.native
    
    def assertTSUnknownKeyword(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSUnknownKeyword))),IArray())))*/ Boolean = js.native
    def assertTSUnknownKeyword(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSUnknownKeyword))),IArray())))*/ Boolean = js.native
    
    def assertTSVoidKeyword(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSVoidKeyword))),IArray())))*/ Boolean = js.native
    def assertTSVoidKeyword(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TSVoidKeyword))),IArray())))*/ Boolean = js.native
    
    def assertTaggedTemplateExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TaggedTemplateExpression))),IArray())))*/ Boolean = js.native
    def assertTaggedTemplateExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TaggedTemplateExpression))),IArray())))*/ Boolean = js.native
    
    def assertTemplateElement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TemplateElement))),IArray())))*/ Boolean = js.native
    def assertTemplateElement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TemplateElement))),IArray())))*/ Boolean = js.native
    
    def assertTemplateLiteral(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TemplateLiteral))),IArray())))*/ Boolean = js.native
    def assertTemplateLiteral(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TemplateLiteral))),IArray())))*/ Boolean = js.native
    
    def assertTerminatorless(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Terminatorless))),IArray())))*/ Boolean = js.native
    def assertTerminatorless(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Terminatorless))),IArray())))*/ Boolean = js.native
    
    def assertThisExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ThisExpression))),IArray())))*/ Boolean = js.native
    def assertThisExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ThisExpression))),IArray())))*/ Boolean = js.native
    
    def assertThisTypeAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ThisTypeAnnotation))),IArray())))*/ Boolean = js.native
    def assertThisTypeAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ThisTypeAnnotation))),IArray())))*/ Boolean = js.native
    
    def assertThrowStatement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ThrowStatement))),IArray())))*/ Boolean = js.native
    def assertThrowStatement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(ThrowStatement))),IArray())))*/ Boolean = js.native
    
    def assertTopicReference(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TopicReference))),IArray())))*/ Boolean = js.native
    def assertTopicReference(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TopicReference))),IArray())))*/ Boolean = js.native
    
    def assertTryStatement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TryStatement))),IArray())))*/ Boolean = js.native
    def assertTryStatement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TryStatement))),IArray())))*/ Boolean = js.native
    
    def assertTupleExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TupleExpression))),IArray())))*/ Boolean = js.native
    def assertTupleExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TupleExpression))),IArray())))*/ Boolean = js.native
    
    def assertTupleTypeAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TupleTypeAnnotation))),IArray())))*/ Boolean = js.native
    def assertTupleTypeAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TupleTypeAnnotation))),IArray())))*/ Boolean = js.native
    
    def assertTypeAlias(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TypeAlias))),IArray())))*/ Boolean = js.native
    def assertTypeAlias(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TypeAlias))),IArray())))*/ Boolean = js.native
    
    def assertTypeAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TypeAnnotation))),IArray())))*/ Boolean = js.native
    def assertTypeAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TypeAnnotation))),IArray())))*/ Boolean = js.native
    
    def assertTypeCastExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TypeCastExpression))),IArray())))*/ Boolean = js.native
    def assertTypeCastExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TypeCastExpression))),IArray())))*/ Boolean = js.native
    
    def assertTypeParameter(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TypeParameter))),IArray())))*/ Boolean = js.native
    def assertTypeParameter(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TypeParameter))),IArray())))*/ Boolean = js.native
    
    def assertTypeParameterDeclaration(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TypeParameterDeclaration))),IArray())))*/ Boolean = js.native
    def assertTypeParameterDeclaration(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TypeParameterDeclaration))),IArray())))*/ Boolean = js.native
    
    def assertTypeParameterInstantiation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TypeParameterInstantiation))),IArray())))*/ Boolean = js.native
    def assertTypeParameterInstantiation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TypeParameterInstantiation))),IArray())))*/ Boolean = js.native
    
    def assertTypeScript(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TypeScript))),IArray())))*/ Boolean = js.native
    def assertTypeScript(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TypeScript))),IArray())))*/ Boolean = js.native
    
    def assertTypeofTypeAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TypeofTypeAnnotation))),IArray())))*/ Boolean = js.native
    def assertTypeofTypeAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(TypeofTypeAnnotation))),IArray())))*/ Boolean = js.native
    
    def assertUnaryExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(UnaryExpression))),IArray())))*/ Boolean = js.native
    def assertUnaryExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(UnaryExpression))),IArray())))*/ Boolean = js.native
    
    def assertUnaryLike(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(UnaryLike))),IArray())))*/ Boolean = js.native
    def assertUnaryLike(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(UnaryLike))),IArray())))*/ Boolean = js.native
    
    def assertUnionTypeAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(UnionTypeAnnotation))),IArray())))*/ Boolean = js.native
    def assertUnionTypeAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(UnionTypeAnnotation))),IArray())))*/ Boolean = js.native
    
    def assertUpdateExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(UpdateExpression))),IArray())))*/ Boolean = js.native
    def assertUpdateExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(UpdateExpression))),IArray())))*/ Boolean = js.native
    
    def assertUserWhitespacable(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(UserWhitespacable))),IArray())))*/ Boolean = js.native
    def assertUserWhitespacable(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(UserWhitespacable))),IArray())))*/ Boolean = js.native
    
    def assertV8IntrinsicIdentifier(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(V8IntrinsicIdentifier))),IArray())))*/ Boolean = js.native
    def assertV8IntrinsicIdentifier(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(V8IntrinsicIdentifier))),IArray())))*/ Boolean = js.native
    
    def assertVariableDeclaration(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(VariableDeclaration))),IArray())))*/ Boolean = js.native
    def assertVariableDeclaration(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(VariableDeclaration))),IArray())))*/ Boolean = js.native
    
    def assertVariableDeclarator(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(VariableDeclarator))),IArray())))*/ Boolean = js.native
    def assertVariableDeclarator(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(VariableDeclarator))),IArray())))*/ Boolean = js.native
    
    def assertVariance(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Variance))),IArray())))*/ Boolean = js.native
    def assertVariance(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(Variance))),IArray())))*/ Boolean = js.native
    
    def assertVoidTypeAnnotation(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(VoidTypeAnnotation))),IArray())))*/ Boolean = js.native
    def assertVoidTypeAnnotation(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(VoidTypeAnnotation))),IArray())))*/ Boolean = js.native
    
    def assertWhile(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(While))),IArray())))*/ Boolean = js.native
    def assertWhile(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(While))),IArray())))*/ Boolean = js.native
    
    def assertWhileStatement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(WhileStatement))),IArray())))*/ Boolean = js.native
    def assertWhileStatement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(WhileStatement))),IArray())))*/ Boolean = js.native
    
    def assertWithStatement(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(WithStatement))),IArray())))*/ Boolean = js.native
    def assertWithStatement(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(WithStatement))),IArray())))*/ Boolean = js.native
    
    def assertYieldExpression(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(YieldExpression))),IArray())))*/ Boolean = js.native
    def assertYieldExpression(opts: js.Object): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,types), TsIdentModule(Some(babel),List(types)), TsIdentSimple(YieldExpression))),IArray())))*/ Boolean = js.native
    
    def baseTypeStrictlyMatches(rightArg: NodePath[Node]): Boolean = js.native
    
    def buildCodeFrameError(msg: String): js.Error = js.native
    def buildCodeFrameError(msg: String, Error: ErrorConstructor): js.Error = js.native
    
    //#endregion
    //#region ------------------------- context -------------------------
    def call(key: String): Boolean = js.native
    
    /**
      * This checks whether or not we're in one of the following positions:
      *
      *   for (KEY in right);
      *   for (KEY;;);
      *
      * This is because these spots allow VariableDeclarations AND normal expressions so we need
      * to tell the path replacement that it's ok to replace this with an expression.
      */
    def canHaveVariableDeclarationOrExpression(): Boolean = js.native
    
    /**
      * This checks whether we are swapping an arrow function's body between an
      * expression and a block statement (or vice versa).
      *
      * This is because arrow functions may implicitly return an expression, which
      * is the same as containing a block statement.
      */
    def canSwapBetweenExpressionAndStatement(replacement: Node): Boolean = js.native
    
    var container: Node | js.Array[Node] | Null = js.native
    
    var context: TraversalContext[Any] = js.native
    
    var contexts: js.Array[TraversalContext[Any]] = js.native
    
    def couldBeBaseType(name: String): Boolean = js.native
    
    var data: Record[String | js.Symbol, Any] = js.native
    
    // Example: https://github.com/babel/babel/blob/63204ae51e020d84a5b246312f5eeb4d981ab952/packages/babel-traverse/src/path/modification.js#L83
    def debug(buildMessage: js.Function0[String]): Unit = js.native
    
    def ensureBlock(): /* asserts this is TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentModule(Some(babel),List(traverse)), TsIdentSimple(NodePath))),IArray(TsTypeIntersect(IArray(TsTypeRef(NoComments,TsQIdent(IArray(TsIdentSimple(T))),IArray()), TsTypeRef(NoComments,TsQIdent(IArray(TsIdentLibraryScoped(babel,traverse), TsIdentSimple(anon), TsIdentSimple(Body))),IArray())))))*/ Boolean = js.native
    
    // isnt(key: keyof T): boolean;
    /** Check whether the path node `key` strict equals `value`. */
    def equals(key: String, value: Any): Boolean = js.native
    
    /**
      * Walk the input `node` and statically evaluate it.
      *
      * Returns an object in the form `{ confident, value, deopt }`. `confident`
      * indicates whether or not we had to drop out of evaluating the expression
      * because of hitting an unknown node that we couldn't confidently find the
      * value of, in which case `deopt` is the path of said node.
      *
      * Example:
      *
      *   t.evaluate(parse("5 + 5")) // { confident: true, value: 10 }
      *   t.evaluate(parse("!true")) // { confident: true, value: false }
      *   t.evaluate(parse("foo + foo")) // { confident: false, value: undefined, deopt: NodePath }
      *
      */
    def evaluate(): Confident = js.native
    
    //#endregion
    //#region ------------------------- evaluation -------------------------
    /**
      * Walk the input `node` and statically evaluate if it's truthy.
      *
      * Returning `true` when we're sure that the expression will evaluate to a
      * truthy value, `false` if we're sure that it will evaluate to a falsy
      * value and `undefined` if we aren't sure. Because of this please do not
      * rely on coercion when using this method and check with === if it's false.
      */
    def evaluateTruthy(): js.UndefOr[Boolean] = js.native
    
    /**
      * Starting at current `NodePath` and going up the tree, return the first
      * `NodePath` that causes the provided `callback` to return a truthy value,
      * or `null` if the `callback` never returns a truthy value.
      */
    def find(callback: js.Function1[/* path */ NodePath[Node], Boolean]): NodePath[Node] | Null = js.native
    
    //#region ------------------------- ancestry -------------------------
    /**
      * Starting at the parent path of the current `NodePath` and going up the
      * tree, return the first `NodePath` that causes the provided `callback`
      * to return a truthy value, or `null` if the `callback` never returns a
      * truthy value.
      */
    def findParent(callback: js.Function1[/* path */ NodePath[Node], Boolean]): NodePath[Node] | Null = js.native
    
    def get(key: String): NodePath[Node] | js.Array[NodePath[Node]] = js.native
    def get(key: String, context: Boolean): NodePath[Node] | js.Array[NodePath[Node]] = js.native
    def get(key: String, context: TraversalContext[Any]): NodePath[Node] | js.Array[NodePath[Node]] = js.native
    def get[K /* <: /* keyof T */ String */](key: K): NodePathResult[
        /* import warning: importer.ImportType#apply Failed type conversion: T[K] */ js.Any
      ] = js.native
    def get[K /* <: /* keyof T */ String */](key: K, context: Boolean): NodePathResult[
        /* import warning: importer.ImportType#apply Failed type conversion: T[K] */ js.Any
      ] = js.native
    def get[K /* <: /* keyof T */ String */](key: K, context: TraversalContext[Any]): NodePathResult[
        /* import warning: importer.ImportType#apply Failed type conversion: T[K] */ js.Any
      ] = js.native
    
    def getAllNextSiblings(): js.Array[NodePath[Node]] = js.native
    
    def getAllPrevSiblings(): js.Array[NodePath[Node]] = js.native
    
    /**
      * Build an array of node paths containing the entire ancestry of the current node path.
      *
      * NOTE: The current node path is included in this.
      */
    def getAncestry(): Array[this.type | NodePath[Node]] = js.native
    
    def getBindingIdentifierPaths(): Record[String, NodePath[Identifier_]] = js.native
    def getBindingIdentifierPaths(duplicates: Boolean): Record[String, NodePath[Identifier_] | js.Array[NodePath[Identifier_]]] = js.native
    def getBindingIdentifierPaths(duplicates: Boolean, outerOnly: Boolean): Record[String, NodePath[Identifier_] | js.Array[NodePath[Identifier_]]] = js.native
    def getBindingIdentifierPaths(duplicates: Unit, outerOnly: Boolean): Record[String, NodePath[Identifier_]] = js.native
    @JSName("getBindingIdentifierPaths")
    def getBindingIdentifierPaths_false(duplicates: `false`): Record[String, NodePath[Identifier_]] = js.native
    @JSName("getBindingIdentifierPaths")
    def getBindingIdentifierPaths_false(duplicates: `false`, outerOnly: Boolean): Record[String, NodePath[Identifier_]] = js.native
    @JSName("getBindingIdentifierPaths")
    def getBindingIdentifierPaths_true(duplicates: `true`): Record[String, js.Array[NodePath[Identifier_]]] = js.native
    @JSName("getBindingIdentifierPaths")
    def getBindingIdentifierPaths_true(duplicates: `true`, outerOnly: Boolean): Record[String, js.Array[NodePath[Identifier_]]] = js.native
    
    def getBindingIdentifiers(): Record[String, Identifier_] = js.native
    def getBindingIdentifiers(duplicates: Boolean): Record[String, Identifier_ | js.Array[Identifier_]] = js.native
    @JSName("getBindingIdentifiers")
    def getBindingIdentifiers_false(duplicates: `false`): Record[String, Identifier_] = js.native
    @JSName("getBindingIdentifiers")
    def getBindingIdentifiers_true(duplicates: `true`): Record[String, js.Array[Identifier_]] = js.native
    
    def getCompletionRecords(): js.Array[NodePath[Node]] = js.native
    
    def getData(key: String): Any = js.native
    def getData(key: String, `def`: Any): Any = js.native
    def getData(key: js.Symbol): Any = js.native
    def getData(key: js.Symbol, `def`: Any): Any = js.native
    
    /** Get the earliest path in the tree where the provided `paths` intersect. */
    def getDeepestCommonAncestorFrom(paths: js.Array[NodePath[Node]]): NodePath[Node] = js.native
    def getDeepestCommonAncestorFrom(
      paths: js.Array[NodePath[Node]],
      filter: js.Function3[
          /* deepest */ Node, 
          /* i */ Double, 
          /* ancestries */ js.Array[js.Array[NodePath[Node]]], 
          NodePath[Node]
        ]
    ): NodePath[Node] = js.native
    
    /**
      * Get the deepest common ancestor and then from it, get the earliest relationship path
      * to that ancestor.
      *
      * Earliest is defined as being "before" all the other nodes in terms of list container
      * position and visiting key.
      */
    def getEarliestCommonAncestorFrom(paths: js.Array[NodePath[Node]]): NodePath[Node] = js.native
    
    /** Get the parent function of the current path. */
    def getFunctionParent(): NodePath[Function] | Null = js.native
    
    def getNextSibling(): NodePath[Node] = js.native
    
    //#endregion
    //#region ------------------------- family -------------------------
    def getOpposite(): NodePath[Node] | Null = js.native
    
    def getOuterBindingIdentifierPaths(): Record[String, NodePath[Identifier_]] = js.native
    def getOuterBindingIdentifierPaths(duplicates: Boolean): Record[String, NodePath[Identifier_] | js.Array[NodePath[Identifier_]]] = js.native
    def getOuterBindingIdentifierPaths(duplicates: Boolean, outerOnly: Boolean): Record[String, NodePath[Identifier_] | js.Array[NodePath[Identifier_]]] = js.native
    def getOuterBindingIdentifierPaths(duplicates: Unit, outerOnly: Boolean): Record[String, NodePath[Identifier_] | js.Array[NodePath[Identifier_]]] = js.native
    @JSName("getOuterBindingIdentifierPaths")
    def getOuterBindingIdentifierPaths_false(duplicates: `false`): Record[String, NodePath[Identifier_]] = js.native
    @JSName("getOuterBindingIdentifierPaths")
    def getOuterBindingIdentifierPaths_true(duplicates: `true`): Record[String, js.Array[NodePath[Identifier_]]] = js.native
    
    def getOuterBindingIdentifiers(): Record[String, Identifier_] = js.native
    def getOuterBindingIdentifiers(duplicates: Boolean): Record[String, Identifier_ | js.Array[Identifier_]] = js.native
    @JSName("getOuterBindingIdentifiers")
    def getOuterBindingIdentifiers_false(duplicates: `false`): Record[String, Identifier_] = js.native
    @JSName("getOuterBindingIdentifiers")
    def getOuterBindingIdentifiers_true(duplicates: `true`): Record[String, js.Array[Identifier_]] = js.native
    
    def getPathLocation(): String = js.native
    
    def getPrevSibling(): NodePath[Node] = js.native
    
    def getScope(scope: Scope): Scope = js.native
    
    def getSibling(key: String): NodePath[Node] = js.native
    def getSibling(key: Double): NodePath[Node] = js.native
    
    /** Get the source code associated with this node. */
    def getSource(): String = js.native
    
    /** Walk up the tree until we hit a parent node path in a list. */
    def getStatementParent(): NodePath[Statement] | Null = js.native
    
    //#endregion
    //#region ------------------------- inference -------------------------
    /** Infer the type of the current `NodePath`. */
    def getTypeAnnotation(): FlowType | TSType = js.native
    
    /**
      * Check whether we have the input `key`. If the `key` references an array then we check
      * if the array has any items, otherwise we just check if it's falsy.
      */
    def has(key: String): Boolean = js.native
    
    def hasNode(): /* is @babel/traverse.@babel/traverse.NodePath<std.Exclude<T, null | undefined>> */ Boolean = js.native
    
    /** Hoist the current node to the highest scope possible and return a UID referencing it. */
    def hoist(scope: Scope): Unit = js.native
    
    var hub: Hub = js.native
    
    var inList: Boolean = js.native
    
    def inType(candidateTypes: String*): Boolean = js.native
    
    /**
      * Insert the provided nodes after the current one. When inserting nodes after an
      * expression, ensure that the completion record is correct by pushing the current node.
      */
    def insertAfter[Nodes /* <: NodesInsertionParam[Node] */](nodes: Nodes): NodePaths[Nodes] = js.native
    
    //#endregion
    //#region ------------------------- modification -------------------------
    /** Insert the provided nodes before the current one. */
    def insertBefore[Nodes /* <: NodesInsertionParam[Node] */](nodes: Nodes): NodePaths[Nodes] = js.native
    
    /** Alias of `has`. */
    def is(key: String): Boolean = js.native
    
    //#endregion
    //#region ------------------------- isXXX -------------------------
    def isAccessor(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Accessor> */ Boolean = js.native
    def isAccessor(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Accessor> */ Boolean = js.native
    
    /**
      * A helper to find if `this` path is an ancestor of `maybeDescendant`
      */
    def isAncestor(maybeDescendant: NodePath[Node]): Boolean = js.native
    
    def isAnyTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.AnyTypeAnnotation> */ Boolean = js.native
    def isAnyTypeAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.AnyTypeAnnotation> */ Boolean = js.native
    
    def isArgumentPlaceholder(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ArgumentPlaceholder> */ Boolean = js.native
    def isArgumentPlaceholder(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ArgumentPlaceholder> */ Boolean = js.native
    
    def isArrayExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ArrayExpression> */ Boolean = js.native
    def isArrayExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ArrayExpression> */ Boolean = js.native
    
    def isArrayPattern(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ArrayPattern> */ Boolean = js.native
    def isArrayPattern(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ArrayPattern> */ Boolean = js.native
    
    def isArrayTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ArrayTypeAnnotation> */ Boolean = js.native
    def isArrayTypeAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ArrayTypeAnnotation> */ Boolean = js.native
    
    def isArrowFunctionExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ArrowFunctionExpression> */ Boolean = js.native
    def isArrowFunctionExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ArrowFunctionExpression> */ Boolean = js.native
    
    def isAssignmentExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.AssignmentExpression> */ Boolean = js.native
    def isAssignmentExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.AssignmentExpression> */ Boolean = js.native
    
    def isAssignmentPattern(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.AssignmentPattern> */ Boolean = js.native
    def isAssignmentPattern(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.AssignmentPattern> */ Boolean = js.native
    
    def isAwaitExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.AwaitExpression> */ Boolean = js.native
    def isAwaitExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.AwaitExpression> */ Boolean = js.native
    
    def isBaseType(baseName: String): Boolean = js.native
    def isBaseType(baseName: String, soft: Boolean): Boolean = js.native
    
    def isBigIntLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BigIntLiteral> */ Boolean = js.native
    def isBigIntLiteral(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BigIntLiteral> */ Boolean = js.native
    
    def isBinary(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Binary> */ Boolean = js.native
    def isBinary(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Binary> */ Boolean = js.native
    
    def isBinaryExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BinaryExpression> */ Boolean = js.native
    def isBinaryExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BinaryExpression> */ Boolean = js.native
    
    def isBindExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BindExpression> */ Boolean = js.native
    def isBindExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BindExpression> */ Boolean = js.native
    
    def isBindingIdentifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Identifier> */ Boolean = js.native
    def isBindingIdentifier(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Identifier> */ Boolean = js.native
    
    /** @deprecated will be removed in Babel 8 */
    def isBlacklisted(): Boolean = js.native
    
    def isBlock(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Block> */ Boolean = js.native
    def isBlock(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Block> */ Boolean = js.native
    
    def isBlockParent(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BlockParent> */ Boolean = js.native
    def isBlockParent(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BlockParent> */ Boolean = js.native
    
    def isBlockScoped(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionDeclaration | @babel/types.@babel/types.ClassDeclaration | @babel/types.@babel/types.VariableDeclaration> */ Boolean = js.native
    def isBlockScoped(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionDeclaration | @babel/types.@babel/types.ClassDeclaration | @babel/types.@babel/types.VariableDeclaration> */ Boolean = js.native
    
    def isBlockStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BlockStatement> */ Boolean = js.native
    def isBlockStatement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BlockStatement> */ Boolean = js.native
    
    def isBooleanLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BooleanLiteral> */ Boolean = js.native
    def isBooleanLiteral(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BooleanLiteral> */ Boolean = js.native
    
    def isBooleanLiteralTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BooleanLiteralTypeAnnotation> */ Boolean = js.native
    def isBooleanLiteralTypeAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BooleanLiteralTypeAnnotation> */ Boolean = js.native
    
    def isBooleanTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BooleanTypeAnnotation> */ Boolean = js.native
    def isBooleanTypeAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BooleanTypeAnnotation> */ Boolean = js.native
    
    def isBreakStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BreakStatement> */ Boolean = js.native
    def isBreakStatement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BreakStatement> */ Boolean = js.native
    
    def isCallExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.CallExpression> */ Boolean = js.native
    def isCallExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.CallExpression> */ Boolean = js.native
    
    def isCatchClause(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.CatchClause> */ Boolean = js.native
    def isCatchClause(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.CatchClause> */ Boolean = js.native
    
    def isClass(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Class> */ Boolean = js.native
    def isClass(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Class> */ Boolean = js.native
    
    def isClassAccessorProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassAccessorProperty> */ Boolean = js.native
    def isClassAccessorProperty(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassAccessorProperty> */ Boolean = js.native
    
    def isClassBody(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassBody> */ Boolean = js.native
    def isClassBody(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassBody> */ Boolean = js.native
    
    def isClassDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassDeclaration> */ Boolean = js.native
    def isClassDeclaration(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassDeclaration> */ Boolean = js.native
    
    def isClassExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassExpression> */ Boolean = js.native
    def isClassExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassExpression> */ Boolean = js.native
    
    def isClassImplements(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassImplements> */ Boolean = js.native
    def isClassImplements(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassImplements> */ Boolean = js.native
    
    def isClassMethod(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassMethod> */ Boolean = js.native
    def isClassMethod(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassMethod> */ Boolean = js.native
    
    def isClassPrivateMethod(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassPrivateMethod> */ Boolean = js.native
    def isClassPrivateMethod(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassPrivateMethod> */ Boolean = js.native
    
    def isClassPrivateProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassPrivateProperty> */ Boolean = js.native
    def isClassPrivateProperty(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassPrivateProperty> */ Boolean = js.native
    
    def isClassProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassProperty> */ Boolean = js.native
    def isClassProperty(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassProperty> */ Boolean = js.native
    
    /** Check whether the current path references a completion record */
    def isCompletionRecord(): Boolean = js.native
    def isCompletionRecord(allowInsideFunction: Boolean): Boolean = js.native
    
    def isCompletionStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.CompletionStatement> */ Boolean = js.native
    def isCompletionStatement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.CompletionStatement> */ Boolean = js.native
    
    def isConditional(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Conditional> */ Boolean = js.native
    def isConditional(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Conditional> */ Boolean = js.native
    
    def isConditionalExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ConditionalExpression> */ Boolean = js.native
    def isConditionalExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ConditionalExpression> */ Boolean = js.native
    
    def isConstantExpression(): Boolean = js.native
    
    def isContinueStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ContinueStatement> */ Boolean = js.native
    def isContinueStatement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ContinueStatement> */ Boolean = js.native
    
    def isDebuggerStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DebuggerStatement> */ Boolean = js.native
    def isDebuggerStatement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DebuggerStatement> */ Boolean = js.native
    
    def isDecimalLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DecimalLiteral> */ Boolean = js.native
    def isDecimalLiteral(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DecimalLiteral> */ Boolean = js.native
    
    def isDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Declaration> */ Boolean = js.native
    def isDeclaration(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Declaration> */ Boolean = js.native
    
    def isDeclareClass(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareClass> */ Boolean = js.native
    def isDeclareClass(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareClass> */ Boolean = js.native
    
    def isDeclareExportAllDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareExportAllDeclaration> */ Boolean = js.native
    def isDeclareExportAllDeclaration(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareExportAllDeclaration> */ Boolean = js.native
    
    def isDeclareExportDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareExportDeclaration> */ Boolean = js.native
    def isDeclareExportDeclaration(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareExportDeclaration> */ Boolean = js.native
    
    def isDeclareFunction(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareFunction> */ Boolean = js.native
    def isDeclareFunction(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareFunction> */ Boolean = js.native
    
    def isDeclareInterface(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareInterface> */ Boolean = js.native
    def isDeclareInterface(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareInterface> */ Boolean = js.native
    
    def isDeclareModule(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareModule> */ Boolean = js.native
    def isDeclareModule(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareModule> */ Boolean = js.native
    
    def isDeclareModuleExports(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareModuleExports> */ Boolean = js.native
    def isDeclareModuleExports(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareModuleExports> */ Boolean = js.native
    
    def isDeclareOpaqueType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareOpaqueType> */ Boolean = js.native
    def isDeclareOpaqueType(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareOpaqueType> */ Boolean = js.native
    
    def isDeclareTypeAlias(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareTypeAlias> */ Boolean = js.native
    def isDeclareTypeAlias(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareTypeAlias> */ Boolean = js.native
    
    def isDeclareVariable(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareVariable> */ Boolean = js.native
    def isDeclareVariable(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareVariable> */ Boolean = js.native
    
    def isDeclaredPredicate(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclaredPredicate> */ Boolean = js.native
    def isDeclaredPredicate(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclaredPredicate> */ Boolean = js.native
    
    def isDecorator(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Decorator> */ Boolean = js.native
    def isDecorator(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Decorator> */ Boolean = js.native
    
    def isDenylisted(): Boolean = js.native
    
    /**
      * A helper to find if `this` path is a descendant of `maybeAncestor`
      */
    def isDescendant(maybeAncestor: NodePath[Node]): Boolean = js.native
    
    def isDirective(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Directive> */ Boolean = js.native
    def isDirective(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Directive> */ Boolean = js.native
    
    def isDirectiveLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DirectiveLiteral> */ Boolean = js.native
    def isDirectiveLiteral(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DirectiveLiteral> */ Boolean = js.native
    
    def isDoExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DoExpression> */ Boolean = js.native
    def isDoExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DoExpression> */ Boolean = js.native
    
    def isDoWhileStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DoWhileStatement> */ Boolean = js.native
    def isDoWhileStatement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DoWhileStatement> */ Boolean = js.native
    
    def isEmptyStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EmptyStatement> */ Boolean = js.native
    def isEmptyStatement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EmptyStatement> */ Boolean = js.native
    
    def isEmptyTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EmptyTypeAnnotation> */ Boolean = js.native
    def isEmptyTypeAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EmptyTypeAnnotation> */ Boolean = js.native
    
    def isEnumBody(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EnumBody> */ Boolean = js.native
    def isEnumBody(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EnumBody> */ Boolean = js.native
    
    def isEnumBooleanBody(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EnumBooleanBody> */ Boolean = js.native
    def isEnumBooleanBody(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EnumBooleanBody> */ Boolean = js.native
    
    def isEnumBooleanMember(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EnumBooleanMember> */ Boolean = js.native
    def isEnumBooleanMember(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EnumBooleanMember> */ Boolean = js.native
    
    def isEnumDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EnumDeclaration> */ Boolean = js.native
    def isEnumDeclaration(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EnumDeclaration> */ Boolean = js.native
    
    def isEnumDefaultedMember(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EnumDefaultedMember> */ Boolean = js.native
    def isEnumDefaultedMember(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EnumDefaultedMember> */ Boolean = js.native
    
    def isEnumMember(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EnumMember> */ Boolean = js.native
    def isEnumMember(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EnumMember> */ Boolean = js.native
    
    def isEnumNumberBody(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EnumNumberBody> */ Boolean = js.native
    def isEnumNumberBody(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EnumNumberBody> */ Boolean = js.native
    
    def isEnumNumberMember(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EnumNumberMember> */ Boolean = js.native
    def isEnumNumberMember(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EnumNumberMember> */ Boolean = js.native
    
    def isEnumStringBody(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EnumStringBody> */ Boolean = js.native
    def isEnumStringBody(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EnumStringBody> */ Boolean = js.native
    
    def isEnumStringMember(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EnumStringMember> */ Boolean = js.native
    def isEnumStringMember(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EnumStringMember> */ Boolean = js.native
    
    def isEnumSymbolBody(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EnumSymbolBody> */ Boolean = js.native
    def isEnumSymbolBody(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EnumSymbolBody> */ Boolean = js.native
    
    /** @deprecated */
    def isExistentialTypeParam(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExistsTypeAnnotation> */ Boolean = js.native
    def isExistentialTypeParam(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExistsTypeAnnotation> */ Boolean = js.native
    
    def isExistsTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExistsTypeAnnotation> */ Boolean = js.native
    def isExistsTypeAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExistsTypeAnnotation> */ Boolean = js.native
    
    def isExportAllDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportAllDeclaration> */ Boolean = js.native
    def isExportAllDeclaration(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportAllDeclaration> */ Boolean = js.native
    
    def isExportDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportDeclaration> */ Boolean = js.native
    def isExportDeclaration(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportDeclaration> */ Boolean = js.native
    
    def isExportDefaultDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportDefaultDeclaration> */ Boolean = js.native
    def isExportDefaultDeclaration(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportDefaultDeclaration> */ Boolean = js.native
    
    def isExportDefaultSpecifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportDefaultSpecifier> */ Boolean = js.native
    def isExportDefaultSpecifier(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportDefaultSpecifier> */ Boolean = js.native
    
    def isExportNamedDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportNamedDeclaration> */ Boolean = js.native
    def isExportNamedDeclaration(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportNamedDeclaration> */ Boolean = js.native
    
    def isExportNamespaceSpecifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportNamespaceSpecifier> */ Boolean = js.native
    def isExportNamespaceSpecifier(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportNamespaceSpecifier> */ Boolean = js.native
    
    def isExportSpecifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportSpecifier> */ Boolean = js.native
    def isExportSpecifier(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportSpecifier> */ Boolean = js.native
    
    def isExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Expression> */ Boolean = js.native
    def isExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Expression> */ Boolean = js.native
    
    def isExpressionStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExpressionStatement> */ Boolean = js.native
    def isExpressionStatement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExpressionStatement> */ Boolean = js.native
    
    def isExpressionWrapper(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExpressionWrapper> */ Boolean = js.native
    def isExpressionWrapper(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExpressionWrapper> */ Boolean = js.native
    
    def isFile(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.File> */ Boolean = js.native
    def isFile(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.File> */ Boolean = js.native
    
    def isFlow(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Flow> */ Boolean = js.native
    def isFlow(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Flow> */ Boolean = js.native
    
    def isFlowBaseAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FlowBaseAnnotation> */ Boolean = js.native
    def isFlowBaseAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FlowBaseAnnotation> */ Boolean = js.native
    
    def isFlowDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FlowDeclaration> */ Boolean = js.native
    def isFlowDeclaration(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FlowDeclaration> */ Boolean = js.native
    
    def isFlowPredicate(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FlowPredicate> */ Boolean = js.native
    def isFlowPredicate(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FlowPredicate> */ Boolean = js.native
    
    def isFlowType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FlowType> */ Boolean = js.native
    def isFlowType(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FlowType> */ Boolean = js.native
    
    def isFor(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.For> */ Boolean = js.native
    def isFor(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.For> */ Boolean = js.native
    
    def isForAwaitStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ForOfStatement> */ Boolean = js.native
    def isForAwaitStatement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ForOfStatement> */ Boolean = js.native
    
    def isForInStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ForInStatement> */ Boolean = js.native
    def isForInStatement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ForInStatement> */ Boolean = js.native
    
    def isForOfStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ForOfStatement> */ Boolean = js.native
    def isForOfStatement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ForOfStatement> */ Boolean = js.native
    
    def isForStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ForStatement> */ Boolean = js.native
    def isForStatement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ForStatement> */ Boolean = js.native
    
    def isForXStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ForXStatement> */ Boolean = js.native
    def isForXStatement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ForXStatement> */ Boolean = js.native
    
    def isFunction(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Function> */ Boolean = js.native
    def isFunction(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Function> */ Boolean = js.native
    
    def isFunctionDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionDeclaration> */ Boolean = js.native
    def isFunctionDeclaration(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionDeclaration> */ Boolean = js.native
    
    def isFunctionExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionExpression> */ Boolean = js.native
    def isFunctionExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionExpression> */ Boolean = js.native
    
    def isFunctionParent(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionParent> */ Boolean = js.native
    def isFunctionParent(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionParent> */ Boolean = js.native
    
    def isFunctionTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionTypeAnnotation> */ Boolean = js.native
    def isFunctionTypeAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionTypeAnnotation> */ Boolean = js.native
    
    def isFunctionTypeParam(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionTypeParam> */ Boolean = js.native
    def isFunctionTypeParam(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionTypeParam> */ Boolean = js.native
    
    def isGenerated(): Boolean = js.native
    def isGenerated(opts: js.Object): Boolean = js.native
    
    def isGenericType(genericName: String): Boolean = js.native
    
    def isGenericTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.GenericTypeAnnotation> */ Boolean = js.native
    def isGenericTypeAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.GenericTypeAnnotation> */ Boolean = js.native
    
    def isIdentifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Identifier> */ Boolean = js.native
    def isIdentifier(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Identifier> */ Boolean = js.native
    
    def isIfStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.IfStatement> */ Boolean = js.native
    def isIfStatement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.IfStatement> */ Boolean = js.native
    
    def isImmutable(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Immutable> */ Boolean = js.native
    def isImmutable(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Immutable> */ Boolean = js.native
    
    def isImport(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Import> */ Boolean = js.native
    def isImport(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Import> */ Boolean = js.native
    
    def isImportAttribute(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ImportAttribute> */ Boolean = js.native
    def isImportAttribute(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ImportAttribute> */ Boolean = js.native
    
    def isImportDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ImportDeclaration> */ Boolean = js.native
    def isImportDeclaration(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ImportDeclaration> */ Boolean = js.native
    
    def isImportDefaultSpecifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ImportDefaultSpecifier> */ Boolean = js.native
    def isImportDefaultSpecifier(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ImportDefaultSpecifier> */ Boolean = js.native
    
    def isImportNamespaceSpecifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ImportNamespaceSpecifier> */ Boolean = js.native
    def isImportNamespaceSpecifier(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ImportNamespaceSpecifier> */ Boolean = js.native
    
    def isImportSpecifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ImportSpecifier> */ Boolean = js.native
    def isImportSpecifier(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ImportSpecifier> */ Boolean = js.native
    
    def isInStrictMode(): Boolean = js.native
    
    def isIndexedAccessType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.IndexedAccessType> */ Boolean = js.native
    def isIndexedAccessType(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.IndexedAccessType> */ Boolean = js.native
    
    def isInferredPredicate(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InferredPredicate> */ Boolean = js.native
    def isInferredPredicate(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InferredPredicate> */ Boolean = js.native
    
    def isInterfaceDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InterfaceDeclaration> */ Boolean = js.native
    def isInterfaceDeclaration(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InterfaceDeclaration> */ Boolean = js.native
    
    def isInterfaceExtends(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InterfaceExtends> */ Boolean = js.native
    def isInterfaceExtends(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InterfaceExtends> */ Boolean = js.native
    
    def isInterfaceTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InterfaceTypeAnnotation> */ Boolean = js.native
    def isInterfaceTypeAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InterfaceTypeAnnotation> */ Boolean = js.native
    
    def isInterpreterDirective(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InterpreterDirective> */ Boolean = js.native
    def isInterpreterDirective(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InterpreterDirective> */ Boolean = js.native
    
    def isIntersectionTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.IntersectionTypeAnnotation> */ Boolean = js.native
    def isIntersectionTypeAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.IntersectionTypeAnnotation> */ Boolean = js.native
    
    def isJSX(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSX> */ Boolean = js.native
    def isJSX(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSX> */ Boolean = js.native
    
    def isJSXAttribute(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXAttribute> */ Boolean = js.native
    def isJSXAttribute(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXAttribute> */ Boolean = js.native
    
    def isJSXClosingElement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXClosingElement> */ Boolean = js.native
    def isJSXClosingElement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXClosingElement> */ Boolean = js.native
    
    def isJSXClosingFragment(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXClosingFragment> */ Boolean = js.native
    def isJSXClosingFragment(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXClosingFragment> */ Boolean = js.native
    
    def isJSXElement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXElement> */ Boolean = js.native
    def isJSXElement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXElement> */ Boolean = js.native
    
    def isJSXEmptyExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXEmptyExpression> */ Boolean = js.native
    def isJSXEmptyExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXEmptyExpression> */ Boolean = js.native
    
    def isJSXExpressionContainer(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXExpressionContainer> */ Boolean = js.native
    def isJSXExpressionContainer(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXExpressionContainer> */ Boolean = js.native
    
    def isJSXFragment(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXFragment> */ Boolean = js.native
    def isJSXFragment(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXFragment> */ Boolean = js.native
    
    def isJSXIdentifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXIdentifier> */ Boolean = js.native
    def isJSXIdentifier(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXIdentifier> */ Boolean = js.native
    
    def isJSXMemberExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXMemberExpression> */ Boolean = js.native
    def isJSXMemberExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXMemberExpression> */ Boolean = js.native
    
    def isJSXNamespacedName(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXNamespacedName> */ Boolean = js.native
    def isJSXNamespacedName(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXNamespacedName> */ Boolean = js.native
    
    def isJSXOpeningElement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXOpeningElement> */ Boolean = js.native
    def isJSXOpeningElement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXOpeningElement> */ Boolean = js.native
    
    def isJSXOpeningFragment(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXOpeningFragment> */ Boolean = js.native
    def isJSXOpeningFragment(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXOpeningFragment> */ Boolean = js.native
    
    def isJSXSpreadAttribute(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXSpreadAttribute> */ Boolean = js.native
    def isJSXSpreadAttribute(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXSpreadAttribute> */ Boolean = js.native
    
    def isJSXSpreadChild(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXSpreadChild> */ Boolean = js.native
    def isJSXSpreadChild(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXSpreadChild> */ Boolean = js.native
    
    def isJSXText(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXText> */ Boolean = js.native
    def isJSXText(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXText> */ Boolean = js.native
    
    def isLVal(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.LVal> */ Boolean = js.native
    def isLVal(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.LVal> */ Boolean = js.native
    
    def isLabeledStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.LabeledStatement> */ Boolean = js.native
    def isLabeledStatement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.LabeledStatement> */ Boolean = js.native
    
    def isLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Literal> */ Boolean = js.native
    def isLiteral(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Literal> */ Boolean = js.native
    
    def isLogicalExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.LogicalExpression> */ Boolean = js.native
    def isLogicalExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.LogicalExpression> */ Boolean = js.native
    
    def isLoop(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Loop> */ Boolean = js.native
    def isLoop(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Loop> */ Boolean = js.native
    
    def isMemberExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.MemberExpression> */ Boolean = js.native
    def isMemberExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.MemberExpression> */ Boolean = js.native
    
    def isMetaProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.MetaProperty> */ Boolean = js.native
    def isMetaProperty(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.MetaProperty> */ Boolean = js.native
    
    def isMethod(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Method> */ Boolean = js.native
    def isMethod(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Method> */ Boolean = js.native
    
    def isMiscellaneous(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Miscellaneous> */ Boolean = js.native
    def isMiscellaneous(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Miscellaneous> */ Boolean = js.native
    
    def isMixedTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.MixedTypeAnnotation> */ Boolean = js.native
    def isMixedTypeAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.MixedTypeAnnotation> */ Boolean = js.native
    
    def isModuleDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ModuleDeclaration> */ Boolean = js.native
    def isModuleDeclaration(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ModuleDeclaration> */ Boolean = js.native
    
    def isModuleExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ModuleExpression> */ Boolean = js.native
    def isModuleExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ModuleExpression> */ Boolean = js.native
    
    def isModuleSpecifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ModuleSpecifier> */ Boolean = js.native
    def isModuleSpecifier(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ModuleSpecifier> */ Boolean = js.native
    
    def isNewExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NewExpression> */ Boolean = js.native
    def isNewExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NewExpression> */ Boolean = js.native
    
    // equals(key: keyof T, value: any): boolean;
    /**
      * Check the type against our stored internal type of the node. This is handy when a node has
      * been removed yet we still internally know the type and need it to calculate node replacement.
      */
    def isNodeType(`type`: String): Boolean = js.native
    
    def isNoop(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Noop> */ Boolean = js.native
    def isNoop(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Noop> */ Boolean = js.native
    
    def isNullLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NullLiteral> */ Boolean = js.native
    def isNullLiteral(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NullLiteral> */ Boolean = js.native
    
    def isNullLiteralTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NullLiteralTypeAnnotation> */ Boolean = js.native
    def isNullLiteralTypeAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NullLiteralTypeAnnotation> */ Boolean = js.native
    
    def isNullableTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NullableTypeAnnotation> */ Boolean = js.native
    def isNullableTypeAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NullableTypeAnnotation> */ Boolean = js.native
    
    /** @deprecated Use `isNumericLiteral` */
    def isNumberLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NumberLiteral> */ Boolean = js.native
    def isNumberLiteral(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NumberLiteral> */ Boolean = js.native
    
    def isNumberLiteralTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NumberLiteralTypeAnnotation> */ Boolean = js.native
    def isNumberLiteralTypeAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NumberLiteralTypeAnnotation> */ Boolean = js.native
    
    def isNumberTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NumberTypeAnnotation> */ Boolean = js.native
    def isNumberTypeAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NumberTypeAnnotation> */ Boolean = js.native
    
    def isNumericLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NumericLiteral> */ Boolean = js.native
    def isNumericLiteral(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NumericLiteral> */ Boolean = js.native
    
    /** @deprecated */
    def isNumericLiteralTypeAnnotation(): Unit = js.native
    def isNumericLiteralTypeAnnotation(opts: js.Object): Unit = js.native
    
    def isObjectExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectExpression> */ Boolean = js.native
    def isObjectExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectExpression> */ Boolean = js.native
    
    def isObjectMember(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectMember> */ Boolean = js.native
    def isObjectMember(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectMember> */ Boolean = js.native
    
    def isObjectMethod(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectMethod> */ Boolean = js.native
    def isObjectMethod(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectMethod> */ Boolean = js.native
    
    def isObjectPattern(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectPattern> */ Boolean = js.native
    def isObjectPattern(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectPattern> */ Boolean = js.native
    
    def isObjectProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectProperty> */ Boolean = js.native
    def isObjectProperty(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectProperty> */ Boolean = js.native
    
    def isObjectTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeAnnotation> */ Boolean = js.native
    def isObjectTypeAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeAnnotation> */ Boolean = js.native
    
    def isObjectTypeCallProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeCallProperty> */ Boolean = js.native
    def isObjectTypeCallProperty(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeCallProperty> */ Boolean = js.native
    
    def isObjectTypeIndexer(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeIndexer> */ Boolean = js.native
    def isObjectTypeIndexer(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeIndexer> */ Boolean = js.native
    
    def isObjectTypeInternalSlot(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeInternalSlot> */ Boolean = js.native
    def isObjectTypeInternalSlot(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeInternalSlot> */ Boolean = js.native
    
    def isObjectTypeProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeProperty> */ Boolean = js.native
    def isObjectTypeProperty(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeProperty> */ Boolean = js.native
    
    def isObjectTypeSpreadProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeSpreadProperty> */ Boolean = js.native
    def isObjectTypeSpreadProperty(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeSpreadProperty> */ Boolean = js.native
    
    def isOpaqueType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.OpaqueType> */ Boolean = js.native
    def isOpaqueType(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.OpaqueType> */ Boolean = js.native
    
    def isOptionalCallExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.OptionalCallExpression> */ Boolean = js.native
    def isOptionalCallExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.OptionalCallExpression> */ Boolean = js.native
    
    def isOptionalIndexedAccessType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.OptionalIndexedAccessType> */ Boolean = js.native
    def isOptionalIndexedAccessType(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.OptionalIndexedAccessType> */ Boolean = js.native
    
    def isOptionalMemberExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.OptionalMemberExpression> */ Boolean = js.native
    def isOptionalMemberExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.OptionalMemberExpression> */ Boolean = js.native
    
    def isParenthesizedExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ParenthesizedExpression> */ Boolean = js.native
    def isParenthesizedExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ParenthesizedExpression> */ Boolean = js.native
    
    def isPattern(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Pattern> */ Boolean = js.native
    def isPattern(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Pattern> */ Boolean = js.native
    
    def isPatternLike(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PatternLike> */ Boolean = js.native
    def isPatternLike(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PatternLike> */ Boolean = js.native
    
    def isPipelineBareFunction(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PipelineBareFunction> */ Boolean = js.native
    def isPipelineBareFunction(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PipelineBareFunction> */ Boolean = js.native
    
    def isPipelinePrimaryTopicReference(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PipelinePrimaryTopicReference> */ Boolean = js.native
    def isPipelinePrimaryTopicReference(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PipelinePrimaryTopicReference> */ Boolean = js.native
    
    def isPipelineTopicExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PipelineTopicExpression> */ Boolean = js.native
    def isPipelineTopicExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PipelineTopicExpression> */ Boolean = js.native
    
    def isPlaceholder(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Placeholder> */ Boolean = js.native
    def isPlaceholder(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Placeholder> */ Boolean = js.native
    
    def isPrivate(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Private> */ Boolean = js.native
    def isPrivate(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Private> */ Boolean = js.native
    
    def isPrivateName(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PrivateName> */ Boolean = js.native
    def isPrivateName(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PrivateName> */ Boolean = js.native
    
    def isProgram(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Program> */ Boolean = js.native
    def isProgram(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Program> */ Boolean = js.native
    
    def isProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Property> */ Boolean = js.native
    def isProperty(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Property> */ Boolean = js.native
    
    def isPure(): Boolean = js.native
    def isPure(opts: js.Object): Boolean = js.native
    
    def isPureish(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Pureish> */ Boolean = js.native
    def isPureish(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Pureish> */ Boolean = js.native
    
    def isQualifiedTypeIdentifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.QualifiedTypeIdentifier> */ Boolean = js.native
    def isQualifiedTypeIdentifier(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.QualifiedTypeIdentifier> */ Boolean = js.native
    
    def isRecordExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.RecordExpression> */ Boolean = js.native
    def isRecordExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.RecordExpression> */ Boolean = js.native
    
    def isReferenced(): Boolean = js.native
    def isReferenced(opts: js.Object): Boolean = js.native
    
    def isReferencedIdentifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Identifier | @babel/types.@babel/types.JSXIdentifier> */ Boolean = js.native
    def isReferencedIdentifier(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Identifier | @babel/types.@babel/types.JSXIdentifier> */ Boolean = js.native
    
    def isReferencedMemberExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.MemberExpression> */ Boolean = js.native
    def isReferencedMemberExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.MemberExpression> */ Boolean = js.native
    
    def isRegExpLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.RegExpLiteral> */ Boolean = js.native
    def isRegExpLiteral(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.RegExpLiteral> */ Boolean = js.native
    
    /** @deprecated Use `isRegExpLiteral` */
    def isRegexLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.RegexLiteral> */ Boolean = js.native
    def isRegexLiteral(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.RegexLiteral> */ Boolean = js.native
    
    def isRestElement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.RestElement> */ Boolean = js.native
    def isRestElement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.RestElement> */ Boolean = js.native
    
    /** @deprecated Use `isRestElement` */
    def isRestProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.RestProperty> */ Boolean = js.native
    def isRestProperty(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.RestProperty> */ Boolean = js.native
    
    def isReturnStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ReturnStatement> */ Boolean = js.native
    def isReturnStatement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ReturnStatement> */ Boolean = js.native
    
    def isScopable(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Scopable> */ Boolean = js.native
    def isScopable(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Scopable> */ Boolean = js.native
    
    def isScope(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Scopable | @babel/types.@babel/types.Pattern> */ Boolean = js.native
    def isScope(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Scopable | @babel/types.@babel/types.Pattern> */ Boolean = js.native
    
    def isSequenceExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SequenceExpression> */ Boolean = js.native
    def isSequenceExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SequenceExpression> */ Boolean = js.native
    
    def isSpreadElement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SpreadElement> */ Boolean = js.native
    def isSpreadElement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SpreadElement> */ Boolean = js.native
    
    /** @deprecated Use `isSpreadElement` */
    def isSpreadProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SpreadProperty> */ Boolean = js.native
    def isSpreadProperty(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SpreadProperty> */ Boolean = js.native
    
    def isStandardized(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Standardized> */ Boolean = js.native
    def isStandardized(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Standardized> */ Boolean = js.native
    
    def isStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Statement> */ Boolean = js.native
    def isStatement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Statement> */ Boolean = js.native
    
    /**
      * Check whether or not the current `key` allows either a single statement or block statement
      * so we can explode it if necessary.
      */
    def isStatementOrBlock(): Boolean = js.native
    
    // has(key: keyof T): boolean;
    def isStatic(): Boolean = js.native
    
    def isStaticBlock(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.StaticBlock> */ Boolean = js.native
    def isStaticBlock(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.StaticBlock> */ Boolean = js.native
    
    def isStringLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.StringLiteral> */ Boolean = js.native
    def isStringLiteral(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.StringLiteral> */ Boolean = js.native
    
    def isStringLiteralTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.StringLiteralTypeAnnotation> */ Boolean = js.native
    def isStringLiteralTypeAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.StringLiteralTypeAnnotation> */ Boolean = js.native
    
    def isStringTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.StringTypeAnnotation> */ Boolean = js.native
    def isStringTypeAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.StringTypeAnnotation> */ Boolean = js.native
    
    def isSuper(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Super> */ Boolean = js.native
    def isSuper(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Super> */ Boolean = js.native
    
    def isSwitchCase(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SwitchCase> */ Boolean = js.native
    def isSwitchCase(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SwitchCase> */ Boolean = js.native
    
    def isSwitchStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SwitchStatement> */ Boolean = js.native
    def isSwitchStatement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SwitchStatement> */ Boolean = js.native
    
    def isSymbolTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SymbolTypeAnnotation> */ Boolean = js.native
    def isSymbolTypeAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SymbolTypeAnnotation> */ Boolean = js.native
    
    def isTSAnyKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSAnyKeyword> */ Boolean = js.native
    def isTSAnyKeyword(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSAnyKeyword> */ Boolean = js.native
    
    def isTSArrayType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSArrayType> */ Boolean = js.native
    def isTSArrayType(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSArrayType> */ Boolean = js.native
    
    def isTSAsExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSAsExpression> */ Boolean = js.native
    def isTSAsExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSAsExpression> */ Boolean = js.native
    
    def isTSBaseType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSBaseType> */ Boolean = js.native
    def isTSBaseType(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSBaseType> */ Boolean = js.native
    
    def isTSBigIntKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSBigIntKeyword> */ Boolean = js.native
    def isTSBigIntKeyword(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSBigIntKeyword> */ Boolean = js.native
    
    def isTSBooleanKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSBooleanKeyword> */ Boolean = js.native
    def isTSBooleanKeyword(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSBooleanKeyword> */ Boolean = js.native
    
    def isTSCallSignatureDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSCallSignatureDeclaration> */ Boolean = js.native
    def isTSCallSignatureDeclaration(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSCallSignatureDeclaration> */ Boolean = js.native
    
    def isTSConditionalType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSConditionalType> */ Boolean = js.native
    def isTSConditionalType(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSConditionalType> */ Boolean = js.native
    
    def isTSConstructSignatureDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSConstructSignatureDeclaration> */ Boolean = js.native
    def isTSConstructSignatureDeclaration(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSConstructSignatureDeclaration> */ Boolean = js.native
    
    def isTSConstructorType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSConstructorType> */ Boolean = js.native
    def isTSConstructorType(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSConstructorType> */ Boolean = js.native
    
    def isTSDeclareFunction(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSDeclareFunction> */ Boolean = js.native
    def isTSDeclareFunction(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSDeclareFunction> */ Boolean = js.native
    
    def isTSDeclareMethod(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSDeclareMethod> */ Boolean = js.native
    def isTSDeclareMethod(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSDeclareMethod> */ Boolean = js.native
    
    def isTSEntityName(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSEntityName> */ Boolean = js.native
    def isTSEntityName(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSEntityName> */ Boolean = js.native
    
    def isTSEnumDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSEnumDeclaration> */ Boolean = js.native
    def isTSEnumDeclaration(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSEnumDeclaration> */ Boolean = js.native
    
    def isTSEnumMember(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSEnumMember> */ Boolean = js.native
    def isTSEnumMember(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSEnumMember> */ Boolean = js.native
    
    def isTSExportAssignment(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSExportAssignment> */ Boolean = js.native
    def isTSExportAssignment(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSExportAssignment> */ Boolean = js.native
    
    def isTSExpressionWithTypeArguments(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSExpressionWithTypeArguments> */ Boolean = js.native
    def isTSExpressionWithTypeArguments(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSExpressionWithTypeArguments> */ Boolean = js.native
    
    def isTSExternalModuleReference(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSExternalModuleReference> */ Boolean = js.native
    def isTSExternalModuleReference(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSExternalModuleReference> */ Boolean = js.native
    
    def isTSFunctionType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSFunctionType> */ Boolean = js.native
    def isTSFunctionType(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSFunctionType> */ Boolean = js.native
    
    def isTSImportEqualsDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSImportEqualsDeclaration> */ Boolean = js.native
    def isTSImportEqualsDeclaration(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSImportEqualsDeclaration> */ Boolean = js.native
    
    def isTSImportType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSImportType> */ Boolean = js.native
    def isTSImportType(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSImportType> */ Boolean = js.native
    
    def isTSIndexSignature(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSIndexSignature> */ Boolean = js.native
    def isTSIndexSignature(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSIndexSignature> */ Boolean = js.native
    
    def isTSIndexedAccessType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSIndexedAccessType> */ Boolean = js.native
    def isTSIndexedAccessType(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSIndexedAccessType> */ Boolean = js.native
    
    def isTSInferType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSInferType> */ Boolean = js.native
    def isTSInferType(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSInferType> */ Boolean = js.native
    
    def isTSInstantiationExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSInstantiationExpression> */ Boolean = js.native
    def isTSInstantiationExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSInstantiationExpression> */ Boolean = js.native
    
    def isTSInterfaceBody(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSInterfaceBody> */ Boolean = js.native
    def isTSInterfaceBody(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSInterfaceBody> */ Boolean = js.native
    
    def isTSInterfaceDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSInterfaceDeclaration> */ Boolean = js.native
    def isTSInterfaceDeclaration(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSInterfaceDeclaration> */ Boolean = js.native
    
    def isTSIntersectionType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSIntersectionType> */ Boolean = js.native
    def isTSIntersectionType(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSIntersectionType> */ Boolean = js.native
    
    def isTSIntrinsicKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSIntrinsicKeyword> */ Boolean = js.native
    def isTSIntrinsicKeyword(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSIntrinsicKeyword> */ Boolean = js.native
    
    def isTSLiteralType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSLiteralType> */ Boolean = js.native
    def isTSLiteralType(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSLiteralType> */ Boolean = js.native
    
    def isTSMappedType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSMappedType> */ Boolean = js.native
    def isTSMappedType(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSMappedType> */ Boolean = js.native
    
    def isTSMethodSignature(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSMethodSignature> */ Boolean = js.native
    def isTSMethodSignature(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSMethodSignature> */ Boolean = js.native
    
    def isTSModuleBlock(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSModuleBlock> */ Boolean = js.native
    def isTSModuleBlock(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSModuleBlock> */ Boolean = js.native
    
    def isTSModuleDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSModuleDeclaration> */ Boolean = js.native
    def isTSModuleDeclaration(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSModuleDeclaration> */ Boolean = js.native
    
    def isTSNamedTupleMember(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNamedTupleMember> */ Boolean = js.native
    def isTSNamedTupleMember(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNamedTupleMember> */ Boolean = js.native
    
    def isTSNamespaceExportDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNamespaceExportDeclaration> */ Boolean = js.native
    def isTSNamespaceExportDeclaration(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNamespaceExportDeclaration> */ Boolean = js.native
    
    def isTSNeverKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNeverKeyword> */ Boolean = js.native
    def isTSNeverKeyword(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNeverKeyword> */ Boolean = js.native
    
    def isTSNonNullExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNonNullExpression> */ Boolean = js.native
    def isTSNonNullExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNonNullExpression> */ Boolean = js.native
    
    def isTSNullKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNullKeyword> */ Boolean = js.native
    def isTSNullKeyword(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNullKeyword> */ Boolean = js.native
    
    def isTSNumberKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNumberKeyword> */ Boolean = js.native
    def isTSNumberKeyword(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNumberKeyword> */ Boolean = js.native
    
    def isTSObjectKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSObjectKeyword> */ Boolean = js.native
    def isTSObjectKeyword(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSObjectKeyword> */ Boolean = js.native
    
    def isTSOptionalType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSOptionalType> */ Boolean = js.native
    def isTSOptionalType(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSOptionalType> */ Boolean = js.native
    
    def isTSParameterProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSParameterProperty> */ Boolean = js.native
    def isTSParameterProperty(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSParameterProperty> */ Boolean = js.native
    
    def isTSParenthesizedType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSParenthesizedType> */ Boolean = js.native
    def isTSParenthesizedType(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSParenthesizedType> */ Boolean = js.native
    
    def isTSPropertySignature(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSPropertySignature> */ Boolean = js.native
    def isTSPropertySignature(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSPropertySignature> */ Boolean = js.native
    
    def isTSQualifiedName(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSQualifiedName> */ Boolean = js.native
    def isTSQualifiedName(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSQualifiedName> */ Boolean = js.native
    
    def isTSRestType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSRestType> */ Boolean = js.native
    def isTSRestType(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSRestType> */ Boolean = js.native
    
    def isTSSatisfiesExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSSatisfiesExpression> */ Boolean = js.native
    def isTSSatisfiesExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSSatisfiesExpression> */ Boolean = js.native
    
    def isTSStringKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSStringKeyword> */ Boolean = js.native
    def isTSStringKeyword(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSStringKeyword> */ Boolean = js.native
    
    def isTSSymbolKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSSymbolKeyword> */ Boolean = js.native
    def isTSSymbolKeyword(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSSymbolKeyword> */ Boolean = js.native
    
    def isTSThisType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSThisType> */ Boolean = js.native
    def isTSThisType(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSThisType> */ Boolean = js.native
    
    def isTSTupleType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTupleType> */ Boolean = js.native
    def isTSTupleType(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTupleType> */ Boolean = js.native
    
    def isTSType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSType> */ Boolean = js.native
    def isTSType(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSType> */ Boolean = js.native
    
    def isTSTypeAliasDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeAliasDeclaration> */ Boolean = js.native
    def isTSTypeAliasDeclaration(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeAliasDeclaration> */ Boolean = js.native
    
    def isTSTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeAnnotation> */ Boolean = js.native
    def isTSTypeAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeAnnotation> */ Boolean = js.native
    
    def isTSTypeAssertion(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeAssertion> */ Boolean = js.native
    def isTSTypeAssertion(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeAssertion> */ Boolean = js.native
    
    def isTSTypeElement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeElement> */ Boolean = js.native
    def isTSTypeElement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeElement> */ Boolean = js.native
    
    def isTSTypeLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeLiteral> */ Boolean = js.native
    def isTSTypeLiteral(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeLiteral> */ Boolean = js.native
    
    def isTSTypeOperator(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeOperator> */ Boolean = js.native
    def isTSTypeOperator(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeOperator> */ Boolean = js.native
    
    def isTSTypeParameter(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeParameter> */ Boolean = js.native
    def isTSTypeParameter(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeParameter> */ Boolean = js.native
    
    def isTSTypeParameterDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeParameterDeclaration> */ Boolean = js.native
    def isTSTypeParameterDeclaration(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeParameterDeclaration> */ Boolean = js.native
    
    def isTSTypeParameterInstantiation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeParameterInstantiation> */ Boolean = js.native
    def isTSTypeParameterInstantiation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeParameterInstantiation> */ Boolean = js.native
    
    def isTSTypePredicate(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypePredicate> */ Boolean = js.native
    def isTSTypePredicate(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypePredicate> */ Boolean = js.native
    
    def isTSTypeQuery(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeQuery> */ Boolean = js.native
    def isTSTypeQuery(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeQuery> */ Boolean = js.native
    
    def isTSTypeReference(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeReference> */ Boolean = js.native
    def isTSTypeReference(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeReference> */ Boolean = js.native
    
    def isTSUndefinedKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSUndefinedKeyword> */ Boolean = js.native
    def isTSUndefinedKeyword(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSUndefinedKeyword> */ Boolean = js.native
    
    def isTSUnionType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSUnionType> */ Boolean = js.native
    def isTSUnionType(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSUnionType> */ Boolean = js.native
    
    def isTSUnknownKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSUnknownKeyword> */ Boolean = js.native
    def isTSUnknownKeyword(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSUnknownKeyword> */ Boolean = js.native
    
    def isTSVoidKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSVoidKeyword> */ Boolean = js.native
    def isTSVoidKeyword(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSVoidKeyword> */ Boolean = js.native
    
    def isTaggedTemplateExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TaggedTemplateExpression> */ Boolean = js.native
    def isTaggedTemplateExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TaggedTemplateExpression> */ Boolean = js.native
    
    def isTemplateElement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TemplateElement> */ Boolean = js.native
    def isTemplateElement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TemplateElement> */ Boolean = js.native
    
    def isTemplateLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TemplateLiteral> */ Boolean = js.native
    def isTemplateLiteral(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TemplateLiteral> */ Boolean = js.native
    
    def isTerminatorless(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Terminatorless> */ Boolean = js.native
    def isTerminatorless(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Terminatorless> */ Boolean = js.native
    
    def isThisExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ThisExpression> */ Boolean = js.native
    def isThisExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ThisExpression> */ Boolean = js.native
    
    def isThisTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ThisTypeAnnotation> */ Boolean = js.native
    def isThisTypeAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ThisTypeAnnotation> */ Boolean = js.native
    
    def isThrowStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ThrowStatement> */ Boolean = js.native
    def isThrowStatement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ThrowStatement> */ Boolean = js.native
    
    def isTopicReference(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TopicReference> */ Boolean = js.native
    def isTopicReference(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TopicReference> */ Boolean = js.native
    
    def isTryStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TryStatement> */ Boolean = js.native
    def isTryStatement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TryStatement> */ Boolean = js.native
    
    def isTupleExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TupleExpression> */ Boolean = js.native
    def isTupleExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TupleExpression> */ Boolean = js.native
    
    def isTupleTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TupleTypeAnnotation> */ Boolean = js.native
    def isTupleTypeAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TupleTypeAnnotation> */ Boolean = js.native
    
    def isTypeAlias(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeAlias> */ Boolean = js.native
    def isTypeAlias(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeAlias> */ Boolean = js.native
    
    def isTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeAnnotation> */ Boolean = js.native
    def isTypeAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeAnnotation> */ Boolean = js.native
    
    def isTypeCastExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeCastExpression> */ Boolean = js.native
    def isTypeCastExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeCastExpression> */ Boolean = js.native
    
    def isTypeParameter(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeParameter> */ Boolean = js.native
    def isTypeParameter(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeParameter> */ Boolean = js.native
    
    def isTypeParameterDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeParameterDeclaration> */ Boolean = js.native
    def isTypeParameterDeclaration(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeParameterDeclaration> */ Boolean = js.native
    
    def isTypeParameterInstantiation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeParameterInstantiation> */ Boolean = js.native
    def isTypeParameterInstantiation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeParameterInstantiation> */ Boolean = js.native
    
    def isTypeScript(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeScript> */ Boolean = js.native
    def isTypeScript(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeScript> */ Boolean = js.native
    
    def isTypeofTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeofTypeAnnotation> */ Boolean = js.native
    def isTypeofTypeAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeofTypeAnnotation> */ Boolean = js.native
    
    def isUnaryExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UnaryExpression> */ Boolean = js.native
    def isUnaryExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UnaryExpression> */ Boolean = js.native
    
    def isUnaryLike(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UnaryLike> */ Boolean = js.native
    def isUnaryLike(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UnaryLike> */ Boolean = js.native
    
    def isUnionTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UnionTypeAnnotation> */ Boolean = js.native
    def isUnionTypeAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UnionTypeAnnotation> */ Boolean = js.native
    
    def isUpdateExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UpdateExpression> */ Boolean = js.native
    def isUpdateExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UpdateExpression> */ Boolean = js.native
    
    def isUser(): Boolean = js.native
    def isUser(opts: js.Object): Boolean = js.native
    
    def isUserWhitespacable(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UserWhitespacable> */ Boolean = js.native
    def isUserWhitespacable(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UserWhitespacable> */ Boolean = js.native
    
    def isV8IntrinsicIdentifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.V8IntrinsicIdentifier> */ Boolean = js.native
    def isV8IntrinsicIdentifier(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.V8IntrinsicIdentifier> */ Boolean = js.native
    
    def isVar(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.VariableDeclaration> */ Boolean = js.native
    def isVar(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.VariableDeclaration> */ Boolean = js.native
    
    def isVariableDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.VariableDeclaration> */ Boolean = js.native
    def isVariableDeclaration(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.VariableDeclaration> */ Boolean = js.native
    
    def isVariableDeclarator(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.VariableDeclarator> */ Boolean = js.native
    def isVariableDeclarator(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.VariableDeclarator> */ Boolean = js.native
    
    def isVariance(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Variance> */ Boolean = js.native
    def isVariance(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Variance> */ Boolean = js.native
    
    def isVoidTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.VoidTypeAnnotation> */ Boolean = js.native
    def isVoidTypeAnnotation(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.VoidTypeAnnotation> */ Boolean = js.native
    
    def isWhile(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.While> */ Boolean = js.native
    def isWhile(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.While> */ Boolean = js.native
    
    def isWhileStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.WhileStatement> */ Boolean = js.native
    def isWhileStatement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.WhileStatement> */ Boolean = js.native
    
    def isWithStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.WithStatement> */ Boolean = js.native
    def isWithStatement(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.WithStatement> */ Boolean = js.native
    
    def isYieldExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.YieldExpression> */ Boolean = js.native
    def isYieldExpression(opts: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.YieldExpression> */ Boolean = js.native
    
    // is(key: keyof T): boolean;
    /** Opposite of `has`. */
    def isnt(key: String): Boolean = js.native
    
    var key: String | Double | Null = js.native
    
    var listKey: String | Null = js.native
    
    //#endregion
    //#region ------------------------- introspection -------------------------
    /**
      * Match the current node if it matches the provided `pattern`.
      *
      * For example, given the match `React.createClass` it would match the
      * parsed nodes of `React.createClass` and `React["createClass"]`.
      */
    def matchesPattern(pattern: String): Boolean = js.native
    def matchesPattern(pattern: String, allowPartial: Boolean): Boolean = js.native
    
    var node: T = js.native
    
    var opts: Any = js.native
    
    var parent: Node = js.native
    
    var parentKey: String = js.native
    
    var parentPath: /* import warning: importer.ImportType#apply Failed type conversion: T extends @babel/types.@babel/types.Program ? null : @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Node> */ js.Any = js.native
    
    def popContext(): Unit = js.native
    
    /**
      * Insert child nodes at the end of the current node.
      * @param listKey - The key at which the child nodes are stored (usually body).
      * @param nodes - the nodes to insert.
      */
    def pushContainer[T /* <: Node */, K /* <: NodeKeyOfArrays[T] */, Nodes /* <: NodesInsertionParam[NodeListType[T, K]] */](listKey: K, nodes: Nodes): NodePaths[Nodes] = js.native
    
    def pushContext(context: TraversalContext[Any]): Unit = js.native
    
    /** Check if the currently assigned path references the `importName` of `moduleSource`. */
    def referencesImport(moduleSource: String, importName: String): Boolean = js.native
    
    //#endregion
    //#region ------------------------- removal -------------------------
    def remove(): Unit = js.native
    
    var removed: Boolean = js.native
    
    /**
      * This method takes an array of statements nodes and then explodes it
      * into expressions. This method retains completion records which is
      * extremely important to retain original semantics.
      */
    def replaceExpressionWithStatements(nodes: js.Array[Statement]): NodePaths[Expression | Statement] = js.native
    
    def replaceInline[Nodes /* <: Node | js.Array[Node] | Array[Node] */](nodes: Nodes): NodePaths[Nodes] = js.native
    
    /** Replace the current node with another. */
    def replaceWith[R /* <: Node */](replacementPath: R): js.Array[NodePath[R]] = js.native
    def replaceWith[R /* <: Node */](replacementPath: NodePath[R]): js.Array[NodePath[R]] = js.native
    
    //#endregion
    //#region ------------------------- replacement -------------------------
    /**
      * Replace a node with an array of multiple. This method performs the following steps:
      *
      *  - Inherit the comments of first provided node with that of the current node.
      *  - Insert the provided nodes after the current node.
      *  - Remove the current node.
      */
    def replaceWithMultiple[Nodes /* <: Node | js.Array[Node] | Array[Node] */](nodes: Nodes): NodePaths[Nodes] = js.native
    
    /**
      * Parse a string as an expression and replace the current node with the result.
      *
      * NOTE: This is typically not a good idea to use. Building source strings when
      * transforming ASTs is an antipattern and SHOULD NOT be encouraged. Even if it's
      * easier to use, your transforms will be extremely brittle.
      */
    def replaceWithSourceString(replacement: String): js.Array[NodePath[Node]] = js.native
    
    def requeue(): Unit = js.native
    def requeue(pathToQueue: NodePath[Node]): Unit = js.native
    
    def resolve(): NodePath[Node] = js.native
    def resolve(dangerous: Boolean): NodePath[Node] = js.native
    def resolve(dangerous: Boolean, resolved: js.Array[NodePath[Node]]): NodePath[Node] = js.native
    def resolve(dangerous: Unit, resolved: js.Array[NodePath[Node]]): NodePath[Node] = js.native
    
    /**
      * Here we resync the node paths `key` and `container`. If they've changed according
      * to what we have stored internally then we attempt to resync by crawling and looking
      * for the new values.
      */
    def resync(): Unit = js.native
    
    var scope: Scope = js.native
    
    def set(key: String, node: Any): Unit = js.native
    
    def setContext(): this.type = js.native
    def setContext(context: TraversalContext[Any]): this.type = js.native
    
    def setData(key: String, `val`: Any): Any = js.native
    def setData(key: js.Symbol, `val`: Any): Any = js.native
    
    def setScope(): Unit = js.native
    
    //#endregion
    //#region ------------------------- comments -------------------------
    /** Share comments amongst siblings. */
    def shareCommentsWithSiblings(): Unit = js.native
    
    var shouldSkip: Boolean = js.native
    
    var shouldStop: Boolean = js.native
    
    def skip(): Unit = js.native
    
    def skipKey(key: String): Unit = js.native
    
    // exploded TraverseOptions
    var skipKeys: (Record[String, Boolean]) | Null = js.native
    
    var state: Any = js.native
    
    def stop(): Unit = js.native
    
    //#endregion
    //#region ------------------------- conversion -------------------------
    def toComputedKey(): PrivateName_ | Expression = js.native
    
    def traverse(visitor: Visitor[Any]): Unit = js.native
    def traverse[T](visitor: Visitor[T], state: T): Unit = js.native
    
    var `type`: /* import warning: importer.ImportType#apply Failed type conversion: T extends @babel/types.@babel/types.Node ? T['type'] : T extends null | undefined ? undefined : 'ClassAccessorProperty' | 'AnyTypeAnnotation' | 'ArgumentPlaceholder' | 'ArrayExpression' | 'ArrayPattern' | 'ArrayTypeAnnotation' | 'ArrowFunctionExpression' | 'AssignmentExpression' | 'AssignmentPattern' | 'AwaitExpression' | 'BigIntLiteral' | 'BinaryExpression' | 'LogicalExpression' | 'BindExpression' | 'BlockStatement' | 'Program' | 'TSModuleBlock' | 'CatchClause' | 'DoWhileStatement' | 'ForInStatement' | 'ForStatement' | 'FunctionDeclaration' | 'FunctionExpression' | 'ObjectMethod' | 'SwitchStatement' | 'WhileStatement' | 'ForOfStatement' | 'ClassMethod' | 'ClassPrivateMethod' | 'StaticBlock' | 'BooleanLiteral' | 'BooleanLiteralTypeAnnotation' | 'BooleanTypeAnnotation' | 'BreakStatement' | 'CallExpression' | 'ClassExpression' | 'ClassDeclaration' | 'ClassBody' | 'ClassImplements' | 'ClassPrivateProperty' | 'ClassProperty' | 'ContinueStatement' | 'ReturnStatement' | 'ThrowStatement' | 'ConditionalExpression' | 'IfStatement' | 'DebuggerStatement' | 'DecimalLiteral' | 'VariableDeclaration' | 'ExportAllDeclaration' | 'ExportDefaultDeclaration' | 'ExportNamedDeclaration' | 'ImportDeclaration' | 'DeclareClass' | 'DeclareFunction' | 'DeclareInterface' | 'DeclareModule' | 'DeclareModuleExports' | 'DeclareTypeAlias' | 'DeclareOpaqueType' | 'DeclareVariable' | 'DeclareExportDeclaration' | 'DeclareExportAllDeclaration' | 'InterfaceDeclaration' | 'OpaqueType' | 'TypeAlias' | 'EnumDeclaration' | 'TSDeclareFunction' | 'TSInterfaceDeclaration' | 'TSTypeAliasDeclaration' | 'TSEnumDeclaration' | 'TSModuleDeclaration' | 'DeclaredPredicate' | 'Decorator' | 'Directive' | 'DirectiveLiteral' | 'DoExpression' | 'EmptyStatement' | 'EmptyTypeAnnotation' | 'EnumBooleanBody' | 'EnumNumberBody' | 'EnumStringBody' | 'EnumSymbolBody' | 'EnumBooleanMember' | 'EnumDefaultedMember' | 'EnumNumberMember' | 'EnumStringMember' | 'ExistsTypeAnnotation' | 'ExportDefaultSpecifier' | 'ExportNamespaceSpecifier' | 'ExportSpecifier' | 'Identifier' | 'StringLiteral' | 'NumericLiteral' | 'NullLiteral' | 'RegExpLiteral' | 'MemberExpression' | 'NewExpression' | 'ObjectExpression' | 'SequenceExpression' | 'ParenthesizedExpression' | 'ThisExpression' | 'UnaryExpression' | 'UpdateExpression' | 'MetaProperty' | 'Super' | 'TaggedTemplateExpression' | 'TemplateLiteral' | 'YieldExpression' | 'Import' | 'OptionalMemberExpression' | 'OptionalCallExpression' | 'TypeCastExpression' | 'JSXElement' | 'JSXFragment' | 'RecordExpression' | 'TupleExpression' | 'ModuleExpression' | 'TopicReference' | 'PipelineTopicExpression' | 'PipelineBareFunction' | 'PipelinePrimaryTopicReference' | 'TSInstantiationExpression' | 'TSAsExpression' | 'TSSatisfiesExpression' | 'TSTypeAssertion' | 'TSNonNullExpression' | 'ExpressionStatement' | 'File' | 'NullLiteralTypeAnnotation' | 'FunctionTypeAnnotation' | 'FunctionTypeParam' | 'GenericTypeAnnotation' | 'InferredPredicate' | 'InterfaceExtends' | 'InterfaceTypeAnnotation' | 'IntersectionTypeAnnotation' | 'MixedTypeAnnotation' | 'NullableTypeAnnotation' | 'NumberLiteralTypeAnnotation' | 'NumberTypeAnnotation' | 'ObjectTypeAnnotation' | 'ObjectTypeInternalSlot' | 'ObjectTypeCallProperty' | 'ObjectTypeIndexer' | 'ObjectTypeProperty' | 'ObjectTypeSpreadProperty' | 'QualifiedTypeIdentifier' | 'StringLiteralTypeAnnotation' | 'StringTypeAnnotation' | 'SymbolTypeAnnotation' | 'ThisTypeAnnotation' | 'TupleTypeAnnotation' | 'TypeofTypeAnnotation' | 'TypeAnnotation' | 'TypeParameter' | 'TypeParameterDeclaration' | 'TypeParameterInstantiation' | 'UnionTypeAnnotation' | 'Variance' | 'VoidTypeAnnotation' | 'IndexedAccessType' | 'OptionalIndexedAccessType' | 'JSXAttribute' | 'JSXClosingElement' | 'JSXExpressionContainer' | 'JSXSpreadChild' | 'JSXOpeningElement' | 'JSXText' | 'JSXOpeningFragment' | 'JSXClosingFragment' | 'ImportAttribute' | 'ImportDefaultSpecifier' | 'ImportNamespaceSpecifier' | 'ImportSpecifier' | 'InterpreterDirective' | 'JSXEmptyExpression' | 'JSXIdentifier' | 'JSXMemberExpression' | 'JSXNamespacedName' | 'JSXSpreadAttribute' | 'RestElement' | 'ObjectPattern' | 'TSParameterProperty' | 'LabeledStatement' | 'Noop' | 'Placeholder' | 'V8IntrinsicIdentifier' | 'ObjectProperty' | 'PrivateName' | 'SpreadElement' | 'SwitchCase' | 'TryStatement' | 'VariableDeclarator' | 'WithStatement' | 'TemplateElement' | 'TSImportEqualsDeclaration' | 'TSExportAssignment' | 'TSNamespaceExportDeclaration' | 'TSAnyKeyword' | 'TSArrayType' | 'TSBooleanKeyword' | 'TSBigIntKeyword' | 'TSIntrinsicKeyword' | 'TSNeverKeyword' | 'TSNullKeyword' | 'TSNumberKeyword' | 'TSObjectKeyword' | 'TSStringKeyword' | 'TSSymbolKeyword' | 'TSUndefinedKeyword' | 'TSUnknownKeyword' | 'TSVoidKeyword' | 'TSThisType' | 'TSLiteralType' | 'TSCallSignatureDeclaration' | 'TSConditionalType' | 'TSConstructSignatureDeclaration' | 'TSConstructorType' | 'TSDeclareMethod' | 'TSQualifiedName' | 'TSEnumMember' | 'TSExpressionWithTypeArguments' | 'TSExternalModuleReference' | 'TSFunctionType' | 'TSImportType' | 'TSIndexSignature' | 'TSIndexedAccessType' | 'TSInferType' | 'TSInterfaceBody' | 'TSIntersectionType' | 'TSMappedType' | 'TSMethodSignature' | 'TSNamedTupleMember' | 'TSOptionalType' | 'TSParenthesizedType' | 'TSPropertySignature' | 'TSRestType' | 'TSTupleType' | 'TSTypeReference' | 'TSTypePredicate' | 'TSTypeQuery' | 'TSTypeLiteral' | 'TSUnionType' | 'TSTypeOperator' | 'TSTypeAnnotation' | 'TSTypeParameter' | 'TSTypeParameterDeclaration' | 'TSTypeParameterInstantiation' | undefined */ js.Any = js.native
    
    var typeAnnotation: js.Object = js.native
    
    /**
      * Insert child nodes at the start of the current node.
      * @param listKey - The key at which the child nodes are stored (usually body).
      * @param nodes - the nodes to insert.
      */
    def unshiftContainer[T /* <: Node */, K /* <: NodeKeyOfArrays[T] */, Nodes /* <: NodesInsertionParam[NodeListType[T, K]] */](listKey: K, nodes: Nodes): NodePaths[Nodes] = js.native
    
    /**
      * Given an arbitrary function, process its content as if it were an arrow function, moving references
      * to "this", "arguments", "super", and such into the function's parent scope. This method is useful if
      * you have wrapped some set of items in an IIFE or other function, but want "this", "arguments", and super"
      * to continue behaving as expected.
      */
    def unwrapFunctionEnvironment(): Unit = js.native
    
    /** Update all sibling node paths after `fromIndex` by `incrementBy`. */
    def updateSiblingKeys(fromIndex: Double, incrementBy: Double): Unit = js.native
    
    def visit(): Boolean = js.native
    
    /** Check if the current path will maybe execute before another path */
    def willIMaybeExecuteBefore(target: NodePath[Node]): Boolean = js.native
  }
  /* static members */
  object NodePath {
    
    @JSImport("@babel/traverse", "NodePath")
    @js.native
    val ^ : js.Any = js.native
    
    inline def get[C /* <: Node */, K /* <: /* keyof C */ String */](opts: Container[C, K]): NodePath[
        /* import warning: importer.ImportType#apply Failed type conversion: C[K] */ js.Any
      ] = ^.asInstanceOf[js.Dynamic].applyDynamic("get")(opts.asInstanceOf[js.Any]).asInstanceOf[NodePath[
        /* import warning: importer.ImportType#apply Failed type conversion: C[K] */ js.Any
      ]]
    inline def get[C /* <: Node */, L /* <: NodeKeyOfArrays[C] */](opts: typings.babelTraverse.anon.Hub[C, L]): /* import warning: importer.ImportType#apply Failed type conversion: C[L] extends std.Array<@babel/types.@babel/types.Node | null | undefined> ? @babel/traverse.@babel/traverse.NodePath<C[L][number]> : never */ js.Any = ^.asInstanceOf[js.Dynamic].applyDynamic("get")(opts.asInstanceOf[js.Any]).asInstanceOf[/* import warning: importer.ImportType#apply Failed type conversion: C[L] extends std.Array<@babel/types.@babel/types.Node | null | undefined> ? @babel/traverse.@babel/traverse.NodePath<C[L][number]> : never */ js.Any]
  }
  
  @JSImport("@babel/traverse", "Scope")
  @js.native
  open class Scope protected () extends StObject {
    /**
      * This searches the current "scope" and collects all references/bindings
      * within.
      */
    def this(path: NodePath[Node]) = this()
    def this(path: NodePath[Node], parentScope: Scope) = this()
    
    def addGlobal(node: Identifier_): Unit = js.native
    def addGlobal(node: JSXIdentifier_): Unit = js.native
    
    def bindingIdentifierEquals(name: String, node: Node): Boolean = js.native
    
    var bindings: StringDictionary[Binding] = js.native
    
    var block: Node = js.native
    
    def buildUndefinedNode(): UnaryExpression_ = js.native
    
    def checkBlockScopedCollisions(local: Binding, kind: BindingKind, name: String, id: js.Object): Unit = js.native
    
    def crawl(): Unit = js.native
    
    var crawling: Boolean = js.native
    
    var data: Record[String | js.Symbol, Any] = js.native
    
    def dump(): Unit = js.native
    
    /** Generate a unique identifier and add it to the current scope. */
    def generateDeclaredUidIdentifier(): Identifier_ = js.native
    def generateDeclaredUidIdentifier(name: String): Identifier_ = js.native
    
    /** Generate a unique `_id1` binding. */
    def generateUid(): String = js.native
    def generateUid(name: String): String = js.native
    
    /** Generate a unique identifier. */
    def generateUidIdentifier(): Identifier_ = js.native
    def generateUidIdentifier(name: String): Identifier_ = js.native
    
    /** Generate a unique identifier based on a node. */
    def generateUidIdentifierBasedOnNode(parent: Node): Identifier_ = js.native
    def generateUidIdentifierBasedOnNode(parent: Node, defaultName: String): Identifier_ = js.native
    
    /** Walks the scope tree and gathers **all** bindings. */
    def getAllBindings(): Record[String, Binding] = js.native
    
    /** Walks the scope tree and gathers all declarations of `kind`. */
    def getAllBindingsOfKind(kinds: String*): Record[String, Binding] = js.native
    
    def getBinding(name: String): js.UndefOr[Binding] = js.native
    
    def getBindingIdentifier(name: String): Identifier_ = js.native
    
    /**
      * Walk up the scope tree until we hit either a BlockStatement/Loop/Program/Function/Switch or reach the
      * very top and hit Program.
      */
    def getBlockParent(): Scope = js.native
    
    /**
      * Recursively walk up scope tree looking for the data `key`.
      */
    def getData(key: String): Any = js.native
    
    /** Walk up the scope tree until we hit either a Function or return null. */
    def getFunctionParent(): Scope | Null = js.native
    
    def getLabel(name: String): js.UndefOr[NodePath[LabeledStatement_]] = js.native
    
    def getOwnBinding(name: String): js.UndefOr[Binding] = js.native
    
    def getOwnBindingIdentifier(name: String): Identifier_ = js.native
    
    /**
      * Walk up from a pattern scope (function param initializer) until we hit a non-pattern scope,
      * then returns its block parent
      * @returns An ancestry scope whose path is a block parent
      */
    def getPatternParent(): Scope = js.native
    
    /** Walk up to the top of the scope tree and get the `Program`. */
    def getProgramParent(): Scope = js.native
    
    var globals: StringDictionary[Identifier_ | JSXIdentifier_] = js.native
    
    def hasBinding(name: String): Boolean = js.native
    def hasBinding(name: String, optsOrNoGlobals: Boolean): Boolean = js.native
    def hasBinding(name: String, optsOrNoGlobals: NoGlobals): Boolean = js.native
    
    def hasGlobal(name: String): Boolean = js.native
    
    def hasLabel(name: String): Boolean = js.native
    
    def hasOwnBinding(name: String): Boolean = js.native
    
    def hasReference(name: String): Boolean = js.native
    
    def hasUid(name: String): Boolean = js.native
    
    var hub: HubInterface = js.native
    
    def isPure(node: Node): Boolean = js.native
    def isPure(node: Node, constantsOnly: Boolean): Boolean = js.native
    
    /**
      * Determine whether evaluating the specific input `node` is a consequenceless reference. ie.
      * evaluating it wont result in potentially arbitrary code from being ran. The following are
      * whitelisted and determined not to cause side effects:
      *
      *  - `this` expressions
      *  - `super` expressions
      *  - Bound identifiers
      */
    def isStatic(node: Node): Boolean = js.native
    
    var labels: Map[String, NodePath[LabeledStatement_]] = js.native
    
    /** Possibly generate a memoised identifier if it is not static and has consequences. */
    def maybeGenerateMemoised(node: Node): Identifier_ = js.native
    def maybeGenerateMemoised(node: Node, dontPush: Boolean): Identifier_ = js.native
    
    /** Move a binding of `name` to another `scope`. */
    def moveBindingTo(name: String, scope: Scope): Unit = js.native
    
    var parent: Scope = js.native
    
    var parentBlock: Node = js.native
    
    def parentHasBinding(name: String): Boolean = js.native
    def parentHasBinding(name: String, opts: NoGlobals): Boolean = js.native
    
    var path: NodePath[Node] = js.native
    
    def push(opts: BlockHoist): Unit = js.native
    
    var references: StringDictionary[`true`] = js.native
    
    def registerBinding(kind: BindingKind, path: NodePath[Node]): Unit = js.native
    def registerBinding(kind: BindingKind, path: NodePath[Node], bindingPath: NodePath[Node]): Unit = js.native
    
    def registerConstantViolation(path: NodePath[Node]): Unit = js.native
    
    def registerDeclaration(path: NodePath[Node]): Unit = js.native
    
    def registerLabel(path: NodePath[LabeledStatement_]): Unit = js.native
    
    def removeBinding(name: String): Unit = js.native
    
    /**
      * Recursively walk up scope tree looking for the data `key` and if it exists,
      * remove it.
      */
    def removeData(key: String): Unit = js.native
    
    def removeOwnBinding(name: String): Unit = js.native
    
    def rename(oldName: String): Unit = js.native
    def rename(oldName: String, newName: String): Unit = js.native
    def rename(oldName: String, newName: String, block: Node): Unit = js.native
    def rename(oldName: String, newName: Unit, block: Node): Unit = js.native
    
    /**
      * Set some arbitrary data on the current scope.
      */
    def setData(key: String, `val`: Any): Any = js.native
    
    def toArray(node: Node): ArrayExpression_ | CallExpression_ | Identifier_ = js.native
    def toArray(node: Node, i: Boolean): ArrayExpression_ | CallExpression_ | Identifier_ = js.native
    def toArray(node: Node, i: Boolean, arrayLikeIsIterable: Boolean): ArrayExpression_ | CallExpression_ | Identifier_ = js.native
    def toArray(node: Node, i: Double): ArrayExpression_ | CallExpression_ | Identifier_ = js.native
    def toArray(node: Node, i: Double, arrayLikeIsIterable: Boolean): ArrayExpression_ | CallExpression_ | Identifier_ = js.native
    def toArray(node: Node, i: Unit, arrayLikeIsIterable: Boolean): ArrayExpression_ | CallExpression_ | Identifier_ = js.native
    
    def traverse(node: js.Array[Node]): Unit = js.native
    def traverse(node: js.Array[Node], opts: Unit, state: Any): Unit = js.native
    def traverse(node: js.Array[Node], opts: TraverseOptions[Node]): Unit = js.native
    def traverse(node: js.Array[Node], opts: TraverseOptions[Node], state: Any): Unit = js.native
    def traverse(node: Node): Unit = js.native
    def traverse(node: Node, opts: Unit, state: Any): Unit = js.native
    def traverse(node: Node, opts: TraverseOptions[Node]): Unit = js.native
    def traverse(node: Node, opts: TraverseOptions[Node], state: Any): Unit = js.native
    @JSName("traverse")
    def traverse_S[S](node: js.Array[Node], opts: TraverseOptions[S], state: S): Unit = js.native
    /** Traverse node with current scope and path. */
    @JSName("traverse")
    def traverse_S[S](node: Node, opts: TraverseOptions[S], state: S): Unit = js.native
    
    var uid: Double = js.native
    
    var uids: StringDictionary[Boolean] = js.native
  }
  /* static members */
  object Scope {
    
    @JSImport("@babel/traverse", "Scope")
    @js.native
    val ^ : js.Any = js.native
    
    /** Variables available in current context. */
    @JSImport("@babel/traverse", "Scope.contextVariables")
    @js.native
    def contextVariables: js.Array[String] = js.native
    inline def contextVariables_=(x: js.Array[String]): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("contextVariables")(x.asInstanceOf[js.Any])
    
    @JSImport("@babel/traverse", "Scope.globals")
    @js.native
    def globals: js.Array[String] = js.native
    inline def globals_=(x: js.Array[String]): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("globals")(x.asInstanceOf[js.Any])
  }
  
  object cache {
    
    @JSImport("@babel/traverse", "cache")
    @js.native
    val ^ : js.Any = js.native
    
    inline def clear(): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("clear")().asInstanceOf[Unit]
    
    inline def clearPath(): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("clearPath")().asInstanceOf[Unit]
    
    inline def clearScope(): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("clearScope")().asInstanceOf[Unit]
    
    @JSImport("@babel/traverse", "cache.path")
    @js.native
    def path: WeakMap[Node, Map[Node, NodePath[Node]]] = js.native
    inline def path_=(x: WeakMap[Node, Map[Node, NodePath[Node]]]): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("path")(x.asInstanceOf[js.Any])
    
    @JSImport("@babel/traverse", "cache.scope")
    @js.native
    def scope: WeakMap[Node, Scope] = js.native
    inline def scope_=(x: WeakMap[Node, Scope]): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("scope")(x.asInstanceOf[js.Any])
  }
  
  object visitors {
    
    @JSImport("@babel/traverse", "visitors")
    @js.native
    val ^ : js.Any = js.native
    
    /**
      * `explode()` will take a `Visitor` object with all of the various shorthands
      * that we support, and validates & normalizes it into a common format, ready
      * to be used in traversal.
      *
      * The various shorthands are:
      * - `Identifier() { ... }` -> `Identifier: { enter() { ... } }`
      * - `"Identifier|NumericLiteral": { ... }` -> `Identifier: { ... }, NumericLiteral: { ... }`
      * - Aliases in `@babel/types`: e.g. `Property: { ... }` -> `ObjectProperty: { ... }, ClassProperty: { ... }`
      *
      * Other normalizations are:
      * - Visitors of virtual types are wrapped, so that they are only visited when their dynamic check passes
      * - `enter` and `exit` functions are wrapped in arrays, to ease merging of visitors
      */
    inline def explode[S](visitor: Visitor[S]): /* import warning: importer.ImportType#apply Failed type conversion: {[ Type in std.Exclude<@babel/types.@babel/types.Node, / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify t.DeprecatedAliases * / any>['type'] ]:? @babel/traverse.@babel/traverse.VisitNodeObject<S, std.Extract<@babel/types.@babel/types.Node, {  type :Type}>>} */ js.Any = ^.asInstanceOf[js.Dynamic].applyDynamic("explode")(visitor.asInstanceOf[js.Any]).asInstanceOf[/* import warning: importer.ImportType#apply Failed type conversion: {[ Type in std.Exclude<@babel/types.@babel/types.Node, / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify t.DeprecatedAliases * / any>['type'] ]:? @babel/traverse.@babel/traverse.VisitNodeObject<S, std.Extract<@babel/types.@babel/types.Node, {  type :Type}>>} */ js.Any]
    
    inline def merge(visitors: js.Array[Visitor[Any]]): Visitor[Any] = ^.asInstanceOf[js.Dynamic].applyDynamic("merge")(visitors.asInstanceOf[js.Any]).asInstanceOf[Visitor[Any]]
    inline def merge(visitors: js.Array[Visitor[Any]], states: js.Array[Any]): Visitor[Any] = (^.asInstanceOf[js.Dynamic].applyDynamic("merge")(visitors.asInstanceOf[js.Any], states.asInstanceOf[js.Any])).asInstanceOf[Visitor[Any]]
    inline def merge(
      visitors: js.Array[Visitor[Any]],
      states: js.Array[Any],
      wrapper: js.Function3[
          /* stateKey */ Any, 
          /* keyof @babel/traverse.@babel/traverse.Visitor<unknown> */ /* visitorKey */ /* import warning: LimitUnionLength.leaveTypeRef Was union type with length 316, starting with typings.babelTraverse.babelTraverseStrings.enter, typings.babelTraverse.babelTraverseStrings.exit, typings.babelTraverse.babelTraverseStrings.ClassExpression */ Any, 
          /* func */ VisitNodeFunction[Any, Node], 
          (VisitNodeFunction[Any, Node]) | Null
        ]
    ): Visitor[Any] = (^.asInstanceOf[js.Dynamic].applyDynamic("merge")(visitors.asInstanceOf[js.Any], states.asInstanceOf[js.Any], wrapper.asInstanceOf[js.Any])).asInstanceOf[Visitor[Any]]
    inline def merge(
      visitors: js.Array[Visitor[Any]],
      states: Unit,
      wrapper: js.Function3[
          /* stateKey */ Any, 
          /* keyof @babel/traverse.@babel/traverse.Visitor<unknown> */ /* visitorKey */ /* import warning: LimitUnionLength.leaveTypeRef Was union type with length 316, starting with typings.babelTraverse.babelTraverseStrings.enter, typings.babelTraverse.babelTraverseStrings.exit, typings.babelTraverse.babelTraverseStrings.ClassExpression */ Any, 
          /* func */ VisitNodeFunction[Any, Node], 
          (VisitNodeFunction[Any, Node]) | Null
        ]
    ): Visitor[Any] = (^.asInstanceOf[js.Dynamic].applyDynamic("merge")(visitors.asInstanceOf[js.Any], states.asInstanceOf[js.Any], wrapper.asInstanceOf[js.Any])).asInstanceOf[Visitor[Any]]
    
    inline def merge_State[State](visitors: js.Array[Visitor[State]]): Visitor[State] = ^.asInstanceOf[js.Dynamic].applyDynamic("merge")(visitors.asInstanceOf[js.Any]).asInstanceOf[Visitor[State]]
    
    inline def verify(visitor: Visitor[Any]): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("verify")(visitor.asInstanceOf[js.Any]).asInstanceOf[Unit]
  }
  
  /* Rewritten from type alias, can be one of: 
    - typings.babelTraverse.babelTraverseStrings.var_
    - typings.babelTraverse.babelTraverseStrings.let
    - typings.babelTraverse.babelTraverseStrings.const
    - typings.babelTraverse.babelTraverseStrings.module
    - typings.babelTraverse.babelTraverseStrings.hoisted
    - typings.babelTraverse.babelTraverseStrings.param
    - typings.babelTraverse.babelTraverseStrings.local
    - typings.babelTraverse.babelTraverseStrings.unknown
  */
  trait BindingKind extends StObject
  object BindingKind {
    
    inline def const: typings.babelTraverse.babelTraverseStrings.const = "const".asInstanceOf[typings.babelTraverse.babelTraverseStrings.const]
    
    inline def hoisted: typings.babelTraverse.babelTraverseStrings.hoisted = "hoisted".asInstanceOf[typings.babelTraverse.babelTraverseStrings.hoisted]
    
    inline def let: typings.babelTraverse.babelTraverseStrings.let = "let".asInstanceOf[typings.babelTraverse.babelTraverseStrings.let]
    
    inline def local: typings.babelTraverse.babelTraverseStrings.local = "local".asInstanceOf[typings.babelTraverse.babelTraverseStrings.local]
    
    inline def module: typings.babelTraverse.babelTraverseStrings.module = "module".asInstanceOf[typings.babelTraverse.babelTraverseStrings.module]
    
    inline def param: typings.babelTraverse.babelTraverseStrings.param = "param".asInstanceOf[typings.babelTraverse.babelTraverseStrings.param]
    
    inline def unknown: typings.babelTraverse.babelTraverseStrings.unknown = "unknown".asInstanceOf[typings.babelTraverse.babelTraverseStrings.unknown]
    
    inline def `var`: var_ = "var".asInstanceOf[var_]
  }
  
  trait HubInterface extends StObject {
    
    def addHelper(name: String): Any
    
    def buildError(node: Node, msg: String, Error: ErrorConstructor): js.Error
    
    def getCode(): js.UndefOr[String]
    
    def getScope(): js.UndefOr[Scope]
  }
  object HubInterface {
    
    inline def apply(
      addHelper: String => Any,
      buildError: (Node, String, ErrorConstructor) => js.Error,
      getCode: () => js.UndefOr[String],
      getScope: () => js.UndefOr[Scope]
    ): HubInterface = {
      val __obj = js.Dynamic.literal(addHelper = js.Any.fromFunction1(addHelper), buildError = js.Any.fromFunction3(buildError), getCode = js.Any.fromFunction0(getCode), getScope = js.Any.fromFunction0(getScope))
      __obj.asInstanceOf[HubInterface]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: HubInterface] (val x: Self) extends AnyVal {
      
      inline def setAddHelper(value: String => Any): Self = StObject.set(x, "addHelper", js.Any.fromFunction1(value))
      
      inline def setBuildError(value: (Node, String, ErrorConstructor) => js.Error): Self = StObject.set(x, "buildError", js.Any.fromFunction3(value))
      
      inline def setGetCode(value: () => js.UndefOr[String]): Self = StObject.set(x, "getCode", js.Any.fromFunction0(value))
      
      inline def setGetScope(value: () => js.UndefOr[Scope]): Self = StObject.set(x, "getScope", js.Any.fromFunction0(value))
    }
  }
  
  type NodeKeyOfArrays[T /* <: Node */] = /* import warning: importer.ImportType#apply Failed type conversion: {[ P in keyof T ]: -? T[P] extends std.Array<@babel/types.@babel/types.Node | null | undefined>? P : never}[keyof T] */ js.Any
  
  type NodeKeyOfNodes[T /* <: Node */] = /* import warning: importer.ImportType#apply Failed type conversion: {[ P in keyof T ]: -? T[P] extends @babel/types.@babel/types.Node | null | undefined? P : never}[keyof T] */ js.Any
  
  /** NOTE: Conditional type definitions are impossible to translate to Scala.
    * See https://www.typescriptlang.org/docs/handbook/2/conditional-types.html for an intro.
    * You'll have to cast your way around this structure, unfortunately.
    * TS definition: {{{
    N[K] extends std.Array<infer P> ? P extends @babel/types.@babel/types.Node ? P : never : never
    }}}
    */
  @js.native
  trait NodeListType[N, K /* <: /* keyof N */ String */] extends StObject
  
  type NodePathResult[T] = /* import warning: importer.ImportType#apply Failed type conversion: std.Extract<T, @babel/types.@babel/types.Node | null | undefined> extends never ? never : @babel/traverse.@babel/traverse.NodePath<std.Extract<T, @babel/types.@babel/types.Node | null | undefined>> */ js.Any
  
  /** NOTE: Conditional type definitions are impossible to translate to Scala.
    * See https://www.typescriptlang.org/docs/handbook/2/conditional-types.html for an intro.
    * This RHS of the type alias is guess work. You should cast if it's not correct in your case.
    * TS definition: {{{
    T extends std.Array<@babel/types.@babel/types.Node> ? {-readonly [ K in keyof T ]: @babel/traverse.@babel/traverse.NodePath<std.Extract<T[K], @babel/types.@babel/types.Node>>} : T extends @babel/types.@babel/types.Node ? [@babel/traverse.@babel/traverse.NodePath<T>] : never
    }}}
    */
  type NodePaths[T /* <: Node | js.Array[Node] */] = js.Array[NodePath[T]]
  
  /* Inlined @babel/traverse.@babel/traverse.Node['type'] | keyof @babel/types.@babel/types.Aliases */
  /* Rewritten from type alias, can be one of: 
    - typings.babelTraverse.babelTraverseStrings.ClassExpression
    - typings.babelTraverse.babelTraverseStrings.TSArrayType
    - typings.babelTraverse.babelTraverseStrings.Loop
    - typings.babelTraverse.babelTraverseStrings.BreakStatement
    - typings.babelTraverse.babelTraverseStrings.StringTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.ExportDefaultSpecifier
    - typings.babelTraverse.babelTraverseStrings.EnumStringMember
    - typings.babelTraverse.babelTraverseStrings.ReturnStatement
    - typings.babelTraverse.babelTraverseStrings.TSSatisfiesExpression
    - typings.babelTraverse.babelTraverseStrings.TSInterfaceBody
    - typings.babelTraverse.babelTraverseStrings.TSAsExpression
    - typings.babelTraverse.babelTraverseStrings.InterfaceTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.BlockParent
    - typings.babelTraverse.babelTraverseStrings.TSAnyKeyword
    - typings.babelTraverse.babelTraverseStrings.TypeCastExpression
    - typings.babelTraverse.babelTraverseStrings.YieldExpression
    - typings.babelTraverse.babelTraverseStrings.ObjectTypeCallProperty
    - typings.babelTraverse.babelTraverseStrings.TupleTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.ImportOrExportDeclaration
    - typings.babelTraverse.babelTraverseStrings.Standardized
    - typings.babelTraverse.babelTraverseStrings.TypeParameterDeclaration
    - typings.babelTraverse.babelTraverseStrings.TSModuleDeclaration
    - typings.babelTraverse.babelTraverseStrings.ForInStatement
    - typings.babelTraverse.babelTraverseStrings.EnumMember
    - typings.babelTraverse.babelTraverseStrings.TSConditionalType
    - typings.babelTraverse.babelTraverseStrings.ImportDefaultSpecifier
    - typings.babelTraverse.babelTraverseStrings.TSLiteralType
    - typings.babelTraverse.babelTraverseStrings.TSTypeParameterDeclaration
    - typings.babelTraverse.babelTraverseStrings.TypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.SpreadElement
    - typings.babelTraverse.babelTraverseStrings.TryStatement
    - typings.babelTraverse.babelTraverseStrings.BlockStatement
    - typings.babelTraverse.babelTraverseStrings.Pattern
    - typings.babelTraverse.babelTraverseStrings.RestElement
    - typings.babelTraverse.babelTraverseStrings.While
    - typings.babelTraverse.babelTraverseStrings.OptionalMemberExpression
    - typings.babelTraverse.babelTraverseStrings.JSX
    - typings.babelTraverse.babelTraverseStrings.File
    - typings.babelTraverse.babelTraverseStrings.TSIndexedAccessType
    - typings.babelTraverse.babelTraverseStrings.TSQualifiedName
    - typings.babelTraverse.babelTraverseStrings.UserWhitespacable
    - typings.babelTraverse.babelTraverseStrings.PipelinePrimaryTopicReference
    - typings.babelTraverse.babelTraverseStrings.JSXExpressionContainer
    - typings.babelTraverse.babelTraverseStrings.TSNullKeyword
    - typings.babelTraverse.babelTraverseStrings.Noop
    - typings.babelTraverse.babelTraverseStrings.DeclareModule
    - typings.babelTraverse.babelTraverseStrings.FlowType
    - typings.babelTraverse.babelTraverseStrings.LabeledStatement
    - typings.babelTraverse.babelTraverseStrings.ExportAllDeclaration
    - typings.babelTraverse.babelTraverseStrings.RegExpLiteral
    - typings.babelTraverse.babelTraverseStrings.WhileStatement
    - typings.babelTraverse.babelTraverseStrings.ContinueStatement
    - typings.babelTraverse.babelTraverseStrings.Accessor
    - typings.babelTraverse.babelTraverseStrings.FunctionTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.TSFunctionType
    - typings.babelTraverse.babelTraverseStrings.NullLiteralTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.SwitchStatement
    - typings.babelTraverse.babelTraverseStrings.OptionalCallExpression
    - typings.babelTraverse.babelTraverseStrings.ExportNamedDeclaration
    - typings.babelTraverse.babelTraverseStrings.CallExpression
    - typings.babelTraverse.babelTraverseStrings.InterfaceDeclaration
    - typings.babelTraverse.babelTraverseStrings.JSXSpreadAttribute
    - typings.babelTraverse.babelTraverseStrings.SymbolTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.ThisTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.TSTypeOperator
    - typings.babelTraverse.babelTraverseStrings.TSBigIntKeyword
    - typings.babelTraverse.babelTraverseStrings.SwitchCase
    - typings.babelTraverse.babelTraverseStrings.TSUnknownKeyword
    - typings.babelTraverse.babelTraverseStrings.ArrayExpression
    - typings.babelTraverse.babelTraverseStrings.MixedTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.ExportDeclaration
    - typings.babelTraverse.babelTraverseStrings.TSVoidKeyword
    - typings.babelTraverse.babelTraverseStrings.NewExpression
    - typings.babelTraverse.babelTraverseStrings.MemberExpression
    - typings.babelTraverse.babelTraverseStrings.RecordExpression
    - typings.babelTraverse.babelTraverseStrings.Flow
    - typings.babelTraverse.babelTraverseStrings.ExpressionStatement
    - typings.babelTraverse.babelTraverseStrings.Directive
    - typings.babelTraverse.babelTraverseStrings.AssignmentPattern
    - typings.babelTraverse.babelTraverseStrings.AnyTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.TSIntrinsicKeyword
    - typings.babelTraverse.babelTraverseStrings.EnumDeclaration
    - typings.babelTraverse.babelTraverseStrings.VariableDeclaration
    - typings.babelTraverse.babelTraverseStrings.IndexedAccessType
    - typings.babelTraverse.babelTraverseStrings.LogicalExpression
    - typings.babelTraverse.babelTraverseStrings.OpaqueType
    - typings.babelTraverse.babelTraverseStrings.TaggedTemplateExpression
    - typings.babelTraverse.babelTraverseStrings.JSXSpreadChild
    - typings.babelTraverse.babelTraverseStrings.JSXOpeningElement
    - typings.babelTraverse.babelTraverseStrings.QualifiedTypeIdentifier
    - typings.babelTraverse.babelTraverseStrings.TSTypeParameterInstantiation
    - typings.babelTraverse.babelTraverseStrings.TSDeclareMethod
    - typings.babelTraverse.babelTraverseStrings.TypeScript
    - typings.babelTraverse.babelTraverseStrings.TemplateLiteral
    - typings.babelTraverse.babelTraverseStrings.BindExpression
    - typings.babelTraverse.babelTraverseStrings.TSType
    - typings.babelTraverse.babelTraverseStrings.ExportDefaultDeclaration
    - typings.babelTraverse.babelTraverseStrings.ObjectTypeSpreadProperty
    - typings.babelTraverse.babelTraverseStrings.Decorator
    - typings.babelTraverse.babelTraverseStrings.MetaProperty
    - typings.babelTraverse.babelTraverseStrings.ObjectTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.IfStatement
    - typings.babelTraverse.babelTraverseStrings.ArrayTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.JSXIdentifier
    - typings.babelTraverse.babelTraverseStrings.InterpreterDirective
    - typings.babelTraverse.babelTraverseStrings.BinaryExpression
    - typings.babelTraverse.babelTraverseStrings.ForXStatement
    - typings.babelTraverse.babelTraverseStrings.TSNamespaceExportDeclaration
    - typings.babelTraverse.babelTraverseStrings.TSEnumDeclaration
    - typings.babelTraverse.babelTraverseStrings.TSTypeAliasDeclaration
    - typings.babelTraverse.babelTraverseStrings.TSUnionType
    - typings.babelTraverse.babelTraverseStrings.TSTypeParameter
    - typings.babelTraverse.babelTraverseStrings.PrivateName
    - typings.babelTraverse.babelTraverseStrings.WithStatement
    - typings.babelTraverse.babelTraverseStrings.TSNonNullExpression
    - typings.babelTraverse.babelTraverseStrings.NullableTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.Identifier
    - typings.babelTraverse.babelTraverseStrings.UpdateExpression
    - typings.babelTraverse.babelTraverseStrings.Terminatorless
    - typings.babelTraverse.babelTraverseStrings.TSStringKeyword
    - typings.babelTraverse.babelTraverseStrings.TopicReference
    - typings.babelTraverse.babelTraverseStrings.JSXAttribute
    - typings.babelTraverse.babelTraverseStrings.TSInferType
    - typings.babelTraverse.babelTraverseStrings.DeclareFunction
    - typings.babelTraverse.babelTraverseStrings.PatternLike
    - typings.babelTraverse.babelTraverseStrings.PipelineTopicExpression
    - typings.babelTraverse.babelTraverseStrings.VoidTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.Scopable
    - typings.babelTraverse.babelTraverseStrings.EmptyStatement
    - typings.babelTraverse.babelTraverseStrings.ClassDeclaration
    - typings.babelTraverse.babelTraverseStrings.DeclareExportAllDeclaration
    - typings.babelTraverse.babelTraverseStrings.StaticBlock
    - typings.babelTraverse.babelTraverseStrings.TSTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.AwaitExpression
    - typings.babelTraverse.babelTraverseStrings.ImportSpecifier
    - typings.babelTraverse.babelTraverseStrings.ArrayPattern
    - typings.babelTraverse.babelTraverseStrings.ExportSpecifier
    - typings.babelTraverse.babelTraverseStrings.EnumBooleanMember
    - typings.babelTraverse.babelTraverseStrings.TSPropertySignature
    - typings.babelTraverse.babelTraverseStrings.ExistsTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.TSTypeQuery
    - typings.babelTraverse.babelTraverseStrings.TSExternalModuleReference
    - typings.babelTraverse.babelTraverseStrings.TSConstructSignatureDeclaration
    - typings.babelTraverse.babelTraverseStrings.FlowPredicate
    - typings.babelTraverse.babelTraverseStrings.ImportAttribute
    - typings.babelTraverse.babelTraverseStrings.Method
    - typings.babelTraverse.babelTraverseStrings.ObjectExpression
    - typings.babelTraverse.babelTraverseStrings.JSXEmptyExpression
    - typings.babelTraverse.babelTraverseStrings.ObjectMethod
    - typings.babelTraverse.babelTraverseStrings.ModuleDeclaration
    - typings.babelTraverse.babelTraverseStrings.Pureish
    - typings.babelTraverse.babelTraverseStrings.TSTypeElement
    - typings.babelTraverse.babelTraverseStrings.TSSymbolKeyword
    - typings.babelTraverse.babelTraverseStrings.TSMappedType
    - typings.babelTraverse.babelTraverseStrings.JSXClosingElement
    - typings.babelTraverse.babelTraverseStrings.VariableDeclarator
    - typings.babelTraverse.babelTraverseStrings.TSEntityName
    - typings.babelTraverse.babelTraverseStrings.ObjectMember
    - typings.babelTraverse.babelTraverseStrings.StringLiteral
    - typings.babelTraverse.babelTraverseStrings.BooleanLiteral
    - typings.babelTraverse.babelTraverseStrings.TSEnumMember
    - typings.babelTraverse.babelTraverseStrings.InferredPredicate
    - typings.babelTraverse.babelTraverseStrings.AssignmentExpression
    - typings.babelTraverse.babelTraverseStrings.FunctionDeclaration
    - typings.babelTraverse.babelTraverseStrings.EnumBooleanBody
    - typings.babelTraverse.babelTraverseStrings.FlowBaseAnnotation
    - typings.babelTraverse.babelTraverseStrings.For
    - typings.babelTraverse.babelTraverseStrings.ModuleSpecifier
    - typings.babelTraverse.babelTraverseStrings.DebuggerStatement
    - typings.babelTraverse.babelTraverseStrings.InterfaceExtends
    - typings.babelTraverse.babelTraverseStrings.ThrowStatement
    - typings.babelTraverse.babelTraverseStrings.V8IntrinsicIdentifier
    - typings.babelTraverse.babelTraverseStrings.EmptyTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.Property
    - typings.babelTraverse.babelTraverseStrings.DirectiveLiteral
    - typings.babelTraverse.babelTraverseStrings.ObjectProperty
    - typings.babelTraverse.babelTraverseStrings.TSExportAssignment
    - typings.babelTraverse.babelTraverseStrings.OptionalIndexedAccessType
    - typings.babelTraverse.babelTraverseStrings.ArrowFunctionExpression
    - typings.babelTraverse.babelTraverseStrings.ModuleExpression
    - typings.babelTraverse.babelTraverseStrings.TSExpressionWithTypeArguments
    - typings.babelTraverse.babelTraverseStrings.TypeofTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.TSCallSignatureDeclaration
    - typings.babelTraverse.babelTraverseStrings.JSXFragment
    - typings.babelTraverse.babelTraverseStrings.Literal
    - typings.babelTraverse.babelTraverseStrings.Variance
    - typings.babelTraverse.babelTraverseStrings.Declaration
    - typings.babelTraverse.babelTraverseStrings.LVal
    - typings.babelTraverse.babelTraverseStrings.JSXNamespacedName
    - typings.babelTraverse.babelTraverseStrings.Program
    - typings.babelTraverse.babelTraverseStrings.TSTypeLiteral
    - typings.babelTraverse.babelTraverseStrings.NumberLiteralTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.DeclareExportDeclaration
    - typings.babelTraverse.babelTraverseStrings.ObjectTypeProperty
    - typings.babelTraverse.babelTraverseStrings.TSImportEqualsDeclaration
    - typings.babelTraverse.babelTraverseStrings.DeclareInterface
    - typings.babelTraverse.babelTraverseStrings.PipelineBareFunction
    - typings.babelTraverse.babelTraverseStrings.EnumStringBody
    - typings.babelTraverse.babelTraverseStrings.NumberTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.Super
    - typings.babelTraverse.babelTraverseStrings.ForOfStatement
    - typings.babelTraverse.babelTraverseStrings.DeclareTypeAlias
    - typings.babelTraverse.babelTraverseStrings.Placeholder
    - typings.babelTraverse.babelTraverseStrings.TSUndefinedKeyword
    - typings.babelTraverse.babelTraverseStrings.ConditionalExpression
    - typings.babelTraverse.babelTraverseStrings.Class
    - typings.babelTraverse.babelTraverseStrings.SequenceExpression
    - typings.babelTraverse.babelTraverseStrings.Import
    - typings.babelTraverse.babelTraverseStrings.TypeParameter
    - typings.babelTraverse.babelTraverseStrings.JSXElement
    - typings.babelTraverse.babelTraverseStrings.ObjectTypeIndexer
    - typings.babelTraverse.babelTraverseStrings.Function
    - typings.babelTraverse.babelTraverseStrings.CatchClause
    - typings.babelTraverse.babelTraverseStrings.Expression
    - typings.babelTraverse.babelTraverseStrings.UnaryExpression
    - typings.babelTraverse.babelTraverseStrings.BooleanLiteralTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.ExportNamespaceSpecifier
    - typings.babelTraverse.babelTraverseStrings.Miscellaneous
    - typings.babelTraverse.babelTraverseStrings.TypeAlias
    - typings.babelTraverse.babelTraverseStrings.TSNumberKeyword
    - typings.babelTraverse.babelTraverseStrings.Conditional
    - typings.babelTraverse.babelTraverseStrings.DeclareVariable
    - typings.babelTraverse.babelTraverseStrings.BooleanTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.BigIntLiteral
    - typings.babelTraverse.babelTraverseStrings.ExpressionWrapper
    - typings.babelTraverse.babelTraverseStrings.TSOptionalType
    - typings.babelTraverse.babelTraverseStrings.TSTypePredicate
    - typings.babelTraverse.babelTraverseStrings.TSInterfaceDeclaration
    - typings.babelTraverse.babelTraverseStrings.DeclaredPredicate
    - typings.babelTraverse.babelTraverseStrings.ClassMethod
    - typings.babelTraverse.babelTraverseStrings.ForStatement
    - typings.babelTraverse.babelTraverseStrings.Statement
    - typings.babelTraverse.babelTraverseStrings.UnaryLike
    - typings.babelTraverse.babelTraverseStrings.EnumDefaultedMember
    - typings.babelTraverse.babelTraverseStrings.ClassProperty
    - typings.babelTraverse.babelTraverseStrings.FunctionExpression
    - typings.babelTraverse.babelTraverseStrings.FunctionParent
    - typings.babelTraverse.babelTraverseStrings.TemplateElement
    - typings.babelTraverse.babelTraverseStrings.JSXText
    - typings.babelTraverse.babelTraverseStrings.TSParameterProperty
    - typings.babelTraverse.babelTraverseStrings.JSXMemberExpression
    - typings.babelTraverse.babelTraverseStrings.EnumSymbolBody
    - typings.babelTraverse.babelTraverseStrings.TSTupleType
    - typings.babelTraverse.babelTraverseStrings.DoWhileStatement
    - typings.babelTraverse.babelTraverseStrings.TSBaseType
    - typings.babelTraverse.babelTraverseStrings.TSDeclareFunction
    - typings.babelTraverse.babelTraverseStrings.ImportNamespaceSpecifier
    - typings.babelTraverse.babelTraverseStrings.TSMethodSignature
    - typings.babelTraverse.babelTraverseStrings.ParenthesizedExpression
    - typings.babelTraverse.babelTraverseStrings.EnumNumberMember
    - typings.babelTraverse.babelTraverseStrings.Private
    - typings.babelTraverse.babelTraverseStrings.DecimalLiteral
    - typings.babelTraverse.babelTraverseStrings.TSIndexSignature
    - typings.babelTraverse.babelTraverseStrings.Block
    - typings.babelTraverse.babelTraverseStrings.TSThisType
    - typings.babelTraverse.babelTraverseStrings.TupleExpression
    - typings.babelTraverse.babelTraverseStrings.TSRestType
    - typings.babelTraverse.babelTraverseStrings.JSXClosingFragment
    - typings.babelTraverse.babelTraverseStrings.ClassImplements
    - typings.babelTraverse.babelTraverseStrings.TSConstructorType
    - typings.babelTraverse.babelTraverseStrings.ClassAccessorProperty
    - typings.babelTraverse.babelTraverseStrings.IntersectionTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.TSInstantiationExpression
    - typings.babelTraverse.babelTraverseStrings.NumericLiteral
    - typings.babelTraverse.babelTraverseStrings.TSObjectKeyword
    - typings.babelTraverse.babelTraverseStrings.DoExpression
    - typings.babelTraverse.babelTraverseStrings.JSXOpeningFragment
    - typings.babelTraverse.babelTraverseStrings.UnionTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.TSNamedTupleMember
    - typings.babelTraverse.babelTraverseStrings.DeclareModuleExports
    - typings.babelTraverse.babelTraverseStrings.ObjectPattern
    - typings.babelTraverse.babelTraverseStrings.TSBooleanKeyword
    - typings.babelTraverse.babelTraverseStrings.StringLiteralTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.TSParenthesizedType
    - typings.babelTraverse.babelTraverseStrings.FunctionTypeParam
    - typings.babelTraverse.babelTraverseStrings.DeclareOpaqueType
    - typings.babelTraverse.babelTraverseStrings.ClassPrivateProperty
    - typings.babelTraverse.babelTraverseStrings.TSModuleBlock
    - typings.babelTraverse.babelTraverseStrings.ClassBody
    - typings.babelTraverse.babelTraverseStrings.ObjectTypeInternalSlot
    - typings.babelTraverse.babelTraverseStrings.ThisExpression
    - typings.babelTraverse.babelTraverseStrings.ClassPrivateMethod
    - typings.babelTraverse.babelTraverseStrings.TSTypeAssertion
    - typings.babelTraverse.babelTraverseStrings.Binary
    - typings.babelTraverse.babelTraverseStrings.TSNeverKeyword
    - typings.babelTraverse.babelTraverseStrings.TSIntersectionType
    - typings.babelTraverse.babelTraverseStrings.ArgumentPlaceholder
    - typings.babelTraverse.babelTraverseStrings.EnumNumberBody
    - typings.babelTraverse.babelTraverseStrings.TSImportType
    - typings.babelTraverse.babelTraverseStrings.FlowDeclaration
    - typings.babelTraverse.babelTraverseStrings.CompletionStatement
    - typings.babelTraverse.babelTraverseStrings.DeclareClass
    - typings.babelTraverse.babelTraverseStrings.ImportDeclaration
    - typings.babelTraverse.babelTraverseStrings.Immutable
    - typings.babelTraverse.babelTraverseStrings.GenericTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.EnumBody
    - typings.babelTraverse.babelTraverseStrings.NullLiteral
    - typings.babelTraverse.babelTraverseStrings.TypeParameterInstantiation
    - typings.babelTraverse.babelTraverseStrings.TSTypeReference
  */
  trait NodeType extends StObject
  object NodeType {
    
    inline def Accessor: typings.babelTraverse.babelTraverseStrings.Accessor = "Accessor".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Accessor]
    
    inline def AnyTypeAnnotation: typings.babelTraverse.babelTraverseStrings.AnyTypeAnnotation = "AnyTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.AnyTypeAnnotation]
    
    inline def ArgumentPlaceholder: typings.babelTraverse.babelTraverseStrings.ArgumentPlaceholder = "ArgumentPlaceholder".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ArgumentPlaceholder]
    
    inline def ArrayExpression: typings.babelTraverse.babelTraverseStrings.ArrayExpression = "ArrayExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ArrayExpression]
    
    inline def ArrayPattern: typings.babelTraverse.babelTraverseStrings.ArrayPattern = "ArrayPattern".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ArrayPattern]
    
    inline def ArrayTypeAnnotation: typings.babelTraverse.babelTraverseStrings.ArrayTypeAnnotation = "ArrayTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ArrayTypeAnnotation]
    
    inline def ArrowFunctionExpression: typings.babelTraverse.babelTraverseStrings.ArrowFunctionExpression = "ArrowFunctionExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ArrowFunctionExpression]
    
    inline def AssignmentExpression: typings.babelTraverse.babelTraverseStrings.AssignmentExpression = "AssignmentExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.AssignmentExpression]
    
    inline def AssignmentPattern: typings.babelTraverse.babelTraverseStrings.AssignmentPattern = "AssignmentPattern".asInstanceOf[typings.babelTraverse.babelTraverseStrings.AssignmentPattern]
    
    inline def AwaitExpression: typings.babelTraverse.babelTraverseStrings.AwaitExpression = "AwaitExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.AwaitExpression]
    
    inline def BigIntLiteral: typings.babelTraverse.babelTraverseStrings.BigIntLiteral = "BigIntLiteral".asInstanceOf[typings.babelTraverse.babelTraverseStrings.BigIntLiteral]
    
    inline def Binary: typings.babelTraverse.babelTraverseStrings.Binary = "Binary".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Binary]
    
    inline def BinaryExpression: typings.babelTraverse.babelTraverseStrings.BinaryExpression = "BinaryExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.BinaryExpression]
    
    inline def BindExpression: typings.babelTraverse.babelTraverseStrings.BindExpression = "BindExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.BindExpression]
    
    inline def Block: typings.babelTraverse.babelTraverseStrings.Block = "Block".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Block]
    
    inline def BlockParent: typings.babelTraverse.babelTraverseStrings.BlockParent = "BlockParent".asInstanceOf[typings.babelTraverse.babelTraverseStrings.BlockParent]
    
    inline def BlockStatement: typings.babelTraverse.babelTraverseStrings.BlockStatement = "BlockStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.BlockStatement]
    
    inline def BooleanLiteral: typings.babelTraverse.babelTraverseStrings.BooleanLiteral = "BooleanLiteral".asInstanceOf[typings.babelTraverse.babelTraverseStrings.BooleanLiteral]
    
    inline def BooleanLiteralTypeAnnotation: typings.babelTraverse.babelTraverseStrings.BooleanLiteralTypeAnnotation = "BooleanLiteralTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.BooleanLiteralTypeAnnotation]
    
    inline def BooleanTypeAnnotation: typings.babelTraverse.babelTraverseStrings.BooleanTypeAnnotation = "BooleanTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.BooleanTypeAnnotation]
    
    inline def BreakStatement: typings.babelTraverse.babelTraverseStrings.BreakStatement = "BreakStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.BreakStatement]
    
    inline def CallExpression: typings.babelTraverse.babelTraverseStrings.CallExpression = "CallExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.CallExpression]
    
    inline def CatchClause: typings.babelTraverse.babelTraverseStrings.CatchClause = "CatchClause".asInstanceOf[typings.babelTraverse.babelTraverseStrings.CatchClause]
    
    inline def Class: typings.babelTraverse.babelTraverseStrings.Class = "Class".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Class]
    
    inline def ClassAccessorProperty: typings.babelTraverse.babelTraverseStrings.ClassAccessorProperty = "ClassAccessorProperty".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ClassAccessorProperty]
    
    inline def ClassBody: typings.babelTraverse.babelTraverseStrings.ClassBody = "ClassBody".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ClassBody]
    
    inline def ClassDeclaration: typings.babelTraverse.babelTraverseStrings.ClassDeclaration = "ClassDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ClassDeclaration]
    
    inline def ClassExpression: typings.babelTraverse.babelTraverseStrings.ClassExpression = "ClassExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ClassExpression]
    
    inline def ClassImplements: typings.babelTraverse.babelTraverseStrings.ClassImplements = "ClassImplements".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ClassImplements]
    
    inline def ClassMethod: typings.babelTraverse.babelTraverseStrings.ClassMethod = "ClassMethod".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ClassMethod]
    
    inline def ClassPrivateMethod: typings.babelTraverse.babelTraverseStrings.ClassPrivateMethod = "ClassPrivateMethod".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ClassPrivateMethod]
    
    inline def ClassPrivateProperty: typings.babelTraverse.babelTraverseStrings.ClassPrivateProperty = "ClassPrivateProperty".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ClassPrivateProperty]
    
    inline def ClassProperty: typings.babelTraverse.babelTraverseStrings.ClassProperty = "ClassProperty".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ClassProperty]
    
    inline def CompletionStatement: typings.babelTraverse.babelTraverseStrings.CompletionStatement = "CompletionStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.CompletionStatement]
    
    inline def Conditional: typings.babelTraverse.babelTraverseStrings.Conditional = "Conditional".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Conditional]
    
    inline def ConditionalExpression: typings.babelTraverse.babelTraverseStrings.ConditionalExpression = "ConditionalExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ConditionalExpression]
    
    inline def ContinueStatement: typings.babelTraverse.babelTraverseStrings.ContinueStatement = "ContinueStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ContinueStatement]
    
    inline def DebuggerStatement: typings.babelTraverse.babelTraverseStrings.DebuggerStatement = "DebuggerStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DebuggerStatement]
    
    inline def DecimalLiteral: typings.babelTraverse.babelTraverseStrings.DecimalLiteral = "DecimalLiteral".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DecimalLiteral]
    
    inline def Declaration: typings.babelTraverse.babelTraverseStrings.Declaration = "Declaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Declaration]
    
    inline def DeclareClass: typings.babelTraverse.babelTraverseStrings.DeclareClass = "DeclareClass".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DeclareClass]
    
    inline def DeclareExportAllDeclaration: typings.babelTraverse.babelTraverseStrings.DeclareExportAllDeclaration = "DeclareExportAllDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DeclareExportAllDeclaration]
    
    inline def DeclareExportDeclaration: typings.babelTraverse.babelTraverseStrings.DeclareExportDeclaration = "DeclareExportDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DeclareExportDeclaration]
    
    inline def DeclareFunction: typings.babelTraverse.babelTraverseStrings.DeclareFunction = "DeclareFunction".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DeclareFunction]
    
    inline def DeclareInterface: typings.babelTraverse.babelTraverseStrings.DeclareInterface = "DeclareInterface".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DeclareInterface]
    
    inline def DeclareModule: typings.babelTraverse.babelTraverseStrings.DeclareModule = "DeclareModule".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DeclareModule]
    
    inline def DeclareModuleExports: typings.babelTraverse.babelTraverseStrings.DeclareModuleExports = "DeclareModuleExports".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DeclareModuleExports]
    
    inline def DeclareOpaqueType: typings.babelTraverse.babelTraverseStrings.DeclareOpaqueType = "DeclareOpaqueType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DeclareOpaqueType]
    
    inline def DeclareTypeAlias: typings.babelTraverse.babelTraverseStrings.DeclareTypeAlias = "DeclareTypeAlias".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DeclareTypeAlias]
    
    inline def DeclareVariable: typings.babelTraverse.babelTraverseStrings.DeclareVariable = "DeclareVariable".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DeclareVariable]
    
    inline def DeclaredPredicate: typings.babelTraverse.babelTraverseStrings.DeclaredPredicate = "DeclaredPredicate".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DeclaredPredicate]
    
    inline def Decorator: typings.babelTraverse.babelTraverseStrings.Decorator = "Decorator".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Decorator]
    
    inline def Directive: typings.babelTraverse.babelTraverseStrings.Directive = "Directive".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Directive]
    
    inline def DirectiveLiteral: typings.babelTraverse.babelTraverseStrings.DirectiveLiteral = "DirectiveLiteral".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DirectiveLiteral]
    
    inline def DoExpression: typings.babelTraverse.babelTraverseStrings.DoExpression = "DoExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DoExpression]
    
    inline def DoWhileStatement: typings.babelTraverse.babelTraverseStrings.DoWhileStatement = "DoWhileStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DoWhileStatement]
    
    inline def EmptyStatement: typings.babelTraverse.babelTraverseStrings.EmptyStatement = "EmptyStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.EmptyStatement]
    
    inline def EmptyTypeAnnotation: typings.babelTraverse.babelTraverseStrings.EmptyTypeAnnotation = "EmptyTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.EmptyTypeAnnotation]
    
    inline def EnumBody: typings.babelTraverse.babelTraverseStrings.EnumBody = "EnumBody".asInstanceOf[typings.babelTraverse.babelTraverseStrings.EnumBody]
    
    inline def EnumBooleanBody: typings.babelTraverse.babelTraverseStrings.EnumBooleanBody = "EnumBooleanBody".asInstanceOf[typings.babelTraverse.babelTraverseStrings.EnumBooleanBody]
    
    inline def EnumBooleanMember: typings.babelTraverse.babelTraverseStrings.EnumBooleanMember = "EnumBooleanMember".asInstanceOf[typings.babelTraverse.babelTraverseStrings.EnumBooleanMember]
    
    inline def EnumDeclaration: typings.babelTraverse.babelTraverseStrings.EnumDeclaration = "EnumDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.EnumDeclaration]
    
    inline def EnumDefaultedMember: typings.babelTraverse.babelTraverseStrings.EnumDefaultedMember = "EnumDefaultedMember".asInstanceOf[typings.babelTraverse.babelTraverseStrings.EnumDefaultedMember]
    
    inline def EnumMember: typings.babelTraverse.babelTraverseStrings.EnumMember = "EnumMember".asInstanceOf[typings.babelTraverse.babelTraverseStrings.EnumMember]
    
    inline def EnumNumberBody: typings.babelTraverse.babelTraverseStrings.EnumNumberBody = "EnumNumberBody".asInstanceOf[typings.babelTraverse.babelTraverseStrings.EnumNumberBody]
    
    inline def EnumNumberMember: typings.babelTraverse.babelTraverseStrings.EnumNumberMember = "EnumNumberMember".asInstanceOf[typings.babelTraverse.babelTraverseStrings.EnumNumberMember]
    
    inline def EnumStringBody: typings.babelTraverse.babelTraverseStrings.EnumStringBody = "EnumStringBody".asInstanceOf[typings.babelTraverse.babelTraverseStrings.EnumStringBody]
    
    inline def EnumStringMember: typings.babelTraverse.babelTraverseStrings.EnumStringMember = "EnumStringMember".asInstanceOf[typings.babelTraverse.babelTraverseStrings.EnumStringMember]
    
    inline def EnumSymbolBody: typings.babelTraverse.babelTraverseStrings.EnumSymbolBody = "EnumSymbolBody".asInstanceOf[typings.babelTraverse.babelTraverseStrings.EnumSymbolBody]
    
    inline def ExistsTypeAnnotation: typings.babelTraverse.babelTraverseStrings.ExistsTypeAnnotation = "ExistsTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ExistsTypeAnnotation]
    
    inline def ExportAllDeclaration: typings.babelTraverse.babelTraverseStrings.ExportAllDeclaration = "ExportAllDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ExportAllDeclaration]
    
    inline def ExportDeclaration: typings.babelTraverse.babelTraverseStrings.ExportDeclaration = "ExportDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ExportDeclaration]
    
    inline def ExportDefaultDeclaration: typings.babelTraverse.babelTraverseStrings.ExportDefaultDeclaration = "ExportDefaultDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ExportDefaultDeclaration]
    
    inline def ExportDefaultSpecifier: typings.babelTraverse.babelTraverseStrings.ExportDefaultSpecifier = "ExportDefaultSpecifier".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ExportDefaultSpecifier]
    
    inline def ExportNamedDeclaration: typings.babelTraverse.babelTraverseStrings.ExportNamedDeclaration = "ExportNamedDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ExportNamedDeclaration]
    
    inline def ExportNamespaceSpecifier: typings.babelTraverse.babelTraverseStrings.ExportNamespaceSpecifier = "ExportNamespaceSpecifier".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ExportNamespaceSpecifier]
    
    inline def ExportSpecifier: typings.babelTraverse.babelTraverseStrings.ExportSpecifier = "ExportSpecifier".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ExportSpecifier]
    
    inline def Expression: typings.babelTraverse.babelTraverseStrings.Expression = "Expression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Expression]
    
    inline def ExpressionStatement: typings.babelTraverse.babelTraverseStrings.ExpressionStatement = "ExpressionStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ExpressionStatement]
    
    inline def ExpressionWrapper: typings.babelTraverse.babelTraverseStrings.ExpressionWrapper = "ExpressionWrapper".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ExpressionWrapper]
    
    inline def File: typings.babelTraverse.babelTraverseStrings.File = "File".asInstanceOf[typings.babelTraverse.babelTraverseStrings.File]
    
    inline def Flow: typings.babelTraverse.babelTraverseStrings.Flow = "Flow".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Flow]
    
    inline def FlowBaseAnnotation: typings.babelTraverse.babelTraverseStrings.FlowBaseAnnotation = "FlowBaseAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.FlowBaseAnnotation]
    
    inline def FlowDeclaration: typings.babelTraverse.babelTraverseStrings.FlowDeclaration = "FlowDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.FlowDeclaration]
    
    inline def FlowPredicate: typings.babelTraverse.babelTraverseStrings.FlowPredicate = "FlowPredicate".asInstanceOf[typings.babelTraverse.babelTraverseStrings.FlowPredicate]
    
    inline def FlowType: typings.babelTraverse.babelTraverseStrings.FlowType = "FlowType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.FlowType]
    
    inline def For: typings.babelTraverse.babelTraverseStrings.For = "For".asInstanceOf[typings.babelTraverse.babelTraverseStrings.For]
    
    inline def ForInStatement: typings.babelTraverse.babelTraverseStrings.ForInStatement = "ForInStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ForInStatement]
    
    inline def ForOfStatement: typings.babelTraverse.babelTraverseStrings.ForOfStatement = "ForOfStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ForOfStatement]
    
    inline def ForStatement: typings.babelTraverse.babelTraverseStrings.ForStatement = "ForStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ForStatement]
    
    inline def ForXStatement: typings.babelTraverse.babelTraverseStrings.ForXStatement = "ForXStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ForXStatement]
    
    inline def Function: typings.babelTraverse.babelTraverseStrings.Function = "Function".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Function]
    
    inline def FunctionDeclaration: typings.babelTraverse.babelTraverseStrings.FunctionDeclaration = "FunctionDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.FunctionDeclaration]
    
    inline def FunctionExpression: typings.babelTraverse.babelTraverseStrings.FunctionExpression = "FunctionExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.FunctionExpression]
    
    inline def FunctionParent: typings.babelTraverse.babelTraverseStrings.FunctionParent = "FunctionParent".asInstanceOf[typings.babelTraverse.babelTraverseStrings.FunctionParent]
    
    inline def FunctionTypeAnnotation: typings.babelTraverse.babelTraverseStrings.FunctionTypeAnnotation = "FunctionTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.FunctionTypeAnnotation]
    
    inline def FunctionTypeParam: typings.babelTraverse.babelTraverseStrings.FunctionTypeParam = "FunctionTypeParam".asInstanceOf[typings.babelTraverse.babelTraverseStrings.FunctionTypeParam]
    
    inline def GenericTypeAnnotation: typings.babelTraverse.babelTraverseStrings.GenericTypeAnnotation = "GenericTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.GenericTypeAnnotation]
    
    inline def Identifier: typings.babelTraverse.babelTraverseStrings.Identifier = "Identifier".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Identifier]
    
    inline def IfStatement: typings.babelTraverse.babelTraverseStrings.IfStatement = "IfStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.IfStatement]
    
    inline def Immutable: typings.babelTraverse.babelTraverseStrings.Immutable = "Immutable".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Immutable]
    
    inline def Import: typings.babelTraverse.babelTraverseStrings.Import = "Import".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Import]
    
    inline def ImportAttribute: typings.babelTraverse.babelTraverseStrings.ImportAttribute = "ImportAttribute".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ImportAttribute]
    
    inline def ImportDeclaration: typings.babelTraverse.babelTraverseStrings.ImportDeclaration = "ImportDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ImportDeclaration]
    
    inline def ImportDefaultSpecifier: typings.babelTraverse.babelTraverseStrings.ImportDefaultSpecifier = "ImportDefaultSpecifier".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ImportDefaultSpecifier]
    
    inline def ImportNamespaceSpecifier: typings.babelTraverse.babelTraverseStrings.ImportNamespaceSpecifier = "ImportNamespaceSpecifier".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ImportNamespaceSpecifier]
    
    inline def ImportOrExportDeclaration: typings.babelTraverse.babelTraverseStrings.ImportOrExportDeclaration = "ImportOrExportDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ImportOrExportDeclaration]
    
    inline def ImportSpecifier: typings.babelTraverse.babelTraverseStrings.ImportSpecifier = "ImportSpecifier".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ImportSpecifier]
    
    inline def IndexedAccessType: typings.babelTraverse.babelTraverseStrings.IndexedAccessType = "IndexedAccessType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.IndexedAccessType]
    
    inline def InferredPredicate: typings.babelTraverse.babelTraverseStrings.InferredPredicate = "InferredPredicate".asInstanceOf[typings.babelTraverse.babelTraverseStrings.InferredPredicate]
    
    inline def InterfaceDeclaration: typings.babelTraverse.babelTraverseStrings.InterfaceDeclaration = "InterfaceDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.InterfaceDeclaration]
    
    inline def InterfaceExtends: typings.babelTraverse.babelTraverseStrings.InterfaceExtends = "InterfaceExtends".asInstanceOf[typings.babelTraverse.babelTraverseStrings.InterfaceExtends]
    
    inline def InterfaceTypeAnnotation: typings.babelTraverse.babelTraverseStrings.InterfaceTypeAnnotation = "InterfaceTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.InterfaceTypeAnnotation]
    
    inline def InterpreterDirective: typings.babelTraverse.babelTraverseStrings.InterpreterDirective = "InterpreterDirective".asInstanceOf[typings.babelTraverse.babelTraverseStrings.InterpreterDirective]
    
    inline def IntersectionTypeAnnotation: typings.babelTraverse.babelTraverseStrings.IntersectionTypeAnnotation = "IntersectionTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.IntersectionTypeAnnotation]
    
    inline def JSX: typings.babelTraverse.babelTraverseStrings.JSX = "JSX".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSX]
    
    inline def JSXAttribute: typings.babelTraverse.babelTraverseStrings.JSXAttribute = "JSXAttribute".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXAttribute]
    
    inline def JSXClosingElement: typings.babelTraverse.babelTraverseStrings.JSXClosingElement = "JSXClosingElement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXClosingElement]
    
    inline def JSXClosingFragment: typings.babelTraverse.babelTraverseStrings.JSXClosingFragment = "JSXClosingFragment".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXClosingFragment]
    
    inline def JSXElement: typings.babelTraverse.babelTraverseStrings.JSXElement = "JSXElement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXElement]
    
    inline def JSXEmptyExpression: typings.babelTraverse.babelTraverseStrings.JSXEmptyExpression = "JSXEmptyExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXEmptyExpression]
    
    inline def JSXExpressionContainer: typings.babelTraverse.babelTraverseStrings.JSXExpressionContainer = "JSXExpressionContainer".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXExpressionContainer]
    
    inline def JSXFragment: typings.babelTraverse.babelTraverseStrings.JSXFragment = "JSXFragment".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXFragment]
    
    inline def JSXIdentifier: typings.babelTraverse.babelTraverseStrings.JSXIdentifier = "JSXIdentifier".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXIdentifier]
    
    inline def JSXMemberExpression: typings.babelTraverse.babelTraverseStrings.JSXMemberExpression = "JSXMemberExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXMemberExpression]
    
    inline def JSXNamespacedName: typings.babelTraverse.babelTraverseStrings.JSXNamespacedName = "JSXNamespacedName".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXNamespacedName]
    
    inline def JSXOpeningElement: typings.babelTraverse.babelTraverseStrings.JSXOpeningElement = "JSXOpeningElement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXOpeningElement]
    
    inline def JSXOpeningFragment: typings.babelTraverse.babelTraverseStrings.JSXOpeningFragment = "JSXOpeningFragment".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXOpeningFragment]
    
    inline def JSXSpreadAttribute: typings.babelTraverse.babelTraverseStrings.JSXSpreadAttribute = "JSXSpreadAttribute".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXSpreadAttribute]
    
    inline def JSXSpreadChild: typings.babelTraverse.babelTraverseStrings.JSXSpreadChild = "JSXSpreadChild".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXSpreadChild]
    
    inline def JSXText: typings.babelTraverse.babelTraverseStrings.JSXText = "JSXText".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXText]
    
    inline def LVal: typings.babelTraverse.babelTraverseStrings.LVal = "LVal".asInstanceOf[typings.babelTraverse.babelTraverseStrings.LVal]
    
    inline def LabeledStatement: typings.babelTraverse.babelTraverseStrings.LabeledStatement = "LabeledStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.LabeledStatement]
    
    inline def Literal: typings.babelTraverse.babelTraverseStrings.Literal = "Literal".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Literal]
    
    inline def LogicalExpression: typings.babelTraverse.babelTraverseStrings.LogicalExpression = "LogicalExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.LogicalExpression]
    
    inline def Loop: typings.babelTraverse.babelTraverseStrings.Loop = "Loop".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Loop]
    
    inline def MemberExpression: typings.babelTraverse.babelTraverseStrings.MemberExpression = "MemberExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.MemberExpression]
    
    inline def MetaProperty: typings.babelTraverse.babelTraverseStrings.MetaProperty = "MetaProperty".asInstanceOf[typings.babelTraverse.babelTraverseStrings.MetaProperty]
    
    inline def Method: typings.babelTraverse.babelTraverseStrings.Method = "Method".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Method]
    
    inline def Miscellaneous: typings.babelTraverse.babelTraverseStrings.Miscellaneous = "Miscellaneous".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Miscellaneous]
    
    inline def MixedTypeAnnotation: typings.babelTraverse.babelTraverseStrings.MixedTypeAnnotation = "MixedTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.MixedTypeAnnotation]
    
    inline def ModuleDeclaration: typings.babelTraverse.babelTraverseStrings.ModuleDeclaration = "ModuleDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ModuleDeclaration]
    
    inline def ModuleExpression: typings.babelTraverse.babelTraverseStrings.ModuleExpression = "ModuleExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ModuleExpression]
    
    inline def ModuleSpecifier: typings.babelTraverse.babelTraverseStrings.ModuleSpecifier = "ModuleSpecifier".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ModuleSpecifier]
    
    inline def NewExpression: typings.babelTraverse.babelTraverseStrings.NewExpression = "NewExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.NewExpression]
    
    inline def Noop: typings.babelTraverse.babelTraverseStrings.Noop = "Noop".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Noop]
    
    inline def NullLiteral: typings.babelTraverse.babelTraverseStrings.NullLiteral = "NullLiteral".asInstanceOf[typings.babelTraverse.babelTraverseStrings.NullLiteral]
    
    inline def NullLiteralTypeAnnotation: typings.babelTraverse.babelTraverseStrings.NullLiteralTypeAnnotation = "NullLiteralTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.NullLiteralTypeAnnotation]
    
    inline def NullableTypeAnnotation: typings.babelTraverse.babelTraverseStrings.NullableTypeAnnotation = "NullableTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.NullableTypeAnnotation]
    
    inline def NumberLiteralTypeAnnotation: typings.babelTraverse.babelTraverseStrings.NumberLiteralTypeAnnotation = "NumberLiteralTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.NumberLiteralTypeAnnotation]
    
    inline def NumberTypeAnnotation: typings.babelTraverse.babelTraverseStrings.NumberTypeAnnotation = "NumberTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.NumberTypeAnnotation]
    
    inline def NumericLiteral: typings.babelTraverse.babelTraverseStrings.NumericLiteral = "NumericLiteral".asInstanceOf[typings.babelTraverse.babelTraverseStrings.NumericLiteral]
    
    inline def ObjectExpression: typings.babelTraverse.babelTraverseStrings.ObjectExpression = "ObjectExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ObjectExpression]
    
    inline def ObjectMember: typings.babelTraverse.babelTraverseStrings.ObjectMember = "ObjectMember".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ObjectMember]
    
    inline def ObjectMethod: typings.babelTraverse.babelTraverseStrings.ObjectMethod = "ObjectMethod".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ObjectMethod]
    
    inline def ObjectPattern: typings.babelTraverse.babelTraverseStrings.ObjectPattern = "ObjectPattern".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ObjectPattern]
    
    inline def ObjectProperty: typings.babelTraverse.babelTraverseStrings.ObjectProperty = "ObjectProperty".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ObjectProperty]
    
    inline def ObjectTypeAnnotation: typings.babelTraverse.babelTraverseStrings.ObjectTypeAnnotation = "ObjectTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ObjectTypeAnnotation]
    
    inline def ObjectTypeCallProperty: typings.babelTraverse.babelTraverseStrings.ObjectTypeCallProperty = "ObjectTypeCallProperty".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ObjectTypeCallProperty]
    
    inline def ObjectTypeIndexer: typings.babelTraverse.babelTraverseStrings.ObjectTypeIndexer = "ObjectTypeIndexer".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ObjectTypeIndexer]
    
    inline def ObjectTypeInternalSlot: typings.babelTraverse.babelTraverseStrings.ObjectTypeInternalSlot = "ObjectTypeInternalSlot".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ObjectTypeInternalSlot]
    
    inline def ObjectTypeProperty: typings.babelTraverse.babelTraverseStrings.ObjectTypeProperty = "ObjectTypeProperty".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ObjectTypeProperty]
    
    inline def ObjectTypeSpreadProperty: typings.babelTraverse.babelTraverseStrings.ObjectTypeSpreadProperty = "ObjectTypeSpreadProperty".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ObjectTypeSpreadProperty]
    
    inline def OpaqueType: typings.babelTraverse.babelTraverseStrings.OpaqueType = "OpaqueType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.OpaqueType]
    
    inline def OptionalCallExpression: typings.babelTraverse.babelTraverseStrings.OptionalCallExpression = "OptionalCallExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.OptionalCallExpression]
    
    inline def OptionalIndexedAccessType: typings.babelTraverse.babelTraverseStrings.OptionalIndexedAccessType = "OptionalIndexedAccessType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.OptionalIndexedAccessType]
    
    inline def OptionalMemberExpression: typings.babelTraverse.babelTraverseStrings.OptionalMemberExpression = "OptionalMemberExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.OptionalMemberExpression]
    
    inline def ParenthesizedExpression: typings.babelTraverse.babelTraverseStrings.ParenthesizedExpression = "ParenthesizedExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ParenthesizedExpression]
    
    inline def Pattern: typings.babelTraverse.babelTraverseStrings.Pattern = "Pattern".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Pattern]
    
    inline def PatternLike: typings.babelTraverse.babelTraverseStrings.PatternLike = "PatternLike".asInstanceOf[typings.babelTraverse.babelTraverseStrings.PatternLike]
    
    inline def PipelineBareFunction: typings.babelTraverse.babelTraverseStrings.PipelineBareFunction = "PipelineBareFunction".asInstanceOf[typings.babelTraverse.babelTraverseStrings.PipelineBareFunction]
    
    inline def PipelinePrimaryTopicReference: typings.babelTraverse.babelTraverseStrings.PipelinePrimaryTopicReference = "PipelinePrimaryTopicReference".asInstanceOf[typings.babelTraverse.babelTraverseStrings.PipelinePrimaryTopicReference]
    
    inline def PipelineTopicExpression: typings.babelTraverse.babelTraverseStrings.PipelineTopicExpression = "PipelineTopicExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.PipelineTopicExpression]
    
    inline def Placeholder: typings.babelTraverse.babelTraverseStrings.Placeholder = "Placeholder".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Placeholder]
    
    inline def Private: typings.babelTraverse.babelTraverseStrings.Private = "Private".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Private]
    
    inline def PrivateName: typings.babelTraverse.babelTraverseStrings.PrivateName = "PrivateName".asInstanceOf[typings.babelTraverse.babelTraverseStrings.PrivateName]
    
    inline def Program: typings.babelTraverse.babelTraverseStrings.Program = "Program".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Program]
    
    inline def Property: typings.babelTraverse.babelTraverseStrings.Property = "Property".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Property]
    
    inline def Pureish: typings.babelTraverse.babelTraverseStrings.Pureish = "Pureish".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Pureish]
    
    inline def QualifiedTypeIdentifier: typings.babelTraverse.babelTraverseStrings.QualifiedTypeIdentifier = "QualifiedTypeIdentifier".asInstanceOf[typings.babelTraverse.babelTraverseStrings.QualifiedTypeIdentifier]
    
    inline def RecordExpression: typings.babelTraverse.babelTraverseStrings.RecordExpression = "RecordExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.RecordExpression]
    
    inline def RegExpLiteral: typings.babelTraverse.babelTraverseStrings.RegExpLiteral = "RegExpLiteral".asInstanceOf[typings.babelTraverse.babelTraverseStrings.RegExpLiteral]
    
    inline def RestElement: typings.babelTraverse.babelTraverseStrings.RestElement = "RestElement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.RestElement]
    
    inline def ReturnStatement: typings.babelTraverse.babelTraverseStrings.ReturnStatement = "ReturnStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ReturnStatement]
    
    inline def Scopable: typings.babelTraverse.babelTraverseStrings.Scopable = "Scopable".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Scopable]
    
    inline def SequenceExpression: typings.babelTraverse.babelTraverseStrings.SequenceExpression = "SequenceExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.SequenceExpression]
    
    inline def SpreadElement: typings.babelTraverse.babelTraverseStrings.SpreadElement = "SpreadElement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.SpreadElement]
    
    inline def Standardized: typings.babelTraverse.babelTraverseStrings.Standardized = "Standardized".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Standardized]
    
    inline def Statement: typings.babelTraverse.babelTraverseStrings.Statement = "Statement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Statement]
    
    inline def StaticBlock: typings.babelTraverse.babelTraverseStrings.StaticBlock = "StaticBlock".asInstanceOf[typings.babelTraverse.babelTraverseStrings.StaticBlock]
    
    inline def StringLiteral: typings.babelTraverse.babelTraverseStrings.StringLiteral = "StringLiteral".asInstanceOf[typings.babelTraverse.babelTraverseStrings.StringLiteral]
    
    inline def StringLiteralTypeAnnotation: typings.babelTraverse.babelTraverseStrings.StringLiteralTypeAnnotation = "StringLiteralTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.StringLiteralTypeAnnotation]
    
    inline def StringTypeAnnotation: typings.babelTraverse.babelTraverseStrings.StringTypeAnnotation = "StringTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.StringTypeAnnotation]
    
    inline def Super: typings.babelTraverse.babelTraverseStrings.Super = "Super".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Super]
    
    inline def SwitchCase: typings.babelTraverse.babelTraverseStrings.SwitchCase = "SwitchCase".asInstanceOf[typings.babelTraverse.babelTraverseStrings.SwitchCase]
    
    inline def SwitchStatement: typings.babelTraverse.babelTraverseStrings.SwitchStatement = "SwitchStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.SwitchStatement]
    
    inline def SymbolTypeAnnotation: typings.babelTraverse.babelTraverseStrings.SymbolTypeAnnotation = "SymbolTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.SymbolTypeAnnotation]
    
    inline def TSAnyKeyword: typings.babelTraverse.babelTraverseStrings.TSAnyKeyword = "TSAnyKeyword".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSAnyKeyword]
    
    inline def TSArrayType: typings.babelTraverse.babelTraverseStrings.TSArrayType = "TSArrayType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSArrayType]
    
    inline def TSAsExpression: typings.babelTraverse.babelTraverseStrings.TSAsExpression = "TSAsExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSAsExpression]
    
    inline def TSBaseType: typings.babelTraverse.babelTraverseStrings.TSBaseType = "TSBaseType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSBaseType]
    
    inline def TSBigIntKeyword: typings.babelTraverse.babelTraverseStrings.TSBigIntKeyword = "TSBigIntKeyword".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSBigIntKeyword]
    
    inline def TSBooleanKeyword: typings.babelTraverse.babelTraverseStrings.TSBooleanKeyword = "TSBooleanKeyword".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSBooleanKeyword]
    
    inline def TSCallSignatureDeclaration: typings.babelTraverse.babelTraverseStrings.TSCallSignatureDeclaration = "TSCallSignatureDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSCallSignatureDeclaration]
    
    inline def TSConditionalType: typings.babelTraverse.babelTraverseStrings.TSConditionalType = "TSConditionalType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSConditionalType]
    
    inline def TSConstructSignatureDeclaration: typings.babelTraverse.babelTraverseStrings.TSConstructSignatureDeclaration = "TSConstructSignatureDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSConstructSignatureDeclaration]
    
    inline def TSConstructorType: typings.babelTraverse.babelTraverseStrings.TSConstructorType = "TSConstructorType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSConstructorType]
    
    inline def TSDeclareFunction: typings.babelTraverse.babelTraverseStrings.TSDeclareFunction = "TSDeclareFunction".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSDeclareFunction]
    
    inline def TSDeclareMethod: typings.babelTraverse.babelTraverseStrings.TSDeclareMethod = "TSDeclareMethod".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSDeclareMethod]
    
    inline def TSEntityName: typings.babelTraverse.babelTraverseStrings.TSEntityName = "TSEntityName".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSEntityName]
    
    inline def TSEnumDeclaration: typings.babelTraverse.babelTraverseStrings.TSEnumDeclaration = "TSEnumDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSEnumDeclaration]
    
    inline def TSEnumMember: typings.babelTraverse.babelTraverseStrings.TSEnumMember = "TSEnumMember".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSEnumMember]
    
    inline def TSExportAssignment: typings.babelTraverse.babelTraverseStrings.TSExportAssignment = "TSExportAssignment".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSExportAssignment]
    
    inline def TSExpressionWithTypeArguments: typings.babelTraverse.babelTraverseStrings.TSExpressionWithTypeArguments = "TSExpressionWithTypeArguments".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSExpressionWithTypeArguments]
    
    inline def TSExternalModuleReference: typings.babelTraverse.babelTraverseStrings.TSExternalModuleReference = "TSExternalModuleReference".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSExternalModuleReference]
    
    inline def TSFunctionType: typings.babelTraverse.babelTraverseStrings.TSFunctionType = "TSFunctionType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSFunctionType]
    
    inline def TSImportEqualsDeclaration: typings.babelTraverse.babelTraverseStrings.TSImportEqualsDeclaration = "TSImportEqualsDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSImportEqualsDeclaration]
    
    inline def TSImportType: typings.babelTraverse.babelTraverseStrings.TSImportType = "TSImportType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSImportType]
    
    inline def TSIndexSignature: typings.babelTraverse.babelTraverseStrings.TSIndexSignature = "TSIndexSignature".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSIndexSignature]
    
    inline def TSIndexedAccessType: typings.babelTraverse.babelTraverseStrings.TSIndexedAccessType = "TSIndexedAccessType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSIndexedAccessType]
    
    inline def TSInferType: typings.babelTraverse.babelTraverseStrings.TSInferType = "TSInferType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSInferType]
    
    inline def TSInstantiationExpression: typings.babelTraverse.babelTraverseStrings.TSInstantiationExpression = "TSInstantiationExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSInstantiationExpression]
    
    inline def TSInterfaceBody: typings.babelTraverse.babelTraverseStrings.TSInterfaceBody = "TSInterfaceBody".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSInterfaceBody]
    
    inline def TSInterfaceDeclaration: typings.babelTraverse.babelTraverseStrings.TSInterfaceDeclaration = "TSInterfaceDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSInterfaceDeclaration]
    
    inline def TSIntersectionType: typings.babelTraverse.babelTraverseStrings.TSIntersectionType = "TSIntersectionType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSIntersectionType]
    
    inline def TSIntrinsicKeyword: typings.babelTraverse.babelTraverseStrings.TSIntrinsicKeyword = "TSIntrinsicKeyword".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSIntrinsicKeyword]
    
    inline def TSLiteralType: typings.babelTraverse.babelTraverseStrings.TSLiteralType = "TSLiteralType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSLiteralType]
    
    inline def TSMappedType: typings.babelTraverse.babelTraverseStrings.TSMappedType = "TSMappedType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSMappedType]
    
    inline def TSMethodSignature: typings.babelTraverse.babelTraverseStrings.TSMethodSignature = "TSMethodSignature".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSMethodSignature]
    
    inline def TSModuleBlock: typings.babelTraverse.babelTraverseStrings.TSModuleBlock = "TSModuleBlock".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSModuleBlock]
    
    inline def TSModuleDeclaration: typings.babelTraverse.babelTraverseStrings.TSModuleDeclaration = "TSModuleDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSModuleDeclaration]
    
    inline def TSNamedTupleMember: typings.babelTraverse.babelTraverseStrings.TSNamedTupleMember = "TSNamedTupleMember".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSNamedTupleMember]
    
    inline def TSNamespaceExportDeclaration: typings.babelTraverse.babelTraverseStrings.TSNamespaceExportDeclaration = "TSNamespaceExportDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSNamespaceExportDeclaration]
    
    inline def TSNeverKeyword: typings.babelTraverse.babelTraverseStrings.TSNeverKeyword = "TSNeverKeyword".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSNeverKeyword]
    
    inline def TSNonNullExpression: typings.babelTraverse.babelTraverseStrings.TSNonNullExpression = "TSNonNullExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSNonNullExpression]
    
    inline def TSNullKeyword: typings.babelTraverse.babelTraverseStrings.TSNullKeyword = "TSNullKeyword".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSNullKeyword]
    
    inline def TSNumberKeyword: typings.babelTraverse.babelTraverseStrings.TSNumberKeyword = "TSNumberKeyword".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSNumberKeyword]
    
    inline def TSObjectKeyword: typings.babelTraverse.babelTraverseStrings.TSObjectKeyword = "TSObjectKeyword".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSObjectKeyword]
    
    inline def TSOptionalType: typings.babelTraverse.babelTraverseStrings.TSOptionalType = "TSOptionalType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSOptionalType]
    
    inline def TSParameterProperty: typings.babelTraverse.babelTraverseStrings.TSParameterProperty = "TSParameterProperty".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSParameterProperty]
    
    inline def TSParenthesizedType: typings.babelTraverse.babelTraverseStrings.TSParenthesizedType = "TSParenthesizedType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSParenthesizedType]
    
    inline def TSPropertySignature: typings.babelTraverse.babelTraverseStrings.TSPropertySignature = "TSPropertySignature".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSPropertySignature]
    
    inline def TSQualifiedName: typings.babelTraverse.babelTraverseStrings.TSQualifiedName = "TSQualifiedName".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSQualifiedName]
    
    inline def TSRestType: typings.babelTraverse.babelTraverseStrings.TSRestType = "TSRestType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSRestType]
    
    inline def TSSatisfiesExpression: typings.babelTraverse.babelTraverseStrings.TSSatisfiesExpression = "TSSatisfiesExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSSatisfiesExpression]
    
    inline def TSStringKeyword: typings.babelTraverse.babelTraverseStrings.TSStringKeyword = "TSStringKeyword".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSStringKeyword]
    
    inline def TSSymbolKeyword: typings.babelTraverse.babelTraverseStrings.TSSymbolKeyword = "TSSymbolKeyword".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSSymbolKeyword]
    
    inline def TSThisType: typings.babelTraverse.babelTraverseStrings.TSThisType = "TSThisType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSThisType]
    
    inline def TSTupleType: typings.babelTraverse.babelTraverseStrings.TSTupleType = "TSTupleType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSTupleType]
    
    inline def TSType: typings.babelTraverse.babelTraverseStrings.TSType = "TSType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSType]
    
    inline def TSTypeAliasDeclaration: typings.babelTraverse.babelTraverseStrings.TSTypeAliasDeclaration = "TSTypeAliasDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSTypeAliasDeclaration]
    
    inline def TSTypeAnnotation: typings.babelTraverse.babelTraverseStrings.TSTypeAnnotation = "TSTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSTypeAnnotation]
    
    inline def TSTypeAssertion: typings.babelTraverse.babelTraverseStrings.TSTypeAssertion = "TSTypeAssertion".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSTypeAssertion]
    
    inline def TSTypeElement: typings.babelTraverse.babelTraverseStrings.TSTypeElement = "TSTypeElement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSTypeElement]
    
    inline def TSTypeLiteral: typings.babelTraverse.babelTraverseStrings.TSTypeLiteral = "TSTypeLiteral".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSTypeLiteral]
    
    inline def TSTypeOperator: typings.babelTraverse.babelTraverseStrings.TSTypeOperator = "TSTypeOperator".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSTypeOperator]
    
    inline def TSTypeParameter: typings.babelTraverse.babelTraverseStrings.TSTypeParameter = "TSTypeParameter".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSTypeParameter]
    
    inline def TSTypeParameterDeclaration: typings.babelTraverse.babelTraverseStrings.TSTypeParameterDeclaration = "TSTypeParameterDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSTypeParameterDeclaration]
    
    inline def TSTypeParameterInstantiation: typings.babelTraverse.babelTraverseStrings.TSTypeParameterInstantiation = "TSTypeParameterInstantiation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSTypeParameterInstantiation]
    
    inline def TSTypePredicate: typings.babelTraverse.babelTraverseStrings.TSTypePredicate = "TSTypePredicate".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSTypePredicate]
    
    inline def TSTypeQuery: typings.babelTraverse.babelTraverseStrings.TSTypeQuery = "TSTypeQuery".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSTypeQuery]
    
    inline def TSTypeReference: typings.babelTraverse.babelTraverseStrings.TSTypeReference = "TSTypeReference".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSTypeReference]
    
    inline def TSUndefinedKeyword: typings.babelTraverse.babelTraverseStrings.TSUndefinedKeyword = "TSUndefinedKeyword".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSUndefinedKeyword]
    
    inline def TSUnionType: typings.babelTraverse.babelTraverseStrings.TSUnionType = "TSUnionType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSUnionType]
    
    inline def TSUnknownKeyword: typings.babelTraverse.babelTraverseStrings.TSUnknownKeyword = "TSUnknownKeyword".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSUnknownKeyword]
    
    inline def TSVoidKeyword: typings.babelTraverse.babelTraverseStrings.TSVoidKeyword = "TSVoidKeyword".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSVoidKeyword]
    
    inline def TaggedTemplateExpression: typings.babelTraverse.babelTraverseStrings.TaggedTemplateExpression = "TaggedTemplateExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TaggedTemplateExpression]
    
    inline def TemplateElement: typings.babelTraverse.babelTraverseStrings.TemplateElement = "TemplateElement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TemplateElement]
    
    inline def TemplateLiteral: typings.babelTraverse.babelTraverseStrings.TemplateLiteral = "TemplateLiteral".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TemplateLiteral]
    
    inline def Terminatorless: typings.babelTraverse.babelTraverseStrings.Terminatorless = "Terminatorless".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Terminatorless]
    
    inline def ThisExpression: typings.babelTraverse.babelTraverseStrings.ThisExpression = "ThisExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ThisExpression]
    
    inline def ThisTypeAnnotation: typings.babelTraverse.babelTraverseStrings.ThisTypeAnnotation = "ThisTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ThisTypeAnnotation]
    
    inline def ThrowStatement: typings.babelTraverse.babelTraverseStrings.ThrowStatement = "ThrowStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ThrowStatement]
    
    inline def TopicReference: typings.babelTraverse.babelTraverseStrings.TopicReference = "TopicReference".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TopicReference]
    
    inline def TryStatement: typings.babelTraverse.babelTraverseStrings.TryStatement = "TryStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TryStatement]
    
    inline def TupleExpression: typings.babelTraverse.babelTraverseStrings.TupleExpression = "TupleExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TupleExpression]
    
    inline def TupleTypeAnnotation: typings.babelTraverse.babelTraverseStrings.TupleTypeAnnotation = "TupleTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TupleTypeAnnotation]
    
    inline def TypeAlias: typings.babelTraverse.babelTraverseStrings.TypeAlias = "TypeAlias".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TypeAlias]
    
    inline def TypeAnnotation: typings.babelTraverse.babelTraverseStrings.TypeAnnotation = "TypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TypeAnnotation]
    
    inline def TypeCastExpression: typings.babelTraverse.babelTraverseStrings.TypeCastExpression = "TypeCastExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TypeCastExpression]
    
    inline def TypeParameter: typings.babelTraverse.babelTraverseStrings.TypeParameter = "TypeParameter".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TypeParameter]
    
    inline def TypeParameterDeclaration: typings.babelTraverse.babelTraverseStrings.TypeParameterDeclaration = "TypeParameterDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TypeParameterDeclaration]
    
    inline def TypeParameterInstantiation: typings.babelTraverse.babelTraverseStrings.TypeParameterInstantiation = "TypeParameterInstantiation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TypeParameterInstantiation]
    
    inline def TypeScript: typings.babelTraverse.babelTraverseStrings.TypeScript = "TypeScript".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TypeScript]
    
    inline def TypeofTypeAnnotation: typings.babelTraverse.babelTraverseStrings.TypeofTypeAnnotation = "TypeofTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TypeofTypeAnnotation]
    
    inline def UnaryExpression: typings.babelTraverse.babelTraverseStrings.UnaryExpression = "UnaryExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.UnaryExpression]
    
    inline def UnaryLike: typings.babelTraverse.babelTraverseStrings.UnaryLike = "UnaryLike".asInstanceOf[typings.babelTraverse.babelTraverseStrings.UnaryLike]
    
    inline def UnionTypeAnnotation: typings.babelTraverse.babelTraverseStrings.UnionTypeAnnotation = "UnionTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.UnionTypeAnnotation]
    
    inline def UpdateExpression: typings.babelTraverse.babelTraverseStrings.UpdateExpression = "UpdateExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.UpdateExpression]
    
    inline def UserWhitespacable: typings.babelTraverse.babelTraverseStrings.UserWhitespacable = "UserWhitespacable".asInstanceOf[typings.babelTraverse.babelTraverseStrings.UserWhitespacable]
    
    inline def V8IntrinsicIdentifier: typings.babelTraverse.babelTraverseStrings.V8IntrinsicIdentifier = "V8IntrinsicIdentifier".asInstanceOf[typings.babelTraverse.babelTraverseStrings.V8IntrinsicIdentifier]
    
    inline def VariableDeclaration: typings.babelTraverse.babelTraverseStrings.VariableDeclaration = "VariableDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.VariableDeclaration]
    
    inline def VariableDeclarator: typings.babelTraverse.babelTraverseStrings.VariableDeclarator = "VariableDeclarator".asInstanceOf[typings.babelTraverse.babelTraverseStrings.VariableDeclarator]
    
    inline def Variance: typings.babelTraverse.babelTraverseStrings.Variance = "Variance".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Variance]
    
    inline def VoidTypeAnnotation: typings.babelTraverse.babelTraverseStrings.VoidTypeAnnotation = "VoidTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.VoidTypeAnnotation]
    
    inline def While: typings.babelTraverse.babelTraverseStrings.While = "While".asInstanceOf[typings.babelTraverse.babelTraverseStrings.While]
    
    inline def WhileStatement: typings.babelTraverse.babelTraverseStrings.WhileStatement = "WhileStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.WhileStatement]
    
    inline def WithStatement: typings.babelTraverse.babelTraverseStrings.WithStatement = "WithStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.WithStatement]
    
    inline def YieldExpression: typings.babelTraverse.babelTraverseStrings.YieldExpression = "YieldExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.YieldExpression]
  }
  
  type NodesInsertionParam[T /* <: Node */] = T | js.Array[T] | Array[T]
  
  trait TraversalContext[S] extends StObject {
    
    var opts: TraverseOptions[Node]
    
    var parentPath: NodePath[Node]
    
    var scope: Scope
    
    var state: S
  }
  object TraversalContext {
    
    inline def apply[S](opts: TraverseOptions[Node], parentPath: NodePath[Node], scope: Scope, state: S): TraversalContext[S] = {
      val __obj = js.Dynamic.literal(opts = opts.asInstanceOf[js.Any], parentPath = parentPath.asInstanceOf[js.Any], scope = scope.asInstanceOf[js.Any], state = state.asInstanceOf[js.Any])
      __obj.asInstanceOf[TraversalContext[S]]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: TraversalContext[?], S] (val x: Self & TraversalContext[S]) extends AnyVal {
      
      inline def setOpts(value: TraverseOptions[Node]): Self = StObject.set(x, "opts", value.asInstanceOf[js.Any])
      
      inline def setParentPath(value: NodePath[Node]): Self = StObject.set(x, "parentPath", value.asInstanceOf[js.Any])
      
      inline def setScope(value: Scope): Self = StObject.set(x, "scope", value.asInstanceOf[js.Any])
      
      inline def setState(value: S): Self = StObject.set(x, "state", value.asInstanceOf[js.Any])
    }
  }
  
  /* Inlined {  scope :@babel/traverse.@babel/traverse.Scope | undefined,   noScope :boolean | undefined,   denylist :std.Array<@babel/traverse.@babel/traverse.NodeType> | undefined,   blacklist :std.Array<@babel/traverse.@babel/traverse.NodeType> | undefined,   shouldSkip :(node : @babel/traverse.@babel/traverse.NodePath<@babel/traverse.@babel/traverse.Node>): boolean | undefined} & @babel/traverse.@babel/traverse.Visitor<S> */
  trait TraverseOptions[S]
    extends StObject
       with // Babel supports `NodeTypesWithoutComment | NodeTypesWithoutComment | ... ` but it is
  // too complex for TS. So we type it as a general visitor only if the key contains `|`
  // this is good enough for non-visitor traverse options e.g. `noScope`
  /* k */ StringDictionary[VisitNode[S, Node]] {
    
    var Accessor: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Accessor]] = js.undefined
    
    var AnyTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `65`]]] = js.undefined
    
    var ArgumentPlaceholder: js.UndefOr[VisitNode[S, Extract[Node, `239`]]] = js.undefined
    
    var ArrayExpression: js.UndefOr[VisitNode[S, Extract[Node, `56`]]] = js.undefined
    
    var ArrayPattern: js.UndefOr[VisitNode[S, Extract[Node, `115`]]] = js.undefined
    
    var ArrayTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `86`]]] = js.undefined
    
    var ArrowFunctionExpression: js.UndefOr[VisitNode[S, Extract[Node, `147`]]] = js.undefined
    
    var AssignmentExpression: js.UndefOr[VisitNode[S, Extract[Node, `135`]]] = js.undefined
    
    var AssignmentPattern: js.UndefOr[VisitNode[S, Extract[Node, `64`]]] = js.undefined
    
    var AwaitExpression: js.UndefOr[VisitNode[S, Extract[Node, `113`]]] = js.undefined
    
    var BigIntLiteral: js.UndefOr[VisitNode[S, Extract[Node, `184`]]] = js.undefined
    
    var Binary: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Binary]] = js.undefined
    
    var BinaryExpression: js.UndefOr[VisitNode[S, Extract[Node, `89`]]] = js.undefined
    
    var BindExpression: js.UndefOr[VisitNode[S, Extract[Node, `79`]]] = js.undefined
    
    var BindingIdentifier: js.UndefOr[VisitNode[S, Identifier_]] = js.undefined
    
    var Block: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Block]] = js.undefined
    
    var BlockParent: js.UndefOr[VisitNode[S, typings.babelTypes.mod.BlockParent]] = js.undefined
    
    var BlockScoped: js.UndefOr[VisitNode[S, Node]] = js.undefined
    
    var BlockStatement: js.UndefOr[VisitNode[S, Extract[Node, `25`]]] = js.undefined
    
    var BooleanLiteral: js.UndefOr[VisitNode[S, Extract[Node, `132`]]] = js.undefined
    
    var BooleanLiteralTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `178`]]] = js.undefined
    
    var BooleanTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `183`]]] = js.undefined
    
    var BreakStatement: js.UndefOr[VisitNode[S, Extract[Node, `1`]]] = js.undefined
    
    var CallExpression: js.UndefOr[VisitNode[S, Extract[Node, `47`]]] = js.undefined
    
    var CatchClause: js.UndefOr[VisitNode[S, Extract[Node, `176`]]] = js.undefined
    
    var Class: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Class]] = js.undefined
    
    var ClassAccessorProperty: js.UndefOr[VisitNode[S, Extract[Node, `214`]]] = js.undefined
    
    var ClassBody: js.UndefOr[VisitNode[S, Extract[Node, `232`]]] = js.undefined
    
    var ClassDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `109`]]] = js.undefined
    
    var ClassExpression: js.UndefOr[VisitNode[S, Extract[Node, Type]]] = js.undefined
    
    var ClassImplements: js.UndefOr[VisitNode[S, Extract[Node, `212`]]] = js.undefined
    
    var ClassMethod: js.UndefOr[VisitNode[S, Extract[Node, `189`]]] = js.undefined
    
    var ClassPrivateMethod: js.UndefOr[VisitNode[S, Extract[Node, `235`]]] = js.undefined
    
    var ClassPrivateProperty: js.UndefOr[VisitNode[S, Extract[Node, `230`]]] = js.undefined
    
    var ClassProperty: js.UndefOr[VisitNode[S, Extract[Node, `192`]]] = js.undefined
    
    var CompletionStatement: js.UndefOr[VisitNode[S, typings.babelTypes.mod.CompletionStatement]] = js.undefined
    
    var Conditional: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Conditional]] = js.undefined
    
    var ConditionalExpression: js.UndefOr[VisitNode[S, Extract[Node, `170`]]] = js.undefined
    
    var ContinueStatement: js.UndefOr[VisitNode[S, Extract[Node, `40`]]] = js.undefined
    
    var DebuggerStatement: js.UndefOr[VisitNode[S, Extract[Node, `138`]]] = js.undefined
    
    var DecimalLiteral: js.UndefOr[VisitNode[S, Extract[Node, `206`]]] = js.undefined
    
    var Declaration: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Declaration]] = js.undefined
    
    var DeclareClass: js.UndefOr[VisitNode[S, Extract[Node, `242`]]] = js.undefined
    
    var DeclareExportAllDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `110`]]] = js.undefined
    
    var DeclareExportDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `158`]]] = js.undefined
    
    var DeclareFunction: js.UndefOr[VisitNode[S, Extract[Node, `105`]]] = js.undefined
    
    var DeclareInterface: js.UndefOr[VisitNode[S, Extract[Node, `161`]]] = js.undefined
    
    var DeclareModule: js.UndefOr[VisitNode[S, Extract[Node, `35`]]] = js.undefined
    
    var DeclareModuleExports: js.UndefOr[VisitNode[S, Extract[Node, `223`]]] = js.undefined
    
    var DeclareOpaqueType: js.UndefOr[VisitNode[S, Extract[Node, `229`]]] = js.undefined
    
    var DeclareTypeAlias: js.UndefOr[VisitNode[S, Extract[Node, `167`]]] = js.undefined
    
    var DeclareVariable: js.UndefOr[VisitNode[S, Extract[Node, `182`]]] = js.undefined
    
    var DeclaredPredicate: js.UndefOr[VisitNode[S, Extract[Node, `188`]]] = js.undefined
    
    var Decorator: js.UndefOr[VisitNode[S, Extract[Node, `82`]]] = js.undefined
    
    var Directive: js.UndefOr[VisitNode[S, Extract[Node, `63`]]] = js.undefined
    
    var DirectiveLiteral: js.UndefOr[VisitNode[S, Extract[Node, `143`]]] = js.undefined
    
    var DoExpression: js.UndefOr[VisitNode[S, Extract[Node, `219`]]] = js.undefined
    
    var DoWhileStatement: js.UndefOr[VisitNode[S, Extract[Node, `200`]]] = js.undefined
    
    var EmptyStatement: js.UndefOr[VisitNode[S, Extract[Node, `108`]]] = js.undefined
    
    var EmptyTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `142`]]] = js.undefined
    
    var EnumBody: js.UndefOr[VisitNode[S, typings.babelTypes.mod.EnumBody]] = js.undefined
    
    var EnumBooleanBody: js.UndefOr[VisitNode[S, Extract[Node, `137`]]] = js.undefined
    
    var EnumBooleanMember: js.UndefOr[VisitNode[S, Extract[Node, `117`]]] = js.undefined
    
    var EnumDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `67`]]] = js.undefined
    
    var EnumDefaultedMember: js.UndefOr[VisitNode[S, Extract[Node, `191`]]] = js.undefined
    
    var EnumMember: js.UndefOr[VisitNode[S, typings.babelTypes.mod.EnumMember]] = js.undefined
    
    var EnumNumberBody: js.UndefOr[VisitNode[S, Extract[Node, `240`]]] = js.undefined
    
    var EnumNumberMember: js.UndefOr[VisitNode[S, Extract[Node, `205`]]] = js.undefined
    
    var EnumStringBody: js.UndefOr[VisitNode[S, Extract[Node, `163`]]] = js.undefined
    
    var EnumStringMember: js.UndefOr[VisitNode[S, Extract[Node, `4`]]] = js.undefined
    
    var EnumSymbolBody: js.UndefOr[VisitNode[S, Extract[Node, `198`]]] = js.undefined
    
    var ExistentialTypeParam: js.UndefOr[VisitNode[S, ExistsTypeAnnotation_]] = js.undefined
    
    var ExistsTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `119`]]] = js.undefined
    
    var ExportAllDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `37`]]] = js.undefined
    
    var ExportDeclaration: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ExportDeclaration]] = js.undefined
    
    var ExportDefaultDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `80`]]] = js.undefined
    
    var ExportDefaultSpecifier: js.UndefOr[VisitNode[S, Extract[Node, `3`]]] = js.undefined
    
    var ExportNamedDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `46`]]] = js.undefined
    
    var ExportNamespaceSpecifier: js.UndefOr[VisitNode[S, Extract[Node, `179`]]] = js.undefined
    
    var ExportSpecifier: js.UndefOr[VisitNode[S, Extract[Node, `116`]]] = js.undefined
    
    var Expression: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Expression]] = js.undefined
    
    var ExpressionStatement: js.UndefOr[VisitNode[S, Extract[Node, `62`]]] = js.undefined
    
    var ExpressionWrapper: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ExpressionWrapper]] = js.undefined
    
    var File: js.UndefOr[VisitNode[S, Extract[Node, `28`]]] = js.undefined
    
    var Flow: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Flow]] = js.undefined
    
    var FlowBaseAnnotation: js.UndefOr[VisitNode[S, typings.babelTypes.mod.FlowBaseAnnotation]] = js.undefined
    
    var FlowDeclaration: js.UndefOr[VisitNode[S, typings.babelTypes.mod.FlowDeclaration]] = js.undefined
    
    var FlowPredicate: js.UndefOr[VisitNode[S, typings.babelTypes.mod.FlowPredicate]] = js.undefined
    
    var FlowType: js.UndefOr[VisitNode[S, typings.babelTypes.mod.FlowType]] = js.undefined
    
    var For: js.UndefOr[VisitNode[S, typings.babelTypes.mod.For]] = js.undefined
    
    var ForAwaitStatement: js.UndefOr[VisitNode[S, ForOfStatement_]] = js.undefined
    
    var ForInStatement: js.UndefOr[VisitNode[S, Extract[Node, `17`]]] = js.undefined
    
    var ForOfStatement: js.UndefOr[VisitNode[S, Extract[Node, `166`]]] = js.undefined
    
    var ForStatement: js.UndefOr[VisitNode[S, Extract[Node, `190`]]] = js.undefined
    
    var ForXStatement: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ForXStatement]] = js.undefined
    
    var Function: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Function]] = js.undefined
    
    var FunctionDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `136`]]] = js.undefined
    
    var FunctionExpression: js.UndefOr[VisitNode[S, Extract[Node, `193`]]] = js.undefined
    
    var FunctionParent: js.UndefOr[VisitNode[S, typings.babelTypes.mod.FunctionParent]] = js.undefined
    
    var FunctionTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `41`]]] = js.undefined
    
    var FunctionTypeParam: js.UndefOr[VisitNode[S, Extract[Node, `228`]]] = js.undefined
    
    var Generated: js.UndefOr[VisitNode[S, Node]] = js.undefined
    
    var GenericTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `244`]]] = js.undefined
    
    var Identifier: js.UndefOr[VisitNode[S, Extract[Node, `99`]]] = js.undefined
    
    var IfStatement: js.UndefOr[VisitNode[S, Extract[Node, `85`]]] = js.undefined
    
    var Immutable: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Immutable]] = js.undefined
    
    var Import: js.UndefOr[VisitNode[S, Extract[Node, `172`]]] = js.undefined
    
    var ImportAttribute: js.UndefOr[VisitNode[S, Extract[Node, `123`]]] = js.undefined
    
    var ImportDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `243`]]] = js.undefined
    
    var ImportDefaultSpecifier: js.UndefOr[VisitNode[S, Extract[Node, `19`]]] = js.undefined
    
    var ImportNamespaceSpecifier: js.UndefOr[VisitNode[S, Extract[Node, `202`]]] = js.undefined
    
    var ImportOrExportDeclaration: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ImportOrExportDeclaration]] = js.undefined
    
    var ImportSpecifier: js.UndefOr[VisitNode[S, Extract[Node, `114`]]] = js.undefined
    
    var IndexedAccessType: js.UndefOr[VisitNode[S, Extract[Node, `69`]]] = js.undefined
    
    var InferredPredicate: js.UndefOr[VisitNode[S, Extract[Node, `134`]]] = js.undefined
    
    var InterfaceDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `48`]]] = js.undefined
    
    var InterfaceExtends: js.UndefOr[VisitNode[S, Extract[Node, `139`]]] = js.undefined
    
    var InterfaceTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `9`]]] = js.undefined
    
    var InterpreterDirective: js.UndefOr[VisitNode[S, Extract[Node, `88`]]] = js.undefined
    
    var IntersectionTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `215`]]] = js.undefined
    
    var JSX: js.UndefOr[VisitNode[S, typings.babelTypes.mod.JSX]] = js.undefined
    
    var JSXAttribute: js.UndefOr[VisitNode[S, Extract[Node, `103`]]] = js.undefined
    
    var JSXClosingElement: js.UndefOr[VisitNode[S, Extract[Node, `129`]]] = js.undefined
    
    var JSXClosingFragment: js.UndefOr[VisitNode[S, Extract[Node, `211`]]] = js.undefined
    
    var JSXElement: js.UndefOr[VisitNode[S, Extract[Node, `174`]]] = js.undefined
    
    var JSXEmptyExpression: js.UndefOr[VisitNode[S, Extract[Node, `125`]]] = js.undefined
    
    var JSXExpressionContainer: js.UndefOr[VisitNode[S, Extract[Node, `32`]]] = js.undefined
    
    var JSXFragment: js.UndefOr[VisitNode[S, Extract[Node, `152`]]] = js.undefined
    
    var JSXIdentifier: js.UndefOr[VisitNode[S, Extract[Node, `87`]]] = js.undefined
    
    var JSXMemberExpression: js.UndefOr[VisitNode[S, Extract[Node, `197`]]] = js.undefined
    
    var JSXNamespacedName: js.UndefOr[VisitNode[S, Extract[Node, `154`]]] = js.undefined
    
    var JSXOpeningElement: js.UndefOr[VisitNode[S, Extract[Node, `74`]]] = js.undefined
    
    var JSXOpeningFragment: js.UndefOr[VisitNode[S, Extract[Node, `220`]]] = js.undefined
    
    var JSXSpreadAttribute: js.UndefOr[VisitNode[S, Extract[Node, `49`]]] = js.undefined
    
    var JSXSpreadChild: js.UndefOr[VisitNode[S, Extract[Node, `73`]]] = js.undefined
    
    var JSXText: js.UndefOr[VisitNode[S, Extract[Node, `195`]]] = js.undefined
    
    var LVal: js.UndefOr[VisitNode[S, typings.babelTypes.mod.LVal]] = js.undefined
    
    var LabeledStatement: js.UndefOr[VisitNode[S, Extract[Node, `36`]]] = js.undefined
    
    var Literal: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Literal]] = js.undefined
    
    var LogicalExpression: js.UndefOr[VisitNode[S, Extract[Node, `70`]]] = js.undefined
    
    var Loop: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Loop]] = js.undefined
    
    var MemberExpression: js.UndefOr[VisitNode[S, Extract[Node, `60`]]] = js.undefined
    
    var MetaProperty: js.UndefOr[VisitNode[S, Extract[Node, `83`]]] = js.undefined
    
    var Method: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Method]] = js.undefined
    
    var Miscellaneous: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Miscellaneous]] = js.undefined
    
    var MixedTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `57`]]] = js.undefined
    
    var ModuleDeclaration: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ModuleDeclaration]] = js.undefined
    
    var ModuleExpression: js.UndefOr[VisitNode[S, Extract[Node, `148`]]] = js.undefined
    
    var ModuleSpecifier: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ModuleSpecifier]] = js.undefined
    
    var NewExpression: js.UndefOr[VisitNode[S, Extract[Node, `59`]]] = js.undefined
    
    var Noop: js.UndefOr[VisitNode[S, Extract[Node, `34`]]] = js.undefined
    
    var NullLiteral: js.UndefOr[VisitNode[S, Extract[Node, `245`]]] = js.undefined
    
    var NullLiteralTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `43`]]] = js.undefined
    
    var NullableTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `98`]]] = js.undefined
    
    var NumberLiteralTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `157`]]] = js.undefined
    
    var NumberTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `164`]]] = js.undefined
    
    var NumericLiteral: js.UndefOr[VisitNode[S, Extract[Node, `217`]]] = js.undefined
    
    var NumericLiteralTypeAnnotation: js.UndefOr[VisitNode[S, NumberLiteralTypeAnnotation_]] = js.undefined
    
    var ObjectExpression: js.UndefOr[VisitNode[S, Extract[Node, `124`]]] = js.undefined
    
    var ObjectMember: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ObjectMember]] = js.undefined
    
    var ObjectMethod: js.UndefOr[VisitNode[S, Extract[Node, `126`]]] = js.undefined
    
    var ObjectPattern: js.UndefOr[VisitNode[S, Extract[Node, `224`]]] = js.undefined
    
    var ObjectProperty: js.UndefOr[VisitNode[S, Extract[Node, `144`]]] = js.undefined
    
    var ObjectTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `84`]]] = js.undefined
    
    var ObjectTypeCallProperty: js.UndefOr[VisitNode[S, Extract[Node, `13`]]] = js.undefined
    
    var ObjectTypeIndexer: js.UndefOr[VisitNode[S, Extract[Node, `175`]]] = js.undefined
    
    var ObjectTypeInternalSlot: js.UndefOr[VisitNode[S, Extract[Node, `233`]]] = js.undefined
    
    var ObjectTypeProperty: js.UndefOr[VisitNode[S, Extract[Node, `159`]]] = js.undefined
    
    var ObjectTypeSpreadProperty: js.UndefOr[VisitNode[S, Extract[Node, `81`]]] = js.undefined
    
    var OpaqueType: js.UndefOr[VisitNode[S, Extract[Node, `71`]]] = js.undefined
    
    var OptionalCallExpression: js.UndefOr[VisitNode[S, Extract[Node, `45`]]] = js.undefined
    
    var OptionalIndexedAccessType: js.UndefOr[VisitNode[S, Extract[Node, `146`]]] = js.undefined
    
    var OptionalMemberExpression: js.UndefOr[VisitNode[S, Extract[Node, `27`]]] = js.undefined
    
    var ParenthesizedExpression: js.UndefOr[VisitNode[S, Extract[Node, `204`]]] = js.undefined
    
    var Pattern: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Pattern]] = js.undefined
    
    var PatternLike: js.UndefOr[VisitNode[S, typings.babelTypes.mod.PatternLike]] = js.undefined
    
    var PipelineBareFunction: js.UndefOr[VisitNode[S, Extract[Node, `162`]]] = js.undefined
    
    var PipelinePrimaryTopicReference: js.UndefOr[VisitNode[S, Extract[Node, `31`]]] = js.undefined
    
    var PipelineTopicExpression: js.UndefOr[VisitNode[S, Extract[Node, `106`]]] = js.undefined
    
    var Placeholder: js.UndefOr[VisitNode[S, Extract[Node, `168`]]] = js.undefined
    
    var Private: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Private]] = js.undefined
    
    var PrivateName: js.UndefOr[VisitNode[S, Extract[Node, `95`]]] = js.undefined
    
    var Program: js.UndefOr[VisitNode[S, Extract[Node, `155`]]] = js.undefined
    
    var Property: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Property]] = js.undefined
    
    var Pure: js.UndefOr[VisitNode[S, Node]] = js.undefined
    
    var Pureish: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Pureish]] = js.undefined
    
    var QualifiedTypeIdentifier: js.UndefOr[VisitNode[S, Extract[Node, `75`]]] = js.undefined
    
    var RecordExpression: js.UndefOr[VisitNode[S, Extract[Node, `61`]]] = js.undefined
    
    var Referenced: js.UndefOr[VisitNode[S, Node]] = js.undefined
    
    var ReferencedIdentifier: js.UndefOr[VisitNode[S, Identifier_ | JSXIdentifier_]] = js.undefined
    
    var ReferencedMemberExpression: js.UndefOr[VisitNode[S, MemberExpression_]] = js.undefined
    
    var RegExpLiteral: js.UndefOr[VisitNode[S, Extract[Node, `38`]]] = js.undefined
    
    var RestElement: js.UndefOr[VisitNode[S, Extract[Node, `26`]]] = js.undefined
    
    var RestProperty: js.UndefOr[VisitNode[S, RestElement_]] = js.undefined
    
    var ReturnStatement: js.UndefOr[VisitNode[S, Extract[Node, `5`]]] = js.undefined
    
    var Scopable: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Scopable]] = js.undefined
    
    var Scope: js.UndefOr[VisitNode[S, Scopable | Pattern]] = js.undefined
    
    var SequenceExpression: js.UndefOr[VisitNode[S, Extract[Node, `171`]]] = js.undefined
    
    var SpreadElement: js.UndefOr[VisitNode[S, Extract[Node, `23`]]] = js.undefined
    
    var SpreadProperty: js.UndefOr[VisitNode[S, RestElement_]] = js.undefined
    
    var Standardized: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Standardized]] = js.undefined
    
    var Statement: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Statement]] = js.undefined
    
    var StaticBlock: js.UndefOr[VisitNode[S, Extract[Node, `111`]]] = js.undefined
    
    var StringLiteral: js.UndefOr[VisitNode[S, Extract[Node, `131`]]] = js.undefined
    
    var StringLiteralTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `226`]]] = js.undefined
    
    var StringTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `2`]]] = js.undefined
    
    var Super: js.UndefOr[VisitNode[S, Extract[Node, `165`]]] = js.undefined
    
    var SwitchCase: js.UndefOr[VisitNode[S, Extract[Node, `54`]]] = js.undefined
    
    var SwitchStatement: js.UndefOr[VisitNode[S, Extract[Node, `44`]]] = js.undefined
    
    var SymbolTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `50`]]] = js.undefined
    
    var TSAnyKeyword: js.UndefOr[VisitNode[S, Extract[Node, `10`]]] = js.undefined
    
    var TSArrayType: js.UndefOr[VisitNode[S, Extract[Node, `0`]]] = js.undefined
    
    var TSAsExpression: js.UndefOr[VisitNode[S, Extract[Node, `8`]]] = js.undefined
    
    var TSBaseType: js.UndefOr[VisitNode[S, typings.babelTypes.mod.TSBaseType]] = js.undefined
    
    var TSBigIntKeyword: js.UndefOr[VisitNode[S, Extract[Node, `53`]]] = js.undefined
    
    var TSBooleanKeyword: js.UndefOr[VisitNode[S, Extract[Node, `225`]]] = js.undefined
    
    var TSCallSignatureDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `151`]]] = js.undefined
    
    var TSConditionalType: js.UndefOr[VisitNode[S, Extract[Node, `18`]]] = js.undefined
    
    var TSConstructSignatureDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `122`]]] = js.undefined
    
    var TSConstructorType: js.UndefOr[VisitNode[S, Extract[Node, `213`]]] = js.undefined
    
    var TSDeclareFunction: js.UndefOr[VisitNode[S, Extract[Node, `201`]]] = js.undefined
    
    var TSDeclareMethod: js.UndefOr[VisitNode[S, Extract[Node, `77`]]] = js.undefined
    
    var TSEntityName: js.UndefOr[VisitNode[S, typings.babelTypes.mod.TSEntityName]] = js.undefined
    
    var TSEnumDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `91`]]] = js.undefined
    
    var TSEnumMember: js.UndefOr[VisitNode[S, Extract[Node, `133`]]] = js.undefined
    
    var TSExportAssignment: js.UndefOr[VisitNode[S, Extract[Node, `145`]]] = js.undefined
    
    var TSExpressionWithTypeArguments: js.UndefOr[VisitNode[S, Extract[Node, `149`]]] = js.undefined
    
    var TSExternalModuleReference: js.UndefOr[VisitNode[S, Extract[Node, `121`]]] = js.undefined
    
    var TSFunctionType: js.UndefOr[VisitNode[S, Extract[Node, `42`]]] = js.undefined
    
    var TSImportEqualsDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `160`]]] = js.undefined
    
    var TSImportType: js.UndefOr[VisitNode[S, Extract[Node, `241`]]] = js.undefined
    
    var TSIndexSignature: js.UndefOr[VisitNode[S, Extract[Node, `207`]]] = js.undefined
    
    var TSIndexedAccessType: js.UndefOr[VisitNode[S, Extract[Node, `29`]]] = js.undefined
    
    var TSInferType: js.UndefOr[VisitNode[S, Extract[Node, `104`]]] = js.undefined
    
    var TSInstantiationExpression: js.UndefOr[VisitNode[S, Extract[Node, `216`]]] = js.undefined
    
    var TSInterfaceBody: js.UndefOr[VisitNode[S, Extract[Node, `7`]]] = js.undefined
    
    var TSInterfaceDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `187`]]] = js.undefined
    
    var TSIntersectionType: js.UndefOr[VisitNode[S, Extract[Node, `238`]]] = js.undefined
    
    var TSIntrinsicKeyword: js.UndefOr[VisitNode[S, Extract[Node, `66`]]] = js.undefined
    
    var TSLiteralType: js.UndefOr[VisitNode[S, Extract[Node, `20`]]] = js.undefined
    
    var TSMappedType: js.UndefOr[VisitNode[S, Extract[Node, `128`]]] = js.undefined
    
    var TSMethodSignature: js.UndefOr[VisitNode[S, Extract[Node, `203`]]] = js.undefined
    
    var TSModuleBlock: js.UndefOr[VisitNode[S, Extract[Node, `231`]]] = js.undefined
    
    var TSModuleDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `16`]]] = js.undefined
    
    var TSNamedTupleMember: js.UndefOr[VisitNode[S, Extract[Node, `222`]]] = js.undefined
    
    var TSNamespaceExportDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `90`]]] = js.undefined
    
    var TSNeverKeyword: js.UndefOr[VisitNode[S, Extract[Node, `237`]]] = js.undefined
    
    var TSNonNullExpression: js.UndefOr[VisitNode[S, Extract[Node, `97`]]] = js.undefined
    
    var TSNullKeyword: js.UndefOr[VisitNode[S, Extract[Node, `33`]]] = js.undefined
    
    var TSNumberKeyword: js.UndefOr[VisitNode[S, Extract[Node, `181`]]] = js.undefined
    
    var TSObjectKeyword: js.UndefOr[VisitNode[S, Extract[Node, `218`]]] = js.undefined
    
    var TSOptionalType: js.UndefOr[VisitNode[S, Extract[Node, `185`]]] = js.undefined
    
    var TSParameterProperty: js.UndefOr[VisitNode[S, Extract[Node, `196`]]] = js.undefined
    
    var TSParenthesizedType: js.UndefOr[VisitNode[S, Extract[Node, `227`]]] = js.undefined
    
    var TSPropertySignature: js.UndefOr[VisitNode[S, Extract[Node, `118`]]] = js.undefined
    
    var TSQualifiedName: js.UndefOr[VisitNode[S, Extract[Node, `30`]]] = js.undefined
    
    var TSRestType: js.UndefOr[VisitNode[S, Extract[Node, `210`]]] = js.undefined
    
    var TSSatisfiesExpression: js.UndefOr[VisitNode[S, Extract[Node, `6`]]] = js.undefined
    
    var TSStringKeyword: js.UndefOr[VisitNode[S, Extract[Node, `101`]]] = js.undefined
    
    var TSSymbolKeyword: js.UndefOr[VisitNode[S, Extract[Node, `127`]]] = js.undefined
    
    var TSThisType: js.UndefOr[VisitNode[S, Extract[Node, `208`]]] = js.undefined
    
    var TSTupleType: js.UndefOr[VisitNode[S, Extract[Node, `199`]]] = js.undefined
    
    var TSType: js.UndefOr[VisitNode[S, typings.babelTypes.mod.TSType]] = js.undefined
    
    var TSTypeAliasDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `92`]]] = js.undefined
    
    var TSTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `112`]]] = js.undefined
    
    var TSTypeAssertion: js.UndefOr[VisitNode[S, Extract[Node, `236`]]] = js.undefined
    
    var TSTypeElement: js.UndefOr[VisitNode[S, typings.babelTypes.mod.TSTypeElement]] = js.undefined
    
    var TSTypeLiteral: js.UndefOr[VisitNode[S, Extract[Node, `156`]]] = js.undefined
    
    var TSTypeOperator: js.UndefOr[VisitNode[S, Extract[Node, `52`]]] = js.undefined
    
    var TSTypeParameter: js.UndefOr[VisitNode[S, Extract[Node, `94`]]] = js.undefined
    
    var TSTypeParameterDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `21`]]] = js.undefined
    
    var TSTypeParameterInstantiation: js.UndefOr[VisitNode[S, Extract[Node, `76`]]] = js.undefined
    
    var TSTypePredicate: js.UndefOr[VisitNode[S, Extract[Node, `186`]]] = js.undefined
    
    var TSTypeQuery: js.UndefOr[VisitNode[S, Extract[Node, `120`]]] = js.undefined
    
    var TSTypeReference: js.UndefOr[VisitNode[S, Extract[Node, `247`]]] = js.undefined
    
    var TSUndefinedKeyword: js.UndefOr[VisitNode[S, Extract[Node, `169`]]] = js.undefined
    
    var TSUnionType: js.UndefOr[VisitNode[S, Extract[Node, `93`]]] = js.undefined
    
    var TSUnknownKeyword: js.UndefOr[VisitNode[S, Extract[Node, `55`]]] = js.undefined
    
    var TSVoidKeyword: js.UndefOr[VisitNode[S, Extract[Node, `58`]]] = js.undefined
    
    var TaggedTemplateExpression: js.UndefOr[VisitNode[S, Extract[Node, `72`]]] = js.undefined
    
    var TemplateElement: js.UndefOr[VisitNode[S, Extract[Node, `194`]]] = js.undefined
    
    var TemplateLiteral: js.UndefOr[VisitNode[S, Extract[Node, `78`]]] = js.undefined
    
    var Terminatorless: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Terminatorless]] = js.undefined
    
    var ThisExpression: js.UndefOr[VisitNode[S, Extract[Node, `234`]]] = js.undefined
    
    var ThisTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `51`]]] = js.undefined
    
    var ThrowStatement: js.UndefOr[VisitNode[S, Extract[Node, `140`]]] = js.undefined
    
    var TopicReference: js.UndefOr[VisitNode[S, Extract[Node, `102`]]] = js.undefined
    
    var TryStatement: js.UndefOr[VisitNode[S, Extract[Node, `24`]]] = js.undefined
    
    var TupleExpression: js.UndefOr[VisitNode[S, Extract[Node, `209`]]] = js.undefined
    
    var TupleTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `14`]]] = js.undefined
    
    var TypeAlias: js.UndefOr[VisitNode[S, Extract[Node, `180`]]] = js.undefined
    
    var TypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `22`]]] = js.undefined
    
    var TypeCastExpression: js.UndefOr[VisitNode[S, Extract[Node, `11`]]] = js.undefined
    
    var TypeParameter: js.UndefOr[VisitNode[S, Extract[Node, `173`]]] = js.undefined
    
    var TypeParameterDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `15`]]] = js.undefined
    
    var TypeParameterInstantiation: js.UndefOr[VisitNode[S, Extract[Node, `246`]]] = js.undefined
    
    var TypeScript: js.UndefOr[VisitNode[S, typings.babelTypes.mod.TypeScript]] = js.undefined
    
    var TypeofTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `150`]]] = js.undefined
    
    var UnaryExpression: js.UndefOr[VisitNode[S, Extract[Node, `177`]]] = js.undefined
    
    var UnaryLike: js.UndefOr[VisitNode[S, typings.babelTypes.mod.UnaryLike]] = js.undefined
    
    var UnionTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `221`]]] = js.undefined
    
    var UpdateExpression: js.UndefOr[VisitNode[S, Extract[Node, `100`]]] = js.undefined
    
    var User: js.UndefOr[VisitNode[S, Node]] = js.undefined
    
    var UserWhitespacable: js.UndefOr[VisitNode[S, typings.babelTypes.mod.UserWhitespacable]] = js.undefined
    
    var V8IntrinsicIdentifier: js.UndefOr[VisitNode[S, Extract[Node, `141`]]] = js.undefined
    
    var Var: js.UndefOr[VisitNode[S, VariableDeclaration_]] = js.undefined
    
    var VariableDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `68`]]] = js.undefined
    
    var VariableDeclarator: js.UndefOr[VisitNode[S, Extract[Node, `130`]]] = js.undefined
    
    var Variance: js.UndefOr[VisitNode[S, Extract[Node, `153`]]] = js.undefined
    
    var VoidTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `107`]]] = js.undefined
    
    var While: js.UndefOr[VisitNode[S, typings.babelTypes.mod.While]] = js.undefined
    
    var WhileStatement: js.UndefOr[VisitNode[S, Extract[Node, `39`]]] = js.undefined
    
    var WithStatement: js.UndefOr[VisitNode[S, Extract[Node, `96`]]] = js.undefined
    
    var YieldExpression: js.UndefOr[VisitNode[S, Extract[Node, `12`]]] = js.undefined
    
    /** @deprecated will be removed in Babel 8 */
    var blacklist: js.UndefOr[js.Array[NodeType]] = js.undefined
    
    var denylist: js.UndefOr[js.Array[NodeType]] = js.undefined
    
    var enter: js.UndefOr[VisitNodeFunction[S, Node]] = js.undefined
    
    var exit: js.UndefOr[VisitNodeFunction[S, Node]] = js.undefined
    
    var noScope: js.UndefOr[Boolean] = js.undefined
    
    var scope: js.UndefOr[Scope] = js.undefined
    
    var shouldSkip: js.UndefOr[js.Function1[/* node */ NodePath[Node], Boolean]] = js.undefined
  }
  object TraverseOptions {
    
    inline def apply[S](Object: js.Object): TraverseOptions[S] = {
      val __obj = js.Dynamic.literal()
      js.Dynamic.global.Object.assign(__obj, Object)
      __obj.asInstanceOf[TraverseOptions[S]]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: TraverseOptions[?], S] (val x: Self & TraverseOptions[S]) extends AnyVal {
      
      inline def setAccessor(value: VisitNode[S, Accessor]): Self = StObject.set(x, "Accessor", value.asInstanceOf[js.Any])
      
      inline def setAccessorUndefined: Self = StObject.set(x, "Accessor", js.undefined)
      
      inline def setAnyTypeAnnotation(value: VisitNode[S, Extract[Node, `65`]]): Self = StObject.set(x, "AnyTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setAnyTypeAnnotationUndefined: Self = StObject.set(x, "AnyTypeAnnotation", js.undefined)
      
      inline def setArgumentPlaceholder(value: VisitNode[S, Extract[Node, `239`]]): Self = StObject.set(x, "ArgumentPlaceholder", value.asInstanceOf[js.Any])
      
      inline def setArgumentPlaceholderUndefined: Self = StObject.set(x, "ArgumentPlaceholder", js.undefined)
      
      inline def setArrayExpression(value: VisitNode[S, Extract[Node, `56`]]): Self = StObject.set(x, "ArrayExpression", value.asInstanceOf[js.Any])
      
      inline def setArrayExpressionUndefined: Self = StObject.set(x, "ArrayExpression", js.undefined)
      
      inline def setArrayPattern(value: VisitNode[S, Extract[Node, `115`]]): Self = StObject.set(x, "ArrayPattern", value.asInstanceOf[js.Any])
      
      inline def setArrayPatternUndefined: Self = StObject.set(x, "ArrayPattern", js.undefined)
      
      inline def setArrayTypeAnnotation(value: VisitNode[S, Extract[Node, `86`]]): Self = StObject.set(x, "ArrayTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setArrayTypeAnnotationUndefined: Self = StObject.set(x, "ArrayTypeAnnotation", js.undefined)
      
      inline def setArrowFunctionExpression(value: VisitNode[S, Extract[Node, `147`]]): Self = StObject.set(x, "ArrowFunctionExpression", value.asInstanceOf[js.Any])
      
      inline def setArrowFunctionExpressionUndefined: Self = StObject.set(x, "ArrowFunctionExpression", js.undefined)
      
      inline def setAssignmentExpression(value: VisitNode[S, Extract[Node, `135`]]): Self = StObject.set(x, "AssignmentExpression", value.asInstanceOf[js.Any])
      
      inline def setAssignmentExpressionUndefined: Self = StObject.set(x, "AssignmentExpression", js.undefined)
      
      inline def setAssignmentPattern(value: VisitNode[S, Extract[Node, `64`]]): Self = StObject.set(x, "AssignmentPattern", value.asInstanceOf[js.Any])
      
      inline def setAssignmentPatternUndefined: Self = StObject.set(x, "AssignmentPattern", js.undefined)
      
      inline def setAwaitExpression(value: VisitNode[S, Extract[Node, `113`]]): Self = StObject.set(x, "AwaitExpression", value.asInstanceOf[js.Any])
      
      inline def setAwaitExpressionUndefined: Self = StObject.set(x, "AwaitExpression", js.undefined)
      
      inline def setBigIntLiteral(value: VisitNode[S, Extract[Node, `184`]]): Self = StObject.set(x, "BigIntLiteral", value.asInstanceOf[js.Any])
      
      inline def setBigIntLiteralUndefined: Self = StObject.set(x, "BigIntLiteral", js.undefined)
      
      inline def setBinary(value: VisitNode[S, Binary]): Self = StObject.set(x, "Binary", value.asInstanceOf[js.Any])
      
      inline def setBinaryExpression(value: VisitNode[S, Extract[Node, `89`]]): Self = StObject.set(x, "BinaryExpression", value.asInstanceOf[js.Any])
      
      inline def setBinaryExpressionUndefined: Self = StObject.set(x, "BinaryExpression", js.undefined)
      
      inline def setBinaryUndefined: Self = StObject.set(x, "Binary", js.undefined)
      
      inline def setBindExpression(value: VisitNode[S, Extract[Node, `79`]]): Self = StObject.set(x, "BindExpression", value.asInstanceOf[js.Any])
      
      inline def setBindExpressionUndefined: Self = StObject.set(x, "BindExpression", js.undefined)
      
      inline def setBindingIdentifier(value: VisitNode[S, Identifier_]): Self = StObject.set(x, "BindingIdentifier", value.asInstanceOf[js.Any])
      
      inline def setBindingIdentifierUndefined: Self = StObject.set(x, "BindingIdentifier", js.undefined)
      
      inline def setBlacklist(value: js.Array[NodeType]): Self = StObject.set(x, "blacklist", value.asInstanceOf[js.Any])
      
      inline def setBlacklistUndefined: Self = StObject.set(x, "blacklist", js.undefined)
      
      inline def setBlacklistVarargs(value: NodeType*): Self = StObject.set(x, "blacklist", js.Array(value*))
      
      inline def setBlock(value: VisitNode[S, Block]): Self = StObject.set(x, "Block", value.asInstanceOf[js.Any])
      
      inline def setBlockParent(value: VisitNode[S, BlockParent]): Self = StObject.set(x, "BlockParent", value.asInstanceOf[js.Any])
      
      inline def setBlockParentUndefined: Self = StObject.set(x, "BlockParent", js.undefined)
      
      inline def setBlockScoped(value: VisitNode[S, Node]): Self = StObject.set(x, "BlockScoped", value.asInstanceOf[js.Any])
      
      inline def setBlockScopedUndefined: Self = StObject.set(x, "BlockScoped", js.undefined)
      
      inline def setBlockStatement(value: VisitNode[S, Extract[Node, `25`]]): Self = StObject.set(x, "BlockStatement", value.asInstanceOf[js.Any])
      
      inline def setBlockStatementUndefined: Self = StObject.set(x, "BlockStatement", js.undefined)
      
      inline def setBlockUndefined: Self = StObject.set(x, "Block", js.undefined)
      
      inline def setBooleanLiteral(value: VisitNode[S, Extract[Node, `132`]]): Self = StObject.set(x, "BooleanLiteral", value.asInstanceOf[js.Any])
      
      inline def setBooleanLiteralTypeAnnotation(value: VisitNode[S, Extract[Node, `178`]]): Self = StObject.set(x, "BooleanLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setBooleanLiteralTypeAnnotationUndefined: Self = StObject.set(x, "BooleanLiteralTypeAnnotation", js.undefined)
      
      inline def setBooleanLiteralUndefined: Self = StObject.set(x, "BooleanLiteral", js.undefined)
      
      inline def setBooleanTypeAnnotation(value: VisitNode[S, Extract[Node, `183`]]): Self = StObject.set(x, "BooleanTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setBooleanTypeAnnotationUndefined: Self = StObject.set(x, "BooleanTypeAnnotation", js.undefined)
      
      inline def setBreakStatement(value: VisitNode[S, Extract[Node, `1`]]): Self = StObject.set(x, "BreakStatement", value.asInstanceOf[js.Any])
      
      inline def setBreakStatementUndefined: Self = StObject.set(x, "BreakStatement", js.undefined)
      
      inline def setCallExpression(value: VisitNode[S, Extract[Node, `47`]]): Self = StObject.set(x, "CallExpression", value.asInstanceOf[js.Any])
      
      inline def setCallExpressionUndefined: Self = StObject.set(x, "CallExpression", js.undefined)
      
      inline def setCatchClause(value: VisitNode[S, Extract[Node, `176`]]): Self = StObject.set(x, "CatchClause", value.asInstanceOf[js.Any])
      
      inline def setCatchClauseUndefined: Self = StObject.set(x, "CatchClause", js.undefined)
      
      inline def setClass(value: VisitNode[S, Class]): Self = StObject.set(x, "Class", value.asInstanceOf[js.Any])
      
      inline def setClassAccessorProperty(value: VisitNode[S, Extract[Node, `214`]]): Self = StObject.set(x, "ClassAccessorProperty", value.asInstanceOf[js.Any])
      
      inline def setClassAccessorPropertyUndefined: Self = StObject.set(x, "ClassAccessorProperty", js.undefined)
      
      inline def setClassBody(value: VisitNode[S, Extract[Node, `232`]]): Self = StObject.set(x, "ClassBody", value.asInstanceOf[js.Any])
      
      inline def setClassBodyUndefined: Self = StObject.set(x, "ClassBody", js.undefined)
      
      inline def setClassDeclaration(value: VisitNode[S, Extract[Node, `109`]]): Self = StObject.set(x, "ClassDeclaration", value.asInstanceOf[js.Any])
      
      inline def setClassDeclarationUndefined: Self = StObject.set(x, "ClassDeclaration", js.undefined)
      
      inline def setClassExpression(value: VisitNode[S, Extract[Node, Type]]): Self = StObject.set(x, "ClassExpression", value.asInstanceOf[js.Any])
      
      inline def setClassExpressionUndefined: Self = StObject.set(x, "ClassExpression", js.undefined)
      
      inline def setClassImplements(value: VisitNode[S, Extract[Node, `212`]]): Self = StObject.set(x, "ClassImplements", value.asInstanceOf[js.Any])
      
      inline def setClassImplementsUndefined: Self = StObject.set(x, "ClassImplements", js.undefined)
      
      inline def setClassMethod(value: VisitNode[S, Extract[Node, `189`]]): Self = StObject.set(x, "ClassMethod", value.asInstanceOf[js.Any])
      
      inline def setClassMethodUndefined: Self = StObject.set(x, "ClassMethod", js.undefined)
      
      inline def setClassPrivateMethod(value: VisitNode[S, Extract[Node, `235`]]): Self = StObject.set(x, "ClassPrivateMethod", value.asInstanceOf[js.Any])
      
      inline def setClassPrivateMethodUndefined: Self = StObject.set(x, "ClassPrivateMethod", js.undefined)
      
      inline def setClassPrivateProperty(value: VisitNode[S, Extract[Node, `230`]]): Self = StObject.set(x, "ClassPrivateProperty", value.asInstanceOf[js.Any])
      
      inline def setClassPrivatePropertyUndefined: Self = StObject.set(x, "ClassPrivateProperty", js.undefined)
      
      inline def setClassProperty(value: VisitNode[S, Extract[Node, `192`]]): Self = StObject.set(x, "ClassProperty", value.asInstanceOf[js.Any])
      
      inline def setClassPropertyUndefined: Self = StObject.set(x, "ClassProperty", js.undefined)
      
      inline def setClassUndefined: Self = StObject.set(x, "Class", js.undefined)
      
      inline def setCompletionStatement(value: VisitNode[S, CompletionStatement]): Self = StObject.set(x, "CompletionStatement", value.asInstanceOf[js.Any])
      
      inline def setCompletionStatementUndefined: Self = StObject.set(x, "CompletionStatement", js.undefined)
      
      inline def setConditional(value: VisitNode[S, Conditional]): Self = StObject.set(x, "Conditional", value.asInstanceOf[js.Any])
      
      inline def setConditionalExpression(value: VisitNode[S, Extract[Node, `170`]]): Self = StObject.set(x, "ConditionalExpression", value.asInstanceOf[js.Any])
      
      inline def setConditionalExpressionUndefined: Self = StObject.set(x, "ConditionalExpression", js.undefined)
      
      inline def setConditionalUndefined: Self = StObject.set(x, "Conditional", js.undefined)
      
      inline def setContinueStatement(value: VisitNode[S, Extract[Node, `40`]]): Self = StObject.set(x, "ContinueStatement", value.asInstanceOf[js.Any])
      
      inline def setContinueStatementUndefined: Self = StObject.set(x, "ContinueStatement", js.undefined)
      
      inline def setDebuggerStatement(value: VisitNode[S, Extract[Node, `138`]]): Self = StObject.set(x, "DebuggerStatement", value.asInstanceOf[js.Any])
      
      inline def setDebuggerStatementUndefined: Self = StObject.set(x, "DebuggerStatement", js.undefined)
      
      inline def setDecimalLiteral(value: VisitNode[S, Extract[Node, `206`]]): Self = StObject.set(x, "DecimalLiteral", value.asInstanceOf[js.Any])
      
      inline def setDecimalLiteralUndefined: Self = StObject.set(x, "DecimalLiteral", js.undefined)
      
      inline def setDeclaration(value: VisitNode[S, Declaration]): Self = StObject.set(x, "Declaration", value.asInstanceOf[js.Any])
      
      inline def setDeclarationUndefined: Self = StObject.set(x, "Declaration", js.undefined)
      
      inline def setDeclareClass(value: VisitNode[S, Extract[Node, `242`]]): Self = StObject.set(x, "DeclareClass", value.asInstanceOf[js.Any])
      
      inline def setDeclareClassUndefined: Self = StObject.set(x, "DeclareClass", js.undefined)
      
      inline def setDeclareExportAllDeclaration(value: VisitNode[S, Extract[Node, `110`]]): Self = StObject.set(x, "DeclareExportAllDeclaration", value.asInstanceOf[js.Any])
      
      inline def setDeclareExportAllDeclarationUndefined: Self = StObject.set(x, "DeclareExportAllDeclaration", js.undefined)
      
      inline def setDeclareExportDeclaration(value: VisitNode[S, Extract[Node, `158`]]): Self = StObject.set(x, "DeclareExportDeclaration", value.asInstanceOf[js.Any])
      
      inline def setDeclareExportDeclarationUndefined: Self = StObject.set(x, "DeclareExportDeclaration", js.undefined)
      
      inline def setDeclareFunction(value: VisitNode[S, Extract[Node, `105`]]): Self = StObject.set(x, "DeclareFunction", value.asInstanceOf[js.Any])
      
      inline def setDeclareFunctionUndefined: Self = StObject.set(x, "DeclareFunction", js.undefined)
      
      inline def setDeclareInterface(value: VisitNode[S, Extract[Node, `161`]]): Self = StObject.set(x, "DeclareInterface", value.asInstanceOf[js.Any])
      
      inline def setDeclareInterfaceUndefined: Self = StObject.set(x, "DeclareInterface", js.undefined)
      
      inline def setDeclareModule(value: VisitNode[S, Extract[Node, `35`]]): Self = StObject.set(x, "DeclareModule", value.asInstanceOf[js.Any])
      
      inline def setDeclareModuleExports(value: VisitNode[S, Extract[Node, `223`]]): Self = StObject.set(x, "DeclareModuleExports", value.asInstanceOf[js.Any])
      
      inline def setDeclareModuleExportsUndefined: Self = StObject.set(x, "DeclareModuleExports", js.undefined)
      
      inline def setDeclareModuleUndefined: Self = StObject.set(x, "DeclareModule", js.undefined)
      
      inline def setDeclareOpaqueType(value: VisitNode[S, Extract[Node, `229`]]): Self = StObject.set(x, "DeclareOpaqueType", value.asInstanceOf[js.Any])
      
      inline def setDeclareOpaqueTypeUndefined: Self = StObject.set(x, "DeclareOpaqueType", js.undefined)
      
      inline def setDeclareTypeAlias(value: VisitNode[S, Extract[Node, `167`]]): Self = StObject.set(x, "DeclareTypeAlias", value.asInstanceOf[js.Any])
      
      inline def setDeclareTypeAliasUndefined: Self = StObject.set(x, "DeclareTypeAlias", js.undefined)
      
      inline def setDeclareVariable(value: VisitNode[S, Extract[Node, `182`]]): Self = StObject.set(x, "DeclareVariable", value.asInstanceOf[js.Any])
      
      inline def setDeclareVariableUndefined: Self = StObject.set(x, "DeclareVariable", js.undefined)
      
      inline def setDeclaredPredicate(value: VisitNode[S, Extract[Node, `188`]]): Self = StObject.set(x, "DeclaredPredicate", value.asInstanceOf[js.Any])
      
      inline def setDeclaredPredicateUndefined: Self = StObject.set(x, "DeclaredPredicate", js.undefined)
      
      inline def setDecorator(value: VisitNode[S, Extract[Node, `82`]]): Self = StObject.set(x, "Decorator", value.asInstanceOf[js.Any])
      
      inline def setDecoratorUndefined: Self = StObject.set(x, "Decorator", js.undefined)
      
      inline def setDenylist(value: js.Array[NodeType]): Self = StObject.set(x, "denylist", value.asInstanceOf[js.Any])
      
      inline def setDenylistUndefined: Self = StObject.set(x, "denylist", js.undefined)
      
      inline def setDenylistVarargs(value: NodeType*): Self = StObject.set(x, "denylist", js.Array(value*))
      
      inline def setDirective(value: VisitNode[S, Extract[Node, `63`]]): Self = StObject.set(x, "Directive", value.asInstanceOf[js.Any])
      
      inline def setDirectiveLiteral(value: VisitNode[S, Extract[Node, `143`]]): Self = StObject.set(x, "DirectiveLiteral", value.asInstanceOf[js.Any])
      
      inline def setDirectiveLiteralUndefined: Self = StObject.set(x, "DirectiveLiteral", js.undefined)
      
      inline def setDirectiveUndefined: Self = StObject.set(x, "Directive", js.undefined)
      
      inline def setDoExpression(value: VisitNode[S, Extract[Node, `219`]]): Self = StObject.set(x, "DoExpression", value.asInstanceOf[js.Any])
      
      inline def setDoExpressionUndefined: Self = StObject.set(x, "DoExpression", js.undefined)
      
      inline def setDoWhileStatement(value: VisitNode[S, Extract[Node, `200`]]): Self = StObject.set(x, "DoWhileStatement", value.asInstanceOf[js.Any])
      
      inline def setDoWhileStatementUndefined: Self = StObject.set(x, "DoWhileStatement", js.undefined)
      
      inline def setEmptyStatement(value: VisitNode[S, Extract[Node, `108`]]): Self = StObject.set(x, "EmptyStatement", value.asInstanceOf[js.Any])
      
      inline def setEmptyStatementUndefined: Self = StObject.set(x, "EmptyStatement", js.undefined)
      
      inline def setEmptyTypeAnnotation(value: VisitNode[S, Extract[Node, `142`]]): Self = StObject.set(x, "EmptyTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setEmptyTypeAnnotationUndefined: Self = StObject.set(x, "EmptyTypeAnnotation", js.undefined)
      
      inline def setEnter(value: VisitNodeFunction[S, Node]): Self = StObject.set(x, "enter", value.asInstanceOf[js.Any])
      
      inline def setEnterUndefined: Self = StObject.set(x, "enter", js.undefined)
      
      inline def setEnumBody(value: VisitNode[S, EnumBody]): Self = StObject.set(x, "EnumBody", value.asInstanceOf[js.Any])
      
      inline def setEnumBodyUndefined: Self = StObject.set(x, "EnumBody", js.undefined)
      
      inline def setEnumBooleanBody(value: VisitNode[S, Extract[Node, `137`]]): Self = StObject.set(x, "EnumBooleanBody", value.asInstanceOf[js.Any])
      
      inline def setEnumBooleanBodyUndefined: Self = StObject.set(x, "EnumBooleanBody", js.undefined)
      
      inline def setEnumBooleanMember(value: VisitNode[S, Extract[Node, `117`]]): Self = StObject.set(x, "EnumBooleanMember", value.asInstanceOf[js.Any])
      
      inline def setEnumBooleanMemberUndefined: Self = StObject.set(x, "EnumBooleanMember", js.undefined)
      
      inline def setEnumDeclaration(value: VisitNode[S, Extract[Node, `67`]]): Self = StObject.set(x, "EnumDeclaration", value.asInstanceOf[js.Any])
      
      inline def setEnumDeclarationUndefined: Self = StObject.set(x, "EnumDeclaration", js.undefined)
      
      inline def setEnumDefaultedMember(value: VisitNode[S, Extract[Node, `191`]]): Self = StObject.set(x, "EnumDefaultedMember", value.asInstanceOf[js.Any])
      
      inline def setEnumDefaultedMemberUndefined: Self = StObject.set(x, "EnumDefaultedMember", js.undefined)
      
      inline def setEnumMember(value: VisitNode[S, EnumMember]): Self = StObject.set(x, "EnumMember", value.asInstanceOf[js.Any])
      
      inline def setEnumMemberUndefined: Self = StObject.set(x, "EnumMember", js.undefined)
      
      inline def setEnumNumberBody(value: VisitNode[S, Extract[Node, `240`]]): Self = StObject.set(x, "EnumNumberBody", value.asInstanceOf[js.Any])
      
      inline def setEnumNumberBodyUndefined: Self = StObject.set(x, "EnumNumberBody", js.undefined)
      
      inline def setEnumNumberMember(value: VisitNode[S, Extract[Node, `205`]]): Self = StObject.set(x, "EnumNumberMember", value.asInstanceOf[js.Any])
      
      inline def setEnumNumberMemberUndefined: Self = StObject.set(x, "EnumNumberMember", js.undefined)
      
      inline def setEnumStringBody(value: VisitNode[S, Extract[Node, `163`]]): Self = StObject.set(x, "EnumStringBody", value.asInstanceOf[js.Any])
      
      inline def setEnumStringBodyUndefined: Self = StObject.set(x, "EnumStringBody", js.undefined)
      
      inline def setEnumStringMember(value: VisitNode[S, Extract[Node, `4`]]): Self = StObject.set(x, "EnumStringMember", value.asInstanceOf[js.Any])
      
      inline def setEnumStringMemberUndefined: Self = StObject.set(x, "EnumStringMember", js.undefined)
      
      inline def setEnumSymbolBody(value: VisitNode[S, Extract[Node, `198`]]): Self = StObject.set(x, "EnumSymbolBody", value.asInstanceOf[js.Any])
      
      inline def setEnumSymbolBodyUndefined: Self = StObject.set(x, "EnumSymbolBody", js.undefined)
      
      inline def setExistentialTypeParam(value: VisitNode[S, ExistsTypeAnnotation_]): Self = StObject.set(x, "ExistentialTypeParam", value.asInstanceOf[js.Any])
      
      inline def setExistentialTypeParamUndefined: Self = StObject.set(x, "ExistentialTypeParam", js.undefined)
      
      inline def setExistsTypeAnnotation(value: VisitNode[S, Extract[Node, `119`]]): Self = StObject.set(x, "ExistsTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setExistsTypeAnnotationUndefined: Self = StObject.set(x, "ExistsTypeAnnotation", js.undefined)
      
      inline def setExit(value: VisitNodeFunction[S, Node]): Self = StObject.set(x, "exit", value.asInstanceOf[js.Any])
      
      inline def setExitUndefined: Self = StObject.set(x, "exit", js.undefined)
      
      inline def setExportAllDeclaration(value: VisitNode[S, Extract[Node, `37`]]): Self = StObject.set(x, "ExportAllDeclaration", value.asInstanceOf[js.Any])
      
      inline def setExportAllDeclarationUndefined: Self = StObject.set(x, "ExportAllDeclaration", js.undefined)
      
      inline def setExportDeclaration(value: VisitNode[S, ExportDeclaration]): Self = StObject.set(x, "ExportDeclaration", value.asInstanceOf[js.Any])
      
      inline def setExportDeclarationUndefined: Self = StObject.set(x, "ExportDeclaration", js.undefined)
      
      inline def setExportDefaultDeclaration(value: VisitNode[S, Extract[Node, `80`]]): Self = StObject.set(x, "ExportDefaultDeclaration", value.asInstanceOf[js.Any])
      
      inline def setExportDefaultDeclarationUndefined: Self = StObject.set(x, "ExportDefaultDeclaration", js.undefined)
      
      inline def setExportDefaultSpecifier(value: VisitNode[S, Extract[Node, `3`]]): Self = StObject.set(x, "ExportDefaultSpecifier", value.asInstanceOf[js.Any])
      
      inline def setExportDefaultSpecifierUndefined: Self = StObject.set(x, "ExportDefaultSpecifier", js.undefined)
      
      inline def setExportNamedDeclaration(value: VisitNode[S, Extract[Node, `46`]]): Self = StObject.set(x, "ExportNamedDeclaration", value.asInstanceOf[js.Any])
      
      inline def setExportNamedDeclarationUndefined: Self = StObject.set(x, "ExportNamedDeclaration", js.undefined)
      
      inline def setExportNamespaceSpecifier(value: VisitNode[S, Extract[Node, `179`]]): Self = StObject.set(x, "ExportNamespaceSpecifier", value.asInstanceOf[js.Any])
      
      inline def setExportNamespaceSpecifierUndefined: Self = StObject.set(x, "ExportNamespaceSpecifier", js.undefined)
      
      inline def setExportSpecifier(value: VisitNode[S, Extract[Node, `116`]]): Self = StObject.set(x, "ExportSpecifier", value.asInstanceOf[js.Any])
      
      inline def setExportSpecifierUndefined: Self = StObject.set(x, "ExportSpecifier", js.undefined)
      
      inline def setExpression(value: VisitNode[S, Expression]): Self = StObject.set(x, "Expression", value.asInstanceOf[js.Any])
      
      inline def setExpressionStatement(value: VisitNode[S, Extract[Node, `62`]]): Self = StObject.set(x, "ExpressionStatement", value.asInstanceOf[js.Any])
      
      inline def setExpressionStatementUndefined: Self = StObject.set(x, "ExpressionStatement", js.undefined)
      
      inline def setExpressionUndefined: Self = StObject.set(x, "Expression", js.undefined)
      
      inline def setExpressionWrapper(value: VisitNode[S, ExpressionWrapper]): Self = StObject.set(x, "ExpressionWrapper", value.asInstanceOf[js.Any])
      
      inline def setExpressionWrapperUndefined: Self = StObject.set(x, "ExpressionWrapper", js.undefined)
      
      inline def setFile(value: VisitNode[S, Extract[Node, `28`]]): Self = StObject.set(x, "File", value.asInstanceOf[js.Any])
      
      inline def setFileUndefined: Self = StObject.set(x, "File", js.undefined)
      
      inline def setFlow(value: VisitNode[S, Flow]): Self = StObject.set(x, "Flow", value.asInstanceOf[js.Any])
      
      inline def setFlowBaseAnnotation(value: VisitNode[S, FlowBaseAnnotation]): Self = StObject.set(x, "FlowBaseAnnotation", value.asInstanceOf[js.Any])
      
      inline def setFlowBaseAnnotationUndefined: Self = StObject.set(x, "FlowBaseAnnotation", js.undefined)
      
      inline def setFlowDeclaration(value: VisitNode[S, FlowDeclaration]): Self = StObject.set(x, "FlowDeclaration", value.asInstanceOf[js.Any])
      
      inline def setFlowDeclarationUndefined: Self = StObject.set(x, "FlowDeclaration", js.undefined)
      
      inline def setFlowPredicate(value: VisitNode[S, FlowPredicate]): Self = StObject.set(x, "FlowPredicate", value.asInstanceOf[js.Any])
      
      inline def setFlowPredicateUndefined: Self = StObject.set(x, "FlowPredicate", js.undefined)
      
      inline def setFlowType(value: VisitNode[S, FlowType]): Self = StObject.set(x, "FlowType", value.asInstanceOf[js.Any])
      
      inline def setFlowTypeUndefined: Self = StObject.set(x, "FlowType", js.undefined)
      
      inline def setFlowUndefined: Self = StObject.set(x, "Flow", js.undefined)
      
      inline def setFor(value: VisitNode[S, For]): Self = StObject.set(x, "For", value.asInstanceOf[js.Any])
      
      inline def setForAwaitStatement(value: VisitNode[S, ForOfStatement_]): Self = StObject.set(x, "ForAwaitStatement", value.asInstanceOf[js.Any])
      
      inline def setForAwaitStatementUndefined: Self = StObject.set(x, "ForAwaitStatement", js.undefined)
      
      inline def setForInStatement(value: VisitNode[S, Extract[Node, `17`]]): Self = StObject.set(x, "ForInStatement", value.asInstanceOf[js.Any])
      
      inline def setForInStatementUndefined: Self = StObject.set(x, "ForInStatement", js.undefined)
      
      inline def setForOfStatement(value: VisitNode[S, Extract[Node, `166`]]): Self = StObject.set(x, "ForOfStatement", value.asInstanceOf[js.Any])
      
      inline def setForOfStatementUndefined: Self = StObject.set(x, "ForOfStatement", js.undefined)
      
      inline def setForStatement(value: VisitNode[S, Extract[Node, `190`]]): Self = StObject.set(x, "ForStatement", value.asInstanceOf[js.Any])
      
      inline def setForStatementUndefined: Self = StObject.set(x, "ForStatement", js.undefined)
      
      inline def setForUndefined: Self = StObject.set(x, "For", js.undefined)
      
      inline def setForXStatement(value: VisitNode[S, ForXStatement]): Self = StObject.set(x, "ForXStatement", value.asInstanceOf[js.Any])
      
      inline def setForXStatementUndefined: Self = StObject.set(x, "ForXStatement", js.undefined)
      
      inline def setFunction(value: VisitNode[S, Function]): Self = StObject.set(x, "Function", value.asInstanceOf[js.Any])
      
      inline def setFunctionDeclaration(value: VisitNode[S, Extract[Node, `136`]]): Self = StObject.set(x, "FunctionDeclaration", value.asInstanceOf[js.Any])
      
      inline def setFunctionDeclarationUndefined: Self = StObject.set(x, "FunctionDeclaration", js.undefined)
      
      inline def setFunctionExpression(value: VisitNode[S, Extract[Node, `193`]]): Self = StObject.set(x, "FunctionExpression", value.asInstanceOf[js.Any])
      
      inline def setFunctionExpressionUndefined: Self = StObject.set(x, "FunctionExpression", js.undefined)
      
      inline def setFunctionParent(value: VisitNode[S, FunctionParent]): Self = StObject.set(x, "FunctionParent", value.asInstanceOf[js.Any])
      
      inline def setFunctionParentUndefined: Self = StObject.set(x, "FunctionParent", js.undefined)
      
      inline def setFunctionTypeAnnotation(value: VisitNode[S, Extract[Node, `41`]]): Self = StObject.set(x, "FunctionTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setFunctionTypeAnnotationUndefined: Self = StObject.set(x, "FunctionTypeAnnotation", js.undefined)
      
      inline def setFunctionTypeParam(value: VisitNode[S, Extract[Node, `228`]]): Self = StObject.set(x, "FunctionTypeParam", value.asInstanceOf[js.Any])
      
      inline def setFunctionTypeParamUndefined: Self = StObject.set(x, "FunctionTypeParam", js.undefined)
      
      inline def setFunctionUndefined: Self = StObject.set(x, "Function", js.undefined)
      
      inline def setGenerated(value: VisitNode[S, Node]): Self = StObject.set(x, "Generated", value.asInstanceOf[js.Any])
      
      inline def setGeneratedUndefined: Self = StObject.set(x, "Generated", js.undefined)
      
      inline def setGenericTypeAnnotation(value: VisitNode[S, Extract[Node, `244`]]): Self = StObject.set(x, "GenericTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setGenericTypeAnnotationUndefined: Self = StObject.set(x, "GenericTypeAnnotation", js.undefined)
      
      inline def setIdentifier(value: VisitNode[S, Extract[Node, `99`]]): Self = StObject.set(x, "Identifier", value.asInstanceOf[js.Any])
      
      inline def setIdentifierUndefined: Self = StObject.set(x, "Identifier", js.undefined)
      
      inline def setIfStatement(value: VisitNode[S, Extract[Node, `85`]]): Self = StObject.set(x, "IfStatement", value.asInstanceOf[js.Any])
      
      inline def setIfStatementUndefined: Self = StObject.set(x, "IfStatement", js.undefined)
      
      inline def setImmutable(value: VisitNode[S, Immutable]): Self = StObject.set(x, "Immutable", value.asInstanceOf[js.Any])
      
      inline def setImmutableUndefined: Self = StObject.set(x, "Immutable", js.undefined)
      
      inline def setImport(value: VisitNode[S, Extract[Node, `172`]]): Self = StObject.set(x, "Import", value.asInstanceOf[js.Any])
      
      inline def setImportAttribute(value: VisitNode[S, Extract[Node, `123`]]): Self = StObject.set(x, "ImportAttribute", value.asInstanceOf[js.Any])
      
      inline def setImportAttributeUndefined: Self = StObject.set(x, "ImportAttribute", js.undefined)
      
      inline def setImportDeclaration(value: VisitNode[S, Extract[Node, `243`]]): Self = StObject.set(x, "ImportDeclaration", value.asInstanceOf[js.Any])
      
      inline def setImportDeclarationUndefined: Self = StObject.set(x, "ImportDeclaration", js.undefined)
      
      inline def setImportDefaultSpecifier(value: VisitNode[S, Extract[Node, `19`]]): Self = StObject.set(x, "ImportDefaultSpecifier", value.asInstanceOf[js.Any])
      
      inline def setImportDefaultSpecifierUndefined: Self = StObject.set(x, "ImportDefaultSpecifier", js.undefined)
      
      inline def setImportNamespaceSpecifier(value: VisitNode[S, Extract[Node, `202`]]): Self = StObject.set(x, "ImportNamespaceSpecifier", value.asInstanceOf[js.Any])
      
      inline def setImportNamespaceSpecifierUndefined: Self = StObject.set(x, "ImportNamespaceSpecifier", js.undefined)
      
      inline def setImportOrExportDeclaration(value: VisitNode[S, ImportOrExportDeclaration]): Self = StObject.set(x, "ImportOrExportDeclaration", value.asInstanceOf[js.Any])
      
      inline def setImportOrExportDeclarationUndefined: Self = StObject.set(x, "ImportOrExportDeclaration", js.undefined)
      
      inline def setImportSpecifier(value: VisitNode[S, Extract[Node, `114`]]): Self = StObject.set(x, "ImportSpecifier", value.asInstanceOf[js.Any])
      
      inline def setImportSpecifierUndefined: Self = StObject.set(x, "ImportSpecifier", js.undefined)
      
      inline def setImportUndefined: Self = StObject.set(x, "Import", js.undefined)
      
      inline def setIndexedAccessType(value: VisitNode[S, Extract[Node, `69`]]): Self = StObject.set(x, "IndexedAccessType", value.asInstanceOf[js.Any])
      
      inline def setIndexedAccessTypeUndefined: Self = StObject.set(x, "IndexedAccessType", js.undefined)
      
      inline def setInferredPredicate(value: VisitNode[S, Extract[Node, `134`]]): Self = StObject.set(x, "InferredPredicate", value.asInstanceOf[js.Any])
      
      inline def setInferredPredicateUndefined: Self = StObject.set(x, "InferredPredicate", js.undefined)
      
      inline def setInterfaceDeclaration(value: VisitNode[S, Extract[Node, `48`]]): Self = StObject.set(x, "InterfaceDeclaration", value.asInstanceOf[js.Any])
      
      inline def setInterfaceDeclarationUndefined: Self = StObject.set(x, "InterfaceDeclaration", js.undefined)
      
      inline def setInterfaceExtends(value: VisitNode[S, Extract[Node, `139`]]): Self = StObject.set(x, "InterfaceExtends", value.asInstanceOf[js.Any])
      
      inline def setInterfaceExtendsUndefined: Self = StObject.set(x, "InterfaceExtends", js.undefined)
      
      inline def setInterfaceTypeAnnotation(value: VisitNode[S, Extract[Node, `9`]]): Self = StObject.set(x, "InterfaceTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setInterfaceTypeAnnotationUndefined: Self = StObject.set(x, "InterfaceTypeAnnotation", js.undefined)
      
      inline def setInterpreterDirective(value: VisitNode[S, Extract[Node, `88`]]): Self = StObject.set(x, "InterpreterDirective", value.asInstanceOf[js.Any])
      
      inline def setInterpreterDirectiveUndefined: Self = StObject.set(x, "InterpreterDirective", js.undefined)
      
      inline def setIntersectionTypeAnnotation(value: VisitNode[S, Extract[Node, `215`]]): Self = StObject.set(x, "IntersectionTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setIntersectionTypeAnnotationUndefined: Self = StObject.set(x, "IntersectionTypeAnnotation", js.undefined)
      
      inline def setJSX(value: VisitNode[S, JSX]): Self = StObject.set(x, "JSX", value.asInstanceOf[js.Any])
      
      inline def setJSXAttribute(value: VisitNode[S, Extract[Node, `103`]]): Self = StObject.set(x, "JSXAttribute", value.asInstanceOf[js.Any])
      
      inline def setJSXAttributeUndefined: Self = StObject.set(x, "JSXAttribute", js.undefined)
      
      inline def setJSXClosingElement(value: VisitNode[S, Extract[Node, `129`]]): Self = StObject.set(x, "JSXClosingElement", value.asInstanceOf[js.Any])
      
      inline def setJSXClosingElementUndefined: Self = StObject.set(x, "JSXClosingElement", js.undefined)
      
      inline def setJSXClosingFragment(value: VisitNode[S, Extract[Node, `211`]]): Self = StObject.set(x, "JSXClosingFragment", value.asInstanceOf[js.Any])
      
      inline def setJSXClosingFragmentUndefined: Self = StObject.set(x, "JSXClosingFragment", js.undefined)
      
      inline def setJSXElement(value: VisitNode[S, Extract[Node, `174`]]): Self = StObject.set(x, "JSXElement", value.asInstanceOf[js.Any])
      
      inline def setJSXElementUndefined: Self = StObject.set(x, "JSXElement", js.undefined)
      
      inline def setJSXEmptyExpression(value: VisitNode[S, Extract[Node, `125`]]): Self = StObject.set(x, "JSXEmptyExpression", value.asInstanceOf[js.Any])
      
      inline def setJSXEmptyExpressionUndefined: Self = StObject.set(x, "JSXEmptyExpression", js.undefined)
      
      inline def setJSXExpressionContainer(value: VisitNode[S, Extract[Node, `32`]]): Self = StObject.set(x, "JSXExpressionContainer", value.asInstanceOf[js.Any])
      
      inline def setJSXExpressionContainerUndefined: Self = StObject.set(x, "JSXExpressionContainer", js.undefined)
      
      inline def setJSXFragment(value: VisitNode[S, Extract[Node, `152`]]): Self = StObject.set(x, "JSXFragment", value.asInstanceOf[js.Any])
      
      inline def setJSXFragmentUndefined: Self = StObject.set(x, "JSXFragment", js.undefined)
      
      inline def setJSXIdentifier(value: VisitNode[S, Extract[Node, `87`]]): Self = StObject.set(x, "JSXIdentifier", value.asInstanceOf[js.Any])
      
      inline def setJSXIdentifierUndefined: Self = StObject.set(x, "JSXIdentifier", js.undefined)
      
      inline def setJSXMemberExpression(value: VisitNode[S, Extract[Node, `197`]]): Self = StObject.set(x, "JSXMemberExpression", value.asInstanceOf[js.Any])
      
      inline def setJSXMemberExpressionUndefined: Self = StObject.set(x, "JSXMemberExpression", js.undefined)
      
      inline def setJSXNamespacedName(value: VisitNode[S, Extract[Node, `154`]]): Self = StObject.set(x, "JSXNamespacedName", value.asInstanceOf[js.Any])
      
      inline def setJSXNamespacedNameUndefined: Self = StObject.set(x, "JSXNamespacedName", js.undefined)
      
      inline def setJSXOpeningElement(value: VisitNode[S, Extract[Node, `74`]]): Self = StObject.set(x, "JSXOpeningElement", value.asInstanceOf[js.Any])
      
      inline def setJSXOpeningElementUndefined: Self = StObject.set(x, "JSXOpeningElement", js.undefined)
      
      inline def setJSXOpeningFragment(value: VisitNode[S, Extract[Node, `220`]]): Self = StObject.set(x, "JSXOpeningFragment", value.asInstanceOf[js.Any])
      
      inline def setJSXOpeningFragmentUndefined: Self = StObject.set(x, "JSXOpeningFragment", js.undefined)
      
      inline def setJSXSpreadAttribute(value: VisitNode[S, Extract[Node, `49`]]): Self = StObject.set(x, "JSXSpreadAttribute", value.asInstanceOf[js.Any])
      
      inline def setJSXSpreadAttributeUndefined: Self = StObject.set(x, "JSXSpreadAttribute", js.undefined)
      
      inline def setJSXSpreadChild(value: VisitNode[S, Extract[Node, `73`]]): Self = StObject.set(x, "JSXSpreadChild", value.asInstanceOf[js.Any])
      
      inline def setJSXSpreadChildUndefined: Self = StObject.set(x, "JSXSpreadChild", js.undefined)
      
      inline def setJSXText(value: VisitNode[S, Extract[Node, `195`]]): Self = StObject.set(x, "JSXText", value.asInstanceOf[js.Any])
      
      inline def setJSXTextUndefined: Self = StObject.set(x, "JSXText", js.undefined)
      
      inline def setJSXUndefined: Self = StObject.set(x, "JSX", js.undefined)
      
      inline def setLVal(value: VisitNode[S, LVal]): Self = StObject.set(x, "LVal", value.asInstanceOf[js.Any])
      
      inline def setLValUndefined: Self = StObject.set(x, "LVal", js.undefined)
      
      inline def setLabeledStatement(value: VisitNode[S, Extract[Node, `36`]]): Self = StObject.set(x, "LabeledStatement", value.asInstanceOf[js.Any])
      
      inline def setLabeledStatementUndefined: Self = StObject.set(x, "LabeledStatement", js.undefined)
      
      inline def setLiteral(value: VisitNode[S, Literal]): Self = StObject.set(x, "Literal", value.asInstanceOf[js.Any])
      
      inline def setLiteralUndefined: Self = StObject.set(x, "Literal", js.undefined)
      
      inline def setLogicalExpression(value: VisitNode[S, Extract[Node, `70`]]): Self = StObject.set(x, "LogicalExpression", value.asInstanceOf[js.Any])
      
      inline def setLogicalExpressionUndefined: Self = StObject.set(x, "LogicalExpression", js.undefined)
      
      inline def setLoop(value: VisitNode[S, Loop]): Self = StObject.set(x, "Loop", value.asInstanceOf[js.Any])
      
      inline def setLoopUndefined: Self = StObject.set(x, "Loop", js.undefined)
      
      inline def setMemberExpression(value: VisitNode[S, Extract[Node, `60`]]): Self = StObject.set(x, "MemberExpression", value.asInstanceOf[js.Any])
      
      inline def setMemberExpressionUndefined: Self = StObject.set(x, "MemberExpression", js.undefined)
      
      inline def setMetaProperty(value: VisitNode[S, Extract[Node, `83`]]): Self = StObject.set(x, "MetaProperty", value.asInstanceOf[js.Any])
      
      inline def setMetaPropertyUndefined: Self = StObject.set(x, "MetaProperty", js.undefined)
      
      inline def setMethod(value: VisitNode[S, Method]): Self = StObject.set(x, "Method", value.asInstanceOf[js.Any])
      
      inline def setMethodUndefined: Self = StObject.set(x, "Method", js.undefined)
      
      inline def setMiscellaneous(value: VisitNode[S, Miscellaneous]): Self = StObject.set(x, "Miscellaneous", value.asInstanceOf[js.Any])
      
      inline def setMiscellaneousUndefined: Self = StObject.set(x, "Miscellaneous", js.undefined)
      
      inline def setMixedTypeAnnotation(value: VisitNode[S, Extract[Node, `57`]]): Self = StObject.set(x, "MixedTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setMixedTypeAnnotationUndefined: Self = StObject.set(x, "MixedTypeAnnotation", js.undefined)
      
      inline def setModuleDeclaration(value: VisitNode[S, ModuleDeclaration]): Self = StObject.set(x, "ModuleDeclaration", value.asInstanceOf[js.Any])
      
      inline def setModuleDeclarationUndefined: Self = StObject.set(x, "ModuleDeclaration", js.undefined)
      
      inline def setModuleExpression(value: VisitNode[S, Extract[Node, `148`]]): Self = StObject.set(x, "ModuleExpression", value.asInstanceOf[js.Any])
      
      inline def setModuleExpressionUndefined: Self = StObject.set(x, "ModuleExpression", js.undefined)
      
      inline def setModuleSpecifier(value: VisitNode[S, ModuleSpecifier]): Self = StObject.set(x, "ModuleSpecifier", value.asInstanceOf[js.Any])
      
      inline def setModuleSpecifierUndefined: Self = StObject.set(x, "ModuleSpecifier", js.undefined)
      
      inline def setNewExpression(value: VisitNode[S, Extract[Node, `59`]]): Self = StObject.set(x, "NewExpression", value.asInstanceOf[js.Any])
      
      inline def setNewExpressionUndefined: Self = StObject.set(x, "NewExpression", js.undefined)
      
      inline def setNoScope(value: Boolean): Self = StObject.set(x, "noScope", value.asInstanceOf[js.Any])
      
      inline def setNoScopeUndefined: Self = StObject.set(x, "noScope", js.undefined)
      
      inline def setNoop(value: VisitNode[S, Extract[Node, `34`]]): Self = StObject.set(x, "Noop", value.asInstanceOf[js.Any])
      
      inline def setNoopUndefined: Self = StObject.set(x, "Noop", js.undefined)
      
      inline def setNullLiteral(value: VisitNode[S, Extract[Node, `245`]]): Self = StObject.set(x, "NullLiteral", value.asInstanceOf[js.Any])
      
      inline def setNullLiteralTypeAnnotation(value: VisitNode[S, Extract[Node, `43`]]): Self = StObject.set(x, "NullLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setNullLiteralTypeAnnotationUndefined: Self = StObject.set(x, "NullLiteralTypeAnnotation", js.undefined)
      
      inline def setNullLiteralUndefined: Self = StObject.set(x, "NullLiteral", js.undefined)
      
      inline def setNullableTypeAnnotation(value: VisitNode[S, Extract[Node, `98`]]): Self = StObject.set(x, "NullableTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setNullableTypeAnnotationUndefined: Self = StObject.set(x, "NullableTypeAnnotation", js.undefined)
      
      inline def setNumberLiteralTypeAnnotation(value: VisitNode[S, Extract[Node, `157`]]): Self = StObject.set(x, "NumberLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setNumberLiteralTypeAnnotationUndefined: Self = StObject.set(x, "NumberLiteralTypeAnnotation", js.undefined)
      
      inline def setNumberTypeAnnotation(value: VisitNode[S, Extract[Node, `164`]]): Self = StObject.set(x, "NumberTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setNumberTypeAnnotationUndefined: Self = StObject.set(x, "NumberTypeAnnotation", js.undefined)
      
      inline def setNumericLiteral(value: VisitNode[S, Extract[Node, `217`]]): Self = StObject.set(x, "NumericLiteral", value.asInstanceOf[js.Any])
      
      inline def setNumericLiteralTypeAnnotation(value: VisitNode[S, NumberLiteralTypeAnnotation_]): Self = StObject.set(x, "NumericLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setNumericLiteralTypeAnnotationUndefined: Self = StObject.set(x, "NumericLiteralTypeAnnotation", js.undefined)
      
      inline def setNumericLiteralUndefined: Self = StObject.set(x, "NumericLiteral", js.undefined)
      
      inline def setObjectExpression(value: VisitNode[S, Extract[Node, `124`]]): Self = StObject.set(x, "ObjectExpression", value.asInstanceOf[js.Any])
      
      inline def setObjectExpressionUndefined: Self = StObject.set(x, "ObjectExpression", js.undefined)
      
      inline def setObjectMember(value: VisitNode[S, ObjectMember]): Self = StObject.set(x, "ObjectMember", value.asInstanceOf[js.Any])
      
      inline def setObjectMemberUndefined: Self = StObject.set(x, "ObjectMember", js.undefined)
      
      inline def setObjectMethod(value: VisitNode[S, Extract[Node, `126`]]): Self = StObject.set(x, "ObjectMethod", value.asInstanceOf[js.Any])
      
      inline def setObjectMethodUndefined: Self = StObject.set(x, "ObjectMethod", js.undefined)
      
      inline def setObjectPattern(value: VisitNode[S, Extract[Node, `224`]]): Self = StObject.set(x, "ObjectPattern", value.asInstanceOf[js.Any])
      
      inline def setObjectPatternUndefined: Self = StObject.set(x, "ObjectPattern", js.undefined)
      
      inline def setObjectProperty(value: VisitNode[S, Extract[Node, `144`]]): Self = StObject.set(x, "ObjectProperty", value.asInstanceOf[js.Any])
      
      inline def setObjectPropertyUndefined: Self = StObject.set(x, "ObjectProperty", js.undefined)
      
      inline def setObjectTypeAnnotation(value: VisitNode[S, Extract[Node, `84`]]): Self = StObject.set(x, "ObjectTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setObjectTypeAnnotationUndefined: Self = StObject.set(x, "ObjectTypeAnnotation", js.undefined)
      
      inline def setObjectTypeCallProperty(value: VisitNode[S, Extract[Node, `13`]]): Self = StObject.set(x, "ObjectTypeCallProperty", value.asInstanceOf[js.Any])
      
      inline def setObjectTypeCallPropertyUndefined: Self = StObject.set(x, "ObjectTypeCallProperty", js.undefined)
      
      inline def setObjectTypeIndexer(value: VisitNode[S, Extract[Node, `175`]]): Self = StObject.set(x, "ObjectTypeIndexer", value.asInstanceOf[js.Any])
      
      inline def setObjectTypeIndexerUndefined: Self = StObject.set(x, "ObjectTypeIndexer", js.undefined)
      
      inline def setObjectTypeInternalSlot(value: VisitNode[S, Extract[Node, `233`]]): Self = StObject.set(x, "ObjectTypeInternalSlot", value.asInstanceOf[js.Any])
      
      inline def setObjectTypeInternalSlotUndefined: Self = StObject.set(x, "ObjectTypeInternalSlot", js.undefined)
      
      inline def setObjectTypeProperty(value: VisitNode[S, Extract[Node, `159`]]): Self = StObject.set(x, "ObjectTypeProperty", value.asInstanceOf[js.Any])
      
      inline def setObjectTypePropertyUndefined: Self = StObject.set(x, "ObjectTypeProperty", js.undefined)
      
      inline def setObjectTypeSpreadProperty(value: VisitNode[S, Extract[Node, `81`]]): Self = StObject.set(x, "ObjectTypeSpreadProperty", value.asInstanceOf[js.Any])
      
      inline def setObjectTypeSpreadPropertyUndefined: Self = StObject.set(x, "ObjectTypeSpreadProperty", js.undefined)
      
      inline def setOpaqueType(value: VisitNode[S, Extract[Node, `71`]]): Self = StObject.set(x, "OpaqueType", value.asInstanceOf[js.Any])
      
      inline def setOpaqueTypeUndefined: Self = StObject.set(x, "OpaqueType", js.undefined)
      
      inline def setOptionalCallExpression(value: VisitNode[S, Extract[Node, `45`]]): Self = StObject.set(x, "OptionalCallExpression", value.asInstanceOf[js.Any])
      
      inline def setOptionalCallExpressionUndefined: Self = StObject.set(x, "OptionalCallExpression", js.undefined)
      
      inline def setOptionalIndexedAccessType(value: VisitNode[S, Extract[Node, `146`]]): Self = StObject.set(x, "OptionalIndexedAccessType", value.asInstanceOf[js.Any])
      
      inline def setOptionalIndexedAccessTypeUndefined: Self = StObject.set(x, "OptionalIndexedAccessType", js.undefined)
      
      inline def setOptionalMemberExpression(value: VisitNode[S, Extract[Node, `27`]]): Self = StObject.set(x, "OptionalMemberExpression", value.asInstanceOf[js.Any])
      
      inline def setOptionalMemberExpressionUndefined: Self = StObject.set(x, "OptionalMemberExpression", js.undefined)
      
      inline def setParenthesizedExpression(value: VisitNode[S, Extract[Node, `204`]]): Self = StObject.set(x, "ParenthesizedExpression", value.asInstanceOf[js.Any])
      
      inline def setParenthesizedExpressionUndefined: Self = StObject.set(x, "ParenthesizedExpression", js.undefined)
      
      inline def setPattern(value: VisitNode[S, Pattern]): Self = StObject.set(x, "Pattern", value.asInstanceOf[js.Any])
      
      inline def setPatternLike(value: VisitNode[S, PatternLike]): Self = StObject.set(x, "PatternLike", value.asInstanceOf[js.Any])
      
      inline def setPatternLikeUndefined: Self = StObject.set(x, "PatternLike", js.undefined)
      
      inline def setPatternUndefined: Self = StObject.set(x, "Pattern", js.undefined)
      
      inline def setPipelineBareFunction(value: VisitNode[S, Extract[Node, `162`]]): Self = StObject.set(x, "PipelineBareFunction", value.asInstanceOf[js.Any])
      
      inline def setPipelineBareFunctionUndefined: Self = StObject.set(x, "PipelineBareFunction", js.undefined)
      
      inline def setPipelinePrimaryTopicReference(value: VisitNode[S, Extract[Node, `31`]]): Self = StObject.set(x, "PipelinePrimaryTopicReference", value.asInstanceOf[js.Any])
      
      inline def setPipelinePrimaryTopicReferenceUndefined: Self = StObject.set(x, "PipelinePrimaryTopicReference", js.undefined)
      
      inline def setPipelineTopicExpression(value: VisitNode[S, Extract[Node, `106`]]): Self = StObject.set(x, "PipelineTopicExpression", value.asInstanceOf[js.Any])
      
      inline def setPipelineTopicExpressionUndefined: Self = StObject.set(x, "PipelineTopicExpression", js.undefined)
      
      inline def setPlaceholder(value: VisitNode[S, Extract[Node, `168`]]): Self = StObject.set(x, "Placeholder", value.asInstanceOf[js.Any])
      
      inline def setPlaceholderUndefined: Self = StObject.set(x, "Placeholder", js.undefined)
      
      inline def setPrivate(value: VisitNode[S, Private]): Self = StObject.set(x, "Private", value.asInstanceOf[js.Any])
      
      inline def setPrivateName(value: VisitNode[S, Extract[Node, `95`]]): Self = StObject.set(x, "PrivateName", value.asInstanceOf[js.Any])
      
      inline def setPrivateNameUndefined: Self = StObject.set(x, "PrivateName", js.undefined)
      
      inline def setPrivateUndefined: Self = StObject.set(x, "Private", js.undefined)
      
      inline def setProgram(value: VisitNode[S, Extract[Node, `155`]]): Self = StObject.set(x, "Program", value.asInstanceOf[js.Any])
      
      inline def setProgramUndefined: Self = StObject.set(x, "Program", js.undefined)
      
      inline def setProperty(value: VisitNode[S, Property]): Self = StObject.set(x, "Property", value.asInstanceOf[js.Any])
      
      inline def setPropertyUndefined: Self = StObject.set(x, "Property", js.undefined)
      
      inline def setPure(value: VisitNode[S, Node]): Self = StObject.set(x, "Pure", value.asInstanceOf[js.Any])
      
      inline def setPureUndefined: Self = StObject.set(x, "Pure", js.undefined)
      
      inline def setPureish(value: VisitNode[S, Pureish]): Self = StObject.set(x, "Pureish", value.asInstanceOf[js.Any])
      
      inline def setPureishUndefined: Self = StObject.set(x, "Pureish", js.undefined)
      
      inline def setQualifiedTypeIdentifier(value: VisitNode[S, Extract[Node, `75`]]): Self = StObject.set(x, "QualifiedTypeIdentifier", value.asInstanceOf[js.Any])
      
      inline def setQualifiedTypeIdentifierUndefined: Self = StObject.set(x, "QualifiedTypeIdentifier", js.undefined)
      
      inline def setRecordExpression(value: VisitNode[S, Extract[Node, `61`]]): Self = StObject.set(x, "RecordExpression", value.asInstanceOf[js.Any])
      
      inline def setRecordExpressionUndefined: Self = StObject.set(x, "RecordExpression", js.undefined)
      
      inline def setReferenced(value: VisitNode[S, Node]): Self = StObject.set(x, "Referenced", value.asInstanceOf[js.Any])
      
      inline def setReferencedIdentifier(value: VisitNode[S, Identifier_ | JSXIdentifier_]): Self = StObject.set(x, "ReferencedIdentifier", value.asInstanceOf[js.Any])
      
      inline def setReferencedIdentifierUndefined: Self = StObject.set(x, "ReferencedIdentifier", js.undefined)
      
      inline def setReferencedMemberExpression(value: VisitNode[S, MemberExpression_]): Self = StObject.set(x, "ReferencedMemberExpression", value.asInstanceOf[js.Any])
      
      inline def setReferencedMemberExpressionUndefined: Self = StObject.set(x, "ReferencedMemberExpression", js.undefined)
      
      inline def setReferencedUndefined: Self = StObject.set(x, "Referenced", js.undefined)
      
      inline def setRegExpLiteral(value: VisitNode[S, Extract[Node, `38`]]): Self = StObject.set(x, "RegExpLiteral", value.asInstanceOf[js.Any])
      
      inline def setRegExpLiteralUndefined: Self = StObject.set(x, "RegExpLiteral", js.undefined)
      
      inline def setRestElement(value: VisitNode[S, Extract[Node, `26`]]): Self = StObject.set(x, "RestElement", value.asInstanceOf[js.Any])
      
      inline def setRestElementUndefined: Self = StObject.set(x, "RestElement", js.undefined)
      
      inline def setRestProperty(value: VisitNode[S, RestElement_]): Self = StObject.set(x, "RestProperty", value.asInstanceOf[js.Any])
      
      inline def setRestPropertyUndefined: Self = StObject.set(x, "RestProperty", js.undefined)
      
      inline def setReturnStatement(value: VisitNode[S, Extract[Node, `5`]]): Self = StObject.set(x, "ReturnStatement", value.asInstanceOf[js.Any])
      
      inline def setReturnStatementUndefined: Self = StObject.set(x, "ReturnStatement", js.undefined)
      
      inline def setScopable(value: VisitNode[S, Scopable]): Self = StObject.set(x, "Scopable", value.asInstanceOf[js.Any])
      
      inline def setScopableUndefined: Self = StObject.set(x, "Scopable", js.undefined)
      
      inline def setScope(value: VisitNode[S, Scopable | Pattern]): Self = StObject.set(x, "Scope", value.asInstanceOf[js.Any])
      
      inline def setScopeUndefined: Self = StObject.set(x, "Scope", js.undefined)
      
      inline def setSequenceExpression(value: VisitNode[S, Extract[Node, `171`]]): Self = StObject.set(x, "SequenceExpression", value.asInstanceOf[js.Any])
      
      inline def setSequenceExpressionUndefined: Self = StObject.set(x, "SequenceExpression", js.undefined)
      
      inline def setShouldSkip(value: /* node */ NodePath[Node] => Boolean): Self = StObject.set(x, "shouldSkip", js.Any.fromFunction1(value))
      
      inline def setShouldSkipUndefined: Self = StObject.set(x, "shouldSkip", js.undefined)
      
      inline def setSpreadElement(value: VisitNode[S, Extract[Node, `23`]]): Self = StObject.set(x, "SpreadElement", value.asInstanceOf[js.Any])
      
      inline def setSpreadElementUndefined: Self = StObject.set(x, "SpreadElement", js.undefined)
      
      inline def setSpreadProperty(value: VisitNode[S, RestElement_]): Self = StObject.set(x, "SpreadProperty", value.asInstanceOf[js.Any])
      
      inline def setSpreadPropertyUndefined: Self = StObject.set(x, "SpreadProperty", js.undefined)
      
      inline def setStandardized(value: VisitNode[S, Standardized]): Self = StObject.set(x, "Standardized", value.asInstanceOf[js.Any])
      
      inline def setStandardizedUndefined: Self = StObject.set(x, "Standardized", js.undefined)
      
      inline def setStatement(value: VisitNode[S, Statement]): Self = StObject.set(x, "Statement", value.asInstanceOf[js.Any])
      
      inline def setStatementUndefined: Self = StObject.set(x, "Statement", js.undefined)
      
      inline def setStaticBlock(value: VisitNode[S, Extract[Node, `111`]]): Self = StObject.set(x, "StaticBlock", value.asInstanceOf[js.Any])
      
      inline def setStaticBlockUndefined: Self = StObject.set(x, "StaticBlock", js.undefined)
      
      inline def setStringLiteral(value: VisitNode[S, Extract[Node, `131`]]): Self = StObject.set(x, "StringLiteral", value.asInstanceOf[js.Any])
      
      inline def setStringLiteralTypeAnnotation(value: VisitNode[S, Extract[Node, `226`]]): Self = StObject.set(x, "StringLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setStringLiteralTypeAnnotationUndefined: Self = StObject.set(x, "StringLiteralTypeAnnotation", js.undefined)
      
      inline def setStringLiteralUndefined: Self = StObject.set(x, "StringLiteral", js.undefined)
      
      inline def setStringTypeAnnotation(value: VisitNode[S, Extract[Node, `2`]]): Self = StObject.set(x, "StringTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setStringTypeAnnotationUndefined: Self = StObject.set(x, "StringTypeAnnotation", js.undefined)
      
      inline def setSuper(value: VisitNode[S, Extract[Node, `165`]]): Self = StObject.set(x, "Super", value.asInstanceOf[js.Any])
      
      inline def setSuperUndefined: Self = StObject.set(x, "Super", js.undefined)
      
      inline def setSwitchCase(value: VisitNode[S, Extract[Node, `54`]]): Self = StObject.set(x, "SwitchCase", value.asInstanceOf[js.Any])
      
      inline def setSwitchCaseUndefined: Self = StObject.set(x, "SwitchCase", js.undefined)
      
      inline def setSwitchStatement(value: VisitNode[S, Extract[Node, `44`]]): Self = StObject.set(x, "SwitchStatement", value.asInstanceOf[js.Any])
      
      inline def setSwitchStatementUndefined: Self = StObject.set(x, "SwitchStatement", js.undefined)
      
      inline def setSymbolTypeAnnotation(value: VisitNode[S, Extract[Node, `50`]]): Self = StObject.set(x, "SymbolTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setSymbolTypeAnnotationUndefined: Self = StObject.set(x, "SymbolTypeAnnotation", js.undefined)
      
      inline def setTSAnyKeyword(value: VisitNode[S, Extract[Node, `10`]]): Self = StObject.set(x, "TSAnyKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSAnyKeywordUndefined: Self = StObject.set(x, "TSAnyKeyword", js.undefined)
      
      inline def setTSArrayType(value: VisitNode[S, Extract[Node, `0`]]): Self = StObject.set(x, "TSArrayType", value.asInstanceOf[js.Any])
      
      inline def setTSArrayTypeUndefined: Self = StObject.set(x, "TSArrayType", js.undefined)
      
      inline def setTSAsExpression(value: VisitNode[S, Extract[Node, `8`]]): Self = StObject.set(x, "TSAsExpression", value.asInstanceOf[js.Any])
      
      inline def setTSAsExpressionUndefined: Self = StObject.set(x, "TSAsExpression", js.undefined)
      
      inline def setTSBaseType(value: VisitNode[S, TSBaseType]): Self = StObject.set(x, "TSBaseType", value.asInstanceOf[js.Any])
      
      inline def setTSBaseTypeUndefined: Self = StObject.set(x, "TSBaseType", js.undefined)
      
      inline def setTSBigIntKeyword(value: VisitNode[S, Extract[Node, `53`]]): Self = StObject.set(x, "TSBigIntKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSBigIntKeywordUndefined: Self = StObject.set(x, "TSBigIntKeyword", js.undefined)
      
      inline def setTSBooleanKeyword(value: VisitNode[S, Extract[Node, `225`]]): Self = StObject.set(x, "TSBooleanKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSBooleanKeywordUndefined: Self = StObject.set(x, "TSBooleanKeyword", js.undefined)
      
      inline def setTSCallSignatureDeclaration(value: VisitNode[S, Extract[Node, `151`]]): Self = StObject.set(x, "TSCallSignatureDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSCallSignatureDeclarationUndefined: Self = StObject.set(x, "TSCallSignatureDeclaration", js.undefined)
      
      inline def setTSConditionalType(value: VisitNode[S, Extract[Node, `18`]]): Self = StObject.set(x, "TSConditionalType", value.asInstanceOf[js.Any])
      
      inline def setTSConditionalTypeUndefined: Self = StObject.set(x, "TSConditionalType", js.undefined)
      
      inline def setTSConstructSignatureDeclaration(value: VisitNode[S, Extract[Node, `122`]]): Self = StObject.set(x, "TSConstructSignatureDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSConstructSignatureDeclarationUndefined: Self = StObject.set(x, "TSConstructSignatureDeclaration", js.undefined)
      
      inline def setTSConstructorType(value: VisitNode[S, Extract[Node, `213`]]): Self = StObject.set(x, "TSConstructorType", value.asInstanceOf[js.Any])
      
      inline def setTSConstructorTypeUndefined: Self = StObject.set(x, "TSConstructorType", js.undefined)
      
      inline def setTSDeclareFunction(value: VisitNode[S, Extract[Node, `201`]]): Self = StObject.set(x, "TSDeclareFunction", value.asInstanceOf[js.Any])
      
      inline def setTSDeclareFunctionUndefined: Self = StObject.set(x, "TSDeclareFunction", js.undefined)
      
      inline def setTSDeclareMethod(value: VisitNode[S, Extract[Node, `77`]]): Self = StObject.set(x, "TSDeclareMethod", value.asInstanceOf[js.Any])
      
      inline def setTSDeclareMethodUndefined: Self = StObject.set(x, "TSDeclareMethod", js.undefined)
      
      inline def setTSEntityName(value: VisitNode[S, TSEntityName]): Self = StObject.set(x, "TSEntityName", value.asInstanceOf[js.Any])
      
      inline def setTSEntityNameUndefined: Self = StObject.set(x, "TSEntityName", js.undefined)
      
      inline def setTSEnumDeclaration(value: VisitNode[S, Extract[Node, `91`]]): Self = StObject.set(x, "TSEnumDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSEnumDeclarationUndefined: Self = StObject.set(x, "TSEnumDeclaration", js.undefined)
      
      inline def setTSEnumMember(value: VisitNode[S, Extract[Node, `133`]]): Self = StObject.set(x, "TSEnumMember", value.asInstanceOf[js.Any])
      
      inline def setTSEnumMemberUndefined: Self = StObject.set(x, "TSEnumMember", js.undefined)
      
      inline def setTSExportAssignment(value: VisitNode[S, Extract[Node, `145`]]): Self = StObject.set(x, "TSExportAssignment", value.asInstanceOf[js.Any])
      
      inline def setTSExportAssignmentUndefined: Self = StObject.set(x, "TSExportAssignment", js.undefined)
      
      inline def setTSExpressionWithTypeArguments(value: VisitNode[S, Extract[Node, `149`]]): Self = StObject.set(x, "TSExpressionWithTypeArguments", value.asInstanceOf[js.Any])
      
      inline def setTSExpressionWithTypeArgumentsUndefined: Self = StObject.set(x, "TSExpressionWithTypeArguments", js.undefined)
      
      inline def setTSExternalModuleReference(value: VisitNode[S, Extract[Node, `121`]]): Self = StObject.set(x, "TSExternalModuleReference", value.asInstanceOf[js.Any])
      
      inline def setTSExternalModuleReferenceUndefined: Self = StObject.set(x, "TSExternalModuleReference", js.undefined)
      
      inline def setTSFunctionType(value: VisitNode[S, Extract[Node, `42`]]): Self = StObject.set(x, "TSFunctionType", value.asInstanceOf[js.Any])
      
      inline def setTSFunctionTypeUndefined: Self = StObject.set(x, "TSFunctionType", js.undefined)
      
      inline def setTSImportEqualsDeclaration(value: VisitNode[S, Extract[Node, `160`]]): Self = StObject.set(x, "TSImportEqualsDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSImportEqualsDeclarationUndefined: Self = StObject.set(x, "TSImportEqualsDeclaration", js.undefined)
      
      inline def setTSImportType(value: VisitNode[S, Extract[Node, `241`]]): Self = StObject.set(x, "TSImportType", value.asInstanceOf[js.Any])
      
      inline def setTSImportTypeUndefined: Self = StObject.set(x, "TSImportType", js.undefined)
      
      inline def setTSIndexSignature(value: VisitNode[S, Extract[Node, `207`]]): Self = StObject.set(x, "TSIndexSignature", value.asInstanceOf[js.Any])
      
      inline def setTSIndexSignatureUndefined: Self = StObject.set(x, "TSIndexSignature", js.undefined)
      
      inline def setTSIndexedAccessType(value: VisitNode[S, Extract[Node, `29`]]): Self = StObject.set(x, "TSIndexedAccessType", value.asInstanceOf[js.Any])
      
      inline def setTSIndexedAccessTypeUndefined: Self = StObject.set(x, "TSIndexedAccessType", js.undefined)
      
      inline def setTSInferType(value: VisitNode[S, Extract[Node, `104`]]): Self = StObject.set(x, "TSInferType", value.asInstanceOf[js.Any])
      
      inline def setTSInferTypeUndefined: Self = StObject.set(x, "TSInferType", js.undefined)
      
      inline def setTSInstantiationExpression(value: VisitNode[S, Extract[Node, `216`]]): Self = StObject.set(x, "TSInstantiationExpression", value.asInstanceOf[js.Any])
      
      inline def setTSInstantiationExpressionUndefined: Self = StObject.set(x, "TSInstantiationExpression", js.undefined)
      
      inline def setTSInterfaceBody(value: VisitNode[S, Extract[Node, `7`]]): Self = StObject.set(x, "TSInterfaceBody", value.asInstanceOf[js.Any])
      
      inline def setTSInterfaceBodyUndefined: Self = StObject.set(x, "TSInterfaceBody", js.undefined)
      
      inline def setTSInterfaceDeclaration(value: VisitNode[S, Extract[Node, `187`]]): Self = StObject.set(x, "TSInterfaceDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSInterfaceDeclarationUndefined: Self = StObject.set(x, "TSInterfaceDeclaration", js.undefined)
      
      inline def setTSIntersectionType(value: VisitNode[S, Extract[Node, `238`]]): Self = StObject.set(x, "TSIntersectionType", value.asInstanceOf[js.Any])
      
      inline def setTSIntersectionTypeUndefined: Self = StObject.set(x, "TSIntersectionType", js.undefined)
      
      inline def setTSIntrinsicKeyword(value: VisitNode[S, Extract[Node, `66`]]): Self = StObject.set(x, "TSIntrinsicKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSIntrinsicKeywordUndefined: Self = StObject.set(x, "TSIntrinsicKeyword", js.undefined)
      
      inline def setTSLiteralType(value: VisitNode[S, Extract[Node, `20`]]): Self = StObject.set(x, "TSLiteralType", value.asInstanceOf[js.Any])
      
      inline def setTSLiteralTypeUndefined: Self = StObject.set(x, "TSLiteralType", js.undefined)
      
      inline def setTSMappedType(value: VisitNode[S, Extract[Node, `128`]]): Self = StObject.set(x, "TSMappedType", value.asInstanceOf[js.Any])
      
      inline def setTSMappedTypeUndefined: Self = StObject.set(x, "TSMappedType", js.undefined)
      
      inline def setTSMethodSignature(value: VisitNode[S, Extract[Node, `203`]]): Self = StObject.set(x, "TSMethodSignature", value.asInstanceOf[js.Any])
      
      inline def setTSMethodSignatureUndefined: Self = StObject.set(x, "TSMethodSignature", js.undefined)
      
      inline def setTSModuleBlock(value: VisitNode[S, Extract[Node, `231`]]): Self = StObject.set(x, "TSModuleBlock", value.asInstanceOf[js.Any])
      
      inline def setTSModuleBlockUndefined: Self = StObject.set(x, "TSModuleBlock", js.undefined)
      
      inline def setTSModuleDeclaration(value: VisitNode[S, Extract[Node, `16`]]): Self = StObject.set(x, "TSModuleDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSModuleDeclarationUndefined: Self = StObject.set(x, "TSModuleDeclaration", js.undefined)
      
      inline def setTSNamedTupleMember(value: VisitNode[S, Extract[Node, `222`]]): Self = StObject.set(x, "TSNamedTupleMember", value.asInstanceOf[js.Any])
      
      inline def setTSNamedTupleMemberUndefined: Self = StObject.set(x, "TSNamedTupleMember", js.undefined)
      
      inline def setTSNamespaceExportDeclaration(value: VisitNode[S, Extract[Node, `90`]]): Self = StObject.set(x, "TSNamespaceExportDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSNamespaceExportDeclarationUndefined: Self = StObject.set(x, "TSNamespaceExportDeclaration", js.undefined)
      
      inline def setTSNeverKeyword(value: VisitNode[S, Extract[Node, `237`]]): Self = StObject.set(x, "TSNeverKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSNeverKeywordUndefined: Self = StObject.set(x, "TSNeverKeyword", js.undefined)
      
      inline def setTSNonNullExpression(value: VisitNode[S, Extract[Node, `97`]]): Self = StObject.set(x, "TSNonNullExpression", value.asInstanceOf[js.Any])
      
      inline def setTSNonNullExpressionUndefined: Self = StObject.set(x, "TSNonNullExpression", js.undefined)
      
      inline def setTSNullKeyword(value: VisitNode[S, Extract[Node, `33`]]): Self = StObject.set(x, "TSNullKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSNullKeywordUndefined: Self = StObject.set(x, "TSNullKeyword", js.undefined)
      
      inline def setTSNumberKeyword(value: VisitNode[S, Extract[Node, `181`]]): Self = StObject.set(x, "TSNumberKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSNumberKeywordUndefined: Self = StObject.set(x, "TSNumberKeyword", js.undefined)
      
      inline def setTSObjectKeyword(value: VisitNode[S, Extract[Node, `218`]]): Self = StObject.set(x, "TSObjectKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSObjectKeywordUndefined: Self = StObject.set(x, "TSObjectKeyword", js.undefined)
      
      inline def setTSOptionalType(value: VisitNode[S, Extract[Node, `185`]]): Self = StObject.set(x, "TSOptionalType", value.asInstanceOf[js.Any])
      
      inline def setTSOptionalTypeUndefined: Self = StObject.set(x, "TSOptionalType", js.undefined)
      
      inline def setTSParameterProperty(value: VisitNode[S, Extract[Node, `196`]]): Self = StObject.set(x, "TSParameterProperty", value.asInstanceOf[js.Any])
      
      inline def setTSParameterPropertyUndefined: Self = StObject.set(x, "TSParameterProperty", js.undefined)
      
      inline def setTSParenthesizedType(value: VisitNode[S, Extract[Node, `227`]]): Self = StObject.set(x, "TSParenthesizedType", value.asInstanceOf[js.Any])
      
      inline def setTSParenthesizedTypeUndefined: Self = StObject.set(x, "TSParenthesizedType", js.undefined)
      
      inline def setTSPropertySignature(value: VisitNode[S, Extract[Node, `118`]]): Self = StObject.set(x, "TSPropertySignature", value.asInstanceOf[js.Any])
      
      inline def setTSPropertySignatureUndefined: Self = StObject.set(x, "TSPropertySignature", js.undefined)
      
      inline def setTSQualifiedName(value: VisitNode[S, Extract[Node, `30`]]): Self = StObject.set(x, "TSQualifiedName", value.asInstanceOf[js.Any])
      
      inline def setTSQualifiedNameUndefined: Self = StObject.set(x, "TSQualifiedName", js.undefined)
      
      inline def setTSRestType(value: VisitNode[S, Extract[Node, `210`]]): Self = StObject.set(x, "TSRestType", value.asInstanceOf[js.Any])
      
      inline def setTSRestTypeUndefined: Self = StObject.set(x, "TSRestType", js.undefined)
      
      inline def setTSSatisfiesExpression(value: VisitNode[S, Extract[Node, `6`]]): Self = StObject.set(x, "TSSatisfiesExpression", value.asInstanceOf[js.Any])
      
      inline def setTSSatisfiesExpressionUndefined: Self = StObject.set(x, "TSSatisfiesExpression", js.undefined)
      
      inline def setTSStringKeyword(value: VisitNode[S, Extract[Node, `101`]]): Self = StObject.set(x, "TSStringKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSStringKeywordUndefined: Self = StObject.set(x, "TSStringKeyword", js.undefined)
      
      inline def setTSSymbolKeyword(value: VisitNode[S, Extract[Node, `127`]]): Self = StObject.set(x, "TSSymbolKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSSymbolKeywordUndefined: Self = StObject.set(x, "TSSymbolKeyword", js.undefined)
      
      inline def setTSThisType(value: VisitNode[S, Extract[Node, `208`]]): Self = StObject.set(x, "TSThisType", value.asInstanceOf[js.Any])
      
      inline def setTSThisTypeUndefined: Self = StObject.set(x, "TSThisType", js.undefined)
      
      inline def setTSTupleType(value: VisitNode[S, Extract[Node, `199`]]): Self = StObject.set(x, "TSTupleType", value.asInstanceOf[js.Any])
      
      inline def setTSTupleTypeUndefined: Self = StObject.set(x, "TSTupleType", js.undefined)
      
      inline def setTSType(value: VisitNode[S, TSType]): Self = StObject.set(x, "TSType", value.asInstanceOf[js.Any])
      
      inline def setTSTypeAliasDeclaration(value: VisitNode[S, Extract[Node, `92`]]): Self = StObject.set(x, "TSTypeAliasDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSTypeAliasDeclarationUndefined: Self = StObject.set(x, "TSTypeAliasDeclaration", js.undefined)
      
      inline def setTSTypeAnnotation(value: VisitNode[S, Extract[Node, `112`]]): Self = StObject.set(x, "TSTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setTSTypeAnnotationUndefined: Self = StObject.set(x, "TSTypeAnnotation", js.undefined)
      
      inline def setTSTypeAssertion(value: VisitNode[S, Extract[Node, `236`]]): Self = StObject.set(x, "TSTypeAssertion", value.asInstanceOf[js.Any])
      
      inline def setTSTypeAssertionUndefined: Self = StObject.set(x, "TSTypeAssertion", js.undefined)
      
      inline def setTSTypeElement(value: VisitNode[S, TSTypeElement]): Self = StObject.set(x, "TSTypeElement", value.asInstanceOf[js.Any])
      
      inline def setTSTypeElementUndefined: Self = StObject.set(x, "TSTypeElement", js.undefined)
      
      inline def setTSTypeLiteral(value: VisitNode[S, Extract[Node, `156`]]): Self = StObject.set(x, "TSTypeLiteral", value.asInstanceOf[js.Any])
      
      inline def setTSTypeLiteralUndefined: Self = StObject.set(x, "TSTypeLiteral", js.undefined)
      
      inline def setTSTypeOperator(value: VisitNode[S, Extract[Node, `52`]]): Self = StObject.set(x, "TSTypeOperator", value.asInstanceOf[js.Any])
      
      inline def setTSTypeOperatorUndefined: Self = StObject.set(x, "TSTypeOperator", js.undefined)
      
      inline def setTSTypeParameter(value: VisitNode[S, Extract[Node, `94`]]): Self = StObject.set(x, "TSTypeParameter", value.asInstanceOf[js.Any])
      
      inline def setTSTypeParameterDeclaration(value: VisitNode[S, Extract[Node, `21`]]): Self = StObject.set(x, "TSTypeParameterDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSTypeParameterDeclarationUndefined: Self = StObject.set(x, "TSTypeParameterDeclaration", js.undefined)
      
      inline def setTSTypeParameterInstantiation(value: VisitNode[S, Extract[Node, `76`]]): Self = StObject.set(x, "TSTypeParameterInstantiation", value.asInstanceOf[js.Any])
      
      inline def setTSTypeParameterInstantiationUndefined: Self = StObject.set(x, "TSTypeParameterInstantiation", js.undefined)
      
      inline def setTSTypeParameterUndefined: Self = StObject.set(x, "TSTypeParameter", js.undefined)
      
      inline def setTSTypePredicate(value: VisitNode[S, Extract[Node, `186`]]): Self = StObject.set(x, "TSTypePredicate", value.asInstanceOf[js.Any])
      
      inline def setTSTypePredicateUndefined: Self = StObject.set(x, "TSTypePredicate", js.undefined)
      
      inline def setTSTypeQuery(value: VisitNode[S, Extract[Node, `120`]]): Self = StObject.set(x, "TSTypeQuery", value.asInstanceOf[js.Any])
      
      inline def setTSTypeQueryUndefined: Self = StObject.set(x, "TSTypeQuery", js.undefined)
      
      inline def setTSTypeReference(value: VisitNode[S, Extract[Node, `247`]]): Self = StObject.set(x, "TSTypeReference", value.asInstanceOf[js.Any])
      
      inline def setTSTypeReferenceUndefined: Self = StObject.set(x, "TSTypeReference", js.undefined)
      
      inline def setTSTypeUndefined: Self = StObject.set(x, "TSType", js.undefined)
      
      inline def setTSUndefinedKeyword(value: VisitNode[S, Extract[Node, `169`]]): Self = StObject.set(x, "TSUndefinedKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSUndefinedKeywordUndefined: Self = StObject.set(x, "TSUndefinedKeyword", js.undefined)
      
      inline def setTSUnionType(value: VisitNode[S, Extract[Node, `93`]]): Self = StObject.set(x, "TSUnionType", value.asInstanceOf[js.Any])
      
      inline def setTSUnionTypeUndefined: Self = StObject.set(x, "TSUnionType", js.undefined)
      
      inline def setTSUnknownKeyword(value: VisitNode[S, Extract[Node, `55`]]): Self = StObject.set(x, "TSUnknownKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSUnknownKeywordUndefined: Self = StObject.set(x, "TSUnknownKeyword", js.undefined)
      
      inline def setTSVoidKeyword(value: VisitNode[S, Extract[Node, `58`]]): Self = StObject.set(x, "TSVoidKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSVoidKeywordUndefined: Self = StObject.set(x, "TSVoidKeyword", js.undefined)
      
      inline def setTaggedTemplateExpression(value: VisitNode[S, Extract[Node, `72`]]): Self = StObject.set(x, "TaggedTemplateExpression", value.asInstanceOf[js.Any])
      
      inline def setTaggedTemplateExpressionUndefined: Self = StObject.set(x, "TaggedTemplateExpression", js.undefined)
      
      inline def setTemplateElement(value: VisitNode[S, Extract[Node, `194`]]): Self = StObject.set(x, "TemplateElement", value.asInstanceOf[js.Any])
      
      inline def setTemplateElementUndefined: Self = StObject.set(x, "TemplateElement", js.undefined)
      
      inline def setTemplateLiteral(value: VisitNode[S, Extract[Node, `78`]]): Self = StObject.set(x, "TemplateLiteral", value.asInstanceOf[js.Any])
      
      inline def setTemplateLiteralUndefined: Self = StObject.set(x, "TemplateLiteral", js.undefined)
      
      inline def setTerminatorless(value: VisitNode[S, Terminatorless]): Self = StObject.set(x, "Terminatorless", value.asInstanceOf[js.Any])
      
      inline def setTerminatorlessUndefined: Self = StObject.set(x, "Terminatorless", js.undefined)
      
      inline def setThisExpression(value: VisitNode[S, Extract[Node, `234`]]): Self = StObject.set(x, "ThisExpression", value.asInstanceOf[js.Any])
      
      inline def setThisExpressionUndefined: Self = StObject.set(x, "ThisExpression", js.undefined)
      
      inline def setThisTypeAnnotation(value: VisitNode[S, Extract[Node, `51`]]): Self = StObject.set(x, "ThisTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setThisTypeAnnotationUndefined: Self = StObject.set(x, "ThisTypeAnnotation", js.undefined)
      
      inline def setThrowStatement(value: VisitNode[S, Extract[Node, `140`]]): Self = StObject.set(x, "ThrowStatement", value.asInstanceOf[js.Any])
      
      inline def setThrowStatementUndefined: Self = StObject.set(x, "ThrowStatement", js.undefined)
      
      inline def setTopicReference(value: VisitNode[S, Extract[Node, `102`]]): Self = StObject.set(x, "TopicReference", value.asInstanceOf[js.Any])
      
      inline def setTopicReferenceUndefined: Self = StObject.set(x, "TopicReference", js.undefined)
      
      inline def setTryStatement(value: VisitNode[S, Extract[Node, `24`]]): Self = StObject.set(x, "TryStatement", value.asInstanceOf[js.Any])
      
      inline def setTryStatementUndefined: Self = StObject.set(x, "TryStatement", js.undefined)
      
      inline def setTupleExpression(value: VisitNode[S, Extract[Node, `209`]]): Self = StObject.set(x, "TupleExpression", value.asInstanceOf[js.Any])
      
      inline def setTupleExpressionUndefined: Self = StObject.set(x, "TupleExpression", js.undefined)
      
      inline def setTupleTypeAnnotation(value: VisitNode[S, Extract[Node, `14`]]): Self = StObject.set(x, "TupleTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setTupleTypeAnnotationUndefined: Self = StObject.set(x, "TupleTypeAnnotation", js.undefined)
      
      inline def setTypeAlias(value: VisitNode[S, Extract[Node, `180`]]): Self = StObject.set(x, "TypeAlias", value.asInstanceOf[js.Any])
      
      inline def setTypeAliasUndefined: Self = StObject.set(x, "TypeAlias", js.undefined)
      
      inline def setTypeAnnotation(value: VisitNode[S, Extract[Node, `22`]]): Self = StObject.set(x, "TypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setTypeAnnotationUndefined: Self = StObject.set(x, "TypeAnnotation", js.undefined)
      
      inline def setTypeCastExpression(value: VisitNode[S, Extract[Node, `11`]]): Self = StObject.set(x, "TypeCastExpression", value.asInstanceOf[js.Any])
      
      inline def setTypeCastExpressionUndefined: Self = StObject.set(x, "TypeCastExpression", js.undefined)
      
      inline def setTypeParameter(value: VisitNode[S, Extract[Node, `173`]]): Self = StObject.set(x, "TypeParameter", value.asInstanceOf[js.Any])
      
      inline def setTypeParameterDeclaration(value: VisitNode[S, Extract[Node, `15`]]): Self = StObject.set(x, "TypeParameterDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTypeParameterDeclarationUndefined: Self = StObject.set(x, "TypeParameterDeclaration", js.undefined)
      
      inline def setTypeParameterInstantiation(value: VisitNode[S, Extract[Node, `246`]]): Self = StObject.set(x, "TypeParameterInstantiation", value.asInstanceOf[js.Any])
      
      inline def setTypeParameterInstantiationUndefined: Self = StObject.set(x, "TypeParameterInstantiation", js.undefined)
      
      inline def setTypeParameterUndefined: Self = StObject.set(x, "TypeParameter", js.undefined)
      
      inline def setTypeScript(value: VisitNode[S, TypeScript]): Self = StObject.set(x, "TypeScript", value.asInstanceOf[js.Any])
      
      inline def setTypeScriptUndefined: Self = StObject.set(x, "TypeScript", js.undefined)
      
      inline def setTypeofTypeAnnotation(value: VisitNode[S, Extract[Node, `150`]]): Self = StObject.set(x, "TypeofTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setTypeofTypeAnnotationUndefined: Self = StObject.set(x, "TypeofTypeAnnotation", js.undefined)
      
      inline def setUnaryExpression(value: VisitNode[S, Extract[Node, `177`]]): Self = StObject.set(x, "UnaryExpression", value.asInstanceOf[js.Any])
      
      inline def setUnaryExpressionUndefined: Self = StObject.set(x, "UnaryExpression", js.undefined)
      
      inline def setUnaryLike(value: VisitNode[S, UnaryLike]): Self = StObject.set(x, "UnaryLike", value.asInstanceOf[js.Any])
      
      inline def setUnaryLikeUndefined: Self = StObject.set(x, "UnaryLike", js.undefined)
      
      inline def setUnionTypeAnnotation(value: VisitNode[S, Extract[Node, `221`]]): Self = StObject.set(x, "UnionTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setUnionTypeAnnotationUndefined: Self = StObject.set(x, "UnionTypeAnnotation", js.undefined)
      
      inline def setUpdateExpression(value: VisitNode[S, Extract[Node, `100`]]): Self = StObject.set(x, "UpdateExpression", value.asInstanceOf[js.Any])
      
      inline def setUpdateExpressionUndefined: Self = StObject.set(x, "UpdateExpression", js.undefined)
      
      inline def setUser(value: VisitNode[S, Node]): Self = StObject.set(x, "User", value.asInstanceOf[js.Any])
      
      inline def setUserUndefined: Self = StObject.set(x, "User", js.undefined)
      
      inline def setUserWhitespacable(value: VisitNode[S, UserWhitespacable]): Self = StObject.set(x, "UserWhitespacable", value.asInstanceOf[js.Any])
      
      inline def setUserWhitespacableUndefined: Self = StObject.set(x, "UserWhitespacable", js.undefined)
      
      inline def setV8IntrinsicIdentifier(value: VisitNode[S, Extract[Node, `141`]]): Self = StObject.set(x, "V8IntrinsicIdentifier", value.asInstanceOf[js.Any])
      
      inline def setV8IntrinsicIdentifierUndefined: Self = StObject.set(x, "V8IntrinsicIdentifier", js.undefined)
      
      inline def setVar(value: VisitNode[S, VariableDeclaration_]): Self = StObject.set(x, "Var", value.asInstanceOf[js.Any])
      
      inline def setVarUndefined: Self = StObject.set(x, "Var", js.undefined)
      
      inline def setVariableDeclaration(value: VisitNode[S, Extract[Node, `68`]]): Self = StObject.set(x, "VariableDeclaration", value.asInstanceOf[js.Any])
      
      inline def setVariableDeclarationUndefined: Self = StObject.set(x, "VariableDeclaration", js.undefined)
      
      inline def setVariableDeclarator(value: VisitNode[S, Extract[Node, `130`]]): Self = StObject.set(x, "VariableDeclarator", value.asInstanceOf[js.Any])
      
      inline def setVariableDeclaratorUndefined: Self = StObject.set(x, "VariableDeclarator", js.undefined)
      
      inline def setVariance(value: VisitNode[S, Extract[Node, `153`]]): Self = StObject.set(x, "Variance", value.asInstanceOf[js.Any])
      
      inline def setVarianceUndefined: Self = StObject.set(x, "Variance", js.undefined)
      
      inline def setVoidTypeAnnotation(value: VisitNode[S, Extract[Node, `107`]]): Self = StObject.set(x, "VoidTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setVoidTypeAnnotationUndefined: Self = StObject.set(x, "VoidTypeAnnotation", js.undefined)
      
      inline def setWhile(value: VisitNode[S, While]): Self = StObject.set(x, "While", value.asInstanceOf[js.Any])
      
      inline def setWhileStatement(value: VisitNode[S, Extract[Node, `39`]]): Self = StObject.set(x, "WhileStatement", value.asInstanceOf[js.Any])
      
      inline def setWhileStatementUndefined: Self = StObject.set(x, "WhileStatement", js.undefined)
      
      inline def setWhileUndefined: Self = StObject.set(x, "While", js.undefined)
      
      inline def setWithStatement(value: VisitNode[S, Extract[Node, `96`]]): Self = StObject.set(x, "WithStatement", value.asInstanceOf[js.Any])
      
      inline def setWithStatementUndefined: Self = StObject.set(x, "WithStatement", js.undefined)
      
      inline def setYieldExpression(value: VisitNode[S, Extract[Node, `12`]]): Self = StObject.set(x, "YieldExpression", value.asInstanceOf[js.Any])
      
      inline def setYieldExpressionUndefined: Self = StObject.set(x, "YieldExpression", js.undefined)
    }
  }
  
  trait VirtualTypeAliases extends StObject {
    
    var BindingIdentifier: Identifier_
    
    var BlockScoped: Node
    
    var ExistentialTypeParam: ExistsTypeAnnotation_
    
    var Flow: typings.babelTypes.mod.Flow | ImportDeclaration_ | ExportDeclaration | ImportSpecifier_
    
    var ForAwaitStatement: ForOfStatement_
    
    var Generated: Node
    
    var NumericLiteralTypeAnnotation: NumberLiteralTypeAnnotation_
    
    var Pure: Node
    
    var Referenced: Node
    
    var ReferencedIdentifier: Identifier_ | JSXIdentifier_
    
    var ReferencedMemberExpression: MemberExpression_
    
    var RestProperty: RestElement_
    
    var Scope: Scopable | Pattern
    
    var SpreadProperty: RestElement_
    
    var User: Node
    
    var Var: VariableDeclaration_
  }
  object VirtualTypeAliases {
    
    @scala.inline
    implicit open class MutableBuilder[Self <: VirtualTypeAliases] (val x: Self) extends AnyVal {
      
      inline def setBindingIdentifier(value: Identifier_): Self = StObject.set(x, "BindingIdentifier", value.asInstanceOf[js.Any])
      
      inline def setBlockScoped(value: Node): Self = StObject.set(x, "BlockScoped", value.asInstanceOf[js.Any])
      
      inline def setExistentialTypeParam(value: ExistsTypeAnnotation_): Self = StObject.set(x, "ExistentialTypeParam", value.asInstanceOf[js.Any])
      
      inline def setFlow(value: Flow | ImportDeclaration_ | ExportDeclaration | ImportSpecifier_): Self = StObject.set(x, "Flow", value.asInstanceOf[js.Any])
      
      inline def setForAwaitStatement(value: ForOfStatement_): Self = StObject.set(x, "ForAwaitStatement", value.asInstanceOf[js.Any])
      
      inline def setGenerated(value: Node): Self = StObject.set(x, "Generated", value.asInstanceOf[js.Any])
      
      inline def setNumericLiteralTypeAnnotation(value: NumberLiteralTypeAnnotation_): Self = StObject.set(x, "NumericLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setPure(value: Node): Self = StObject.set(x, "Pure", value.asInstanceOf[js.Any])
      
      inline def setReferenced(value: Node): Self = StObject.set(x, "Referenced", value.asInstanceOf[js.Any])
      
      inline def setReferencedIdentifier(value: Identifier_ | JSXIdentifier_): Self = StObject.set(x, "ReferencedIdentifier", value.asInstanceOf[js.Any])
      
      inline def setReferencedMemberExpression(value: MemberExpression_): Self = StObject.set(x, "ReferencedMemberExpression", value.asInstanceOf[js.Any])
      
      inline def setRestProperty(value: RestElement_): Self = StObject.set(x, "RestProperty", value.asInstanceOf[js.Any])
      
      inline def setScope(value: Scopable | Pattern): Self = StObject.set(x, "Scope", value.asInstanceOf[js.Any])
      
      inline def setSpreadProperty(value: RestElement_): Self = StObject.set(x, "SpreadProperty", value.asInstanceOf[js.Any])
      
      inline def setUser(value: Node): Self = StObject.set(x, "User", value.asInstanceOf[js.Any])
      
      inline def setVar(value: VariableDeclaration_): Self = StObject.set(x, "Var", value.asInstanceOf[js.Any])
    }
  }
  
  type VisitNode[S, P /* <: Node */] = (VisitNodeFunction[S, P]) | (VisitNodeObject[S, P])
  
  type VisitNodeFunction[S, P /* <: Node */] = js.ThisFunction2[/* this */ S, /* path */ NodePath[P], /* state */ S, Unit]
  
  trait VisitNodeObject[S, P /* <: Node */] extends StObject {
    
    var enter: js.UndefOr[VisitNodeFunction[S, P]] = js.undefined
    
    var exit: js.UndefOr[VisitNodeFunction[S, P]] = js.undefined
  }
  object VisitNodeObject {
    
    inline def apply[S, P /* <: Node */](): VisitNodeObject[S, P] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[VisitNodeObject[S, P]]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: VisitNodeObject[?, ?], S, P /* <: Node */] (val x: Self & (VisitNodeObject[S, P])) extends AnyVal {
      
      inline def setEnter(value: VisitNodeFunction[S, P]): Self = StObject.set(x, "enter", value.asInstanceOf[js.Any])
      
      inline def setEnterUndefined: Self = StObject.set(x, "enter", js.undefined)
      
      inline def setExit(value: VisitNodeFunction[S, P]): Self = StObject.set(x, "exit", value.asInstanceOf[js.Any])
      
      inline def setExitUndefined: Self = StObject.set(x, "exit", js.undefined)
    }
  }
  
  /* Inlined @babel/traverse.@babel/traverse.VisitNodeObject<S, @babel/traverse.@babel/traverse.Node> & {[ Type in @babel/traverse.@babel/traverse.Node['type'] ]:? @babel/traverse.@babel/traverse.VisitNode<S, std.Extract<@babel/traverse.@babel/traverse.Node, {  type :Type}>>} & {[ K in keyof @babel/types.@babel/types.Aliases ]:? @babel/traverse.@babel/traverse.VisitNode<S, @babel/types.@babel/types.Aliases[K]>} & {[ K in keyof @babel/traverse.@babel/traverse.VirtualTypeAliases ]:? @babel/traverse.@babel/traverse.VisitNode<S, @babel/traverse.@babel/traverse.VirtualTypeAliases[K]>} & {[k: / * template literal string: ${string}|${string} * / string] : @babel/traverse.@babel/traverse.VisitNode<S, @babel/traverse.@babel/traverse.Node>} */
  trait Visitor[S]
    extends StObject
       with // Babel supports `NodeTypesWithoutComment | NodeTypesWithoutComment | ... ` but it is
  // too complex for TS. So we type it as a general visitor only if the key contains `|`
  // this is good enough for non-visitor traverse options e.g. `noScope`
  /* k */ StringDictionary[VisitNode[S, Node]] {
    
    var Accessor: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Accessor]] = js.undefined
    
    var AnyTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `65`]]] = js.undefined
    
    var ArgumentPlaceholder: js.UndefOr[VisitNode[S, Extract[Node, `239`]]] = js.undefined
    
    var ArrayExpression: js.UndefOr[VisitNode[S, Extract[Node, `56`]]] = js.undefined
    
    var ArrayPattern: js.UndefOr[VisitNode[S, Extract[Node, `115`]]] = js.undefined
    
    var ArrayTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `86`]]] = js.undefined
    
    var ArrowFunctionExpression: js.UndefOr[VisitNode[S, Extract[Node, `147`]]] = js.undefined
    
    var AssignmentExpression: js.UndefOr[VisitNode[S, Extract[Node, `135`]]] = js.undefined
    
    var AssignmentPattern: js.UndefOr[VisitNode[S, Extract[Node, `64`]]] = js.undefined
    
    var AwaitExpression: js.UndefOr[VisitNode[S, Extract[Node, `113`]]] = js.undefined
    
    var BigIntLiteral: js.UndefOr[VisitNode[S, Extract[Node, `184`]]] = js.undefined
    
    var Binary: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Binary]] = js.undefined
    
    var BinaryExpression: js.UndefOr[VisitNode[S, Extract[Node, `89`]]] = js.undefined
    
    var BindExpression: js.UndefOr[VisitNode[S, Extract[Node, `79`]]] = js.undefined
    
    var BindingIdentifier: js.UndefOr[VisitNode[S, Identifier_]] = js.undefined
    
    var Block: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Block]] = js.undefined
    
    var BlockParent: js.UndefOr[VisitNode[S, typings.babelTypes.mod.BlockParent]] = js.undefined
    
    var BlockScoped: js.UndefOr[VisitNode[S, Node]] = js.undefined
    
    var BlockStatement: js.UndefOr[VisitNode[S, Extract[Node, `25`]]] = js.undefined
    
    var BooleanLiteral: js.UndefOr[VisitNode[S, Extract[Node, `132`]]] = js.undefined
    
    var BooleanLiteralTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `178`]]] = js.undefined
    
    var BooleanTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `183`]]] = js.undefined
    
    var BreakStatement: js.UndefOr[VisitNode[S, Extract[Node, `1`]]] = js.undefined
    
    var CallExpression: js.UndefOr[VisitNode[S, Extract[Node, `47`]]] = js.undefined
    
    var CatchClause: js.UndefOr[VisitNode[S, Extract[Node, `176`]]] = js.undefined
    
    var Class: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Class]] = js.undefined
    
    var ClassAccessorProperty: js.UndefOr[VisitNode[S, Extract[Node, `214`]]] = js.undefined
    
    var ClassBody: js.UndefOr[VisitNode[S, Extract[Node, `232`]]] = js.undefined
    
    var ClassDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `109`]]] = js.undefined
    
    var ClassExpression: js.UndefOr[VisitNode[S, Extract[Node, Type]]] = js.undefined
    
    var ClassImplements: js.UndefOr[VisitNode[S, Extract[Node, `212`]]] = js.undefined
    
    var ClassMethod: js.UndefOr[VisitNode[S, Extract[Node, `189`]]] = js.undefined
    
    var ClassPrivateMethod: js.UndefOr[VisitNode[S, Extract[Node, `235`]]] = js.undefined
    
    var ClassPrivateProperty: js.UndefOr[VisitNode[S, Extract[Node, `230`]]] = js.undefined
    
    var ClassProperty: js.UndefOr[VisitNode[S, Extract[Node, `192`]]] = js.undefined
    
    var CompletionStatement: js.UndefOr[VisitNode[S, typings.babelTypes.mod.CompletionStatement]] = js.undefined
    
    var Conditional: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Conditional]] = js.undefined
    
    var ConditionalExpression: js.UndefOr[VisitNode[S, Extract[Node, `170`]]] = js.undefined
    
    var ContinueStatement: js.UndefOr[VisitNode[S, Extract[Node, `40`]]] = js.undefined
    
    var DebuggerStatement: js.UndefOr[VisitNode[S, Extract[Node, `138`]]] = js.undefined
    
    var DecimalLiteral: js.UndefOr[VisitNode[S, Extract[Node, `206`]]] = js.undefined
    
    var Declaration: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Declaration]] = js.undefined
    
    var DeclareClass: js.UndefOr[VisitNode[S, Extract[Node, `242`]]] = js.undefined
    
    var DeclareExportAllDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `110`]]] = js.undefined
    
    var DeclareExportDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `158`]]] = js.undefined
    
    var DeclareFunction: js.UndefOr[VisitNode[S, Extract[Node, `105`]]] = js.undefined
    
    var DeclareInterface: js.UndefOr[VisitNode[S, Extract[Node, `161`]]] = js.undefined
    
    var DeclareModule: js.UndefOr[VisitNode[S, Extract[Node, `35`]]] = js.undefined
    
    var DeclareModuleExports: js.UndefOr[VisitNode[S, Extract[Node, `223`]]] = js.undefined
    
    var DeclareOpaqueType: js.UndefOr[VisitNode[S, Extract[Node, `229`]]] = js.undefined
    
    var DeclareTypeAlias: js.UndefOr[VisitNode[S, Extract[Node, `167`]]] = js.undefined
    
    var DeclareVariable: js.UndefOr[VisitNode[S, Extract[Node, `182`]]] = js.undefined
    
    var DeclaredPredicate: js.UndefOr[VisitNode[S, Extract[Node, `188`]]] = js.undefined
    
    var Decorator: js.UndefOr[VisitNode[S, Extract[Node, `82`]]] = js.undefined
    
    var Directive: js.UndefOr[VisitNode[S, Extract[Node, `63`]]] = js.undefined
    
    var DirectiveLiteral: js.UndefOr[VisitNode[S, Extract[Node, `143`]]] = js.undefined
    
    var DoExpression: js.UndefOr[VisitNode[S, Extract[Node, `219`]]] = js.undefined
    
    var DoWhileStatement: js.UndefOr[VisitNode[S, Extract[Node, `200`]]] = js.undefined
    
    var EmptyStatement: js.UndefOr[VisitNode[S, Extract[Node, `108`]]] = js.undefined
    
    var EmptyTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `142`]]] = js.undefined
    
    var EnumBody: js.UndefOr[VisitNode[S, typings.babelTypes.mod.EnumBody]] = js.undefined
    
    var EnumBooleanBody: js.UndefOr[VisitNode[S, Extract[Node, `137`]]] = js.undefined
    
    var EnumBooleanMember: js.UndefOr[VisitNode[S, Extract[Node, `117`]]] = js.undefined
    
    var EnumDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `67`]]] = js.undefined
    
    var EnumDefaultedMember: js.UndefOr[VisitNode[S, Extract[Node, `191`]]] = js.undefined
    
    var EnumMember: js.UndefOr[VisitNode[S, typings.babelTypes.mod.EnumMember]] = js.undefined
    
    var EnumNumberBody: js.UndefOr[VisitNode[S, Extract[Node, `240`]]] = js.undefined
    
    var EnumNumberMember: js.UndefOr[VisitNode[S, Extract[Node, `205`]]] = js.undefined
    
    var EnumStringBody: js.UndefOr[VisitNode[S, Extract[Node, `163`]]] = js.undefined
    
    var EnumStringMember: js.UndefOr[VisitNode[S, Extract[Node, `4`]]] = js.undefined
    
    var EnumSymbolBody: js.UndefOr[VisitNode[S, Extract[Node, `198`]]] = js.undefined
    
    var ExistentialTypeParam: js.UndefOr[VisitNode[S, ExistsTypeAnnotation_]] = js.undefined
    
    var ExistsTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `119`]]] = js.undefined
    
    var ExportAllDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `37`]]] = js.undefined
    
    var ExportDeclaration: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ExportDeclaration]] = js.undefined
    
    var ExportDefaultDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `80`]]] = js.undefined
    
    var ExportDefaultSpecifier: js.UndefOr[VisitNode[S, Extract[Node, `3`]]] = js.undefined
    
    var ExportNamedDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `46`]]] = js.undefined
    
    var ExportNamespaceSpecifier: js.UndefOr[VisitNode[S, Extract[Node, `179`]]] = js.undefined
    
    var ExportSpecifier: js.UndefOr[VisitNode[S, Extract[Node, `116`]]] = js.undefined
    
    var Expression: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Expression]] = js.undefined
    
    var ExpressionStatement: js.UndefOr[VisitNode[S, Extract[Node, `62`]]] = js.undefined
    
    var ExpressionWrapper: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ExpressionWrapper]] = js.undefined
    
    var File: js.UndefOr[VisitNode[S, Extract[Node, `28`]]] = js.undefined
    
    var Flow: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Flow]] = js.undefined
    
    var FlowBaseAnnotation: js.UndefOr[VisitNode[S, typings.babelTypes.mod.FlowBaseAnnotation]] = js.undefined
    
    var FlowDeclaration: js.UndefOr[VisitNode[S, typings.babelTypes.mod.FlowDeclaration]] = js.undefined
    
    var FlowPredicate: js.UndefOr[VisitNode[S, typings.babelTypes.mod.FlowPredicate]] = js.undefined
    
    var FlowType: js.UndefOr[VisitNode[S, typings.babelTypes.mod.FlowType]] = js.undefined
    
    var For: js.UndefOr[VisitNode[S, typings.babelTypes.mod.For]] = js.undefined
    
    var ForAwaitStatement: js.UndefOr[VisitNode[S, ForOfStatement_]] = js.undefined
    
    var ForInStatement: js.UndefOr[VisitNode[S, Extract[Node, `17`]]] = js.undefined
    
    var ForOfStatement: js.UndefOr[VisitNode[S, Extract[Node, `166`]]] = js.undefined
    
    var ForStatement: js.UndefOr[VisitNode[S, Extract[Node, `190`]]] = js.undefined
    
    var ForXStatement: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ForXStatement]] = js.undefined
    
    var Function: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Function]] = js.undefined
    
    var FunctionDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `136`]]] = js.undefined
    
    var FunctionExpression: js.UndefOr[VisitNode[S, Extract[Node, `193`]]] = js.undefined
    
    var FunctionParent: js.UndefOr[VisitNode[S, typings.babelTypes.mod.FunctionParent]] = js.undefined
    
    var FunctionTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `41`]]] = js.undefined
    
    var FunctionTypeParam: js.UndefOr[VisitNode[S, Extract[Node, `228`]]] = js.undefined
    
    var Generated: js.UndefOr[VisitNode[S, Node]] = js.undefined
    
    var GenericTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `244`]]] = js.undefined
    
    var Identifier: js.UndefOr[VisitNode[S, Extract[Node, `99`]]] = js.undefined
    
    var IfStatement: js.UndefOr[VisitNode[S, Extract[Node, `85`]]] = js.undefined
    
    var Immutable: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Immutable]] = js.undefined
    
    var Import: js.UndefOr[VisitNode[S, Extract[Node, `172`]]] = js.undefined
    
    var ImportAttribute: js.UndefOr[VisitNode[S, Extract[Node, `123`]]] = js.undefined
    
    var ImportDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `243`]]] = js.undefined
    
    var ImportDefaultSpecifier: js.UndefOr[VisitNode[S, Extract[Node, `19`]]] = js.undefined
    
    var ImportNamespaceSpecifier: js.UndefOr[VisitNode[S, Extract[Node, `202`]]] = js.undefined
    
    var ImportOrExportDeclaration: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ImportOrExportDeclaration]] = js.undefined
    
    var ImportSpecifier: js.UndefOr[VisitNode[S, Extract[Node, `114`]]] = js.undefined
    
    var IndexedAccessType: js.UndefOr[VisitNode[S, Extract[Node, `69`]]] = js.undefined
    
    var InferredPredicate: js.UndefOr[VisitNode[S, Extract[Node, `134`]]] = js.undefined
    
    var InterfaceDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `48`]]] = js.undefined
    
    var InterfaceExtends: js.UndefOr[VisitNode[S, Extract[Node, `139`]]] = js.undefined
    
    var InterfaceTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `9`]]] = js.undefined
    
    var InterpreterDirective: js.UndefOr[VisitNode[S, Extract[Node, `88`]]] = js.undefined
    
    var IntersectionTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `215`]]] = js.undefined
    
    var JSX: js.UndefOr[VisitNode[S, typings.babelTypes.mod.JSX]] = js.undefined
    
    var JSXAttribute: js.UndefOr[VisitNode[S, Extract[Node, `103`]]] = js.undefined
    
    var JSXClosingElement: js.UndefOr[VisitNode[S, Extract[Node, `129`]]] = js.undefined
    
    var JSXClosingFragment: js.UndefOr[VisitNode[S, Extract[Node, `211`]]] = js.undefined
    
    var JSXElement: js.UndefOr[VisitNode[S, Extract[Node, `174`]]] = js.undefined
    
    var JSXEmptyExpression: js.UndefOr[VisitNode[S, Extract[Node, `125`]]] = js.undefined
    
    var JSXExpressionContainer: js.UndefOr[VisitNode[S, Extract[Node, `32`]]] = js.undefined
    
    var JSXFragment: js.UndefOr[VisitNode[S, Extract[Node, `152`]]] = js.undefined
    
    var JSXIdentifier: js.UndefOr[VisitNode[S, Extract[Node, `87`]]] = js.undefined
    
    var JSXMemberExpression: js.UndefOr[VisitNode[S, Extract[Node, `197`]]] = js.undefined
    
    var JSXNamespacedName: js.UndefOr[VisitNode[S, Extract[Node, `154`]]] = js.undefined
    
    var JSXOpeningElement: js.UndefOr[VisitNode[S, Extract[Node, `74`]]] = js.undefined
    
    var JSXOpeningFragment: js.UndefOr[VisitNode[S, Extract[Node, `220`]]] = js.undefined
    
    var JSXSpreadAttribute: js.UndefOr[VisitNode[S, Extract[Node, `49`]]] = js.undefined
    
    var JSXSpreadChild: js.UndefOr[VisitNode[S, Extract[Node, `73`]]] = js.undefined
    
    var JSXText: js.UndefOr[VisitNode[S, Extract[Node, `195`]]] = js.undefined
    
    var LVal: js.UndefOr[VisitNode[S, typings.babelTypes.mod.LVal]] = js.undefined
    
    var LabeledStatement: js.UndefOr[VisitNode[S, Extract[Node, `36`]]] = js.undefined
    
    var Literal: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Literal]] = js.undefined
    
    var LogicalExpression: js.UndefOr[VisitNode[S, Extract[Node, `70`]]] = js.undefined
    
    var Loop: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Loop]] = js.undefined
    
    var MemberExpression: js.UndefOr[VisitNode[S, Extract[Node, `60`]]] = js.undefined
    
    var MetaProperty: js.UndefOr[VisitNode[S, Extract[Node, `83`]]] = js.undefined
    
    var Method: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Method]] = js.undefined
    
    var Miscellaneous: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Miscellaneous]] = js.undefined
    
    var MixedTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `57`]]] = js.undefined
    
    var ModuleDeclaration: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ModuleDeclaration]] = js.undefined
    
    var ModuleExpression: js.UndefOr[VisitNode[S, Extract[Node, `148`]]] = js.undefined
    
    var ModuleSpecifier: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ModuleSpecifier]] = js.undefined
    
    var NewExpression: js.UndefOr[VisitNode[S, Extract[Node, `59`]]] = js.undefined
    
    var Noop: js.UndefOr[VisitNode[S, Extract[Node, `34`]]] = js.undefined
    
    var NullLiteral: js.UndefOr[VisitNode[S, Extract[Node, `245`]]] = js.undefined
    
    var NullLiteralTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `43`]]] = js.undefined
    
    var NullableTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `98`]]] = js.undefined
    
    var NumberLiteralTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `157`]]] = js.undefined
    
    var NumberTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `164`]]] = js.undefined
    
    var NumericLiteral: js.UndefOr[VisitNode[S, Extract[Node, `217`]]] = js.undefined
    
    var NumericLiteralTypeAnnotation: js.UndefOr[VisitNode[S, NumberLiteralTypeAnnotation_]] = js.undefined
    
    var ObjectExpression: js.UndefOr[VisitNode[S, Extract[Node, `124`]]] = js.undefined
    
    var ObjectMember: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ObjectMember]] = js.undefined
    
    var ObjectMethod: js.UndefOr[VisitNode[S, Extract[Node, `126`]]] = js.undefined
    
    var ObjectPattern: js.UndefOr[VisitNode[S, Extract[Node, `224`]]] = js.undefined
    
    var ObjectProperty: js.UndefOr[VisitNode[S, Extract[Node, `144`]]] = js.undefined
    
    var ObjectTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `84`]]] = js.undefined
    
    var ObjectTypeCallProperty: js.UndefOr[VisitNode[S, Extract[Node, `13`]]] = js.undefined
    
    var ObjectTypeIndexer: js.UndefOr[VisitNode[S, Extract[Node, `175`]]] = js.undefined
    
    var ObjectTypeInternalSlot: js.UndefOr[VisitNode[S, Extract[Node, `233`]]] = js.undefined
    
    var ObjectTypeProperty: js.UndefOr[VisitNode[S, Extract[Node, `159`]]] = js.undefined
    
    var ObjectTypeSpreadProperty: js.UndefOr[VisitNode[S, Extract[Node, `81`]]] = js.undefined
    
    var OpaqueType: js.UndefOr[VisitNode[S, Extract[Node, `71`]]] = js.undefined
    
    var OptionalCallExpression: js.UndefOr[VisitNode[S, Extract[Node, `45`]]] = js.undefined
    
    var OptionalIndexedAccessType: js.UndefOr[VisitNode[S, Extract[Node, `146`]]] = js.undefined
    
    var OptionalMemberExpression: js.UndefOr[VisitNode[S, Extract[Node, `27`]]] = js.undefined
    
    var ParenthesizedExpression: js.UndefOr[VisitNode[S, Extract[Node, `204`]]] = js.undefined
    
    var Pattern: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Pattern]] = js.undefined
    
    var PatternLike: js.UndefOr[VisitNode[S, typings.babelTypes.mod.PatternLike]] = js.undefined
    
    var PipelineBareFunction: js.UndefOr[VisitNode[S, Extract[Node, `162`]]] = js.undefined
    
    var PipelinePrimaryTopicReference: js.UndefOr[VisitNode[S, Extract[Node, `31`]]] = js.undefined
    
    var PipelineTopicExpression: js.UndefOr[VisitNode[S, Extract[Node, `106`]]] = js.undefined
    
    var Placeholder: js.UndefOr[VisitNode[S, Extract[Node, `168`]]] = js.undefined
    
    var Private: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Private]] = js.undefined
    
    var PrivateName: js.UndefOr[VisitNode[S, Extract[Node, `95`]]] = js.undefined
    
    var Program: js.UndefOr[VisitNode[S, Extract[Node, `155`]]] = js.undefined
    
    var Property: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Property]] = js.undefined
    
    var Pure: js.UndefOr[VisitNode[S, Node]] = js.undefined
    
    var Pureish: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Pureish]] = js.undefined
    
    var QualifiedTypeIdentifier: js.UndefOr[VisitNode[S, Extract[Node, `75`]]] = js.undefined
    
    var RecordExpression: js.UndefOr[VisitNode[S, Extract[Node, `61`]]] = js.undefined
    
    var Referenced: js.UndefOr[VisitNode[S, Node]] = js.undefined
    
    var ReferencedIdentifier: js.UndefOr[VisitNode[S, Identifier_ | JSXIdentifier_]] = js.undefined
    
    var ReferencedMemberExpression: js.UndefOr[VisitNode[S, MemberExpression_]] = js.undefined
    
    var RegExpLiteral: js.UndefOr[VisitNode[S, Extract[Node, `38`]]] = js.undefined
    
    var RestElement: js.UndefOr[VisitNode[S, Extract[Node, `26`]]] = js.undefined
    
    var RestProperty: js.UndefOr[VisitNode[S, RestElement_]] = js.undefined
    
    var ReturnStatement: js.UndefOr[VisitNode[S, Extract[Node, `5`]]] = js.undefined
    
    var Scopable: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Scopable]] = js.undefined
    
    var Scope: js.UndefOr[VisitNode[S, Scopable | Pattern]] = js.undefined
    
    var SequenceExpression: js.UndefOr[VisitNode[S, Extract[Node, `171`]]] = js.undefined
    
    var SpreadElement: js.UndefOr[VisitNode[S, Extract[Node, `23`]]] = js.undefined
    
    var SpreadProperty: js.UndefOr[VisitNode[S, RestElement_]] = js.undefined
    
    var Standardized: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Standardized]] = js.undefined
    
    var Statement: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Statement]] = js.undefined
    
    var StaticBlock: js.UndefOr[VisitNode[S, Extract[Node, `111`]]] = js.undefined
    
    var StringLiteral: js.UndefOr[VisitNode[S, Extract[Node, `131`]]] = js.undefined
    
    var StringLiteralTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `226`]]] = js.undefined
    
    var StringTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `2`]]] = js.undefined
    
    var Super: js.UndefOr[VisitNode[S, Extract[Node, `165`]]] = js.undefined
    
    var SwitchCase: js.UndefOr[VisitNode[S, Extract[Node, `54`]]] = js.undefined
    
    var SwitchStatement: js.UndefOr[VisitNode[S, Extract[Node, `44`]]] = js.undefined
    
    var SymbolTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `50`]]] = js.undefined
    
    var TSAnyKeyword: js.UndefOr[VisitNode[S, Extract[Node, `10`]]] = js.undefined
    
    var TSArrayType: js.UndefOr[VisitNode[S, Extract[Node, `0`]]] = js.undefined
    
    var TSAsExpression: js.UndefOr[VisitNode[S, Extract[Node, `8`]]] = js.undefined
    
    var TSBaseType: js.UndefOr[VisitNode[S, typings.babelTypes.mod.TSBaseType]] = js.undefined
    
    var TSBigIntKeyword: js.UndefOr[VisitNode[S, Extract[Node, `53`]]] = js.undefined
    
    var TSBooleanKeyword: js.UndefOr[VisitNode[S, Extract[Node, `225`]]] = js.undefined
    
    var TSCallSignatureDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `151`]]] = js.undefined
    
    var TSConditionalType: js.UndefOr[VisitNode[S, Extract[Node, `18`]]] = js.undefined
    
    var TSConstructSignatureDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `122`]]] = js.undefined
    
    var TSConstructorType: js.UndefOr[VisitNode[S, Extract[Node, `213`]]] = js.undefined
    
    var TSDeclareFunction: js.UndefOr[VisitNode[S, Extract[Node, `201`]]] = js.undefined
    
    var TSDeclareMethod: js.UndefOr[VisitNode[S, Extract[Node, `77`]]] = js.undefined
    
    var TSEntityName: js.UndefOr[VisitNode[S, typings.babelTypes.mod.TSEntityName]] = js.undefined
    
    var TSEnumDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `91`]]] = js.undefined
    
    var TSEnumMember: js.UndefOr[VisitNode[S, Extract[Node, `133`]]] = js.undefined
    
    var TSExportAssignment: js.UndefOr[VisitNode[S, Extract[Node, `145`]]] = js.undefined
    
    var TSExpressionWithTypeArguments: js.UndefOr[VisitNode[S, Extract[Node, `149`]]] = js.undefined
    
    var TSExternalModuleReference: js.UndefOr[VisitNode[S, Extract[Node, `121`]]] = js.undefined
    
    var TSFunctionType: js.UndefOr[VisitNode[S, Extract[Node, `42`]]] = js.undefined
    
    var TSImportEqualsDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `160`]]] = js.undefined
    
    var TSImportType: js.UndefOr[VisitNode[S, Extract[Node, `241`]]] = js.undefined
    
    var TSIndexSignature: js.UndefOr[VisitNode[S, Extract[Node, `207`]]] = js.undefined
    
    var TSIndexedAccessType: js.UndefOr[VisitNode[S, Extract[Node, `29`]]] = js.undefined
    
    var TSInferType: js.UndefOr[VisitNode[S, Extract[Node, `104`]]] = js.undefined
    
    var TSInstantiationExpression: js.UndefOr[VisitNode[S, Extract[Node, `216`]]] = js.undefined
    
    var TSInterfaceBody: js.UndefOr[VisitNode[S, Extract[Node, `7`]]] = js.undefined
    
    var TSInterfaceDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `187`]]] = js.undefined
    
    var TSIntersectionType: js.UndefOr[VisitNode[S, Extract[Node, `238`]]] = js.undefined
    
    var TSIntrinsicKeyword: js.UndefOr[VisitNode[S, Extract[Node, `66`]]] = js.undefined
    
    var TSLiteralType: js.UndefOr[VisitNode[S, Extract[Node, `20`]]] = js.undefined
    
    var TSMappedType: js.UndefOr[VisitNode[S, Extract[Node, `128`]]] = js.undefined
    
    var TSMethodSignature: js.UndefOr[VisitNode[S, Extract[Node, `203`]]] = js.undefined
    
    var TSModuleBlock: js.UndefOr[VisitNode[S, Extract[Node, `231`]]] = js.undefined
    
    var TSModuleDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `16`]]] = js.undefined
    
    var TSNamedTupleMember: js.UndefOr[VisitNode[S, Extract[Node, `222`]]] = js.undefined
    
    var TSNamespaceExportDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `90`]]] = js.undefined
    
    var TSNeverKeyword: js.UndefOr[VisitNode[S, Extract[Node, `237`]]] = js.undefined
    
    var TSNonNullExpression: js.UndefOr[VisitNode[S, Extract[Node, `97`]]] = js.undefined
    
    var TSNullKeyword: js.UndefOr[VisitNode[S, Extract[Node, `33`]]] = js.undefined
    
    var TSNumberKeyword: js.UndefOr[VisitNode[S, Extract[Node, `181`]]] = js.undefined
    
    var TSObjectKeyword: js.UndefOr[VisitNode[S, Extract[Node, `218`]]] = js.undefined
    
    var TSOptionalType: js.UndefOr[VisitNode[S, Extract[Node, `185`]]] = js.undefined
    
    var TSParameterProperty: js.UndefOr[VisitNode[S, Extract[Node, `196`]]] = js.undefined
    
    var TSParenthesizedType: js.UndefOr[VisitNode[S, Extract[Node, `227`]]] = js.undefined
    
    var TSPropertySignature: js.UndefOr[VisitNode[S, Extract[Node, `118`]]] = js.undefined
    
    var TSQualifiedName: js.UndefOr[VisitNode[S, Extract[Node, `30`]]] = js.undefined
    
    var TSRestType: js.UndefOr[VisitNode[S, Extract[Node, `210`]]] = js.undefined
    
    var TSSatisfiesExpression: js.UndefOr[VisitNode[S, Extract[Node, `6`]]] = js.undefined
    
    var TSStringKeyword: js.UndefOr[VisitNode[S, Extract[Node, `101`]]] = js.undefined
    
    var TSSymbolKeyword: js.UndefOr[VisitNode[S, Extract[Node, `127`]]] = js.undefined
    
    var TSThisType: js.UndefOr[VisitNode[S, Extract[Node, `208`]]] = js.undefined
    
    var TSTupleType: js.UndefOr[VisitNode[S, Extract[Node, `199`]]] = js.undefined
    
    var TSType: js.UndefOr[VisitNode[S, typings.babelTypes.mod.TSType]] = js.undefined
    
    var TSTypeAliasDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `92`]]] = js.undefined
    
    var TSTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `112`]]] = js.undefined
    
    var TSTypeAssertion: js.UndefOr[VisitNode[S, Extract[Node, `236`]]] = js.undefined
    
    var TSTypeElement: js.UndefOr[VisitNode[S, typings.babelTypes.mod.TSTypeElement]] = js.undefined
    
    var TSTypeLiteral: js.UndefOr[VisitNode[S, Extract[Node, `156`]]] = js.undefined
    
    var TSTypeOperator: js.UndefOr[VisitNode[S, Extract[Node, `52`]]] = js.undefined
    
    var TSTypeParameter: js.UndefOr[VisitNode[S, Extract[Node, `94`]]] = js.undefined
    
    var TSTypeParameterDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `21`]]] = js.undefined
    
    var TSTypeParameterInstantiation: js.UndefOr[VisitNode[S, Extract[Node, `76`]]] = js.undefined
    
    var TSTypePredicate: js.UndefOr[VisitNode[S, Extract[Node, `186`]]] = js.undefined
    
    var TSTypeQuery: js.UndefOr[VisitNode[S, Extract[Node, `120`]]] = js.undefined
    
    var TSTypeReference: js.UndefOr[VisitNode[S, Extract[Node, `247`]]] = js.undefined
    
    var TSUndefinedKeyword: js.UndefOr[VisitNode[S, Extract[Node, `169`]]] = js.undefined
    
    var TSUnionType: js.UndefOr[VisitNode[S, Extract[Node, `93`]]] = js.undefined
    
    var TSUnknownKeyword: js.UndefOr[VisitNode[S, Extract[Node, `55`]]] = js.undefined
    
    var TSVoidKeyword: js.UndefOr[VisitNode[S, Extract[Node, `58`]]] = js.undefined
    
    var TaggedTemplateExpression: js.UndefOr[VisitNode[S, Extract[Node, `72`]]] = js.undefined
    
    var TemplateElement: js.UndefOr[VisitNode[S, Extract[Node, `194`]]] = js.undefined
    
    var TemplateLiteral: js.UndefOr[VisitNode[S, Extract[Node, `78`]]] = js.undefined
    
    var Terminatorless: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Terminatorless]] = js.undefined
    
    var ThisExpression: js.UndefOr[VisitNode[S, Extract[Node, `234`]]] = js.undefined
    
    var ThisTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `51`]]] = js.undefined
    
    var ThrowStatement: js.UndefOr[VisitNode[S, Extract[Node, `140`]]] = js.undefined
    
    var TopicReference: js.UndefOr[VisitNode[S, Extract[Node, `102`]]] = js.undefined
    
    var TryStatement: js.UndefOr[VisitNode[S, Extract[Node, `24`]]] = js.undefined
    
    var TupleExpression: js.UndefOr[VisitNode[S, Extract[Node, `209`]]] = js.undefined
    
    var TupleTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `14`]]] = js.undefined
    
    var TypeAlias: js.UndefOr[VisitNode[S, Extract[Node, `180`]]] = js.undefined
    
    var TypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `22`]]] = js.undefined
    
    var TypeCastExpression: js.UndefOr[VisitNode[S, Extract[Node, `11`]]] = js.undefined
    
    var TypeParameter: js.UndefOr[VisitNode[S, Extract[Node, `173`]]] = js.undefined
    
    var TypeParameterDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `15`]]] = js.undefined
    
    var TypeParameterInstantiation: js.UndefOr[VisitNode[S, Extract[Node, `246`]]] = js.undefined
    
    var TypeScript: js.UndefOr[VisitNode[S, typings.babelTypes.mod.TypeScript]] = js.undefined
    
    var TypeofTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `150`]]] = js.undefined
    
    var UnaryExpression: js.UndefOr[VisitNode[S, Extract[Node, `177`]]] = js.undefined
    
    var UnaryLike: js.UndefOr[VisitNode[S, typings.babelTypes.mod.UnaryLike]] = js.undefined
    
    var UnionTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `221`]]] = js.undefined
    
    var UpdateExpression: js.UndefOr[VisitNode[S, Extract[Node, `100`]]] = js.undefined
    
    var User: js.UndefOr[VisitNode[S, Node]] = js.undefined
    
    var UserWhitespacable: js.UndefOr[VisitNode[S, typings.babelTypes.mod.UserWhitespacable]] = js.undefined
    
    var V8IntrinsicIdentifier: js.UndefOr[VisitNode[S, Extract[Node, `141`]]] = js.undefined
    
    var Var: js.UndefOr[VisitNode[S, VariableDeclaration_]] = js.undefined
    
    var VariableDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `68`]]] = js.undefined
    
    var VariableDeclarator: js.UndefOr[VisitNode[S, Extract[Node, `130`]]] = js.undefined
    
    var Variance: js.UndefOr[VisitNode[S, Extract[Node, `153`]]] = js.undefined
    
    var VoidTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `107`]]] = js.undefined
    
    var While: js.UndefOr[VisitNode[S, typings.babelTypes.mod.While]] = js.undefined
    
    var WhileStatement: js.UndefOr[VisitNode[S, Extract[Node, `39`]]] = js.undefined
    
    var WithStatement: js.UndefOr[VisitNode[S, Extract[Node, `96`]]] = js.undefined
    
    var YieldExpression: js.UndefOr[VisitNode[S, Extract[Node, `12`]]] = js.undefined
    
    var enter: js.UndefOr[VisitNodeFunction[S, Node]] = js.undefined
    
    var exit: js.UndefOr[VisitNodeFunction[S, Node]] = js.undefined
  }
  object Visitor {
    
    inline def apply[S](Object: js.Object): Visitor[S] = {
      val __obj = js.Dynamic.literal()
      js.Dynamic.global.Object.assign(__obj, Object)
      __obj.asInstanceOf[Visitor[S]]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: Visitor[?], S] (val x: Self & Visitor[S]) extends AnyVal {
      
      inline def setAccessor(value: VisitNode[S, Accessor]): Self = StObject.set(x, "Accessor", value.asInstanceOf[js.Any])
      
      inline def setAccessorUndefined: Self = StObject.set(x, "Accessor", js.undefined)
      
      inline def setAnyTypeAnnotation(value: VisitNode[S, Extract[Node, `65`]]): Self = StObject.set(x, "AnyTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setAnyTypeAnnotationUndefined: Self = StObject.set(x, "AnyTypeAnnotation", js.undefined)
      
      inline def setArgumentPlaceholder(value: VisitNode[S, Extract[Node, `239`]]): Self = StObject.set(x, "ArgumentPlaceholder", value.asInstanceOf[js.Any])
      
      inline def setArgumentPlaceholderUndefined: Self = StObject.set(x, "ArgumentPlaceholder", js.undefined)
      
      inline def setArrayExpression(value: VisitNode[S, Extract[Node, `56`]]): Self = StObject.set(x, "ArrayExpression", value.asInstanceOf[js.Any])
      
      inline def setArrayExpressionUndefined: Self = StObject.set(x, "ArrayExpression", js.undefined)
      
      inline def setArrayPattern(value: VisitNode[S, Extract[Node, `115`]]): Self = StObject.set(x, "ArrayPattern", value.asInstanceOf[js.Any])
      
      inline def setArrayPatternUndefined: Self = StObject.set(x, "ArrayPattern", js.undefined)
      
      inline def setArrayTypeAnnotation(value: VisitNode[S, Extract[Node, `86`]]): Self = StObject.set(x, "ArrayTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setArrayTypeAnnotationUndefined: Self = StObject.set(x, "ArrayTypeAnnotation", js.undefined)
      
      inline def setArrowFunctionExpression(value: VisitNode[S, Extract[Node, `147`]]): Self = StObject.set(x, "ArrowFunctionExpression", value.asInstanceOf[js.Any])
      
      inline def setArrowFunctionExpressionUndefined: Self = StObject.set(x, "ArrowFunctionExpression", js.undefined)
      
      inline def setAssignmentExpression(value: VisitNode[S, Extract[Node, `135`]]): Self = StObject.set(x, "AssignmentExpression", value.asInstanceOf[js.Any])
      
      inline def setAssignmentExpressionUndefined: Self = StObject.set(x, "AssignmentExpression", js.undefined)
      
      inline def setAssignmentPattern(value: VisitNode[S, Extract[Node, `64`]]): Self = StObject.set(x, "AssignmentPattern", value.asInstanceOf[js.Any])
      
      inline def setAssignmentPatternUndefined: Self = StObject.set(x, "AssignmentPattern", js.undefined)
      
      inline def setAwaitExpression(value: VisitNode[S, Extract[Node, `113`]]): Self = StObject.set(x, "AwaitExpression", value.asInstanceOf[js.Any])
      
      inline def setAwaitExpressionUndefined: Self = StObject.set(x, "AwaitExpression", js.undefined)
      
      inline def setBigIntLiteral(value: VisitNode[S, Extract[Node, `184`]]): Self = StObject.set(x, "BigIntLiteral", value.asInstanceOf[js.Any])
      
      inline def setBigIntLiteralUndefined: Self = StObject.set(x, "BigIntLiteral", js.undefined)
      
      inline def setBinary(value: VisitNode[S, Binary]): Self = StObject.set(x, "Binary", value.asInstanceOf[js.Any])
      
      inline def setBinaryExpression(value: VisitNode[S, Extract[Node, `89`]]): Self = StObject.set(x, "BinaryExpression", value.asInstanceOf[js.Any])
      
      inline def setBinaryExpressionUndefined: Self = StObject.set(x, "BinaryExpression", js.undefined)
      
      inline def setBinaryUndefined: Self = StObject.set(x, "Binary", js.undefined)
      
      inline def setBindExpression(value: VisitNode[S, Extract[Node, `79`]]): Self = StObject.set(x, "BindExpression", value.asInstanceOf[js.Any])
      
      inline def setBindExpressionUndefined: Self = StObject.set(x, "BindExpression", js.undefined)
      
      inline def setBindingIdentifier(value: VisitNode[S, Identifier_]): Self = StObject.set(x, "BindingIdentifier", value.asInstanceOf[js.Any])
      
      inline def setBindingIdentifierUndefined: Self = StObject.set(x, "BindingIdentifier", js.undefined)
      
      inline def setBlock(value: VisitNode[S, Block]): Self = StObject.set(x, "Block", value.asInstanceOf[js.Any])
      
      inline def setBlockParent(value: VisitNode[S, BlockParent]): Self = StObject.set(x, "BlockParent", value.asInstanceOf[js.Any])
      
      inline def setBlockParentUndefined: Self = StObject.set(x, "BlockParent", js.undefined)
      
      inline def setBlockScoped(value: VisitNode[S, Node]): Self = StObject.set(x, "BlockScoped", value.asInstanceOf[js.Any])
      
      inline def setBlockScopedUndefined: Self = StObject.set(x, "BlockScoped", js.undefined)
      
      inline def setBlockStatement(value: VisitNode[S, Extract[Node, `25`]]): Self = StObject.set(x, "BlockStatement", value.asInstanceOf[js.Any])
      
      inline def setBlockStatementUndefined: Self = StObject.set(x, "BlockStatement", js.undefined)
      
      inline def setBlockUndefined: Self = StObject.set(x, "Block", js.undefined)
      
      inline def setBooleanLiteral(value: VisitNode[S, Extract[Node, `132`]]): Self = StObject.set(x, "BooleanLiteral", value.asInstanceOf[js.Any])
      
      inline def setBooleanLiteralTypeAnnotation(value: VisitNode[S, Extract[Node, `178`]]): Self = StObject.set(x, "BooleanLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setBooleanLiteralTypeAnnotationUndefined: Self = StObject.set(x, "BooleanLiteralTypeAnnotation", js.undefined)
      
      inline def setBooleanLiteralUndefined: Self = StObject.set(x, "BooleanLiteral", js.undefined)
      
      inline def setBooleanTypeAnnotation(value: VisitNode[S, Extract[Node, `183`]]): Self = StObject.set(x, "BooleanTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setBooleanTypeAnnotationUndefined: Self = StObject.set(x, "BooleanTypeAnnotation", js.undefined)
      
      inline def setBreakStatement(value: VisitNode[S, Extract[Node, `1`]]): Self = StObject.set(x, "BreakStatement", value.asInstanceOf[js.Any])
      
      inline def setBreakStatementUndefined: Self = StObject.set(x, "BreakStatement", js.undefined)
      
      inline def setCallExpression(value: VisitNode[S, Extract[Node, `47`]]): Self = StObject.set(x, "CallExpression", value.asInstanceOf[js.Any])
      
      inline def setCallExpressionUndefined: Self = StObject.set(x, "CallExpression", js.undefined)
      
      inline def setCatchClause(value: VisitNode[S, Extract[Node, `176`]]): Self = StObject.set(x, "CatchClause", value.asInstanceOf[js.Any])
      
      inline def setCatchClauseUndefined: Self = StObject.set(x, "CatchClause", js.undefined)
      
      inline def setClass(value: VisitNode[S, Class]): Self = StObject.set(x, "Class", value.asInstanceOf[js.Any])
      
      inline def setClassAccessorProperty(value: VisitNode[S, Extract[Node, `214`]]): Self = StObject.set(x, "ClassAccessorProperty", value.asInstanceOf[js.Any])
      
      inline def setClassAccessorPropertyUndefined: Self = StObject.set(x, "ClassAccessorProperty", js.undefined)
      
      inline def setClassBody(value: VisitNode[S, Extract[Node, `232`]]): Self = StObject.set(x, "ClassBody", value.asInstanceOf[js.Any])
      
      inline def setClassBodyUndefined: Self = StObject.set(x, "ClassBody", js.undefined)
      
      inline def setClassDeclaration(value: VisitNode[S, Extract[Node, `109`]]): Self = StObject.set(x, "ClassDeclaration", value.asInstanceOf[js.Any])
      
      inline def setClassDeclarationUndefined: Self = StObject.set(x, "ClassDeclaration", js.undefined)
      
      inline def setClassExpression(value: VisitNode[S, Extract[Node, Type]]): Self = StObject.set(x, "ClassExpression", value.asInstanceOf[js.Any])
      
      inline def setClassExpressionUndefined: Self = StObject.set(x, "ClassExpression", js.undefined)
      
      inline def setClassImplements(value: VisitNode[S, Extract[Node, `212`]]): Self = StObject.set(x, "ClassImplements", value.asInstanceOf[js.Any])
      
      inline def setClassImplementsUndefined: Self = StObject.set(x, "ClassImplements", js.undefined)
      
      inline def setClassMethod(value: VisitNode[S, Extract[Node, `189`]]): Self = StObject.set(x, "ClassMethod", value.asInstanceOf[js.Any])
      
      inline def setClassMethodUndefined: Self = StObject.set(x, "ClassMethod", js.undefined)
      
      inline def setClassPrivateMethod(value: VisitNode[S, Extract[Node, `235`]]): Self = StObject.set(x, "ClassPrivateMethod", value.asInstanceOf[js.Any])
      
      inline def setClassPrivateMethodUndefined: Self = StObject.set(x, "ClassPrivateMethod", js.undefined)
      
      inline def setClassPrivateProperty(value: VisitNode[S, Extract[Node, `230`]]): Self = StObject.set(x, "ClassPrivateProperty", value.asInstanceOf[js.Any])
      
      inline def setClassPrivatePropertyUndefined: Self = StObject.set(x, "ClassPrivateProperty", js.undefined)
      
      inline def setClassProperty(value: VisitNode[S, Extract[Node, `192`]]): Self = StObject.set(x, "ClassProperty", value.asInstanceOf[js.Any])
      
      inline def setClassPropertyUndefined: Self = StObject.set(x, "ClassProperty", js.undefined)
      
      inline def setClassUndefined: Self = StObject.set(x, "Class", js.undefined)
      
      inline def setCompletionStatement(value: VisitNode[S, CompletionStatement]): Self = StObject.set(x, "CompletionStatement", value.asInstanceOf[js.Any])
      
      inline def setCompletionStatementUndefined: Self = StObject.set(x, "CompletionStatement", js.undefined)
      
      inline def setConditional(value: VisitNode[S, Conditional]): Self = StObject.set(x, "Conditional", value.asInstanceOf[js.Any])
      
      inline def setConditionalExpression(value: VisitNode[S, Extract[Node, `170`]]): Self = StObject.set(x, "ConditionalExpression", value.asInstanceOf[js.Any])
      
      inline def setConditionalExpressionUndefined: Self = StObject.set(x, "ConditionalExpression", js.undefined)
      
      inline def setConditionalUndefined: Self = StObject.set(x, "Conditional", js.undefined)
      
      inline def setContinueStatement(value: VisitNode[S, Extract[Node, `40`]]): Self = StObject.set(x, "ContinueStatement", value.asInstanceOf[js.Any])
      
      inline def setContinueStatementUndefined: Self = StObject.set(x, "ContinueStatement", js.undefined)
      
      inline def setDebuggerStatement(value: VisitNode[S, Extract[Node, `138`]]): Self = StObject.set(x, "DebuggerStatement", value.asInstanceOf[js.Any])
      
      inline def setDebuggerStatementUndefined: Self = StObject.set(x, "DebuggerStatement", js.undefined)
      
      inline def setDecimalLiteral(value: VisitNode[S, Extract[Node, `206`]]): Self = StObject.set(x, "DecimalLiteral", value.asInstanceOf[js.Any])
      
      inline def setDecimalLiteralUndefined: Self = StObject.set(x, "DecimalLiteral", js.undefined)
      
      inline def setDeclaration(value: VisitNode[S, Declaration]): Self = StObject.set(x, "Declaration", value.asInstanceOf[js.Any])
      
      inline def setDeclarationUndefined: Self = StObject.set(x, "Declaration", js.undefined)
      
      inline def setDeclareClass(value: VisitNode[S, Extract[Node, `242`]]): Self = StObject.set(x, "DeclareClass", value.asInstanceOf[js.Any])
      
      inline def setDeclareClassUndefined: Self = StObject.set(x, "DeclareClass", js.undefined)
      
      inline def setDeclareExportAllDeclaration(value: VisitNode[S, Extract[Node, `110`]]): Self = StObject.set(x, "DeclareExportAllDeclaration", value.asInstanceOf[js.Any])
      
      inline def setDeclareExportAllDeclarationUndefined: Self = StObject.set(x, "DeclareExportAllDeclaration", js.undefined)
      
      inline def setDeclareExportDeclaration(value: VisitNode[S, Extract[Node, `158`]]): Self = StObject.set(x, "DeclareExportDeclaration", value.asInstanceOf[js.Any])
      
      inline def setDeclareExportDeclarationUndefined: Self = StObject.set(x, "DeclareExportDeclaration", js.undefined)
      
      inline def setDeclareFunction(value: VisitNode[S, Extract[Node, `105`]]): Self = StObject.set(x, "DeclareFunction", value.asInstanceOf[js.Any])
      
      inline def setDeclareFunctionUndefined: Self = StObject.set(x, "DeclareFunction", js.undefined)
      
      inline def setDeclareInterface(value: VisitNode[S, Extract[Node, `161`]]): Self = StObject.set(x, "DeclareInterface", value.asInstanceOf[js.Any])
      
      inline def setDeclareInterfaceUndefined: Self = StObject.set(x, "DeclareInterface", js.undefined)
      
      inline def setDeclareModule(value: VisitNode[S, Extract[Node, `35`]]): Self = StObject.set(x, "DeclareModule", value.asInstanceOf[js.Any])
      
      inline def setDeclareModuleExports(value: VisitNode[S, Extract[Node, `223`]]): Self = StObject.set(x, "DeclareModuleExports", value.asInstanceOf[js.Any])
      
      inline def setDeclareModuleExportsUndefined: Self = StObject.set(x, "DeclareModuleExports", js.undefined)
      
      inline def setDeclareModuleUndefined: Self = StObject.set(x, "DeclareModule", js.undefined)
      
      inline def setDeclareOpaqueType(value: VisitNode[S, Extract[Node, `229`]]): Self = StObject.set(x, "DeclareOpaqueType", value.asInstanceOf[js.Any])
      
      inline def setDeclareOpaqueTypeUndefined: Self = StObject.set(x, "DeclareOpaqueType", js.undefined)
      
      inline def setDeclareTypeAlias(value: VisitNode[S, Extract[Node, `167`]]): Self = StObject.set(x, "DeclareTypeAlias", value.asInstanceOf[js.Any])
      
      inline def setDeclareTypeAliasUndefined: Self = StObject.set(x, "DeclareTypeAlias", js.undefined)
      
      inline def setDeclareVariable(value: VisitNode[S, Extract[Node, `182`]]): Self = StObject.set(x, "DeclareVariable", value.asInstanceOf[js.Any])
      
      inline def setDeclareVariableUndefined: Self = StObject.set(x, "DeclareVariable", js.undefined)
      
      inline def setDeclaredPredicate(value: VisitNode[S, Extract[Node, `188`]]): Self = StObject.set(x, "DeclaredPredicate", value.asInstanceOf[js.Any])
      
      inline def setDeclaredPredicateUndefined: Self = StObject.set(x, "DeclaredPredicate", js.undefined)
      
      inline def setDecorator(value: VisitNode[S, Extract[Node, `82`]]): Self = StObject.set(x, "Decorator", value.asInstanceOf[js.Any])
      
      inline def setDecoratorUndefined: Self = StObject.set(x, "Decorator", js.undefined)
      
      inline def setDirective(value: VisitNode[S, Extract[Node, `63`]]): Self = StObject.set(x, "Directive", value.asInstanceOf[js.Any])
      
      inline def setDirectiveLiteral(value: VisitNode[S, Extract[Node, `143`]]): Self = StObject.set(x, "DirectiveLiteral", value.asInstanceOf[js.Any])
      
      inline def setDirectiveLiteralUndefined: Self = StObject.set(x, "DirectiveLiteral", js.undefined)
      
      inline def setDirectiveUndefined: Self = StObject.set(x, "Directive", js.undefined)
      
      inline def setDoExpression(value: VisitNode[S, Extract[Node, `219`]]): Self = StObject.set(x, "DoExpression", value.asInstanceOf[js.Any])
      
      inline def setDoExpressionUndefined: Self = StObject.set(x, "DoExpression", js.undefined)
      
      inline def setDoWhileStatement(value: VisitNode[S, Extract[Node, `200`]]): Self = StObject.set(x, "DoWhileStatement", value.asInstanceOf[js.Any])
      
      inline def setDoWhileStatementUndefined: Self = StObject.set(x, "DoWhileStatement", js.undefined)
      
      inline def setEmptyStatement(value: VisitNode[S, Extract[Node, `108`]]): Self = StObject.set(x, "EmptyStatement", value.asInstanceOf[js.Any])
      
      inline def setEmptyStatementUndefined: Self = StObject.set(x, "EmptyStatement", js.undefined)
      
      inline def setEmptyTypeAnnotation(value: VisitNode[S, Extract[Node, `142`]]): Self = StObject.set(x, "EmptyTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setEmptyTypeAnnotationUndefined: Self = StObject.set(x, "EmptyTypeAnnotation", js.undefined)
      
      inline def setEnter(value: VisitNodeFunction[S, Node]): Self = StObject.set(x, "enter", value.asInstanceOf[js.Any])
      
      inline def setEnterUndefined: Self = StObject.set(x, "enter", js.undefined)
      
      inline def setEnumBody(value: VisitNode[S, EnumBody]): Self = StObject.set(x, "EnumBody", value.asInstanceOf[js.Any])
      
      inline def setEnumBodyUndefined: Self = StObject.set(x, "EnumBody", js.undefined)
      
      inline def setEnumBooleanBody(value: VisitNode[S, Extract[Node, `137`]]): Self = StObject.set(x, "EnumBooleanBody", value.asInstanceOf[js.Any])
      
      inline def setEnumBooleanBodyUndefined: Self = StObject.set(x, "EnumBooleanBody", js.undefined)
      
      inline def setEnumBooleanMember(value: VisitNode[S, Extract[Node, `117`]]): Self = StObject.set(x, "EnumBooleanMember", value.asInstanceOf[js.Any])
      
      inline def setEnumBooleanMemberUndefined: Self = StObject.set(x, "EnumBooleanMember", js.undefined)
      
      inline def setEnumDeclaration(value: VisitNode[S, Extract[Node, `67`]]): Self = StObject.set(x, "EnumDeclaration", value.asInstanceOf[js.Any])
      
      inline def setEnumDeclarationUndefined: Self = StObject.set(x, "EnumDeclaration", js.undefined)
      
      inline def setEnumDefaultedMember(value: VisitNode[S, Extract[Node, `191`]]): Self = StObject.set(x, "EnumDefaultedMember", value.asInstanceOf[js.Any])
      
      inline def setEnumDefaultedMemberUndefined: Self = StObject.set(x, "EnumDefaultedMember", js.undefined)
      
      inline def setEnumMember(value: VisitNode[S, EnumMember]): Self = StObject.set(x, "EnumMember", value.asInstanceOf[js.Any])
      
      inline def setEnumMemberUndefined: Self = StObject.set(x, "EnumMember", js.undefined)
      
      inline def setEnumNumberBody(value: VisitNode[S, Extract[Node, `240`]]): Self = StObject.set(x, "EnumNumberBody", value.asInstanceOf[js.Any])
      
      inline def setEnumNumberBodyUndefined: Self = StObject.set(x, "EnumNumberBody", js.undefined)
      
      inline def setEnumNumberMember(value: VisitNode[S, Extract[Node, `205`]]): Self = StObject.set(x, "EnumNumberMember", value.asInstanceOf[js.Any])
      
      inline def setEnumNumberMemberUndefined: Self = StObject.set(x, "EnumNumberMember", js.undefined)
      
      inline def setEnumStringBody(value: VisitNode[S, Extract[Node, `163`]]): Self = StObject.set(x, "EnumStringBody", value.asInstanceOf[js.Any])
      
      inline def setEnumStringBodyUndefined: Self = StObject.set(x, "EnumStringBody", js.undefined)
      
      inline def setEnumStringMember(value: VisitNode[S, Extract[Node, `4`]]): Self = StObject.set(x, "EnumStringMember", value.asInstanceOf[js.Any])
      
      inline def setEnumStringMemberUndefined: Self = StObject.set(x, "EnumStringMember", js.undefined)
      
      inline def setEnumSymbolBody(value: VisitNode[S, Extract[Node, `198`]]): Self = StObject.set(x, "EnumSymbolBody", value.asInstanceOf[js.Any])
      
      inline def setEnumSymbolBodyUndefined: Self = StObject.set(x, "EnumSymbolBody", js.undefined)
      
      inline def setExistentialTypeParam(value: VisitNode[S, ExistsTypeAnnotation_]): Self = StObject.set(x, "ExistentialTypeParam", value.asInstanceOf[js.Any])
      
      inline def setExistentialTypeParamUndefined: Self = StObject.set(x, "ExistentialTypeParam", js.undefined)
      
      inline def setExistsTypeAnnotation(value: VisitNode[S, Extract[Node, `119`]]): Self = StObject.set(x, "ExistsTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setExistsTypeAnnotationUndefined: Self = StObject.set(x, "ExistsTypeAnnotation", js.undefined)
      
      inline def setExit(value: VisitNodeFunction[S, Node]): Self = StObject.set(x, "exit", value.asInstanceOf[js.Any])
      
      inline def setExitUndefined: Self = StObject.set(x, "exit", js.undefined)
      
      inline def setExportAllDeclaration(value: VisitNode[S, Extract[Node, `37`]]): Self = StObject.set(x, "ExportAllDeclaration", value.asInstanceOf[js.Any])
      
      inline def setExportAllDeclarationUndefined: Self = StObject.set(x, "ExportAllDeclaration", js.undefined)
      
      inline def setExportDeclaration(value: VisitNode[S, ExportDeclaration]): Self = StObject.set(x, "ExportDeclaration", value.asInstanceOf[js.Any])
      
      inline def setExportDeclarationUndefined: Self = StObject.set(x, "ExportDeclaration", js.undefined)
      
      inline def setExportDefaultDeclaration(value: VisitNode[S, Extract[Node, `80`]]): Self = StObject.set(x, "ExportDefaultDeclaration", value.asInstanceOf[js.Any])
      
      inline def setExportDefaultDeclarationUndefined: Self = StObject.set(x, "ExportDefaultDeclaration", js.undefined)
      
      inline def setExportDefaultSpecifier(value: VisitNode[S, Extract[Node, `3`]]): Self = StObject.set(x, "ExportDefaultSpecifier", value.asInstanceOf[js.Any])
      
      inline def setExportDefaultSpecifierUndefined: Self = StObject.set(x, "ExportDefaultSpecifier", js.undefined)
      
      inline def setExportNamedDeclaration(value: VisitNode[S, Extract[Node, `46`]]): Self = StObject.set(x, "ExportNamedDeclaration", value.asInstanceOf[js.Any])
      
      inline def setExportNamedDeclarationUndefined: Self = StObject.set(x, "ExportNamedDeclaration", js.undefined)
      
      inline def setExportNamespaceSpecifier(value: VisitNode[S, Extract[Node, `179`]]): Self = StObject.set(x, "ExportNamespaceSpecifier", value.asInstanceOf[js.Any])
      
      inline def setExportNamespaceSpecifierUndefined: Self = StObject.set(x, "ExportNamespaceSpecifier", js.undefined)
      
      inline def setExportSpecifier(value: VisitNode[S, Extract[Node, `116`]]): Self = StObject.set(x, "ExportSpecifier", value.asInstanceOf[js.Any])
      
      inline def setExportSpecifierUndefined: Self = StObject.set(x, "ExportSpecifier", js.undefined)
      
      inline def setExpression(value: VisitNode[S, Expression]): Self = StObject.set(x, "Expression", value.asInstanceOf[js.Any])
      
      inline def setExpressionStatement(value: VisitNode[S, Extract[Node, `62`]]): Self = StObject.set(x, "ExpressionStatement", value.asInstanceOf[js.Any])
      
      inline def setExpressionStatementUndefined: Self = StObject.set(x, "ExpressionStatement", js.undefined)
      
      inline def setExpressionUndefined: Self = StObject.set(x, "Expression", js.undefined)
      
      inline def setExpressionWrapper(value: VisitNode[S, ExpressionWrapper]): Self = StObject.set(x, "ExpressionWrapper", value.asInstanceOf[js.Any])
      
      inline def setExpressionWrapperUndefined: Self = StObject.set(x, "ExpressionWrapper", js.undefined)
      
      inline def setFile(value: VisitNode[S, Extract[Node, `28`]]): Self = StObject.set(x, "File", value.asInstanceOf[js.Any])
      
      inline def setFileUndefined: Self = StObject.set(x, "File", js.undefined)
      
      inline def setFlow(value: VisitNode[S, Flow]): Self = StObject.set(x, "Flow", value.asInstanceOf[js.Any])
      
      inline def setFlowBaseAnnotation(value: VisitNode[S, FlowBaseAnnotation]): Self = StObject.set(x, "FlowBaseAnnotation", value.asInstanceOf[js.Any])
      
      inline def setFlowBaseAnnotationUndefined: Self = StObject.set(x, "FlowBaseAnnotation", js.undefined)
      
      inline def setFlowDeclaration(value: VisitNode[S, FlowDeclaration]): Self = StObject.set(x, "FlowDeclaration", value.asInstanceOf[js.Any])
      
      inline def setFlowDeclarationUndefined: Self = StObject.set(x, "FlowDeclaration", js.undefined)
      
      inline def setFlowPredicate(value: VisitNode[S, FlowPredicate]): Self = StObject.set(x, "FlowPredicate", value.asInstanceOf[js.Any])
      
      inline def setFlowPredicateUndefined: Self = StObject.set(x, "FlowPredicate", js.undefined)
      
      inline def setFlowType(value: VisitNode[S, FlowType]): Self = StObject.set(x, "FlowType", value.asInstanceOf[js.Any])
      
      inline def setFlowTypeUndefined: Self = StObject.set(x, "FlowType", js.undefined)
      
      inline def setFlowUndefined: Self = StObject.set(x, "Flow", js.undefined)
      
      inline def setFor(value: VisitNode[S, For]): Self = StObject.set(x, "For", value.asInstanceOf[js.Any])
      
      inline def setForAwaitStatement(value: VisitNode[S, ForOfStatement_]): Self = StObject.set(x, "ForAwaitStatement", value.asInstanceOf[js.Any])
      
      inline def setForAwaitStatementUndefined: Self = StObject.set(x, "ForAwaitStatement", js.undefined)
      
      inline def setForInStatement(value: VisitNode[S, Extract[Node, `17`]]): Self = StObject.set(x, "ForInStatement", value.asInstanceOf[js.Any])
      
      inline def setForInStatementUndefined: Self = StObject.set(x, "ForInStatement", js.undefined)
      
      inline def setForOfStatement(value: VisitNode[S, Extract[Node, `166`]]): Self = StObject.set(x, "ForOfStatement", value.asInstanceOf[js.Any])
      
      inline def setForOfStatementUndefined: Self = StObject.set(x, "ForOfStatement", js.undefined)
      
      inline def setForStatement(value: VisitNode[S, Extract[Node, `190`]]): Self = StObject.set(x, "ForStatement", value.asInstanceOf[js.Any])
      
      inline def setForStatementUndefined: Self = StObject.set(x, "ForStatement", js.undefined)
      
      inline def setForUndefined: Self = StObject.set(x, "For", js.undefined)
      
      inline def setForXStatement(value: VisitNode[S, ForXStatement]): Self = StObject.set(x, "ForXStatement", value.asInstanceOf[js.Any])
      
      inline def setForXStatementUndefined: Self = StObject.set(x, "ForXStatement", js.undefined)
      
      inline def setFunction(value: VisitNode[S, Function]): Self = StObject.set(x, "Function", value.asInstanceOf[js.Any])
      
      inline def setFunctionDeclaration(value: VisitNode[S, Extract[Node, `136`]]): Self = StObject.set(x, "FunctionDeclaration", value.asInstanceOf[js.Any])
      
      inline def setFunctionDeclarationUndefined: Self = StObject.set(x, "FunctionDeclaration", js.undefined)
      
      inline def setFunctionExpression(value: VisitNode[S, Extract[Node, `193`]]): Self = StObject.set(x, "FunctionExpression", value.asInstanceOf[js.Any])
      
      inline def setFunctionExpressionUndefined: Self = StObject.set(x, "FunctionExpression", js.undefined)
      
      inline def setFunctionParent(value: VisitNode[S, FunctionParent]): Self = StObject.set(x, "FunctionParent", value.asInstanceOf[js.Any])
      
      inline def setFunctionParentUndefined: Self = StObject.set(x, "FunctionParent", js.undefined)
      
      inline def setFunctionTypeAnnotation(value: VisitNode[S, Extract[Node, `41`]]): Self = StObject.set(x, "FunctionTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setFunctionTypeAnnotationUndefined: Self = StObject.set(x, "FunctionTypeAnnotation", js.undefined)
      
      inline def setFunctionTypeParam(value: VisitNode[S, Extract[Node, `228`]]): Self = StObject.set(x, "FunctionTypeParam", value.asInstanceOf[js.Any])
      
      inline def setFunctionTypeParamUndefined: Self = StObject.set(x, "FunctionTypeParam", js.undefined)
      
      inline def setFunctionUndefined: Self = StObject.set(x, "Function", js.undefined)
      
      inline def setGenerated(value: VisitNode[S, Node]): Self = StObject.set(x, "Generated", value.asInstanceOf[js.Any])
      
      inline def setGeneratedUndefined: Self = StObject.set(x, "Generated", js.undefined)
      
      inline def setGenericTypeAnnotation(value: VisitNode[S, Extract[Node, `244`]]): Self = StObject.set(x, "GenericTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setGenericTypeAnnotationUndefined: Self = StObject.set(x, "GenericTypeAnnotation", js.undefined)
      
      inline def setIdentifier(value: VisitNode[S, Extract[Node, `99`]]): Self = StObject.set(x, "Identifier", value.asInstanceOf[js.Any])
      
      inline def setIdentifierUndefined: Self = StObject.set(x, "Identifier", js.undefined)
      
      inline def setIfStatement(value: VisitNode[S, Extract[Node, `85`]]): Self = StObject.set(x, "IfStatement", value.asInstanceOf[js.Any])
      
      inline def setIfStatementUndefined: Self = StObject.set(x, "IfStatement", js.undefined)
      
      inline def setImmutable(value: VisitNode[S, Immutable]): Self = StObject.set(x, "Immutable", value.asInstanceOf[js.Any])
      
      inline def setImmutableUndefined: Self = StObject.set(x, "Immutable", js.undefined)
      
      inline def setImport(value: VisitNode[S, Extract[Node, `172`]]): Self = StObject.set(x, "Import", value.asInstanceOf[js.Any])
      
      inline def setImportAttribute(value: VisitNode[S, Extract[Node, `123`]]): Self = StObject.set(x, "ImportAttribute", value.asInstanceOf[js.Any])
      
      inline def setImportAttributeUndefined: Self = StObject.set(x, "ImportAttribute", js.undefined)
      
      inline def setImportDeclaration(value: VisitNode[S, Extract[Node, `243`]]): Self = StObject.set(x, "ImportDeclaration", value.asInstanceOf[js.Any])
      
      inline def setImportDeclarationUndefined: Self = StObject.set(x, "ImportDeclaration", js.undefined)
      
      inline def setImportDefaultSpecifier(value: VisitNode[S, Extract[Node, `19`]]): Self = StObject.set(x, "ImportDefaultSpecifier", value.asInstanceOf[js.Any])
      
      inline def setImportDefaultSpecifierUndefined: Self = StObject.set(x, "ImportDefaultSpecifier", js.undefined)
      
      inline def setImportNamespaceSpecifier(value: VisitNode[S, Extract[Node, `202`]]): Self = StObject.set(x, "ImportNamespaceSpecifier", value.asInstanceOf[js.Any])
      
      inline def setImportNamespaceSpecifierUndefined: Self = StObject.set(x, "ImportNamespaceSpecifier", js.undefined)
      
      inline def setImportOrExportDeclaration(value: VisitNode[S, ImportOrExportDeclaration]): Self = StObject.set(x, "ImportOrExportDeclaration", value.asInstanceOf[js.Any])
      
      inline def setImportOrExportDeclarationUndefined: Self = StObject.set(x, "ImportOrExportDeclaration", js.undefined)
      
      inline def setImportSpecifier(value: VisitNode[S, Extract[Node, `114`]]): Self = StObject.set(x, "ImportSpecifier", value.asInstanceOf[js.Any])
      
      inline def setImportSpecifierUndefined: Self = StObject.set(x, "ImportSpecifier", js.undefined)
      
      inline def setImportUndefined: Self = StObject.set(x, "Import", js.undefined)
      
      inline def setIndexedAccessType(value: VisitNode[S, Extract[Node, `69`]]): Self = StObject.set(x, "IndexedAccessType", value.asInstanceOf[js.Any])
      
      inline def setIndexedAccessTypeUndefined: Self = StObject.set(x, "IndexedAccessType", js.undefined)
      
      inline def setInferredPredicate(value: VisitNode[S, Extract[Node, `134`]]): Self = StObject.set(x, "InferredPredicate", value.asInstanceOf[js.Any])
      
      inline def setInferredPredicateUndefined: Self = StObject.set(x, "InferredPredicate", js.undefined)
      
      inline def setInterfaceDeclaration(value: VisitNode[S, Extract[Node, `48`]]): Self = StObject.set(x, "InterfaceDeclaration", value.asInstanceOf[js.Any])
      
      inline def setInterfaceDeclarationUndefined: Self = StObject.set(x, "InterfaceDeclaration", js.undefined)
      
      inline def setInterfaceExtends(value: VisitNode[S, Extract[Node, `139`]]): Self = StObject.set(x, "InterfaceExtends", value.asInstanceOf[js.Any])
      
      inline def setInterfaceExtendsUndefined: Self = StObject.set(x, "InterfaceExtends", js.undefined)
      
      inline def setInterfaceTypeAnnotation(value: VisitNode[S, Extract[Node, `9`]]): Self = StObject.set(x, "InterfaceTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setInterfaceTypeAnnotationUndefined: Self = StObject.set(x, "InterfaceTypeAnnotation", js.undefined)
      
      inline def setInterpreterDirective(value: VisitNode[S, Extract[Node, `88`]]): Self = StObject.set(x, "InterpreterDirective", value.asInstanceOf[js.Any])
      
      inline def setInterpreterDirectiveUndefined: Self = StObject.set(x, "InterpreterDirective", js.undefined)
      
      inline def setIntersectionTypeAnnotation(value: VisitNode[S, Extract[Node, `215`]]): Self = StObject.set(x, "IntersectionTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setIntersectionTypeAnnotationUndefined: Self = StObject.set(x, "IntersectionTypeAnnotation", js.undefined)
      
      inline def setJSX(value: VisitNode[S, JSX]): Self = StObject.set(x, "JSX", value.asInstanceOf[js.Any])
      
      inline def setJSXAttribute(value: VisitNode[S, Extract[Node, `103`]]): Self = StObject.set(x, "JSXAttribute", value.asInstanceOf[js.Any])
      
      inline def setJSXAttributeUndefined: Self = StObject.set(x, "JSXAttribute", js.undefined)
      
      inline def setJSXClosingElement(value: VisitNode[S, Extract[Node, `129`]]): Self = StObject.set(x, "JSXClosingElement", value.asInstanceOf[js.Any])
      
      inline def setJSXClosingElementUndefined: Self = StObject.set(x, "JSXClosingElement", js.undefined)
      
      inline def setJSXClosingFragment(value: VisitNode[S, Extract[Node, `211`]]): Self = StObject.set(x, "JSXClosingFragment", value.asInstanceOf[js.Any])
      
      inline def setJSXClosingFragmentUndefined: Self = StObject.set(x, "JSXClosingFragment", js.undefined)
      
      inline def setJSXElement(value: VisitNode[S, Extract[Node, `174`]]): Self = StObject.set(x, "JSXElement", value.asInstanceOf[js.Any])
      
      inline def setJSXElementUndefined: Self = StObject.set(x, "JSXElement", js.undefined)
      
      inline def setJSXEmptyExpression(value: VisitNode[S, Extract[Node, `125`]]): Self = StObject.set(x, "JSXEmptyExpression", value.asInstanceOf[js.Any])
      
      inline def setJSXEmptyExpressionUndefined: Self = StObject.set(x, "JSXEmptyExpression", js.undefined)
      
      inline def setJSXExpressionContainer(value: VisitNode[S, Extract[Node, `32`]]): Self = StObject.set(x, "JSXExpressionContainer", value.asInstanceOf[js.Any])
      
      inline def setJSXExpressionContainerUndefined: Self = StObject.set(x, "JSXExpressionContainer", js.undefined)
      
      inline def setJSXFragment(value: VisitNode[S, Extract[Node, `152`]]): Self = StObject.set(x, "JSXFragment", value.asInstanceOf[js.Any])
      
      inline def setJSXFragmentUndefined: Self = StObject.set(x, "JSXFragment", js.undefined)
      
      inline def setJSXIdentifier(value: VisitNode[S, Extract[Node, `87`]]): Self = StObject.set(x, "JSXIdentifier", value.asInstanceOf[js.Any])
      
      inline def setJSXIdentifierUndefined: Self = StObject.set(x, "JSXIdentifier", js.undefined)
      
      inline def setJSXMemberExpression(value: VisitNode[S, Extract[Node, `197`]]): Self = StObject.set(x, "JSXMemberExpression", value.asInstanceOf[js.Any])
      
      inline def setJSXMemberExpressionUndefined: Self = StObject.set(x, "JSXMemberExpression", js.undefined)
      
      inline def setJSXNamespacedName(value: VisitNode[S, Extract[Node, `154`]]): Self = StObject.set(x, "JSXNamespacedName", value.asInstanceOf[js.Any])
      
      inline def setJSXNamespacedNameUndefined: Self = StObject.set(x, "JSXNamespacedName", js.undefined)
      
      inline def setJSXOpeningElement(value: VisitNode[S, Extract[Node, `74`]]): Self = StObject.set(x, "JSXOpeningElement", value.asInstanceOf[js.Any])
      
      inline def setJSXOpeningElementUndefined: Self = StObject.set(x, "JSXOpeningElement", js.undefined)
      
      inline def setJSXOpeningFragment(value: VisitNode[S, Extract[Node, `220`]]): Self = StObject.set(x, "JSXOpeningFragment", value.asInstanceOf[js.Any])
      
      inline def setJSXOpeningFragmentUndefined: Self = StObject.set(x, "JSXOpeningFragment", js.undefined)
      
      inline def setJSXSpreadAttribute(value: VisitNode[S, Extract[Node, `49`]]): Self = StObject.set(x, "JSXSpreadAttribute", value.asInstanceOf[js.Any])
      
      inline def setJSXSpreadAttributeUndefined: Self = StObject.set(x, "JSXSpreadAttribute", js.undefined)
      
      inline def setJSXSpreadChild(value: VisitNode[S, Extract[Node, `73`]]): Self = StObject.set(x, "JSXSpreadChild", value.asInstanceOf[js.Any])
      
      inline def setJSXSpreadChildUndefined: Self = StObject.set(x, "JSXSpreadChild", js.undefined)
      
      inline def setJSXText(value: VisitNode[S, Extract[Node, `195`]]): Self = StObject.set(x, "JSXText", value.asInstanceOf[js.Any])
      
      inline def setJSXTextUndefined: Self = StObject.set(x, "JSXText", js.undefined)
      
      inline def setJSXUndefined: Self = StObject.set(x, "JSX", js.undefined)
      
      inline def setLVal(value: VisitNode[S, LVal]): Self = StObject.set(x, "LVal", value.asInstanceOf[js.Any])
      
      inline def setLValUndefined: Self = StObject.set(x, "LVal", js.undefined)
      
      inline def setLabeledStatement(value: VisitNode[S, Extract[Node, `36`]]): Self = StObject.set(x, "LabeledStatement", value.asInstanceOf[js.Any])
      
      inline def setLabeledStatementUndefined: Self = StObject.set(x, "LabeledStatement", js.undefined)
      
      inline def setLiteral(value: VisitNode[S, Literal]): Self = StObject.set(x, "Literal", value.asInstanceOf[js.Any])
      
      inline def setLiteralUndefined: Self = StObject.set(x, "Literal", js.undefined)
      
      inline def setLogicalExpression(value: VisitNode[S, Extract[Node, `70`]]): Self = StObject.set(x, "LogicalExpression", value.asInstanceOf[js.Any])
      
      inline def setLogicalExpressionUndefined: Self = StObject.set(x, "LogicalExpression", js.undefined)
      
      inline def setLoop(value: VisitNode[S, Loop]): Self = StObject.set(x, "Loop", value.asInstanceOf[js.Any])
      
      inline def setLoopUndefined: Self = StObject.set(x, "Loop", js.undefined)
      
      inline def setMemberExpression(value: VisitNode[S, Extract[Node, `60`]]): Self = StObject.set(x, "MemberExpression", value.asInstanceOf[js.Any])
      
      inline def setMemberExpressionUndefined: Self = StObject.set(x, "MemberExpression", js.undefined)
      
      inline def setMetaProperty(value: VisitNode[S, Extract[Node, `83`]]): Self = StObject.set(x, "MetaProperty", value.asInstanceOf[js.Any])
      
      inline def setMetaPropertyUndefined: Self = StObject.set(x, "MetaProperty", js.undefined)
      
      inline def setMethod(value: VisitNode[S, Method]): Self = StObject.set(x, "Method", value.asInstanceOf[js.Any])
      
      inline def setMethodUndefined: Self = StObject.set(x, "Method", js.undefined)
      
      inline def setMiscellaneous(value: VisitNode[S, Miscellaneous]): Self = StObject.set(x, "Miscellaneous", value.asInstanceOf[js.Any])
      
      inline def setMiscellaneousUndefined: Self = StObject.set(x, "Miscellaneous", js.undefined)
      
      inline def setMixedTypeAnnotation(value: VisitNode[S, Extract[Node, `57`]]): Self = StObject.set(x, "MixedTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setMixedTypeAnnotationUndefined: Self = StObject.set(x, "MixedTypeAnnotation", js.undefined)
      
      inline def setModuleDeclaration(value: VisitNode[S, ModuleDeclaration]): Self = StObject.set(x, "ModuleDeclaration", value.asInstanceOf[js.Any])
      
      inline def setModuleDeclarationUndefined: Self = StObject.set(x, "ModuleDeclaration", js.undefined)
      
      inline def setModuleExpression(value: VisitNode[S, Extract[Node, `148`]]): Self = StObject.set(x, "ModuleExpression", value.asInstanceOf[js.Any])
      
      inline def setModuleExpressionUndefined: Self = StObject.set(x, "ModuleExpression", js.undefined)
      
      inline def setModuleSpecifier(value: VisitNode[S, ModuleSpecifier]): Self = StObject.set(x, "ModuleSpecifier", value.asInstanceOf[js.Any])
      
      inline def setModuleSpecifierUndefined: Self = StObject.set(x, "ModuleSpecifier", js.undefined)
      
      inline def setNewExpression(value: VisitNode[S, Extract[Node, `59`]]): Self = StObject.set(x, "NewExpression", value.asInstanceOf[js.Any])
      
      inline def setNewExpressionUndefined: Self = StObject.set(x, "NewExpression", js.undefined)
      
      inline def setNoop(value: VisitNode[S, Extract[Node, `34`]]): Self = StObject.set(x, "Noop", value.asInstanceOf[js.Any])
      
      inline def setNoopUndefined: Self = StObject.set(x, "Noop", js.undefined)
      
      inline def setNullLiteral(value: VisitNode[S, Extract[Node, `245`]]): Self = StObject.set(x, "NullLiteral", value.asInstanceOf[js.Any])
      
      inline def setNullLiteralTypeAnnotation(value: VisitNode[S, Extract[Node, `43`]]): Self = StObject.set(x, "NullLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setNullLiteralTypeAnnotationUndefined: Self = StObject.set(x, "NullLiteralTypeAnnotation", js.undefined)
      
      inline def setNullLiteralUndefined: Self = StObject.set(x, "NullLiteral", js.undefined)
      
      inline def setNullableTypeAnnotation(value: VisitNode[S, Extract[Node, `98`]]): Self = StObject.set(x, "NullableTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setNullableTypeAnnotationUndefined: Self = StObject.set(x, "NullableTypeAnnotation", js.undefined)
      
      inline def setNumberLiteralTypeAnnotation(value: VisitNode[S, Extract[Node, `157`]]): Self = StObject.set(x, "NumberLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setNumberLiteralTypeAnnotationUndefined: Self = StObject.set(x, "NumberLiteralTypeAnnotation", js.undefined)
      
      inline def setNumberTypeAnnotation(value: VisitNode[S, Extract[Node, `164`]]): Self = StObject.set(x, "NumberTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setNumberTypeAnnotationUndefined: Self = StObject.set(x, "NumberTypeAnnotation", js.undefined)
      
      inline def setNumericLiteral(value: VisitNode[S, Extract[Node, `217`]]): Self = StObject.set(x, "NumericLiteral", value.asInstanceOf[js.Any])
      
      inline def setNumericLiteralTypeAnnotation(value: VisitNode[S, NumberLiteralTypeAnnotation_]): Self = StObject.set(x, "NumericLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setNumericLiteralTypeAnnotationUndefined: Self = StObject.set(x, "NumericLiteralTypeAnnotation", js.undefined)
      
      inline def setNumericLiteralUndefined: Self = StObject.set(x, "NumericLiteral", js.undefined)
      
      inline def setObjectExpression(value: VisitNode[S, Extract[Node, `124`]]): Self = StObject.set(x, "ObjectExpression", value.asInstanceOf[js.Any])
      
      inline def setObjectExpressionUndefined: Self = StObject.set(x, "ObjectExpression", js.undefined)
      
      inline def setObjectMember(value: VisitNode[S, ObjectMember]): Self = StObject.set(x, "ObjectMember", value.asInstanceOf[js.Any])
      
      inline def setObjectMemberUndefined: Self = StObject.set(x, "ObjectMember", js.undefined)
      
      inline def setObjectMethod(value: VisitNode[S, Extract[Node, `126`]]): Self = StObject.set(x, "ObjectMethod", value.asInstanceOf[js.Any])
      
      inline def setObjectMethodUndefined: Self = StObject.set(x, "ObjectMethod", js.undefined)
      
      inline def setObjectPattern(value: VisitNode[S, Extract[Node, `224`]]): Self = StObject.set(x, "ObjectPattern", value.asInstanceOf[js.Any])
      
      inline def setObjectPatternUndefined: Self = StObject.set(x, "ObjectPattern", js.undefined)
      
      inline def setObjectProperty(value: VisitNode[S, Extract[Node, `144`]]): Self = StObject.set(x, "ObjectProperty", value.asInstanceOf[js.Any])
      
      inline def setObjectPropertyUndefined: Self = StObject.set(x, "ObjectProperty", js.undefined)
      
      inline def setObjectTypeAnnotation(value: VisitNode[S, Extract[Node, `84`]]): Self = StObject.set(x, "ObjectTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setObjectTypeAnnotationUndefined: Self = StObject.set(x, "ObjectTypeAnnotation", js.undefined)
      
      inline def setObjectTypeCallProperty(value: VisitNode[S, Extract[Node, `13`]]): Self = StObject.set(x, "ObjectTypeCallProperty", value.asInstanceOf[js.Any])
      
      inline def setObjectTypeCallPropertyUndefined: Self = StObject.set(x, "ObjectTypeCallProperty", js.undefined)
      
      inline def setObjectTypeIndexer(value: VisitNode[S, Extract[Node, `175`]]): Self = StObject.set(x, "ObjectTypeIndexer", value.asInstanceOf[js.Any])
      
      inline def setObjectTypeIndexerUndefined: Self = StObject.set(x, "ObjectTypeIndexer", js.undefined)
      
      inline def setObjectTypeInternalSlot(value: VisitNode[S, Extract[Node, `233`]]): Self = StObject.set(x, "ObjectTypeInternalSlot", value.asInstanceOf[js.Any])
      
      inline def setObjectTypeInternalSlotUndefined: Self = StObject.set(x, "ObjectTypeInternalSlot", js.undefined)
      
      inline def setObjectTypeProperty(value: VisitNode[S, Extract[Node, `159`]]): Self = StObject.set(x, "ObjectTypeProperty", value.asInstanceOf[js.Any])
      
      inline def setObjectTypePropertyUndefined: Self = StObject.set(x, "ObjectTypeProperty", js.undefined)
      
      inline def setObjectTypeSpreadProperty(value: VisitNode[S, Extract[Node, `81`]]): Self = StObject.set(x, "ObjectTypeSpreadProperty", value.asInstanceOf[js.Any])
      
      inline def setObjectTypeSpreadPropertyUndefined: Self = StObject.set(x, "ObjectTypeSpreadProperty", js.undefined)
      
      inline def setOpaqueType(value: VisitNode[S, Extract[Node, `71`]]): Self = StObject.set(x, "OpaqueType", value.asInstanceOf[js.Any])
      
      inline def setOpaqueTypeUndefined: Self = StObject.set(x, "OpaqueType", js.undefined)
      
      inline def setOptionalCallExpression(value: VisitNode[S, Extract[Node, `45`]]): Self = StObject.set(x, "OptionalCallExpression", value.asInstanceOf[js.Any])
      
      inline def setOptionalCallExpressionUndefined: Self = StObject.set(x, "OptionalCallExpression", js.undefined)
      
      inline def setOptionalIndexedAccessType(value: VisitNode[S, Extract[Node, `146`]]): Self = StObject.set(x, "OptionalIndexedAccessType", value.asInstanceOf[js.Any])
      
      inline def setOptionalIndexedAccessTypeUndefined: Self = StObject.set(x, "OptionalIndexedAccessType", js.undefined)
      
      inline def setOptionalMemberExpression(value: VisitNode[S, Extract[Node, `27`]]): Self = StObject.set(x, "OptionalMemberExpression", value.asInstanceOf[js.Any])
      
      inline def setOptionalMemberExpressionUndefined: Self = StObject.set(x, "OptionalMemberExpression", js.undefined)
      
      inline def setParenthesizedExpression(value: VisitNode[S, Extract[Node, `204`]]): Self = StObject.set(x, "ParenthesizedExpression", value.asInstanceOf[js.Any])
      
      inline def setParenthesizedExpressionUndefined: Self = StObject.set(x, "ParenthesizedExpression", js.undefined)
      
      inline def setPattern(value: VisitNode[S, Pattern]): Self = StObject.set(x, "Pattern", value.asInstanceOf[js.Any])
      
      inline def setPatternLike(value: VisitNode[S, PatternLike]): Self = StObject.set(x, "PatternLike", value.asInstanceOf[js.Any])
      
      inline def setPatternLikeUndefined: Self = StObject.set(x, "PatternLike", js.undefined)
      
      inline def setPatternUndefined: Self = StObject.set(x, "Pattern", js.undefined)
      
      inline def setPipelineBareFunction(value: VisitNode[S, Extract[Node, `162`]]): Self = StObject.set(x, "PipelineBareFunction", value.asInstanceOf[js.Any])
      
      inline def setPipelineBareFunctionUndefined: Self = StObject.set(x, "PipelineBareFunction", js.undefined)
      
      inline def setPipelinePrimaryTopicReference(value: VisitNode[S, Extract[Node, `31`]]): Self = StObject.set(x, "PipelinePrimaryTopicReference", value.asInstanceOf[js.Any])
      
      inline def setPipelinePrimaryTopicReferenceUndefined: Self = StObject.set(x, "PipelinePrimaryTopicReference", js.undefined)
      
      inline def setPipelineTopicExpression(value: VisitNode[S, Extract[Node, `106`]]): Self = StObject.set(x, "PipelineTopicExpression", value.asInstanceOf[js.Any])
      
      inline def setPipelineTopicExpressionUndefined: Self = StObject.set(x, "PipelineTopicExpression", js.undefined)
      
      inline def setPlaceholder(value: VisitNode[S, Extract[Node, `168`]]): Self = StObject.set(x, "Placeholder", value.asInstanceOf[js.Any])
      
      inline def setPlaceholderUndefined: Self = StObject.set(x, "Placeholder", js.undefined)
      
      inline def setPrivate(value: VisitNode[S, Private]): Self = StObject.set(x, "Private", value.asInstanceOf[js.Any])
      
      inline def setPrivateName(value: VisitNode[S, Extract[Node, `95`]]): Self = StObject.set(x, "PrivateName", value.asInstanceOf[js.Any])
      
      inline def setPrivateNameUndefined: Self = StObject.set(x, "PrivateName", js.undefined)
      
      inline def setPrivateUndefined: Self = StObject.set(x, "Private", js.undefined)
      
      inline def setProgram(value: VisitNode[S, Extract[Node, `155`]]): Self = StObject.set(x, "Program", value.asInstanceOf[js.Any])
      
      inline def setProgramUndefined: Self = StObject.set(x, "Program", js.undefined)
      
      inline def setProperty(value: VisitNode[S, Property]): Self = StObject.set(x, "Property", value.asInstanceOf[js.Any])
      
      inline def setPropertyUndefined: Self = StObject.set(x, "Property", js.undefined)
      
      inline def setPure(value: VisitNode[S, Node]): Self = StObject.set(x, "Pure", value.asInstanceOf[js.Any])
      
      inline def setPureUndefined: Self = StObject.set(x, "Pure", js.undefined)
      
      inline def setPureish(value: VisitNode[S, Pureish]): Self = StObject.set(x, "Pureish", value.asInstanceOf[js.Any])
      
      inline def setPureishUndefined: Self = StObject.set(x, "Pureish", js.undefined)
      
      inline def setQualifiedTypeIdentifier(value: VisitNode[S, Extract[Node, `75`]]): Self = StObject.set(x, "QualifiedTypeIdentifier", value.asInstanceOf[js.Any])
      
      inline def setQualifiedTypeIdentifierUndefined: Self = StObject.set(x, "QualifiedTypeIdentifier", js.undefined)
      
      inline def setRecordExpression(value: VisitNode[S, Extract[Node, `61`]]): Self = StObject.set(x, "RecordExpression", value.asInstanceOf[js.Any])
      
      inline def setRecordExpressionUndefined: Self = StObject.set(x, "RecordExpression", js.undefined)
      
      inline def setReferenced(value: VisitNode[S, Node]): Self = StObject.set(x, "Referenced", value.asInstanceOf[js.Any])
      
      inline def setReferencedIdentifier(value: VisitNode[S, Identifier_ | JSXIdentifier_]): Self = StObject.set(x, "ReferencedIdentifier", value.asInstanceOf[js.Any])
      
      inline def setReferencedIdentifierUndefined: Self = StObject.set(x, "ReferencedIdentifier", js.undefined)
      
      inline def setReferencedMemberExpression(value: VisitNode[S, MemberExpression_]): Self = StObject.set(x, "ReferencedMemberExpression", value.asInstanceOf[js.Any])
      
      inline def setReferencedMemberExpressionUndefined: Self = StObject.set(x, "ReferencedMemberExpression", js.undefined)
      
      inline def setReferencedUndefined: Self = StObject.set(x, "Referenced", js.undefined)
      
      inline def setRegExpLiteral(value: VisitNode[S, Extract[Node, `38`]]): Self = StObject.set(x, "RegExpLiteral", value.asInstanceOf[js.Any])
      
      inline def setRegExpLiteralUndefined: Self = StObject.set(x, "RegExpLiteral", js.undefined)
      
      inline def setRestElement(value: VisitNode[S, Extract[Node, `26`]]): Self = StObject.set(x, "RestElement", value.asInstanceOf[js.Any])
      
      inline def setRestElementUndefined: Self = StObject.set(x, "RestElement", js.undefined)
      
      inline def setRestProperty(value: VisitNode[S, RestElement_]): Self = StObject.set(x, "RestProperty", value.asInstanceOf[js.Any])
      
      inline def setRestPropertyUndefined: Self = StObject.set(x, "RestProperty", js.undefined)
      
      inline def setReturnStatement(value: VisitNode[S, Extract[Node, `5`]]): Self = StObject.set(x, "ReturnStatement", value.asInstanceOf[js.Any])
      
      inline def setReturnStatementUndefined: Self = StObject.set(x, "ReturnStatement", js.undefined)
      
      inline def setScopable(value: VisitNode[S, Scopable]): Self = StObject.set(x, "Scopable", value.asInstanceOf[js.Any])
      
      inline def setScopableUndefined: Self = StObject.set(x, "Scopable", js.undefined)
      
      inline def setScope(value: VisitNode[S, Scopable | Pattern]): Self = StObject.set(x, "Scope", value.asInstanceOf[js.Any])
      
      inline def setScopeUndefined: Self = StObject.set(x, "Scope", js.undefined)
      
      inline def setSequenceExpression(value: VisitNode[S, Extract[Node, `171`]]): Self = StObject.set(x, "SequenceExpression", value.asInstanceOf[js.Any])
      
      inline def setSequenceExpressionUndefined: Self = StObject.set(x, "SequenceExpression", js.undefined)
      
      inline def setSpreadElement(value: VisitNode[S, Extract[Node, `23`]]): Self = StObject.set(x, "SpreadElement", value.asInstanceOf[js.Any])
      
      inline def setSpreadElementUndefined: Self = StObject.set(x, "SpreadElement", js.undefined)
      
      inline def setSpreadProperty(value: VisitNode[S, RestElement_]): Self = StObject.set(x, "SpreadProperty", value.asInstanceOf[js.Any])
      
      inline def setSpreadPropertyUndefined: Self = StObject.set(x, "SpreadProperty", js.undefined)
      
      inline def setStandardized(value: VisitNode[S, Standardized]): Self = StObject.set(x, "Standardized", value.asInstanceOf[js.Any])
      
      inline def setStandardizedUndefined: Self = StObject.set(x, "Standardized", js.undefined)
      
      inline def setStatement(value: VisitNode[S, Statement]): Self = StObject.set(x, "Statement", value.asInstanceOf[js.Any])
      
      inline def setStatementUndefined: Self = StObject.set(x, "Statement", js.undefined)
      
      inline def setStaticBlock(value: VisitNode[S, Extract[Node, `111`]]): Self = StObject.set(x, "StaticBlock", value.asInstanceOf[js.Any])
      
      inline def setStaticBlockUndefined: Self = StObject.set(x, "StaticBlock", js.undefined)
      
      inline def setStringLiteral(value: VisitNode[S, Extract[Node, `131`]]): Self = StObject.set(x, "StringLiteral", value.asInstanceOf[js.Any])
      
      inline def setStringLiteralTypeAnnotation(value: VisitNode[S, Extract[Node, `226`]]): Self = StObject.set(x, "StringLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setStringLiteralTypeAnnotationUndefined: Self = StObject.set(x, "StringLiteralTypeAnnotation", js.undefined)
      
      inline def setStringLiteralUndefined: Self = StObject.set(x, "StringLiteral", js.undefined)
      
      inline def setStringTypeAnnotation(value: VisitNode[S, Extract[Node, `2`]]): Self = StObject.set(x, "StringTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setStringTypeAnnotationUndefined: Self = StObject.set(x, "StringTypeAnnotation", js.undefined)
      
      inline def setSuper(value: VisitNode[S, Extract[Node, `165`]]): Self = StObject.set(x, "Super", value.asInstanceOf[js.Any])
      
      inline def setSuperUndefined: Self = StObject.set(x, "Super", js.undefined)
      
      inline def setSwitchCase(value: VisitNode[S, Extract[Node, `54`]]): Self = StObject.set(x, "SwitchCase", value.asInstanceOf[js.Any])
      
      inline def setSwitchCaseUndefined: Self = StObject.set(x, "SwitchCase", js.undefined)
      
      inline def setSwitchStatement(value: VisitNode[S, Extract[Node, `44`]]): Self = StObject.set(x, "SwitchStatement", value.asInstanceOf[js.Any])
      
      inline def setSwitchStatementUndefined: Self = StObject.set(x, "SwitchStatement", js.undefined)
      
      inline def setSymbolTypeAnnotation(value: VisitNode[S, Extract[Node, `50`]]): Self = StObject.set(x, "SymbolTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setSymbolTypeAnnotationUndefined: Self = StObject.set(x, "SymbolTypeAnnotation", js.undefined)
      
      inline def setTSAnyKeyword(value: VisitNode[S, Extract[Node, `10`]]): Self = StObject.set(x, "TSAnyKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSAnyKeywordUndefined: Self = StObject.set(x, "TSAnyKeyword", js.undefined)
      
      inline def setTSArrayType(value: VisitNode[S, Extract[Node, `0`]]): Self = StObject.set(x, "TSArrayType", value.asInstanceOf[js.Any])
      
      inline def setTSArrayTypeUndefined: Self = StObject.set(x, "TSArrayType", js.undefined)
      
      inline def setTSAsExpression(value: VisitNode[S, Extract[Node, `8`]]): Self = StObject.set(x, "TSAsExpression", value.asInstanceOf[js.Any])
      
      inline def setTSAsExpressionUndefined: Self = StObject.set(x, "TSAsExpression", js.undefined)
      
      inline def setTSBaseType(value: VisitNode[S, TSBaseType]): Self = StObject.set(x, "TSBaseType", value.asInstanceOf[js.Any])
      
      inline def setTSBaseTypeUndefined: Self = StObject.set(x, "TSBaseType", js.undefined)
      
      inline def setTSBigIntKeyword(value: VisitNode[S, Extract[Node, `53`]]): Self = StObject.set(x, "TSBigIntKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSBigIntKeywordUndefined: Self = StObject.set(x, "TSBigIntKeyword", js.undefined)
      
      inline def setTSBooleanKeyword(value: VisitNode[S, Extract[Node, `225`]]): Self = StObject.set(x, "TSBooleanKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSBooleanKeywordUndefined: Self = StObject.set(x, "TSBooleanKeyword", js.undefined)
      
      inline def setTSCallSignatureDeclaration(value: VisitNode[S, Extract[Node, `151`]]): Self = StObject.set(x, "TSCallSignatureDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSCallSignatureDeclarationUndefined: Self = StObject.set(x, "TSCallSignatureDeclaration", js.undefined)
      
      inline def setTSConditionalType(value: VisitNode[S, Extract[Node, `18`]]): Self = StObject.set(x, "TSConditionalType", value.asInstanceOf[js.Any])
      
      inline def setTSConditionalTypeUndefined: Self = StObject.set(x, "TSConditionalType", js.undefined)
      
      inline def setTSConstructSignatureDeclaration(value: VisitNode[S, Extract[Node, `122`]]): Self = StObject.set(x, "TSConstructSignatureDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSConstructSignatureDeclarationUndefined: Self = StObject.set(x, "TSConstructSignatureDeclaration", js.undefined)
      
      inline def setTSConstructorType(value: VisitNode[S, Extract[Node, `213`]]): Self = StObject.set(x, "TSConstructorType", value.asInstanceOf[js.Any])
      
      inline def setTSConstructorTypeUndefined: Self = StObject.set(x, "TSConstructorType", js.undefined)
      
      inline def setTSDeclareFunction(value: VisitNode[S, Extract[Node, `201`]]): Self = StObject.set(x, "TSDeclareFunction", value.asInstanceOf[js.Any])
      
      inline def setTSDeclareFunctionUndefined: Self = StObject.set(x, "TSDeclareFunction", js.undefined)
      
      inline def setTSDeclareMethod(value: VisitNode[S, Extract[Node, `77`]]): Self = StObject.set(x, "TSDeclareMethod", value.asInstanceOf[js.Any])
      
      inline def setTSDeclareMethodUndefined: Self = StObject.set(x, "TSDeclareMethod", js.undefined)
      
      inline def setTSEntityName(value: VisitNode[S, TSEntityName]): Self = StObject.set(x, "TSEntityName", value.asInstanceOf[js.Any])
      
      inline def setTSEntityNameUndefined: Self = StObject.set(x, "TSEntityName", js.undefined)
      
      inline def setTSEnumDeclaration(value: VisitNode[S, Extract[Node, `91`]]): Self = StObject.set(x, "TSEnumDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSEnumDeclarationUndefined: Self = StObject.set(x, "TSEnumDeclaration", js.undefined)
      
      inline def setTSEnumMember(value: VisitNode[S, Extract[Node, `133`]]): Self = StObject.set(x, "TSEnumMember", value.asInstanceOf[js.Any])
      
      inline def setTSEnumMemberUndefined: Self = StObject.set(x, "TSEnumMember", js.undefined)
      
      inline def setTSExportAssignment(value: VisitNode[S, Extract[Node, `145`]]): Self = StObject.set(x, "TSExportAssignment", value.asInstanceOf[js.Any])
      
      inline def setTSExportAssignmentUndefined: Self = StObject.set(x, "TSExportAssignment", js.undefined)
      
      inline def setTSExpressionWithTypeArguments(value: VisitNode[S, Extract[Node, `149`]]): Self = StObject.set(x, "TSExpressionWithTypeArguments", value.asInstanceOf[js.Any])
      
      inline def setTSExpressionWithTypeArgumentsUndefined: Self = StObject.set(x, "TSExpressionWithTypeArguments", js.undefined)
      
      inline def setTSExternalModuleReference(value: VisitNode[S, Extract[Node, `121`]]): Self = StObject.set(x, "TSExternalModuleReference", value.asInstanceOf[js.Any])
      
      inline def setTSExternalModuleReferenceUndefined: Self = StObject.set(x, "TSExternalModuleReference", js.undefined)
      
      inline def setTSFunctionType(value: VisitNode[S, Extract[Node, `42`]]): Self = StObject.set(x, "TSFunctionType", value.asInstanceOf[js.Any])
      
      inline def setTSFunctionTypeUndefined: Self = StObject.set(x, "TSFunctionType", js.undefined)
      
      inline def setTSImportEqualsDeclaration(value: VisitNode[S, Extract[Node, `160`]]): Self = StObject.set(x, "TSImportEqualsDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSImportEqualsDeclarationUndefined: Self = StObject.set(x, "TSImportEqualsDeclaration", js.undefined)
      
      inline def setTSImportType(value: VisitNode[S, Extract[Node, `241`]]): Self = StObject.set(x, "TSImportType", value.asInstanceOf[js.Any])
      
      inline def setTSImportTypeUndefined: Self = StObject.set(x, "TSImportType", js.undefined)
      
      inline def setTSIndexSignature(value: VisitNode[S, Extract[Node, `207`]]): Self = StObject.set(x, "TSIndexSignature", value.asInstanceOf[js.Any])
      
      inline def setTSIndexSignatureUndefined: Self = StObject.set(x, "TSIndexSignature", js.undefined)
      
      inline def setTSIndexedAccessType(value: VisitNode[S, Extract[Node, `29`]]): Self = StObject.set(x, "TSIndexedAccessType", value.asInstanceOf[js.Any])
      
      inline def setTSIndexedAccessTypeUndefined: Self = StObject.set(x, "TSIndexedAccessType", js.undefined)
      
      inline def setTSInferType(value: VisitNode[S, Extract[Node, `104`]]): Self = StObject.set(x, "TSInferType", value.asInstanceOf[js.Any])
      
      inline def setTSInferTypeUndefined: Self = StObject.set(x, "TSInferType", js.undefined)
      
      inline def setTSInstantiationExpression(value: VisitNode[S, Extract[Node, `216`]]): Self = StObject.set(x, "TSInstantiationExpression", value.asInstanceOf[js.Any])
      
      inline def setTSInstantiationExpressionUndefined: Self = StObject.set(x, "TSInstantiationExpression", js.undefined)
      
      inline def setTSInterfaceBody(value: VisitNode[S, Extract[Node, `7`]]): Self = StObject.set(x, "TSInterfaceBody", value.asInstanceOf[js.Any])
      
      inline def setTSInterfaceBodyUndefined: Self = StObject.set(x, "TSInterfaceBody", js.undefined)
      
      inline def setTSInterfaceDeclaration(value: VisitNode[S, Extract[Node, `187`]]): Self = StObject.set(x, "TSInterfaceDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSInterfaceDeclarationUndefined: Self = StObject.set(x, "TSInterfaceDeclaration", js.undefined)
      
      inline def setTSIntersectionType(value: VisitNode[S, Extract[Node, `238`]]): Self = StObject.set(x, "TSIntersectionType", value.asInstanceOf[js.Any])
      
      inline def setTSIntersectionTypeUndefined: Self = StObject.set(x, "TSIntersectionType", js.undefined)
      
      inline def setTSIntrinsicKeyword(value: VisitNode[S, Extract[Node, `66`]]): Self = StObject.set(x, "TSIntrinsicKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSIntrinsicKeywordUndefined: Self = StObject.set(x, "TSIntrinsicKeyword", js.undefined)
      
      inline def setTSLiteralType(value: VisitNode[S, Extract[Node, `20`]]): Self = StObject.set(x, "TSLiteralType", value.asInstanceOf[js.Any])
      
      inline def setTSLiteralTypeUndefined: Self = StObject.set(x, "TSLiteralType", js.undefined)
      
      inline def setTSMappedType(value: VisitNode[S, Extract[Node, `128`]]): Self = StObject.set(x, "TSMappedType", value.asInstanceOf[js.Any])
      
      inline def setTSMappedTypeUndefined: Self = StObject.set(x, "TSMappedType", js.undefined)
      
      inline def setTSMethodSignature(value: VisitNode[S, Extract[Node, `203`]]): Self = StObject.set(x, "TSMethodSignature", value.asInstanceOf[js.Any])
      
      inline def setTSMethodSignatureUndefined: Self = StObject.set(x, "TSMethodSignature", js.undefined)
      
      inline def setTSModuleBlock(value: VisitNode[S, Extract[Node, `231`]]): Self = StObject.set(x, "TSModuleBlock", value.asInstanceOf[js.Any])
      
      inline def setTSModuleBlockUndefined: Self = StObject.set(x, "TSModuleBlock", js.undefined)
      
      inline def setTSModuleDeclaration(value: VisitNode[S, Extract[Node, `16`]]): Self = StObject.set(x, "TSModuleDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSModuleDeclarationUndefined: Self = StObject.set(x, "TSModuleDeclaration", js.undefined)
      
      inline def setTSNamedTupleMember(value: VisitNode[S, Extract[Node, `222`]]): Self = StObject.set(x, "TSNamedTupleMember", value.asInstanceOf[js.Any])
      
      inline def setTSNamedTupleMemberUndefined: Self = StObject.set(x, "TSNamedTupleMember", js.undefined)
      
      inline def setTSNamespaceExportDeclaration(value: VisitNode[S, Extract[Node, `90`]]): Self = StObject.set(x, "TSNamespaceExportDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSNamespaceExportDeclarationUndefined: Self = StObject.set(x, "TSNamespaceExportDeclaration", js.undefined)
      
      inline def setTSNeverKeyword(value: VisitNode[S, Extract[Node, `237`]]): Self = StObject.set(x, "TSNeverKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSNeverKeywordUndefined: Self = StObject.set(x, "TSNeverKeyword", js.undefined)
      
      inline def setTSNonNullExpression(value: VisitNode[S, Extract[Node, `97`]]): Self = StObject.set(x, "TSNonNullExpression", value.asInstanceOf[js.Any])
      
      inline def setTSNonNullExpressionUndefined: Self = StObject.set(x, "TSNonNullExpression", js.undefined)
      
      inline def setTSNullKeyword(value: VisitNode[S, Extract[Node, `33`]]): Self = StObject.set(x, "TSNullKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSNullKeywordUndefined: Self = StObject.set(x, "TSNullKeyword", js.undefined)
      
      inline def setTSNumberKeyword(value: VisitNode[S, Extract[Node, `181`]]): Self = StObject.set(x, "TSNumberKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSNumberKeywordUndefined: Self = StObject.set(x, "TSNumberKeyword", js.undefined)
      
      inline def setTSObjectKeyword(value: VisitNode[S, Extract[Node, `218`]]): Self = StObject.set(x, "TSObjectKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSObjectKeywordUndefined: Self = StObject.set(x, "TSObjectKeyword", js.undefined)
      
      inline def setTSOptionalType(value: VisitNode[S, Extract[Node, `185`]]): Self = StObject.set(x, "TSOptionalType", value.asInstanceOf[js.Any])
      
      inline def setTSOptionalTypeUndefined: Self = StObject.set(x, "TSOptionalType", js.undefined)
      
      inline def setTSParameterProperty(value: VisitNode[S, Extract[Node, `196`]]): Self = StObject.set(x, "TSParameterProperty", value.asInstanceOf[js.Any])
      
      inline def setTSParameterPropertyUndefined: Self = StObject.set(x, "TSParameterProperty", js.undefined)
      
      inline def setTSParenthesizedType(value: VisitNode[S, Extract[Node, `227`]]): Self = StObject.set(x, "TSParenthesizedType", value.asInstanceOf[js.Any])
      
      inline def setTSParenthesizedTypeUndefined: Self = StObject.set(x, "TSParenthesizedType", js.undefined)
      
      inline def setTSPropertySignature(value: VisitNode[S, Extract[Node, `118`]]): Self = StObject.set(x, "TSPropertySignature", value.asInstanceOf[js.Any])
      
      inline def setTSPropertySignatureUndefined: Self = StObject.set(x, "TSPropertySignature", js.undefined)
      
      inline def setTSQualifiedName(value: VisitNode[S, Extract[Node, `30`]]): Self = StObject.set(x, "TSQualifiedName", value.asInstanceOf[js.Any])
      
      inline def setTSQualifiedNameUndefined: Self = StObject.set(x, "TSQualifiedName", js.undefined)
      
      inline def setTSRestType(value: VisitNode[S, Extract[Node, `210`]]): Self = StObject.set(x, "TSRestType", value.asInstanceOf[js.Any])
      
      inline def setTSRestTypeUndefined: Self = StObject.set(x, "TSRestType", js.undefined)
      
      inline def setTSSatisfiesExpression(value: VisitNode[S, Extract[Node, `6`]]): Self = StObject.set(x, "TSSatisfiesExpression", value.asInstanceOf[js.Any])
      
      inline def setTSSatisfiesExpressionUndefined: Self = StObject.set(x, "TSSatisfiesExpression", js.undefined)
      
      inline def setTSStringKeyword(value: VisitNode[S, Extract[Node, `101`]]): Self = StObject.set(x, "TSStringKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSStringKeywordUndefined: Self = StObject.set(x, "TSStringKeyword", js.undefined)
      
      inline def setTSSymbolKeyword(value: VisitNode[S, Extract[Node, `127`]]): Self = StObject.set(x, "TSSymbolKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSSymbolKeywordUndefined: Self = StObject.set(x, "TSSymbolKeyword", js.undefined)
      
      inline def setTSThisType(value: VisitNode[S, Extract[Node, `208`]]): Self = StObject.set(x, "TSThisType", value.asInstanceOf[js.Any])
      
      inline def setTSThisTypeUndefined: Self = StObject.set(x, "TSThisType", js.undefined)
      
      inline def setTSTupleType(value: VisitNode[S, Extract[Node, `199`]]): Self = StObject.set(x, "TSTupleType", value.asInstanceOf[js.Any])
      
      inline def setTSTupleTypeUndefined: Self = StObject.set(x, "TSTupleType", js.undefined)
      
      inline def setTSType(value: VisitNode[S, TSType]): Self = StObject.set(x, "TSType", value.asInstanceOf[js.Any])
      
      inline def setTSTypeAliasDeclaration(value: VisitNode[S, Extract[Node, `92`]]): Self = StObject.set(x, "TSTypeAliasDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSTypeAliasDeclarationUndefined: Self = StObject.set(x, "TSTypeAliasDeclaration", js.undefined)
      
      inline def setTSTypeAnnotation(value: VisitNode[S, Extract[Node, `112`]]): Self = StObject.set(x, "TSTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setTSTypeAnnotationUndefined: Self = StObject.set(x, "TSTypeAnnotation", js.undefined)
      
      inline def setTSTypeAssertion(value: VisitNode[S, Extract[Node, `236`]]): Self = StObject.set(x, "TSTypeAssertion", value.asInstanceOf[js.Any])
      
      inline def setTSTypeAssertionUndefined: Self = StObject.set(x, "TSTypeAssertion", js.undefined)
      
      inline def setTSTypeElement(value: VisitNode[S, TSTypeElement]): Self = StObject.set(x, "TSTypeElement", value.asInstanceOf[js.Any])
      
      inline def setTSTypeElementUndefined: Self = StObject.set(x, "TSTypeElement", js.undefined)
      
      inline def setTSTypeLiteral(value: VisitNode[S, Extract[Node, `156`]]): Self = StObject.set(x, "TSTypeLiteral", value.asInstanceOf[js.Any])
      
      inline def setTSTypeLiteralUndefined: Self = StObject.set(x, "TSTypeLiteral", js.undefined)
      
      inline def setTSTypeOperator(value: VisitNode[S, Extract[Node, `52`]]): Self = StObject.set(x, "TSTypeOperator", value.asInstanceOf[js.Any])
      
      inline def setTSTypeOperatorUndefined: Self = StObject.set(x, "TSTypeOperator", js.undefined)
      
      inline def setTSTypeParameter(value: VisitNode[S, Extract[Node, `94`]]): Self = StObject.set(x, "TSTypeParameter", value.asInstanceOf[js.Any])
      
      inline def setTSTypeParameterDeclaration(value: VisitNode[S, Extract[Node, `21`]]): Self = StObject.set(x, "TSTypeParameterDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSTypeParameterDeclarationUndefined: Self = StObject.set(x, "TSTypeParameterDeclaration", js.undefined)
      
      inline def setTSTypeParameterInstantiation(value: VisitNode[S, Extract[Node, `76`]]): Self = StObject.set(x, "TSTypeParameterInstantiation", value.asInstanceOf[js.Any])
      
      inline def setTSTypeParameterInstantiationUndefined: Self = StObject.set(x, "TSTypeParameterInstantiation", js.undefined)
      
      inline def setTSTypeParameterUndefined: Self = StObject.set(x, "TSTypeParameter", js.undefined)
      
      inline def setTSTypePredicate(value: VisitNode[S, Extract[Node, `186`]]): Self = StObject.set(x, "TSTypePredicate", value.asInstanceOf[js.Any])
      
      inline def setTSTypePredicateUndefined: Self = StObject.set(x, "TSTypePredicate", js.undefined)
      
      inline def setTSTypeQuery(value: VisitNode[S, Extract[Node, `120`]]): Self = StObject.set(x, "TSTypeQuery", value.asInstanceOf[js.Any])
      
      inline def setTSTypeQueryUndefined: Self = StObject.set(x, "TSTypeQuery", js.undefined)
      
      inline def setTSTypeReference(value: VisitNode[S, Extract[Node, `247`]]): Self = StObject.set(x, "TSTypeReference", value.asInstanceOf[js.Any])
      
      inline def setTSTypeReferenceUndefined: Self = StObject.set(x, "TSTypeReference", js.undefined)
      
      inline def setTSTypeUndefined: Self = StObject.set(x, "TSType", js.undefined)
      
      inline def setTSUndefinedKeyword(value: VisitNode[S, Extract[Node, `169`]]): Self = StObject.set(x, "TSUndefinedKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSUndefinedKeywordUndefined: Self = StObject.set(x, "TSUndefinedKeyword", js.undefined)
      
      inline def setTSUnionType(value: VisitNode[S, Extract[Node, `93`]]): Self = StObject.set(x, "TSUnionType", value.asInstanceOf[js.Any])
      
      inline def setTSUnionTypeUndefined: Self = StObject.set(x, "TSUnionType", js.undefined)
      
      inline def setTSUnknownKeyword(value: VisitNode[S, Extract[Node, `55`]]): Self = StObject.set(x, "TSUnknownKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSUnknownKeywordUndefined: Self = StObject.set(x, "TSUnknownKeyword", js.undefined)
      
      inline def setTSVoidKeyword(value: VisitNode[S, Extract[Node, `58`]]): Self = StObject.set(x, "TSVoidKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSVoidKeywordUndefined: Self = StObject.set(x, "TSVoidKeyword", js.undefined)
      
      inline def setTaggedTemplateExpression(value: VisitNode[S, Extract[Node, `72`]]): Self = StObject.set(x, "TaggedTemplateExpression", value.asInstanceOf[js.Any])
      
      inline def setTaggedTemplateExpressionUndefined: Self = StObject.set(x, "TaggedTemplateExpression", js.undefined)
      
      inline def setTemplateElement(value: VisitNode[S, Extract[Node, `194`]]): Self = StObject.set(x, "TemplateElement", value.asInstanceOf[js.Any])
      
      inline def setTemplateElementUndefined: Self = StObject.set(x, "TemplateElement", js.undefined)
      
      inline def setTemplateLiteral(value: VisitNode[S, Extract[Node, `78`]]): Self = StObject.set(x, "TemplateLiteral", value.asInstanceOf[js.Any])
      
      inline def setTemplateLiteralUndefined: Self = StObject.set(x, "TemplateLiteral", js.undefined)
      
      inline def setTerminatorless(value: VisitNode[S, Terminatorless]): Self = StObject.set(x, "Terminatorless", value.asInstanceOf[js.Any])
      
      inline def setTerminatorlessUndefined: Self = StObject.set(x, "Terminatorless", js.undefined)
      
      inline def setThisExpression(value: VisitNode[S, Extract[Node, `234`]]): Self = StObject.set(x, "ThisExpression", value.asInstanceOf[js.Any])
      
      inline def setThisExpressionUndefined: Self = StObject.set(x, "ThisExpression", js.undefined)
      
      inline def setThisTypeAnnotation(value: VisitNode[S, Extract[Node, `51`]]): Self = StObject.set(x, "ThisTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setThisTypeAnnotationUndefined: Self = StObject.set(x, "ThisTypeAnnotation", js.undefined)
      
      inline def setThrowStatement(value: VisitNode[S, Extract[Node, `140`]]): Self = StObject.set(x, "ThrowStatement", value.asInstanceOf[js.Any])
      
      inline def setThrowStatementUndefined: Self = StObject.set(x, "ThrowStatement", js.undefined)
      
      inline def setTopicReference(value: VisitNode[S, Extract[Node, `102`]]): Self = StObject.set(x, "TopicReference", value.asInstanceOf[js.Any])
      
      inline def setTopicReferenceUndefined: Self = StObject.set(x, "TopicReference", js.undefined)
      
      inline def setTryStatement(value: VisitNode[S, Extract[Node, `24`]]): Self = StObject.set(x, "TryStatement", value.asInstanceOf[js.Any])
      
      inline def setTryStatementUndefined: Self = StObject.set(x, "TryStatement", js.undefined)
      
      inline def setTupleExpression(value: VisitNode[S, Extract[Node, `209`]]): Self = StObject.set(x, "TupleExpression", value.asInstanceOf[js.Any])
      
      inline def setTupleExpressionUndefined: Self = StObject.set(x, "TupleExpression", js.undefined)
      
      inline def setTupleTypeAnnotation(value: VisitNode[S, Extract[Node, `14`]]): Self = StObject.set(x, "TupleTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setTupleTypeAnnotationUndefined: Self = StObject.set(x, "TupleTypeAnnotation", js.undefined)
      
      inline def setTypeAlias(value: VisitNode[S, Extract[Node, `180`]]): Self = StObject.set(x, "TypeAlias", value.asInstanceOf[js.Any])
      
      inline def setTypeAliasUndefined: Self = StObject.set(x, "TypeAlias", js.undefined)
      
      inline def setTypeAnnotation(value: VisitNode[S, Extract[Node, `22`]]): Self = StObject.set(x, "TypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setTypeAnnotationUndefined: Self = StObject.set(x, "TypeAnnotation", js.undefined)
      
      inline def setTypeCastExpression(value: VisitNode[S, Extract[Node, `11`]]): Self = StObject.set(x, "TypeCastExpression", value.asInstanceOf[js.Any])
      
      inline def setTypeCastExpressionUndefined: Self = StObject.set(x, "TypeCastExpression", js.undefined)
      
      inline def setTypeParameter(value: VisitNode[S, Extract[Node, `173`]]): Self = StObject.set(x, "TypeParameter", value.asInstanceOf[js.Any])
      
      inline def setTypeParameterDeclaration(value: VisitNode[S, Extract[Node, `15`]]): Self = StObject.set(x, "TypeParameterDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTypeParameterDeclarationUndefined: Self = StObject.set(x, "TypeParameterDeclaration", js.undefined)
      
      inline def setTypeParameterInstantiation(value: VisitNode[S, Extract[Node, `246`]]): Self = StObject.set(x, "TypeParameterInstantiation", value.asInstanceOf[js.Any])
      
      inline def setTypeParameterInstantiationUndefined: Self = StObject.set(x, "TypeParameterInstantiation", js.undefined)
      
      inline def setTypeParameterUndefined: Self = StObject.set(x, "TypeParameter", js.undefined)
      
      inline def setTypeScript(value: VisitNode[S, TypeScript]): Self = StObject.set(x, "TypeScript", value.asInstanceOf[js.Any])
      
      inline def setTypeScriptUndefined: Self = StObject.set(x, "TypeScript", js.undefined)
      
      inline def setTypeofTypeAnnotation(value: VisitNode[S, Extract[Node, `150`]]): Self = StObject.set(x, "TypeofTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setTypeofTypeAnnotationUndefined: Self = StObject.set(x, "TypeofTypeAnnotation", js.undefined)
      
      inline def setUnaryExpression(value: VisitNode[S, Extract[Node, `177`]]): Self = StObject.set(x, "UnaryExpression", value.asInstanceOf[js.Any])
      
      inline def setUnaryExpressionUndefined: Self = StObject.set(x, "UnaryExpression", js.undefined)
      
      inline def setUnaryLike(value: VisitNode[S, UnaryLike]): Self = StObject.set(x, "UnaryLike", value.asInstanceOf[js.Any])
      
      inline def setUnaryLikeUndefined: Self = StObject.set(x, "UnaryLike", js.undefined)
      
      inline def setUnionTypeAnnotation(value: VisitNode[S, Extract[Node, `221`]]): Self = StObject.set(x, "UnionTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setUnionTypeAnnotationUndefined: Self = StObject.set(x, "UnionTypeAnnotation", js.undefined)
      
      inline def setUpdateExpression(value: VisitNode[S, Extract[Node, `100`]]): Self = StObject.set(x, "UpdateExpression", value.asInstanceOf[js.Any])
      
      inline def setUpdateExpressionUndefined: Self = StObject.set(x, "UpdateExpression", js.undefined)
      
      inline def setUser(value: VisitNode[S, Node]): Self = StObject.set(x, "User", value.asInstanceOf[js.Any])
      
      inline def setUserUndefined: Self = StObject.set(x, "User", js.undefined)
      
      inline def setUserWhitespacable(value: VisitNode[S, UserWhitespacable]): Self = StObject.set(x, "UserWhitespacable", value.asInstanceOf[js.Any])
      
      inline def setUserWhitespacableUndefined: Self = StObject.set(x, "UserWhitespacable", js.undefined)
      
      inline def setV8IntrinsicIdentifier(value: VisitNode[S, Extract[Node, `141`]]): Self = StObject.set(x, "V8IntrinsicIdentifier", value.asInstanceOf[js.Any])
      
      inline def setV8IntrinsicIdentifierUndefined: Self = StObject.set(x, "V8IntrinsicIdentifier", js.undefined)
      
      inline def setVar(value: VisitNode[S, VariableDeclaration_]): Self = StObject.set(x, "Var", value.asInstanceOf[js.Any])
      
      inline def setVarUndefined: Self = StObject.set(x, "Var", js.undefined)
      
      inline def setVariableDeclaration(value: VisitNode[S, Extract[Node, `68`]]): Self = StObject.set(x, "VariableDeclaration", value.asInstanceOf[js.Any])
      
      inline def setVariableDeclarationUndefined: Self = StObject.set(x, "VariableDeclaration", js.undefined)
      
      inline def setVariableDeclarator(value: VisitNode[S, Extract[Node, `130`]]): Self = StObject.set(x, "VariableDeclarator", value.asInstanceOf[js.Any])
      
      inline def setVariableDeclaratorUndefined: Self = StObject.set(x, "VariableDeclarator", js.undefined)
      
      inline def setVariance(value: VisitNode[S, Extract[Node, `153`]]): Self = StObject.set(x, "Variance", value.asInstanceOf[js.Any])
      
      inline def setVarianceUndefined: Self = StObject.set(x, "Variance", js.undefined)
      
      inline def setVoidTypeAnnotation(value: VisitNode[S, Extract[Node, `107`]]): Self = StObject.set(x, "VoidTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setVoidTypeAnnotationUndefined: Self = StObject.set(x, "VoidTypeAnnotation", js.undefined)
      
      inline def setWhile(value: VisitNode[S, While]): Self = StObject.set(x, "While", value.asInstanceOf[js.Any])
      
      inline def setWhileStatement(value: VisitNode[S, Extract[Node, `39`]]): Self = StObject.set(x, "WhileStatement", value.asInstanceOf[js.Any])
      
      inline def setWhileStatementUndefined: Self = StObject.set(x, "WhileStatement", js.undefined)
      
      inline def setWhileUndefined: Self = StObject.set(x, "While", js.undefined)
      
      inline def setWithStatement(value: VisitNode[S, Extract[Node, `96`]]): Self = StObject.set(x, "WithStatement", value.asInstanceOf[js.Any])
      
      inline def setWithStatementUndefined: Self = StObject.set(x, "WithStatement", js.undefined)
      
      inline def setYieldExpression(value: VisitNode[S, Extract[Node, `12`]]): Self = StObject.set(x, "YieldExpression", value.asInstanceOf[js.Any])
      
      inline def setYieldExpressionUndefined: Self = StObject.set(x, "YieldExpression", js.undefined)
    }
  }
}
