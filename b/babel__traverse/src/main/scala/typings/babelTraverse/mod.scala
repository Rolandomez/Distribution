package typings.babelTraverse

import org.scalablytyped.runtime.Instantiable1
import org.scalablytyped.runtime.StringDictionary
import typings.babelTraverse.anon.Confident
import typings.babelTraverse.anon.Container
import typings.babelTraverse.anon.FnCall
import typings.babelTraverse.anon.Id
import typings.babelTraverse.anon.Identifier
import typings.babelTraverse.anon.Type
import typings.babelTraverse.anon.Typeofvisitors
import typings.babelTraverse.anon.`0`
import typings.babelTraverse.anon.`100`
import typings.babelTraverse.anon.`101`
import typings.babelTraverse.anon.`102`
import typings.babelTraverse.anon.`103`
import typings.babelTraverse.anon.`104`
import typings.babelTraverse.anon.`105`
import typings.babelTraverse.anon.`106`
import typings.babelTraverse.anon.`107`
import typings.babelTraverse.anon.`108`
import typings.babelTraverse.anon.`109`
import typings.babelTraverse.anon.`10`
import typings.babelTraverse.anon.`110`
import typings.babelTraverse.anon.`111`
import typings.babelTraverse.anon.`112`
import typings.babelTraverse.anon.`113`
import typings.babelTraverse.anon.`114`
import typings.babelTraverse.anon.`115`
import typings.babelTraverse.anon.`116`
import typings.babelTraverse.anon.`117`
import typings.babelTraverse.anon.`118`
import typings.babelTraverse.anon.`119`
import typings.babelTraverse.anon.`11`
import typings.babelTraverse.anon.`120`
import typings.babelTraverse.anon.`121`
import typings.babelTraverse.anon.`122`
import typings.babelTraverse.anon.`123`
import typings.babelTraverse.anon.`124`
import typings.babelTraverse.anon.`125`
import typings.babelTraverse.anon.`126`
import typings.babelTraverse.anon.`127`
import typings.babelTraverse.anon.`128`
import typings.babelTraverse.anon.`129`
import typings.babelTraverse.anon.`12`
import typings.babelTraverse.anon.`130`
import typings.babelTraverse.anon.`131`
import typings.babelTraverse.anon.`132`
import typings.babelTraverse.anon.`133`
import typings.babelTraverse.anon.`134`
import typings.babelTraverse.anon.`135`
import typings.babelTraverse.anon.`136`
import typings.babelTraverse.anon.`137`
import typings.babelTraverse.anon.`138`
import typings.babelTraverse.anon.`139`
import typings.babelTraverse.anon.`13`
import typings.babelTraverse.anon.`140`
import typings.babelTraverse.anon.`141`
import typings.babelTraverse.anon.`142`
import typings.babelTraverse.anon.`143`
import typings.babelTraverse.anon.`144`
import typings.babelTraverse.anon.`145`
import typings.babelTraverse.anon.`146`
import typings.babelTraverse.anon.`147`
import typings.babelTraverse.anon.`148`
import typings.babelTraverse.anon.`149`
import typings.babelTraverse.anon.`14`
import typings.babelTraverse.anon.`150`
import typings.babelTraverse.anon.`151`
import typings.babelTraverse.anon.`152`
import typings.babelTraverse.anon.`153`
import typings.babelTraverse.anon.`154`
import typings.babelTraverse.anon.`155`
import typings.babelTraverse.anon.`156`
import typings.babelTraverse.anon.`157`
import typings.babelTraverse.anon.`158`
import typings.babelTraverse.anon.`159`
import typings.babelTraverse.anon.`15`
import typings.babelTraverse.anon.`160`
import typings.babelTraverse.anon.`161`
import typings.babelTraverse.anon.`162`
import typings.babelTraverse.anon.`163`
import typings.babelTraverse.anon.`164`
import typings.babelTraverse.anon.`165`
import typings.babelTraverse.anon.`166`
import typings.babelTraverse.anon.`167`
import typings.babelTraverse.anon.`168`
import typings.babelTraverse.anon.`169`
import typings.babelTraverse.anon.`16`
import typings.babelTraverse.anon.`170`
import typings.babelTraverse.anon.`171`
import typings.babelTraverse.anon.`172`
import typings.babelTraverse.anon.`173`
import typings.babelTraverse.anon.`174`
import typings.babelTraverse.anon.`175`
import typings.babelTraverse.anon.`176`
import typings.babelTraverse.anon.`177`
import typings.babelTraverse.anon.`178`
import typings.babelTraverse.anon.`179`
import typings.babelTraverse.anon.`17`
import typings.babelTraverse.anon.`180`
import typings.babelTraverse.anon.`181`
import typings.babelTraverse.anon.`182`
import typings.babelTraverse.anon.`183`
import typings.babelTraverse.anon.`184`
import typings.babelTraverse.anon.`185`
import typings.babelTraverse.anon.`186`
import typings.babelTraverse.anon.`187`
import typings.babelTraverse.anon.`188`
import typings.babelTraverse.anon.`189`
import typings.babelTraverse.anon.`18`
import typings.babelTraverse.anon.`190`
import typings.babelTraverse.anon.`191`
import typings.babelTraverse.anon.`192`
import typings.babelTraverse.anon.`193`
import typings.babelTraverse.anon.`194`
import typings.babelTraverse.anon.`195`
import typings.babelTraverse.anon.`196`
import typings.babelTraverse.anon.`197`
import typings.babelTraverse.anon.`198`
import typings.babelTraverse.anon.`199`
import typings.babelTraverse.anon.`19`
import typings.babelTraverse.anon.`1`
import typings.babelTraverse.anon.`200`
import typings.babelTraverse.anon.`201`
import typings.babelTraverse.anon.`202`
import typings.babelTraverse.anon.`203`
import typings.babelTraverse.anon.`204`
import typings.babelTraverse.anon.`205`
import typings.babelTraverse.anon.`206`
import typings.babelTraverse.anon.`207`
import typings.babelTraverse.anon.`208`
import typings.babelTraverse.anon.`209`
import typings.babelTraverse.anon.`20`
import typings.babelTraverse.anon.`210`
import typings.babelTraverse.anon.`211`
import typings.babelTraverse.anon.`212`
import typings.babelTraverse.anon.`213`
import typings.babelTraverse.anon.`214`
import typings.babelTraverse.anon.`215`
import typings.babelTraverse.anon.`216`
import typings.babelTraverse.anon.`217`
import typings.babelTraverse.anon.`218`
import typings.babelTraverse.anon.`219`
import typings.babelTraverse.anon.`21`
import typings.babelTraverse.anon.`220`
import typings.babelTraverse.anon.`221`
import typings.babelTraverse.anon.`222`
import typings.babelTraverse.anon.`223`
import typings.babelTraverse.anon.`224`
import typings.babelTraverse.anon.`225`
import typings.babelTraverse.anon.`226`
import typings.babelTraverse.anon.`227`
import typings.babelTraverse.anon.`228`
import typings.babelTraverse.anon.`229`
import typings.babelTraverse.anon.`22`
import typings.babelTraverse.anon.`230`
import typings.babelTraverse.anon.`231`
import typings.babelTraverse.anon.`232`
import typings.babelTraverse.anon.`233`
import typings.babelTraverse.anon.`234`
import typings.babelTraverse.anon.`235`
import typings.babelTraverse.anon.`236`
import typings.babelTraverse.anon.`237`
import typings.babelTraverse.anon.`238`
import typings.babelTraverse.anon.`239`
import typings.babelTraverse.anon.`23`
import typings.babelTraverse.anon.`240`
import typings.babelTraverse.anon.`241`
import typings.babelTraverse.anon.`242`
import typings.babelTraverse.anon.`243`
import typings.babelTraverse.anon.`244`
import typings.babelTraverse.anon.`245`
import typings.babelTraverse.anon.`246`
import typings.babelTraverse.anon.`24`
import typings.babelTraverse.anon.`25`
import typings.babelTraverse.anon.`26`
import typings.babelTraverse.anon.`27`
import typings.babelTraverse.anon.`28`
import typings.babelTraverse.anon.`29`
import typings.babelTraverse.anon.`2`
import typings.babelTraverse.anon.`30`
import typings.babelTraverse.anon.`31`
import typings.babelTraverse.anon.`32`
import typings.babelTraverse.anon.`33`
import typings.babelTraverse.anon.`34`
import typings.babelTraverse.anon.`35`
import typings.babelTraverse.anon.`36`
import typings.babelTraverse.anon.`37`
import typings.babelTraverse.anon.`38`
import typings.babelTraverse.anon.`39`
import typings.babelTraverse.anon.`3`
import typings.babelTraverse.anon.`40`
import typings.babelTraverse.anon.`41`
import typings.babelTraverse.anon.`42`
import typings.babelTraverse.anon.`43`
import typings.babelTraverse.anon.`44`
import typings.babelTraverse.anon.`45`
import typings.babelTraverse.anon.`46`
import typings.babelTraverse.anon.`47`
import typings.babelTraverse.anon.`48`
import typings.babelTraverse.anon.`49`
import typings.babelTraverse.anon.`4`
import typings.babelTraverse.anon.`50`
import typings.babelTraverse.anon.`51`
import typings.babelTraverse.anon.`52`
import typings.babelTraverse.anon.`53`
import typings.babelTraverse.anon.`54`
import typings.babelTraverse.anon.`55`
import typings.babelTraverse.anon.`56`
import typings.babelTraverse.anon.`57`
import typings.babelTraverse.anon.`58`
import typings.babelTraverse.anon.`59`
import typings.babelTraverse.anon.`5`
import typings.babelTraverse.anon.`60`
import typings.babelTraverse.anon.`61`
import typings.babelTraverse.anon.`62`
import typings.babelTraverse.anon.`63`
import typings.babelTraverse.anon.`64`
import typings.babelTraverse.anon.`65`
import typings.babelTraverse.anon.`66`
import typings.babelTraverse.anon.`67`
import typings.babelTraverse.anon.`68`
import typings.babelTraverse.anon.`69`
import typings.babelTraverse.anon.`6`
import typings.babelTraverse.anon.`70`
import typings.babelTraverse.anon.`71`
import typings.babelTraverse.anon.`72`
import typings.babelTraverse.anon.`73`
import typings.babelTraverse.anon.`74`
import typings.babelTraverse.anon.`75`
import typings.babelTraverse.anon.`76`
import typings.babelTraverse.anon.`77`
import typings.babelTraverse.anon.`78`
import typings.babelTraverse.anon.`79`
import typings.babelTraverse.anon.`7`
import typings.babelTraverse.anon.`80`
import typings.babelTraverse.anon.`81`
import typings.babelTraverse.anon.`82`
import typings.babelTraverse.anon.`83`
import typings.babelTraverse.anon.`84`
import typings.babelTraverse.anon.`85`
import typings.babelTraverse.anon.`86`
import typings.babelTraverse.anon.`87`
import typings.babelTraverse.anon.`88`
import typings.babelTraverse.anon.`89`
import typings.babelTraverse.anon.`8`
import typings.babelTraverse.anon.`90`
import typings.babelTraverse.anon.`91`
import typings.babelTraverse.anon.`92`
import typings.babelTraverse.anon.`93`
import typings.babelTraverse.anon.`94`
import typings.babelTraverse.anon.`95`
import typings.babelTraverse.anon.`96`
import typings.babelTraverse.anon.`97`
import typings.babelTraverse.anon.`98`
import typings.babelTraverse.anon.`99`
import typings.babelTraverse.anon.`9`
import typings.babelTraverse.babelTraverseBooleans.`false`
import typings.babelTraverse.babelTraverseBooleans.`true`
import typings.babelTypes.mod.Accessor
import typings.babelTypes.mod.Binary
import typings.babelTypes.mod.Block
import typings.babelTypes.mod.BlockParent
import typings.babelTypes.mod.Class
import typings.babelTypes.mod.CompletionStatement
import typings.babelTypes.mod.Conditional
import typings.babelTypes.mod.Declaration
import typings.babelTypes.mod.EnumBody
import typings.babelTypes.mod.EnumMember
import typings.babelTypes.mod.ExportDeclaration
import typings.babelTypes.mod.Expression
import typings.babelTypes.mod.ExpressionWrapper
import typings.babelTypes.mod.Flow
import typings.babelTypes.mod.FlowBaseAnnotation
import typings.babelTypes.mod.FlowDeclaration
import typings.babelTypes.mod.FlowPredicate
import typings.babelTypes.mod.FlowType
import typings.babelTypes.mod.For
import typings.babelTypes.mod.ForXStatement
import typings.babelTypes.mod.Function
import typings.babelTypes.mod.FunctionParent
import typings.babelTypes.mod.Identifier_
import typings.babelTypes.mod.Immutable
import typings.babelTypes.mod.JSX
import typings.babelTypes.mod.LVal
import typings.babelTypes.mod.Literal
import typings.babelTypes.mod.Loop
import typings.babelTypes.mod.Method
import typings.babelTypes.mod.Miscellaneous
import typings.babelTypes.mod.ModuleDeclaration
import typings.babelTypes.mod.ModuleSpecifier
import typings.babelTypes.mod.Node
import typings.babelTypes.mod.ObjectMember
import typings.babelTypes.mod.Pattern
import typings.babelTypes.mod.PatternLike
import typings.babelTypes.mod.Private
import typings.babelTypes.mod.Property
import typings.babelTypes.mod.Pureish
import typings.babelTypes.mod.Scopable
import typings.babelTypes.mod.Standardized
import typings.babelTypes.mod.Statement
import typings.babelTypes.mod.TSBaseType
import typings.babelTypes.mod.TSEntityName
import typings.babelTypes.mod.TSType
import typings.babelTypes.mod.TSTypeElement
import typings.babelTypes.mod.Terminatorless
import typings.babelTypes.mod.TypeScript
import typings.babelTypes.mod.UnaryLike
import typings.babelTypes.mod.UserWhitespacable
import typings.babelTypes.mod.While
import typings.std.Extract
import typings.std.Record
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object mod {
  
  object default {
    
    inline def apply(
      parent: js.UndefOr[Node | js.Array[Node] | Null],
      opts: js.UndefOr[TraverseOptions[Node]],
      scope: js.UndefOr[Scope],
      state: js.UndefOr[Any],
      parentPath: js.UndefOr[NodePath[Node]]
    ): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply[S](parent: js.Array[Node], opts: TraverseOptions[S], scope: Unit, state: S): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply[S](
      parent: js.Array[Node],
      opts: TraverseOptions[S],
      scope: Unit,
      state: S,
      parentPath: NodePath[Node]
    ): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply[S](parent: js.Array[Node], opts: TraverseOptions[S], scope: Scope, state: S): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply[S](
      parent: js.Array[Node],
      opts: TraverseOptions[S],
      scope: Scope,
      state: S,
      parentPath: NodePath[Node]
    ): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply[S](parent: Null, opts: TraverseOptions[S], scope: Unit, state: S): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply[S](parent: Null, opts: TraverseOptions[S], scope: Unit, state: S, parentPath: NodePath[Node]): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply[S](parent: Null, opts: TraverseOptions[S], scope: Scope, state: S): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply[S](parent: Null, opts: TraverseOptions[S], scope: Scope, state: S, parentPath: NodePath[Node]): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply[S](parent: Unit, opts: TraverseOptions[S], scope: Unit, state: S): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply[S](parent: Unit, opts: TraverseOptions[S], scope: Unit, state: S, parentPath: NodePath[Node]): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply[S](parent: Unit, opts: TraverseOptions[S], scope: Scope, state: S): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply[S](parent: Unit, opts: TraverseOptions[S], scope: Scope, state: S, parentPath: NodePath[Node]): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply[S](parent: Node, opts: TraverseOptions[S], scope: Unit, state: S): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply[S](parent: Node, opts: TraverseOptions[S], scope: Unit, state: S, parentPath: NodePath[Node]): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply[S](parent: Node, opts: TraverseOptions[S], scope: Scope, state: S): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def apply[S](parent: Node, opts: TraverseOptions[S], scope: Scope, state: S, parentPath: NodePath[Node]): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
    
    @JSImport("@babel/traverse", JSImport.Default)
    @js.native
    val ^ : js.Any = js.native
    
    @JSImport("@babel/traverse", "default.explode")
    @js.native
    def explode: FnCall = js.native
    inline def explode[S](visitor: Visitor[S]): /* import warning: importer.ImportType#apply Failed type conversion: {[ Type in 'ClassAccessorProperty' | 'AnyTypeAnnotation' | 'ArgumentPlaceholder' | 'ArrayExpression' | 'ArrayPattern' | 'ArrayTypeAnnotation' | 'ArrowFunctionExpression' | 'AssignmentExpression' | 'AssignmentPattern' | 'AwaitExpression' | 'BigIntLiteral' | 'BinaryExpression' | 'LogicalExpression' | 'BindExpression' | 'BlockStatement' | 'Program' | 'TSModuleBlock' | 'CatchClause' | 'DoWhileStatement' | 'ForInStatement' | 'ForStatement' | 'FunctionDeclaration' | 'FunctionExpression' | 'ObjectMethod' | 'SwitchStatement' | 'WhileStatement' | 'ForOfStatement' | 'ClassMethod' | 'ClassPrivateMethod' | 'StaticBlock' | 'BooleanLiteral' | 'BooleanLiteralTypeAnnotation' | 'BooleanTypeAnnotation' | 'BreakStatement' | 'CallExpression' | 'ClassExpression' | 'ClassDeclaration' | 'ClassBody' | 'ClassImplements' | 'ClassPrivateProperty' | 'ClassProperty' | 'ContinueStatement' | 'ReturnStatement' | 'ThrowStatement' | 'ConditionalExpression' | 'IfStatement' | 'DebuggerStatement' | 'DecimalLiteral' | 'VariableDeclaration' | 'ExportAllDeclaration' | 'ExportDefaultDeclaration' | 'ExportNamedDeclaration' | 'ImportDeclaration' | 'DeclareClass' | 'DeclareFunction' | 'DeclareInterface' | 'DeclareModule' | 'DeclareModuleExports' | 'DeclareTypeAlias' | 'DeclareOpaqueType' | 'DeclareVariable' | 'DeclareExportDeclaration' | 'DeclareExportAllDeclaration' | 'InterfaceDeclaration' | 'OpaqueType' | 'TypeAlias' | 'EnumDeclaration' | 'TSDeclareFunction' | 'TSInterfaceDeclaration' | 'TSTypeAliasDeclaration' | 'TSEnumDeclaration' | 'TSModuleDeclaration' | 'DeclaredPredicate' | 'Decorator' | 'Directive' | 'DirectiveLiteral' | 'DoExpression' | 'EmptyStatement' | 'EmptyTypeAnnotation' | 'EnumBooleanBody' | 'EnumNumberBody' | 'EnumStringBody' | 'EnumSymbolBody' | 'EnumBooleanMember' | 'EnumDefaultedMember' | 'EnumNumberMember' | 'EnumStringMember' | 'ExistsTypeAnnotation' | 'ExportDefaultSpecifier' | 'ExportNamespaceSpecifier' | 'ExportSpecifier' | 'Identifier' | 'StringLiteral' | 'NumericLiteral' | 'NullLiteral' | 'RegExpLiteral' | 'MemberExpression' | 'NewExpression' | 'ObjectExpression' | 'SequenceExpression' | 'ParenthesizedExpression' | 'ThisExpression' | 'UnaryExpression' | 'UpdateExpression' | 'MetaProperty' | 'Super' | 'TaggedTemplateExpression' | 'TemplateLiteral' | 'YieldExpression' | 'Import' | 'OptionalMemberExpression' | 'OptionalCallExpression' | 'TypeCastExpression' | 'JSXElement' | 'JSXFragment' | 'RecordExpression' | 'TupleExpression' | 'ModuleExpression' | 'TopicReference' | 'PipelineTopicExpression' | 'PipelineBareFunction' | 'PipelinePrimaryTopicReference' | 'TSInstantiationExpression' | 'TSAsExpression' | 'TSTypeAssertion' | 'TSNonNullExpression' | 'ExpressionStatement' | 'File' | 'NullLiteralTypeAnnotation' | 'FunctionTypeAnnotation' | 'FunctionTypeParam' | 'GenericTypeAnnotation' | 'InferredPredicate' | 'InterfaceExtends' | 'InterfaceTypeAnnotation' | 'IntersectionTypeAnnotation' | 'MixedTypeAnnotation' | 'NullableTypeAnnotation' | 'NumberLiteralTypeAnnotation' | 'NumberTypeAnnotation' | 'ObjectTypeAnnotation' | 'ObjectTypeInternalSlot' | 'ObjectTypeCallProperty' | 'ObjectTypeIndexer' | 'ObjectTypeProperty' | 'ObjectTypeSpreadProperty' | 'QualifiedTypeIdentifier' | 'StringLiteralTypeAnnotation' | 'StringTypeAnnotation' | 'SymbolTypeAnnotation' | 'ThisTypeAnnotation' | 'TupleTypeAnnotation' | 'TypeofTypeAnnotation' | 'TypeAnnotation' | 'TypeParameter' | 'TypeParameterDeclaration' | 'TypeParameterInstantiation' | 'UnionTypeAnnotation' | 'Variance' | 'VoidTypeAnnotation' | 'IndexedAccessType' | 'OptionalIndexedAccessType' | 'JSXAttribute' | 'JSXClosingElement' | 'JSXExpressionContainer' | 'JSXSpreadChild' | 'JSXOpeningElement' | 'JSXText' | 'JSXOpeningFragment' | 'JSXClosingFragment' | 'ImportAttribute' | 'ImportDefaultSpecifier' | 'ImportNamespaceSpecifier' | 'ImportSpecifier' | 'InterpreterDirective' | 'JSXEmptyExpression' | 'JSXIdentifier' | 'JSXMemberExpression' | 'JSXNamespacedName' | 'JSXSpreadAttribute' | 'RestElement' | 'ObjectPattern' | 'TSParameterProperty' | 'LabeledStatement' | 'Noop' | 'Placeholder' | 'V8IntrinsicIdentifier' | 'ObjectProperty' | 'PrivateName' | 'SpreadElement' | 'SwitchCase' | 'TryStatement' | 'VariableDeclarator' | 'WithStatement' | 'TemplateElement' | 'TSImportEqualsDeclaration' | 'TSExportAssignment' | 'TSNamespaceExportDeclaration' | 'TSAnyKeyword' | 'TSArrayType' | 'TSBooleanKeyword' | 'TSBigIntKeyword' | 'TSIntrinsicKeyword' | 'TSNeverKeyword' | 'TSNullKeyword' | 'TSNumberKeyword' | 'TSObjectKeyword' | 'TSStringKeyword' | 'TSSymbolKeyword' | 'TSUndefinedKeyword' | 'TSUnknownKeyword' | 'TSVoidKeyword' | 'TSThisType' | 'TSLiteralType' | 'TSCallSignatureDeclaration' | 'TSConditionalType' | 'TSConstructSignatureDeclaration' | 'TSConstructorType' | 'TSDeclareMethod' | 'TSQualifiedName' | 'TSEnumMember' | 'TSExpressionWithTypeArguments' | 'TSExternalModuleReference' | 'TSFunctionType' | 'TSImportType' | 'TSIndexSignature' | 'TSIndexedAccessType' | 'TSInferType' | 'TSInterfaceBody' | 'TSIntersectionType' | 'TSMappedType' | 'TSMethodSignature' | 'TSNamedTupleMember' | 'TSOptionalType' | 'TSParenthesizedType' | 'TSPropertySignature' | 'TSRestType' | 'TSTupleType' | 'TSTypeReference' | 'TSTypePredicate' | 'TSTypeQuery' | 'TSTypeLiteral' | 'TSUnionType' | 'TSTypeOperator' | 'TSTypeAnnotation' | 'TSTypeParameter' | 'TSTypeParameterDeclaration' | 'TSTypeParameterInstantiation' ]:? @babel/traverse.@babel/traverse.VisitNodeObject<S, std.Extract<@babel/types.@babel/types.Node, {  type :Type}>>} */ js.Any = ^.asInstanceOf[js.Dynamic].applyDynamic("explode")(visitor.asInstanceOf[js.Any]).asInstanceOf[/* import warning: importer.ImportType#apply Failed type conversion: {[ Type in 'ClassAccessorProperty' | 'AnyTypeAnnotation' | 'ArgumentPlaceholder' | 'ArrayExpression' | 'ArrayPattern' | 'ArrayTypeAnnotation' | 'ArrowFunctionExpression' | 'AssignmentExpression' | 'AssignmentPattern' | 'AwaitExpression' | 'BigIntLiteral' | 'BinaryExpression' | 'LogicalExpression' | 'BindExpression' | 'BlockStatement' | 'Program' | 'TSModuleBlock' | 'CatchClause' | 'DoWhileStatement' | 'ForInStatement' | 'ForStatement' | 'FunctionDeclaration' | 'FunctionExpression' | 'ObjectMethod' | 'SwitchStatement' | 'WhileStatement' | 'ForOfStatement' | 'ClassMethod' | 'ClassPrivateMethod' | 'StaticBlock' | 'BooleanLiteral' | 'BooleanLiteralTypeAnnotation' | 'BooleanTypeAnnotation' | 'BreakStatement' | 'CallExpression' | 'ClassExpression' | 'ClassDeclaration' | 'ClassBody' | 'ClassImplements' | 'ClassPrivateProperty' | 'ClassProperty' | 'ContinueStatement' | 'ReturnStatement' | 'ThrowStatement' | 'ConditionalExpression' | 'IfStatement' | 'DebuggerStatement' | 'DecimalLiteral' | 'VariableDeclaration' | 'ExportAllDeclaration' | 'ExportDefaultDeclaration' | 'ExportNamedDeclaration' | 'ImportDeclaration' | 'DeclareClass' | 'DeclareFunction' | 'DeclareInterface' | 'DeclareModule' | 'DeclareModuleExports' | 'DeclareTypeAlias' | 'DeclareOpaqueType' | 'DeclareVariable' | 'DeclareExportDeclaration' | 'DeclareExportAllDeclaration' | 'InterfaceDeclaration' | 'OpaqueType' | 'TypeAlias' | 'EnumDeclaration' | 'TSDeclareFunction' | 'TSInterfaceDeclaration' | 'TSTypeAliasDeclaration' | 'TSEnumDeclaration' | 'TSModuleDeclaration' | 'DeclaredPredicate' | 'Decorator' | 'Directive' | 'DirectiveLiteral' | 'DoExpression' | 'EmptyStatement' | 'EmptyTypeAnnotation' | 'EnumBooleanBody' | 'EnumNumberBody' | 'EnumStringBody' | 'EnumSymbolBody' | 'EnumBooleanMember' | 'EnumDefaultedMember' | 'EnumNumberMember' | 'EnumStringMember' | 'ExistsTypeAnnotation' | 'ExportDefaultSpecifier' | 'ExportNamespaceSpecifier' | 'ExportSpecifier' | 'Identifier' | 'StringLiteral' | 'NumericLiteral' | 'NullLiteral' | 'RegExpLiteral' | 'MemberExpression' | 'NewExpression' | 'ObjectExpression' | 'SequenceExpression' | 'ParenthesizedExpression' | 'ThisExpression' | 'UnaryExpression' | 'UpdateExpression' | 'MetaProperty' | 'Super' | 'TaggedTemplateExpression' | 'TemplateLiteral' | 'YieldExpression' | 'Import' | 'OptionalMemberExpression' | 'OptionalCallExpression' | 'TypeCastExpression' | 'JSXElement' | 'JSXFragment' | 'RecordExpression' | 'TupleExpression' | 'ModuleExpression' | 'TopicReference' | 'PipelineTopicExpression' | 'PipelineBareFunction' | 'PipelinePrimaryTopicReference' | 'TSInstantiationExpression' | 'TSAsExpression' | 'TSTypeAssertion' | 'TSNonNullExpression' | 'ExpressionStatement' | 'File' | 'NullLiteralTypeAnnotation' | 'FunctionTypeAnnotation' | 'FunctionTypeParam' | 'GenericTypeAnnotation' | 'InferredPredicate' | 'InterfaceExtends' | 'InterfaceTypeAnnotation' | 'IntersectionTypeAnnotation' | 'MixedTypeAnnotation' | 'NullableTypeAnnotation' | 'NumberLiteralTypeAnnotation' | 'NumberTypeAnnotation' | 'ObjectTypeAnnotation' | 'ObjectTypeInternalSlot' | 'ObjectTypeCallProperty' | 'ObjectTypeIndexer' | 'ObjectTypeProperty' | 'ObjectTypeSpreadProperty' | 'QualifiedTypeIdentifier' | 'StringLiteralTypeAnnotation' | 'StringTypeAnnotation' | 'SymbolTypeAnnotation' | 'ThisTypeAnnotation' | 'TupleTypeAnnotation' | 'TypeofTypeAnnotation' | 'TypeAnnotation' | 'TypeParameter' | 'TypeParameterDeclaration' | 'TypeParameterInstantiation' | 'UnionTypeAnnotation' | 'Variance' | 'VoidTypeAnnotation' | 'IndexedAccessType' | 'OptionalIndexedAccessType' | 'JSXAttribute' | 'JSXClosingElement' | 'JSXExpressionContainer' | 'JSXSpreadChild' | 'JSXOpeningElement' | 'JSXText' | 'JSXOpeningFragment' | 'JSXClosingFragment' | 'ImportAttribute' | 'ImportDefaultSpecifier' | 'ImportNamespaceSpecifier' | 'ImportSpecifier' | 'InterpreterDirective' | 'JSXEmptyExpression' | 'JSXIdentifier' | 'JSXMemberExpression' | 'JSXNamespacedName' | 'JSXSpreadAttribute' | 'RestElement' | 'ObjectPattern' | 'TSParameterProperty' | 'LabeledStatement' | 'Noop' | 'Placeholder' | 'V8IntrinsicIdentifier' | 'ObjectProperty' | 'PrivateName' | 'SpreadElement' | 'SwitchCase' | 'TryStatement' | 'VariableDeclarator' | 'WithStatement' | 'TemplateElement' | 'TSImportEqualsDeclaration' | 'TSExportAssignment' | 'TSNamespaceExportDeclaration' | 'TSAnyKeyword' | 'TSArrayType' | 'TSBooleanKeyword' | 'TSBigIntKeyword' | 'TSIntrinsicKeyword' | 'TSNeverKeyword' | 'TSNullKeyword' | 'TSNumberKeyword' | 'TSObjectKeyword' | 'TSStringKeyword' | 'TSSymbolKeyword' | 'TSUndefinedKeyword' | 'TSUnknownKeyword' | 'TSVoidKeyword' | 'TSThisType' | 'TSLiteralType' | 'TSCallSignatureDeclaration' | 'TSConditionalType' | 'TSConstructSignatureDeclaration' | 'TSConstructorType' | 'TSDeclareMethod' | 'TSQualifiedName' | 'TSEnumMember' | 'TSExpressionWithTypeArguments' | 'TSExternalModuleReference' | 'TSFunctionType' | 'TSImportType' | 'TSIndexSignature' | 'TSIndexedAccessType' | 'TSInferType' | 'TSInterfaceBody' | 'TSIntersectionType' | 'TSMappedType' | 'TSMethodSignature' | 'TSNamedTupleMember' | 'TSOptionalType' | 'TSParenthesizedType' | 'TSPropertySignature' | 'TSRestType' | 'TSTupleType' | 'TSTypeReference' | 'TSTypePredicate' | 'TSTypeQuery' | 'TSTypeLiteral' | 'TSUnionType' | 'TSTypeOperator' | 'TSTypeAnnotation' | 'TSTypeParameter' | 'TSTypeParameterDeclaration' | 'TSTypeParameterInstantiation' ]:? @babel/traverse.@babel/traverse.VisitNodeObject<S, std.Extract<@babel/types.@babel/types.Node, {  type :Type}>>} */ js.Any]
    inline def explode_=(x: FnCall): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("explode")(x.asInstanceOf[js.Any])
    
    @JSImport("@babel/traverse", "default.verify")
    @js.native
    def verify: js.Function1[/* visitor */ Visitor[js.Object], Unit] = js.native
    inline def verify(visitor: Visitor[js.Object]): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("verify")(visitor.asInstanceOf[js.Any]).asInstanceOf[Unit]
    inline def verify_=(x: js.Function1[/* visitor */ Visitor[js.Object], Unit]): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("verify")(x.asInstanceOf[js.Any])
    
    @JSImport("@babel/traverse", "default.visitors")
    @js.native
    def visitors: Typeofvisitors = js.native
    inline def visitors_=(x: Typeofvisitors): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("visitors")(x.asInstanceOf[js.Any])
  }
  
  @JSImport("@babel/traverse", "Binding")
  @js.native
  open class Binding protected () extends StObject {
    def this(opts: Identifier) = this()
    
    def clearValue(): Unit = js.native
    
    var constant: Boolean = js.native
    
    var constantViolations: js.Array[NodePath[Node]] = js.native
    
    def deopValue(): Unit = js.native
    
    def dereference(): Unit = js.native
    
    var hasDeoptedValue: js.UndefOr[Boolean] = js.native
    
    var hasValue: js.UndefOr[Boolean] = js.native
    
    var identifier: Identifier_ = js.native
    
    var kind: BindingKind = js.native
    
    var path: NodePath[Node] = js.native
    
    def reassign(path: NodePath[Node]): Unit = js.native
    
    def reference(path: NodePath[Node]): Unit = js.native
    
    var referencePaths: js.Array[NodePath[Node]] = js.native
    
    var referenced: Boolean = js.native
    
    var references: Double = js.native
    
    var scope: Scope = js.native
    
    def setValue(value: Any): Unit = js.native
    
    var value: js.UndefOr[Any] = js.native
  }
  
  @JSImport("@babel/traverse", "Hub")
  @js.native
  open class Hub ()
    extends StObject
       with HubInterface {
    
    /* CompleteClass */
    override def addHelper(name: String): Any = js.native
    
    /* CompleteClass */
    override def buildError[E /* <: js.Error */](node: Node, msg: String, Error: Instantiable1[/* message */ js.UndefOr[String], E]): E = js.native
    
    /* CompleteClass */
    override def getCode(): js.UndefOr[String] = js.native
    
    /* CompleteClass */
    override def getScope(): js.UndefOr[Scope] = js.native
  }
  
  @JSImport("@babel/traverse", "NodePath")
  @js.native
  open class NodePath[T] protected () extends StObject {
    def this(hub: Hub, parent: Node) = this()
    
    def addComment(`type`: String, content: String): Unit = js.native
    def addComment(`type`: String, content: String, line: Boolean): Unit = js.native
    
    /** Give node `comments` of the specified `type`. */
    def addComments(`type`: String, comments: js.Array[Any]): Unit = js.native
    
    //#endregion
    //#region ------------------------- assertXXX -------------------------
    def assertAnyTypeAnnotation(): Unit = js.native
    def assertAnyTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertArrayExpression(): Unit = js.native
    def assertArrayExpression(props: js.Object): Unit = js.native
    
    def assertArrayPattern(): Unit = js.native
    def assertArrayPattern(props: js.Object): Unit = js.native
    
    def assertArrayTypeAnnotation(): Unit = js.native
    def assertArrayTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertArrowFunctionExpression(): Unit = js.native
    def assertArrowFunctionExpression(props: js.Object): Unit = js.native
    
    def assertAssignmentExpression(): Unit = js.native
    def assertAssignmentExpression(props: js.Object): Unit = js.native
    
    def assertAssignmentPattern(): Unit = js.native
    def assertAssignmentPattern(props: js.Object): Unit = js.native
    
    def assertAwaitExpression(): Unit = js.native
    def assertAwaitExpression(props: js.Object): Unit = js.native
    
    def assertBigIntLiteral(): Unit = js.native
    def assertBigIntLiteral(props: js.Object): Unit = js.native
    
    def assertBinary(): Unit = js.native
    def assertBinary(props: js.Object): Unit = js.native
    
    def assertBinaryExpression(): Unit = js.native
    def assertBinaryExpression(props: js.Object): Unit = js.native
    
    def assertBindExpression(): Unit = js.native
    def assertBindExpression(props: js.Object): Unit = js.native
    
    def assertBindingIdentifier(): Unit = js.native
    def assertBindingIdentifier(props: js.Object): Unit = js.native
    
    def assertBlock(): Unit = js.native
    def assertBlock(props: js.Object): Unit = js.native
    
    def assertBlockParent(): Unit = js.native
    def assertBlockParent(props: js.Object): Unit = js.native
    
    def assertBlockScoped(): Unit = js.native
    def assertBlockScoped(props: js.Object): Unit = js.native
    
    def assertBlockStatement(): Unit = js.native
    def assertBlockStatement(props: js.Object): Unit = js.native
    
    def assertBooleanLiteral(): Unit = js.native
    def assertBooleanLiteral(props: js.Object): Unit = js.native
    
    def assertBooleanLiteralTypeAnnotation(): Unit = js.native
    def assertBooleanLiteralTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertBooleanTypeAnnotation(): Unit = js.native
    def assertBooleanTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertBreakStatement(): Unit = js.native
    def assertBreakStatement(props: js.Object): Unit = js.native
    
    def assertCallExpression(): Unit = js.native
    def assertCallExpression(props: js.Object): Unit = js.native
    
    def assertCatchClause(): Unit = js.native
    def assertCatchClause(props: js.Object): Unit = js.native
    
    def assertClass(): Unit = js.native
    def assertClass(props: js.Object): Unit = js.native
    
    def assertClassBody(): Unit = js.native
    def assertClassBody(props: js.Object): Unit = js.native
    
    def assertClassDeclaration(): Unit = js.native
    def assertClassDeclaration(props: js.Object): Unit = js.native
    
    def assertClassExpression(): Unit = js.native
    def assertClassExpression(props: js.Object): Unit = js.native
    
    def assertClassImplements(): Unit = js.native
    def assertClassImplements(props: js.Object): Unit = js.native
    
    def assertClassMethod(): Unit = js.native
    def assertClassMethod(props: js.Object): Unit = js.native
    
    def assertClassPrivateMethod(): Unit = js.native
    def assertClassPrivateMethod(props: js.Object): Unit = js.native
    
    def assertClassPrivateProperty(): Unit = js.native
    def assertClassPrivateProperty(props: js.Object): Unit = js.native
    
    def assertClassProperty(): Unit = js.native
    def assertClassProperty(props: js.Object): Unit = js.native
    
    def assertCompletionStatement(): Unit = js.native
    def assertCompletionStatement(props: js.Object): Unit = js.native
    
    def assertConditional(): Unit = js.native
    def assertConditional(props: js.Object): Unit = js.native
    
    def assertConditionalExpression(): Unit = js.native
    def assertConditionalExpression(props: js.Object): Unit = js.native
    
    def assertContinueStatement(): Unit = js.native
    def assertContinueStatement(props: js.Object): Unit = js.native
    
    def assertDebuggerStatement(): Unit = js.native
    def assertDebuggerStatement(props: js.Object): Unit = js.native
    
    def assertDeclaration(): Unit = js.native
    def assertDeclaration(props: js.Object): Unit = js.native
    
    def assertDeclareClass(): Unit = js.native
    def assertDeclareClass(props: js.Object): Unit = js.native
    
    def assertDeclareExportAllDeclaration(): Unit = js.native
    def assertDeclareExportAllDeclaration(props: js.Object): Unit = js.native
    
    def assertDeclareExportDeclaration(): Unit = js.native
    def assertDeclareExportDeclaration(props: js.Object): Unit = js.native
    
    def assertDeclareFunction(): Unit = js.native
    def assertDeclareFunction(props: js.Object): Unit = js.native
    
    def assertDeclareInterface(): Unit = js.native
    def assertDeclareInterface(props: js.Object): Unit = js.native
    
    def assertDeclareModule(): Unit = js.native
    def assertDeclareModule(props: js.Object): Unit = js.native
    
    def assertDeclareModuleExports(): Unit = js.native
    def assertDeclareModuleExports(props: js.Object): Unit = js.native
    
    def assertDeclareOpaqueType(): Unit = js.native
    def assertDeclareOpaqueType(props: js.Object): Unit = js.native
    
    def assertDeclareTypeAlias(): Unit = js.native
    def assertDeclareTypeAlias(props: js.Object): Unit = js.native
    
    def assertDeclareVariable(): Unit = js.native
    def assertDeclareVariable(props: js.Object): Unit = js.native
    
    def assertDeclaredPredicate(): Unit = js.native
    def assertDeclaredPredicate(props: js.Object): Unit = js.native
    
    def assertDecorator(): Unit = js.native
    def assertDecorator(props: js.Object): Unit = js.native
    
    def assertDirective(): Unit = js.native
    def assertDirective(props: js.Object): Unit = js.native
    
    def assertDirectiveLiteral(): Unit = js.native
    def assertDirectiveLiteral(props: js.Object): Unit = js.native
    
    def assertDoExpression(): Unit = js.native
    def assertDoExpression(props: js.Object): Unit = js.native
    
    def assertDoWhileStatement(): Unit = js.native
    def assertDoWhileStatement(props: js.Object): Unit = js.native
    
    def assertEmptyStatement(): Unit = js.native
    def assertEmptyStatement(props: js.Object): Unit = js.native
    
    def assertEmptyTypeAnnotation(): Unit = js.native
    def assertEmptyTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertExistsTypeAnnotation(): Unit = js.native
    def assertExistsTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertExportAllDeclaration(): Unit = js.native
    def assertExportAllDeclaration(props: js.Object): Unit = js.native
    
    def assertExportDeclaration(): Unit = js.native
    def assertExportDeclaration(props: js.Object): Unit = js.native
    
    def assertExportDefaultDeclaration(): Unit = js.native
    def assertExportDefaultDeclaration(props: js.Object): Unit = js.native
    
    def assertExportDefaultSpecifier(): Unit = js.native
    def assertExportDefaultSpecifier(props: js.Object): Unit = js.native
    
    def assertExportNamedDeclaration(): Unit = js.native
    def assertExportNamedDeclaration(props: js.Object): Unit = js.native
    
    def assertExportNamespaceSpecifier(): Unit = js.native
    def assertExportNamespaceSpecifier(props: js.Object): Unit = js.native
    
    def assertExportSpecifier(): Unit = js.native
    def assertExportSpecifier(props: js.Object): Unit = js.native
    
    def assertExpression(): Unit = js.native
    def assertExpression(props: js.Object): Unit = js.native
    
    def assertExpressionStatement(): Unit = js.native
    def assertExpressionStatement(props: js.Object): Unit = js.native
    
    def assertExpressionWrapper(): Unit = js.native
    def assertExpressionWrapper(props: js.Object): Unit = js.native
    
    def assertFile(): Unit = js.native
    def assertFile(props: js.Object): Unit = js.native
    
    def assertFlow(): Unit = js.native
    def assertFlow(props: js.Object): Unit = js.native
    
    def assertFlowBaseAnnotation(): Unit = js.native
    def assertFlowBaseAnnotation(props: js.Object): Unit = js.native
    
    def assertFlowDeclaration(): Unit = js.native
    def assertFlowDeclaration(props: js.Object): Unit = js.native
    
    def assertFlowPredicate(): Unit = js.native
    def assertFlowPredicate(props: js.Object): Unit = js.native
    
    def assertFlowType(): Unit = js.native
    def assertFlowType(props: js.Object): Unit = js.native
    
    def assertFor(): Unit = js.native
    def assertFor(props: js.Object): Unit = js.native
    
    def assertForInStatement(): Unit = js.native
    def assertForInStatement(props: js.Object): Unit = js.native
    
    def assertForOfStatement(): Unit = js.native
    def assertForOfStatement(props: js.Object): Unit = js.native
    
    def assertForStatement(): Unit = js.native
    def assertForStatement(props: js.Object): Unit = js.native
    
    def assertForXStatement(): Unit = js.native
    def assertForXStatement(props: js.Object): Unit = js.native
    
    def assertFunction(): Unit = js.native
    def assertFunction(props: js.Object): Unit = js.native
    
    def assertFunctionDeclaration(): Unit = js.native
    def assertFunctionDeclaration(props: js.Object): Unit = js.native
    
    def assertFunctionExpression(): Unit = js.native
    def assertFunctionExpression(props: js.Object): Unit = js.native
    
    def assertFunctionParent(): Unit = js.native
    def assertFunctionParent(props: js.Object): Unit = js.native
    
    def assertFunctionTypeAnnotation(): Unit = js.native
    def assertFunctionTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertFunctionTypeParam(): Unit = js.native
    def assertFunctionTypeParam(props: js.Object): Unit = js.native
    
    def assertGenerated(): Unit = js.native
    def assertGenerated(props: js.Object): Unit = js.native
    
    def assertGenericTypeAnnotation(): Unit = js.native
    def assertGenericTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertIdentifier(): Unit = js.native
    def assertIdentifier(props: js.Object): Unit = js.native
    
    def assertIfStatement(): Unit = js.native
    def assertIfStatement(props: js.Object): Unit = js.native
    
    def assertImmutable(): Unit = js.native
    def assertImmutable(props: js.Object): Unit = js.native
    
    def assertImport(): Unit = js.native
    def assertImport(props: js.Object): Unit = js.native
    
    def assertImportDeclaration(): Unit = js.native
    def assertImportDeclaration(props: js.Object): Unit = js.native
    
    def assertImportDefaultSpecifier(): Unit = js.native
    def assertImportDefaultSpecifier(props: js.Object): Unit = js.native
    
    def assertImportNamespaceSpecifier(): Unit = js.native
    def assertImportNamespaceSpecifier(props: js.Object): Unit = js.native
    
    def assertImportSpecifier(): Unit = js.native
    def assertImportSpecifier(props: js.Object): Unit = js.native
    
    def assertInferredPredicate(): Unit = js.native
    def assertInferredPredicate(props: js.Object): Unit = js.native
    
    def assertInterfaceDeclaration(): Unit = js.native
    def assertInterfaceDeclaration(props: js.Object): Unit = js.native
    
    def assertInterfaceExtends(): Unit = js.native
    def assertInterfaceExtends(props: js.Object): Unit = js.native
    
    def assertInterfaceTypeAnnotation(): Unit = js.native
    def assertInterfaceTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertInterpreterDirective(): Unit = js.native
    def assertInterpreterDirective(props: js.Object): Unit = js.native
    
    def assertIntersectionTypeAnnotation(): Unit = js.native
    def assertIntersectionTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertJSX(): Unit = js.native
    def assertJSX(props: js.Object): Unit = js.native
    
    def assertJSXAttribute(): Unit = js.native
    def assertJSXAttribute(props: js.Object): Unit = js.native
    
    def assertJSXClosingElement(): Unit = js.native
    def assertJSXClosingElement(props: js.Object): Unit = js.native
    
    def assertJSXClosingFragment(): Unit = js.native
    def assertJSXClosingFragment(props: js.Object): Unit = js.native
    
    def assertJSXElement(): Unit = js.native
    def assertJSXElement(props: js.Object): Unit = js.native
    
    def assertJSXEmptyExpression(): Unit = js.native
    def assertJSXEmptyExpression(props: js.Object): Unit = js.native
    
    def assertJSXExpressionContainer(): Unit = js.native
    def assertJSXExpressionContainer(props: js.Object): Unit = js.native
    
    def assertJSXFragment(): Unit = js.native
    def assertJSXFragment(props: js.Object): Unit = js.native
    
    def assertJSXIdentifier(): Unit = js.native
    def assertJSXIdentifier(props: js.Object): Unit = js.native
    
    def assertJSXMemberExpression(): Unit = js.native
    def assertJSXMemberExpression(props: js.Object): Unit = js.native
    
    def assertJSXNamespacedName(): Unit = js.native
    def assertJSXNamespacedName(props: js.Object): Unit = js.native
    
    def assertJSXOpeningElement(): Unit = js.native
    def assertJSXOpeningElement(props: js.Object): Unit = js.native
    
    def assertJSXOpeningFragment(): Unit = js.native
    def assertJSXOpeningFragment(props: js.Object): Unit = js.native
    
    def assertJSXSpreadAttribute(): Unit = js.native
    def assertJSXSpreadAttribute(props: js.Object): Unit = js.native
    
    def assertJSXSpreadChild(): Unit = js.native
    def assertJSXSpreadChild(props: js.Object): Unit = js.native
    
    def assertJSXText(): Unit = js.native
    def assertJSXText(props: js.Object): Unit = js.native
    
    def assertLVal(): Unit = js.native
    def assertLVal(props: js.Object): Unit = js.native
    
    def assertLabeledStatement(): Unit = js.native
    def assertLabeledStatement(props: js.Object): Unit = js.native
    
    def assertLiteral(): Unit = js.native
    def assertLiteral(props: js.Object): Unit = js.native
    
    def assertLogicalExpression(): Unit = js.native
    def assertLogicalExpression(props: js.Object): Unit = js.native
    
    def assertLoop(): Unit = js.native
    def assertLoop(props: js.Object): Unit = js.native
    
    def assertMemberExpression(): Unit = js.native
    def assertMemberExpression(props: js.Object): Unit = js.native
    
    def assertMetaProperty(): Unit = js.native
    def assertMetaProperty(props: js.Object): Unit = js.native
    
    def assertMethod(): Unit = js.native
    def assertMethod(props: js.Object): Unit = js.native
    
    def assertMixedTypeAnnotation(): Unit = js.native
    def assertMixedTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertModuleDeclaration(): Unit = js.native
    def assertModuleDeclaration(props: js.Object): Unit = js.native
    
    def assertModuleSpecifier(): Unit = js.native
    def assertModuleSpecifier(props: js.Object): Unit = js.native
    
    def assertNewExpression(): Unit = js.native
    def assertNewExpression(props: js.Object): Unit = js.native
    
    def assertNoop(): Unit = js.native
    def assertNoop(props: js.Object): Unit = js.native
    
    def assertNullLiteral(): Unit = js.native
    def assertNullLiteral(props: js.Object): Unit = js.native
    
    def assertNullLiteralTypeAnnotation(): Unit = js.native
    def assertNullLiteralTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertNullableTypeAnnotation(): Unit = js.native
    def assertNullableTypeAnnotation(props: js.Object): Unit = js.native
    
    /** @deprecated Use `assertNumericLiteral` */
    def assertNumberLiteral(): Unit = js.native
    def assertNumberLiteral(props: js.Object): Unit = js.native
    
    def assertNumberLiteralTypeAnnotation(): Unit = js.native
    def assertNumberLiteralTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertNumberTypeAnnotation(): Unit = js.native
    def assertNumberTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertNumericLiteral(): Unit = js.native
    def assertNumericLiteral(props: js.Object): Unit = js.native
    
    def assertObjectExpression(): Unit = js.native
    def assertObjectExpression(props: js.Object): Unit = js.native
    
    def assertObjectMember(): Unit = js.native
    def assertObjectMember(props: js.Object): Unit = js.native
    
    def assertObjectMethod(): Unit = js.native
    def assertObjectMethod(props: js.Object): Unit = js.native
    
    def assertObjectPattern(): Unit = js.native
    def assertObjectPattern(props: js.Object): Unit = js.native
    
    def assertObjectProperty(): Unit = js.native
    def assertObjectProperty(props: js.Object): Unit = js.native
    
    def assertObjectTypeAnnotation(): Unit = js.native
    def assertObjectTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertObjectTypeCallProperty(): Unit = js.native
    def assertObjectTypeCallProperty(props: js.Object): Unit = js.native
    
    def assertObjectTypeIndexer(): Unit = js.native
    def assertObjectTypeIndexer(props: js.Object): Unit = js.native
    
    def assertObjectTypeInternalSlot(): Unit = js.native
    def assertObjectTypeInternalSlot(props: js.Object): Unit = js.native
    
    def assertObjectTypeProperty(): Unit = js.native
    def assertObjectTypeProperty(props: js.Object): Unit = js.native
    
    def assertObjectTypeSpreadProperty(): Unit = js.native
    def assertObjectTypeSpreadProperty(props: js.Object): Unit = js.native
    
    def assertOpaqueType(): Unit = js.native
    def assertOpaqueType(props: js.Object): Unit = js.native
    
    def assertOptionalCallExpression(): Unit = js.native
    def assertOptionalCallExpression(props: js.Object): Unit = js.native
    
    def assertOptionalMemberExpression(): Unit = js.native
    def assertOptionalMemberExpression(props: js.Object): Unit = js.native
    
    def assertParenthesizedExpression(): Unit = js.native
    def assertParenthesizedExpression(props: js.Object): Unit = js.native
    
    def assertPattern(): Unit = js.native
    def assertPattern(props: js.Object): Unit = js.native
    
    def assertPatternLike(): Unit = js.native
    def assertPatternLike(props: js.Object): Unit = js.native
    
    def assertPipelineBareFunction(): Unit = js.native
    def assertPipelineBareFunction(props: js.Object): Unit = js.native
    
    def assertPipelinePrimaryTopicReference(): Unit = js.native
    def assertPipelinePrimaryTopicReference(props: js.Object): Unit = js.native
    
    def assertPipelineTopicExpression(): Unit = js.native
    def assertPipelineTopicExpression(props: js.Object): Unit = js.native
    
    def assertPrivate(): Unit = js.native
    def assertPrivate(props: js.Object): Unit = js.native
    
    def assertPrivateName(): Unit = js.native
    def assertPrivateName(props: js.Object): Unit = js.native
    
    def assertProgram(): Unit = js.native
    def assertProgram(props: js.Object): Unit = js.native
    
    def assertProperty(): Unit = js.native
    def assertProperty(props: js.Object): Unit = js.native
    
    def assertPure(): Unit = js.native
    def assertPure(props: js.Object): Unit = js.native
    
    def assertPureish(): Unit = js.native
    def assertPureish(props: js.Object): Unit = js.native
    
    def assertQualifiedTypeIdentifier(): Unit = js.native
    def assertQualifiedTypeIdentifier(props: js.Object): Unit = js.native
    
    def assertReferenced(): Unit = js.native
    def assertReferenced(props: js.Object): Unit = js.native
    
    def assertReferencedIdentifier(): Unit = js.native
    def assertReferencedIdentifier(props: js.Object): Unit = js.native
    
    def assertReferencedMemberExpression(): Unit = js.native
    def assertReferencedMemberExpression(props: js.Object): Unit = js.native
    
    def assertRegExpLiteral(): Unit = js.native
    def assertRegExpLiteral(props: js.Object): Unit = js.native
    
    /** @deprecated Use `assertRegExpLiteral` */
    def assertRegexLiteral(): Unit = js.native
    def assertRegexLiteral(props: js.Object): Unit = js.native
    
    def assertRestElement(): Unit = js.native
    def assertRestElement(props: js.Object): Unit = js.native
    
    /** @deprecated Use `assertRestElement` */
    def assertRestProperty(): Unit = js.native
    def assertRestProperty(props: js.Object): Unit = js.native
    
    def assertReturnStatement(): Unit = js.native
    def assertReturnStatement(props: js.Object): Unit = js.native
    
    def assertScopable(): Unit = js.native
    def assertScopable(props: js.Object): Unit = js.native
    
    def assertScope(): Unit = js.native
    def assertScope(props: js.Object): Unit = js.native
    
    def assertSequenceExpression(): Unit = js.native
    def assertSequenceExpression(props: js.Object): Unit = js.native
    
    def assertSpreadElement(): Unit = js.native
    def assertSpreadElement(props: js.Object): Unit = js.native
    
    /** @deprecated Use `assertSpreadElement` */
    def assertSpreadProperty(): Unit = js.native
    def assertSpreadProperty(props: js.Object): Unit = js.native
    
    def assertStatement(): Unit = js.native
    def assertStatement(props: js.Object): Unit = js.native
    
    def assertStringLiteral(): Unit = js.native
    def assertStringLiteral(props: js.Object): Unit = js.native
    
    def assertStringLiteralTypeAnnotation(): Unit = js.native
    def assertStringLiteralTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertStringTypeAnnotation(): Unit = js.native
    def assertStringTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertSuper(): Unit = js.native
    def assertSuper(props: js.Object): Unit = js.native
    
    def assertSwitchCase(): Unit = js.native
    def assertSwitchCase(props: js.Object): Unit = js.native
    
    def assertSwitchStatement(): Unit = js.native
    def assertSwitchStatement(props: js.Object): Unit = js.native
    
    def assertTSAnyKeyword(): Unit = js.native
    def assertTSAnyKeyword(props: js.Object): Unit = js.native
    
    def assertTSArrayType(): Unit = js.native
    def assertTSArrayType(props: js.Object): Unit = js.native
    
    def assertTSAsExpression(): Unit = js.native
    def assertTSAsExpression(props: js.Object): Unit = js.native
    
    def assertTSBooleanKeyword(): Unit = js.native
    def assertTSBooleanKeyword(props: js.Object): Unit = js.native
    
    def assertTSCallSignatureDeclaration(): Unit = js.native
    def assertTSCallSignatureDeclaration(props: js.Object): Unit = js.native
    
    def assertTSConditionalType(): Unit = js.native
    def assertTSConditionalType(props: js.Object): Unit = js.native
    
    def assertTSConstructSignatureDeclaration(): Unit = js.native
    def assertTSConstructSignatureDeclaration(props: js.Object): Unit = js.native
    
    def assertTSConstructorType(): Unit = js.native
    def assertTSConstructorType(props: js.Object): Unit = js.native
    
    def assertTSDeclareFunction(): Unit = js.native
    def assertTSDeclareFunction(props: js.Object): Unit = js.native
    
    def assertTSDeclareMethod(): Unit = js.native
    def assertTSDeclareMethod(props: js.Object): Unit = js.native
    
    def assertTSEntityName(): Unit = js.native
    def assertTSEntityName(props: js.Object): Unit = js.native
    
    def assertTSEnumDeclaration(): Unit = js.native
    def assertTSEnumDeclaration(props: js.Object): Unit = js.native
    
    def assertTSEnumMember(): Unit = js.native
    def assertTSEnumMember(props: js.Object): Unit = js.native
    
    def assertTSExportAssignment(): Unit = js.native
    def assertTSExportAssignment(props: js.Object): Unit = js.native
    
    def assertTSExpressionWithTypeArguments(): Unit = js.native
    def assertTSExpressionWithTypeArguments(props: js.Object): Unit = js.native
    
    def assertTSExternalModuleReference(): Unit = js.native
    def assertTSExternalModuleReference(props: js.Object): Unit = js.native
    
    def assertTSFunctionType(): Unit = js.native
    def assertTSFunctionType(props: js.Object): Unit = js.native
    
    def assertTSImportEqualsDeclaration(): Unit = js.native
    def assertTSImportEqualsDeclaration(props: js.Object): Unit = js.native
    
    def assertTSImportType(): Unit = js.native
    def assertTSImportType(props: js.Object): Unit = js.native
    
    def assertTSIndexSignature(): Unit = js.native
    def assertTSIndexSignature(props: js.Object): Unit = js.native
    
    def assertTSIndexedAccessType(): Unit = js.native
    def assertTSIndexedAccessType(props: js.Object): Unit = js.native
    
    def assertTSInferType(): Unit = js.native
    def assertTSInferType(props: js.Object): Unit = js.native
    
    def assertTSInterfaceBody(): Unit = js.native
    def assertTSInterfaceBody(props: js.Object): Unit = js.native
    
    def assertTSInterfaceDeclaration(): Unit = js.native
    def assertTSInterfaceDeclaration(props: js.Object): Unit = js.native
    
    def assertTSIntersectionType(): Unit = js.native
    def assertTSIntersectionType(props: js.Object): Unit = js.native
    
    def assertTSLiteralType(): Unit = js.native
    def assertTSLiteralType(props: js.Object): Unit = js.native
    
    def assertTSMappedType(): Unit = js.native
    def assertTSMappedType(props: js.Object): Unit = js.native
    
    def assertTSMethodSignature(): Unit = js.native
    def assertTSMethodSignature(props: js.Object): Unit = js.native
    
    def assertTSModuleBlock(): Unit = js.native
    def assertTSModuleBlock(props: js.Object): Unit = js.native
    
    def assertTSModuleDeclaration(): Unit = js.native
    def assertTSModuleDeclaration(props: js.Object): Unit = js.native
    
    def assertTSNamespaceExportDeclaration(): Unit = js.native
    def assertTSNamespaceExportDeclaration(props: js.Object): Unit = js.native
    
    def assertTSNeverKeyword(): Unit = js.native
    def assertTSNeverKeyword(props: js.Object): Unit = js.native
    
    def assertTSNonNullExpression(): Unit = js.native
    def assertTSNonNullExpression(props: js.Object): Unit = js.native
    
    def assertTSNullKeyword(): Unit = js.native
    def assertTSNullKeyword(props: js.Object): Unit = js.native
    
    def assertTSNumberKeyword(): Unit = js.native
    def assertTSNumberKeyword(props: js.Object): Unit = js.native
    
    def assertTSObjectKeyword(): Unit = js.native
    def assertTSObjectKeyword(props: js.Object): Unit = js.native
    
    def assertTSOptionalType(): Unit = js.native
    def assertTSOptionalType(props: js.Object): Unit = js.native
    
    def assertTSParameterProperty(): Unit = js.native
    def assertTSParameterProperty(props: js.Object): Unit = js.native
    
    def assertTSParenthesizedType(): Unit = js.native
    def assertTSParenthesizedType(props: js.Object): Unit = js.native
    
    def assertTSPropertySignature(): Unit = js.native
    def assertTSPropertySignature(props: js.Object): Unit = js.native
    
    def assertTSQualifiedName(): Unit = js.native
    def assertTSQualifiedName(props: js.Object): Unit = js.native
    
    def assertTSRestType(): Unit = js.native
    def assertTSRestType(props: js.Object): Unit = js.native
    
    def assertTSStringKeyword(): Unit = js.native
    def assertTSStringKeyword(props: js.Object): Unit = js.native
    
    def assertTSSymbolKeyword(): Unit = js.native
    def assertTSSymbolKeyword(props: js.Object): Unit = js.native
    
    def assertTSThisType(): Unit = js.native
    def assertTSThisType(props: js.Object): Unit = js.native
    
    def assertTSTupleType(): Unit = js.native
    def assertTSTupleType(props: js.Object): Unit = js.native
    
    def assertTSType(): Unit = js.native
    def assertTSType(props: js.Object): Unit = js.native
    
    def assertTSTypeAliasDeclaration(): Unit = js.native
    def assertTSTypeAliasDeclaration(props: js.Object): Unit = js.native
    
    def assertTSTypeAnnotation(): Unit = js.native
    def assertTSTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertTSTypeAssertion(): Unit = js.native
    def assertTSTypeAssertion(props: js.Object): Unit = js.native
    
    def assertTSTypeElement(): Unit = js.native
    def assertTSTypeElement(props: js.Object): Unit = js.native
    
    def assertTSTypeLiteral(): Unit = js.native
    def assertTSTypeLiteral(props: js.Object): Unit = js.native
    
    def assertTSTypeOperator(): Unit = js.native
    def assertTSTypeOperator(props: js.Object): Unit = js.native
    
    def assertTSTypeParameter(): Unit = js.native
    def assertTSTypeParameter(props: js.Object): Unit = js.native
    
    def assertTSTypeParameterDeclaration(): Unit = js.native
    def assertTSTypeParameterDeclaration(props: js.Object): Unit = js.native
    
    def assertTSTypeParameterInstantiation(): Unit = js.native
    def assertTSTypeParameterInstantiation(props: js.Object): Unit = js.native
    
    def assertTSTypePredicate(): Unit = js.native
    def assertTSTypePredicate(props: js.Object): Unit = js.native
    
    def assertTSTypeQuery(): Unit = js.native
    def assertTSTypeQuery(props: js.Object): Unit = js.native
    
    def assertTSTypeReference(): Unit = js.native
    def assertTSTypeReference(props: js.Object): Unit = js.native
    
    def assertTSUndefinedKeyword(): Unit = js.native
    def assertTSUndefinedKeyword(props: js.Object): Unit = js.native
    
    def assertTSUnionType(): Unit = js.native
    def assertTSUnionType(props: js.Object): Unit = js.native
    
    def assertTSUnknownKeyword(): Unit = js.native
    def assertTSUnknownKeyword(props: js.Object): Unit = js.native
    
    def assertTSVoidKeyword(): Unit = js.native
    def assertTSVoidKeyword(props: js.Object): Unit = js.native
    
    def assertTaggedTemplateExpression(): Unit = js.native
    def assertTaggedTemplateExpression(props: js.Object): Unit = js.native
    
    def assertTemplateElement(): Unit = js.native
    def assertTemplateElement(props: js.Object): Unit = js.native
    
    def assertTemplateLiteral(): Unit = js.native
    def assertTemplateLiteral(props: js.Object): Unit = js.native
    
    def assertTerminatorless(): Unit = js.native
    def assertTerminatorless(props: js.Object): Unit = js.native
    
    def assertThisExpression(): Unit = js.native
    def assertThisExpression(props: js.Object): Unit = js.native
    
    def assertThisTypeAnnotation(): Unit = js.native
    def assertThisTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertThrowStatement(): Unit = js.native
    def assertThrowStatement(props: js.Object): Unit = js.native
    
    def assertTryStatement(): Unit = js.native
    def assertTryStatement(props: js.Object): Unit = js.native
    
    def assertTupleTypeAnnotation(): Unit = js.native
    def assertTupleTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertTypeAlias(): Unit = js.native
    def assertTypeAlias(props: js.Object): Unit = js.native
    
    def assertTypeAnnotation(): Unit = js.native
    def assertTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertTypeCastExpression(): Unit = js.native
    def assertTypeCastExpression(props: js.Object): Unit = js.native
    
    def assertTypeParameter(): Unit = js.native
    def assertTypeParameter(props: js.Object): Unit = js.native
    
    def assertTypeParameterDeclaration(): Unit = js.native
    def assertTypeParameterDeclaration(props: js.Object): Unit = js.native
    
    def assertTypeParameterInstantiation(): Unit = js.native
    def assertTypeParameterInstantiation(props: js.Object): Unit = js.native
    
    def assertTypeofTypeAnnotation(): Unit = js.native
    def assertTypeofTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertUnaryExpression(): Unit = js.native
    def assertUnaryExpression(props: js.Object): Unit = js.native
    
    def assertUnaryLike(): Unit = js.native
    def assertUnaryLike(props: js.Object): Unit = js.native
    
    def assertUnionTypeAnnotation(): Unit = js.native
    def assertUnionTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertUpdateExpression(): Unit = js.native
    def assertUpdateExpression(props: js.Object): Unit = js.native
    
    def assertUser(): Unit = js.native
    def assertUser(props: js.Object): Unit = js.native
    
    def assertUserWhitespacable(): Unit = js.native
    def assertUserWhitespacable(props: js.Object): Unit = js.native
    
    def assertVar(): Unit = js.native
    def assertVar(props: js.Object): Unit = js.native
    
    def assertVariableDeclaration(): Unit = js.native
    def assertVariableDeclaration(props: js.Object): Unit = js.native
    
    def assertVariableDeclarator(): Unit = js.native
    def assertVariableDeclarator(props: js.Object): Unit = js.native
    
    def assertVariance(): Unit = js.native
    def assertVariance(props: js.Object): Unit = js.native
    
    def assertVoidTypeAnnotation(): Unit = js.native
    def assertVoidTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertWhile(): Unit = js.native
    def assertWhile(props: js.Object): Unit = js.native
    
    def assertWhileStatement(): Unit = js.native
    def assertWhileStatement(props: js.Object): Unit = js.native
    
    def assertWithStatement(): Unit = js.native
    def assertWithStatement(props: js.Object): Unit = js.native
    
    def assertYieldExpression(): Unit = js.native
    def assertYieldExpression(props: js.Object): Unit = js.native
    
    def baseTypeStrictlyMatches(right: NodePath[Node]): Boolean = js.native
    
    def buildCodeFrameError[TError /* <: js.Error */](msg: String): TError = js.native
    def buildCodeFrameError[TError /* <: js.Error */](msg: String, Error: Instantiable1[/* msg */ String, TError]): TError = js.native
    
    //#endregion
    //#region ------------------------- context -------------------------
    def call(key: String): Boolean = js.native
    
    /**
      * This checks whether or not we're in one of the following positions:
      *
      *   for (KEY in right);
      *   for (KEY;;);
      *
      * This is because these spots allow VariableDeclarations AND normal expressions so we need
      * to tell the path replacement that it's ok to replace this with an expression.
      */
    def canHaveVariableDeclarationOrExpression(): Boolean = js.native
    
    /**
      * This checks whether we are swapping an arrow function's body between an
      * expression and a block statement (or vice versa).
      *
      * This is because arrow functions may implicitly return an expression, which
      * is the same as containing a block statement.
      */
    def canSwapBetweenExpressionAndStatement(replacement: Node): Boolean = js.native
    
    var container: js.Object | js.Array[js.Object] = js.native
    
    var context: TraversalContext = js.native
    
    var contexts: js.Array[TraversalContext] = js.native
    
    def couldBeBaseType(name: String): Boolean = js.native
    
    var data: js.Object = js.native
    
    // Example: https://github.com/babel/babel/blob/63204ae51e020d84a5b246312f5eeb4d981ab952/packages/babel-traverse/src/path/modification.js#L83
    def debug(buildMessage: js.Function0[String]): Unit = js.native
    
    /** Check whether the path node `key` strict equals `value`. */
    def equals(key: String, value: Any): Boolean = js.native
    
    /**
      * Walk the input `node` and statically evaluate it.
      *
      * Returns an object in the form `{ confident, value }`. `confident` indicates
      * whether or not we had to drop out of evaluating the expression because of
      * hitting an unknown node that we couldn't confidently find the value of.
      *
      * Example:
      *
      *   t.evaluate(parse("5 + 5")) // { confident: true, value: 10 }
      *   t.evaluate(parse("!true")) // { confident: true, value: false }
      *   t.evaluate(parse("foo + foo")) // { confident: false, value: undefined }
      */
    def evaluate(): Confident = js.native
    
    //#endregion
    //#region ------------------------- evaluation -------------------------
    /**
      * Walk the input `node` and statically evaluate if it's truthy.
      *
      * Returning `true` when we're sure that the expression will evaluate to a
      * truthy value, `false` if we're sure that it will evaluate to a falsy
      * value and `undefined` if we aren't sure. Because of this please do not
      * rely on coercion when using this method and check with === if it's false.
      */
    def evaluateTruthy(): Boolean = js.native
    
    /**
      * Starting at current `NodePath` and going up the tree, return the first
      * `NodePath` that causes the provided `callback` to return a truthy value,
      * or `null` if the `callback` never returns a truthy value.
      */
    def find(callback: js.Function1[/* path */ NodePath[Node], Boolean]): NodePath[Node] | Null = js.native
    
    //#region ------------------------- ancestry -------------------------
    /**
      * Starting at the parent path of the current `NodePath` and going up the
      * tree, return the first `NodePath` that causes the provided `callback`
      * to return a truthy value, or `null` if the `callback` never returns a
      * truthy value.
      */
    def findParent(callback: js.Function1[/* path */ NodePath[Node], Boolean]): NodePath[Node] | Null = js.native
    
    def get(key: String): NodePath[Node] | js.Array[NodePath[Node]] = js.native
    def get(key: String, context: Boolean): NodePath[Node] | js.Array[NodePath[Node]] = js.native
    def get(key: String, context: TraversalContext): NodePath[Node] | js.Array[NodePath[Node]] = js.native
    def get[K /* <: /* keyof T */ String */](key: K): NodePathResult[
        /* import warning: importer.ImportType#apply Failed type conversion: T[K] */ js.Any
      ] = js.native
    def get[K /* <: /* keyof T */ String */](key: K, context: Boolean): NodePathResult[
        /* import warning: importer.ImportType#apply Failed type conversion: T[K] */ js.Any
      ] = js.native
    def get[K /* <: /* keyof T */ String */](key: K, context: TraversalContext): NodePathResult[
        /* import warning: importer.ImportType#apply Failed type conversion: T[K] */ js.Any
      ] = js.native
    
    def getAllNextSiblings(): js.Array[NodePath[Node]] = js.native
    
    def getAllPrevSiblings(): js.Array[NodePath[Node]] = js.native
    
    /**
      * Build an array of node paths containing the entire ancestry of the current node path.
      *
      * NOTE: The current node path is included in this.
      */
    def getAncestry(): Array[this.type | NodePath[Node]] = js.native
    
    def getBindingIdentifierPaths(): Record[String, NodePath[Identifier_]] = js.native
    def getBindingIdentifierPaths(duplicates: Boolean): Record[String, NodePath[Identifier_] | js.Array[NodePath[Identifier_]]] = js.native
    def getBindingIdentifierPaths(duplicates: Boolean, outerOnly: Boolean): Record[String, NodePath[Identifier_] | js.Array[NodePath[Identifier_]]] = js.native
    def getBindingIdentifierPaths(duplicates: Unit, outerOnly: Boolean): Record[String, NodePath[Identifier_]] = js.native
    @JSName("getBindingIdentifierPaths")
    def getBindingIdentifierPaths_false(duplicates: `false`): Record[String, NodePath[Identifier_]] = js.native
    @JSName("getBindingIdentifierPaths")
    def getBindingIdentifierPaths_false(duplicates: `false`, outerOnly: Boolean): Record[String, NodePath[Identifier_]] = js.native
    @JSName("getBindingIdentifierPaths")
    def getBindingIdentifierPaths_true(duplicates: `true`): Record[String, js.Array[NodePath[Identifier_]]] = js.native
    @JSName("getBindingIdentifierPaths")
    def getBindingIdentifierPaths_true(duplicates: `true`, outerOnly: Boolean): Record[String, js.Array[NodePath[Identifier_]]] = js.native
    
    def getBindingIdentifiers(): Record[String, Identifier_] = js.native
    def getBindingIdentifiers(duplicates: Boolean): Record[String, Identifier_ | js.Array[Identifier_]] = js.native
    @JSName("getBindingIdentifiers")
    def getBindingIdentifiers_false(duplicates: `false`): Record[String, Identifier_] = js.native
    @JSName("getBindingIdentifiers")
    def getBindingIdentifiers_true(duplicates: `true`): Record[String, js.Array[Identifier_]] = js.native
    
    def getCompletionRecords(): js.Array[NodePath[Node]] = js.native
    
    def getData(key: String): Any = js.native
    def getData(key: String, `def`: Any): Any = js.native
    
    /** Get the earliest path in the tree where the provided `paths` intersect. */
    def getDeepestCommonAncestorFrom(paths: js.Array[NodePath[Node]]): NodePath[Node] = js.native
    def getDeepestCommonAncestorFrom(
      paths: js.Array[NodePath[Node]],
      filter: js.Function3[
          /* deepest */ Node, 
          /* i */ Double, 
          /* ancestries */ js.Array[NodePath[Node]], 
          NodePath[Node]
        ]
    ): NodePath[Node] = js.native
    
    /**
      * Get the deepest common ancestor and then from it, get the earliest relationship path
      * to that ancestor.
      *
      * Earliest is defined as being "before" all the other nodes in terms of list container
      * position and visiting key.
      */
    def getEarliestCommonAncestorFrom(paths: js.Array[NodePath[Node]]): NodePath[Node] = js.native
    
    /** Get the parent function of the current path. */
    def getFunctionParent(): NodePath[Function] | Null = js.native
    
    def getNextSibling(): NodePath[Node] = js.native
    
    //#endregion
    //#region ------------------------- family -------------------------
    def getOpposite(): NodePath[Node] = js.native
    
    def getOuterBindingIdentifierPaths(): Record[String, NodePath[Identifier_]] = js.native
    def getOuterBindingIdentifierPaths(duplicates: Boolean): Record[String, NodePath[Identifier_] | js.Array[NodePath[Identifier_]]] = js.native
    def getOuterBindingIdentifierPaths(duplicates: Boolean, outerOnly: Boolean): Record[String, NodePath[Identifier_] | js.Array[NodePath[Identifier_]]] = js.native
    def getOuterBindingIdentifierPaths(duplicates: Unit, outerOnly: Boolean): Record[String, NodePath[Identifier_] | js.Array[NodePath[Identifier_]]] = js.native
    @JSName("getOuterBindingIdentifierPaths")
    def getOuterBindingIdentifierPaths_false(duplicates: `false`): Record[String, NodePath[Identifier_]] = js.native
    @JSName("getOuterBindingIdentifierPaths")
    def getOuterBindingIdentifierPaths_true(duplicates: `true`): Record[String, js.Array[NodePath[Identifier_]]] = js.native
    
    def getOuterBindingIdentifiers(): Record[String, Identifier_] = js.native
    def getOuterBindingIdentifiers(duplicates: Boolean): Record[String, Identifier_ | js.Array[Identifier_]] = js.native
    @JSName("getOuterBindingIdentifiers")
    def getOuterBindingIdentifiers_false(duplicates: `false`): Record[String, Identifier_] = js.native
    @JSName("getOuterBindingIdentifiers")
    def getOuterBindingIdentifiers_true(duplicates: `true`): Record[String, js.Array[Identifier_]] = js.native
    
    def getPathLocation(): String = js.native
    
    def getPrevSibling(): NodePath[Node] = js.native
    
    def getScope(scope: Scope): Scope = js.native
    
    def getSibling(key: String): NodePath[Node] = js.native
    def getSibling(key: Double): NodePath[Node] = js.native
    
    /** Get the source code associated with this node. */
    def getSource(): String = js.native
    
    /** Walk up the tree until we hit a parent node path in a list. */
    def getStatementParent(): NodePath[Statement] | Null = js.native
    
    //#endregion
    //#region ------------------------- inference -------------------------
    /** Infer the type of the current `NodePath`. */
    def getTypeAnnotation(): FlowType = js.native
    
    /**
      * Check whether we have the input `key`. If the `key` references an array then we check
      * if the array has any items, otherwise we just check if it's falsy.
      */
    def has(key: String): Boolean = js.native
    
    def hasNode(): /* is @babel/traverse.@babel/traverse.NodePath<std.NonNullable<this['node']>> */ Boolean = js.native
    
    /** Hoist the current node to the highest scope possible and return a UID referencing it. */
    def hoist(scope: Scope): Unit = js.native
    
    var hub: Hub = js.native
    
    var inList: Boolean = js.native
    
    def inType(candidateTypes: String*): Boolean = js.native
    
    /**
      * Insert the provided nodes after the current one. When inserting nodes after an
      * expression, ensure that the completion record is correct by pushing the current node.
      */
    def insertAfter[Nodes /* <: Node | js.Array[Node] */](nodes: Nodes): NodePaths[Nodes] = js.native
    
    //#endregion
    //#region ------------------------- modification -------------------------
    /** Insert the provided nodes before the current one. */
    def insertBefore[Nodes /* <: Node | js.Array[Node] */](nodes: Nodes): NodePaths[Nodes] = js.native
    
    /** Alias of `has`. */
    def is(key: String): Boolean = js.native
    
    /**
      * A helper to find if `this` path is an ancestor of `maybeDescendant`
      */
    def isAncestor(maybeDescendant: NodePath[Node]): Boolean = js.native
    
    //#endregion
    //#region ------------------------- isXXX -------------------------
    def isAnyTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.AnyTypeAnnotation> */ Boolean = js.native
    def isAnyTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.AnyTypeAnnotation> */ Boolean = js.native
    
    def isArrayExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ArrayExpression> */ Boolean = js.native
    def isArrayExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ArrayExpression> */ Boolean = js.native
    
    def isArrayPattern(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ArrayPattern> */ Boolean = js.native
    def isArrayPattern(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ArrayPattern> */ Boolean = js.native
    
    def isArrayTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ArrayTypeAnnotation> */ Boolean = js.native
    def isArrayTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ArrayTypeAnnotation> */ Boolean = js.native
    
    def isArrowFunctionExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ArrowFunctionExpression> */ Boolean = js.native
    def isArrowFunctionExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ArrowFunctionExpression> */ Boolean = js.native
    
    def isAssignmentExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.AssignmentExpression> */ Boolean = js.native
    def isAssignmentExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.AssignmentExpression> */ Boolean = js.native
    
    def isAssignmentPattern(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.AssignmentPattern> */ Boolean = js.native
    def isAssignmentPattern(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.AssignmentPattern> */ Boolean = js.native
    
    def isAwaitExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.AwaitExpression> */ Boolean = js.native
    def isAwaitExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.AwaitExpression> */ Boolean = js.native
    
    def isBaseType(baseName: String): Boolean = js.native
    def isBaseType(baseName: String, soft: Boolean): Boolean = js.native
    
    def isBigIntLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BigIntLiteral> */ Boolean = js.native
    def isBigIntLiteral(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BigIntLiteral> */ Boolean = js.native
    
    def isBinary(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Binary> */ Boolean = js.native
    def isBinary(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Binary> */ Boolean = js.native
    
    def isBinaryExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BinaryExpression> */ Boolean = js.native
    def isBinaryExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BinaryExpression> */ Boolean = js.native
    
    def isBindExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BindExpression> */ Boolean = js.native
    def isBindExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BindExpression> */ Boolean = js.native
    
    def isBindingIdentifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Identifier> */ Boolean = js.native
    def isBindingIdentifier(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Identifier> */ Boolean = js.native
    
    def isBlacklisted(): Boolean = js.native
    
    def isBlock(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Block> */ Boolean = js.native
    def isBlock(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Block> */ Boolean = js.native
    
    def isBlockParent(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BlockParent> */ Boolean = js.native
    def isBlockParent(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BlockParent> */ Boolean = js.native
    
    def isBlockScoped(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionDeclaration | @babel/types.@babel/types.ClassDeclaration | @babel/types.@babel/types.VariableDeclaration> */ Boolean = js.native
    def isBlockScoped(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionDeclaration | @babel/types.@babel/types.ClassDeclaration | @babel/types.@babel/types.VariableDeclaration> */ Boolean = js.native
    
    def isBlockStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BlockStatement> */ Boolean = js.native
    def isBlockStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BlockStatement> */ Boolean = js.native
    
    def isBooleanLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BooleanLiteral> */ Boolean = js.native
    def isBooleanLiteral(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BooleanLiteral> */ Boolean = js.native
    
    def isBooleanLiteralTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BooleanLiteralTypeAnnotation> */ Boolean = js.native
    def isBooleanLiteralTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BooleanLiteralTypeAnnotation> */ Boolean = js.native
    
    def isBooleanTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BooleanTypeAnnotation> */ Boolean = js.native
    def isBooleanTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BooleanTypeAnnotation> */ Boolean = js.native
    
    def isBreakStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BreakStatement> */ Boolean = js.native
    def isBreakStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BreakStatement> */ Boolean = js.native
    
    def isCallExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.CallExpression> */ Boolean = js.native
    def isCallExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.CallExpression> */ Boolean = js.native
    
    def isCatchClause(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.CatchClause> */ Boolean = js.native
    def isCatchClause(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.CatchClause> */ Boolean = js.native
    
    def isClass(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Class> */ Boolean = js.native
    def isClass(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Class> */ Boolean = js.native
    
    def isClassBody(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassBody> */ Boolean = js.native
    def isClassBody(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassBody> */ Boolean = js.native
    
    def isClassDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassDeclaration> */ Boolean = js.native
    def isClassDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassDeclaration> */ Boolean = js.native
    
    def isClassExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassExpression> */ Boolean = js.native
    def isClassExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassExpression> */ Boolean = js.native
    
    def isClassImplements(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassImplements> */ Boolean = js.native
    def isClassImplements(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassImplements> */ Boolean = js.native
    
    def isClassMethod(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassMethod> */ Boolean = js.native
    def isClassMethod(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassMethod> */ Boolean = js.native
    
    def isClassPrivateMethod(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassPrivateMethod> */ Boolean = js.native
    def isClassPrivateMethod(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassPrivateMethod> */ Boolean = js.native
    
    def isClassPrivateProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassPrivateProperty> */ Boolean = js.native
    def isClassPrivateProperty(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassPrivateProperty> */ Boolean = js.native
    
    def isClassProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassProperty> */ Boolean = js.native
    def isClassProperty(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassProperty> */ Boolean = js.native
    
    /** Check whether the current path references a completion record */
    def isCompletionRecord(): Boolean = js.native
    def isCompletionRecord(allowInsideFunction: Boolean): Boolean = js.native
    
    def isCompletionStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.CompletionStatement> */ Boolean = js.native
    def isCompletionStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.CompletionStatement> */ Boolean = js.native
    
    def isConditional(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Conditional> */ Boolean = js.native
    def isConditional(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Conditional> */ Boolean = js.native
    
    def isConditionalExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ConditionalExpression> */ Boolean = js.native
    def isConditionalExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ConditionalExpression> */ Boolean = js.native
    
    def isContinueStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ContinueStatement> */ Boolean = js.native
    def isContinueStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ContinueStatement> */ Boolean = js.native
    
    def isDebuggerStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DebuggerStatement> */ Boolean = js.native
    def isDebuggerStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DebuggerStatement> */ Boolean = js.native
    
    def isDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Declaration> */ Boolean = js.native
    def isDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Declaration> */ Boolean = js.native
    
    def isDeclareClass(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareClass> */ Boolean = js.native
    def isDeclareClass(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareClass> */ Boolean = js.native
    
    def isDeclareExportAllDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareExportAllDeclaration> */ Boolean = js.native
    def isDeclareExportAllDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareExportAllDeclaration> */ Boolean = js.native
    
    def isDeclareExportDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareExportDeclaration> */ Boolean = js.native
    def isDeclareExportDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareExportDeclaration> */ Boolean = js.native
    
    def isDeclareFunction(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareFunction> */ Boolean = js.native
    def isDeclareFunction(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareFunction> */ Boolean = js.native
    
    def isDeclareInterface(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareInterface> */ Boolean = js.native
    def isDeclareInterface(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareInterface> */ Boolean = js.native
    
    def isDeclareModule(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareModule> */ Boolean = js.native
    def isDeclareModule(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareModule> */ Boolean = js.native
    
    def isDeclareModuleExports(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareModuleExports> */ Boolean = js.native
    def isDeclareModuleExports(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareModuleExports> */ Boolean = js.native
    
    def isDeclareOpaqueType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareOpaqueType> */ Boolean = js.native
    def isDeclareOpaqueType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareOpaqueType> */ Boolean = js.native
    
    def isDeclareTypeAlias(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareTypeAlias> */ Boolean = js.native
    def isDeclareTypeAlias(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareTypeAlias> */ Boolean = js.native
    
    def isDeclareVariable(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareVariable> */ Boolean = js.native
    def isDeclareVariable(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareVariable> */ Boolean = js.native
    
    def isDeclaredPredicate(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclaredPredicate> */ Boolean = js.native
    def isDeclaredPredicate(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclaredPredicate> */ Boolean = js.native
    
    def isDecorator(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Decorator> */ Boolean = js.native
    def isDecorator(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Decorator> */ Boolean = js.native
    
    /**
      * A helper to find if `this` path is a descendant of `maybeAncestor`
      */
    def isDescendant(maybeAncestor: NodePath[Node]): Boolean = js.native
    
    def isDirective(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Directive> */ Boolean = js.native
    def isDirective(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Directive> */ Boolean = js.native
    
    def isDirectiveLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DirectiveLiteral> */ Boolean = js.native
    def isDirectiveLiteral(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DirectiveLiteral> */ Boolean = js.native
    
    def isDoExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DoExpression> */ Boolean = js.native
    def isDoExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DoExpression> */ Boolean = js.native
    
    def isDoWhileStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DoWhileStatement> */ Boolean = js.native
    def isDoWhileStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DoWhileStatement> */ Boolean = js.native
    
    def isEmptyStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EmptyStatement> */ Boolean = js.native
    def isEmptyStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EmptyStatement> */ Boolean = js.native
    
    def isEmptyTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EmptyTypeAnnotation> */ Boolean = js.native
    def isEmptyTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EmptyTypeAnnotation> */ Boolean = js.native
    
    def isExistsTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExistsTypeAnnotation> */ Boolean = js.native
    def isExistsTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExistsTypeAnnotation> */ Boolean = js.native
    
    def isExportAllDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportAllDeclaration> */ Boolean = js.native
    def isExportAllDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportAllDeclaration> */ Boolean = js.native
    
    def isExportDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportDeclaration> */ Boolean = js.native
    def isExportDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportDeclaration> */ Boolean = js.native
    
    def isExportDefaultDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportDefaultDeclaration> */ Boolean = js.native
    def isExportDefaultDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportDefaultDeclaration> */ Boolean = js.native
    
    def isExportDefaultSpecifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportDefaultSpecifier> */ Boolean = js.native
    def isExportDefaultSpecifier(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportDefaultSpecifier> */ Boolean = js.native
    
    def isExportNamedDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportNamedDeclaration> */ Boolean = js.native
    def isExportNamedDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportNamedDeclaration> */ Boolean = js.native
    
    def isExportNamespaceSpecifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportNamespaceSpecifier> */ Boolean = js.native
    def isExportNamespaceSpecifier(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportNamespaceSpecifier> */ Boolean = js.native
    
    def isExportSpecifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportSpecifier> */ Boolean = js.native
    def isExportSpecifier(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportSpecifier> */ Boolean = js.native
    
    def isExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Expression> */ Boolean = js.native
    def isExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Expression> */ Boolean = js.native
    
    def isExpressionStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExpressionStatement> */ Boolean = js.native
    def isExpressionStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExpressionStatement> */ Boolean = js.native
    
    def isExpressionWrapper(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExpressionWrapper> */ Boolean = js.native
    def isExpressionWrapper(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExpressionWrapper> */ Boolean = js.native
    
    def isFile(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.File> */ Boolean = js.native
    def isFile(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.File> */ Boolean = js.native
    
    def isFlow(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Flow> */ Boolean = js.native
    def isFlow(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Flow> */ Boolean = js.native
    
    def isFlowBaseAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FlowBaseAnnotation> */ Boolean = js.native
    def isFlowBaseAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FlowBaseAnnotation> */ Boolean = js.native
    
    def isFlowDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FlowDeclaration> */ Boolean = js.native
    def isFlowDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FlowDeclaration> */ Boolean = js.native
    
    def isFlowPredicate(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FlowPredicate> */ Boolean = js.native
    def isFlowPredicate(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FlowPredicate> */ Boolean = js.native
    
    def isFlowType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FlowType> */ Boolean = js.native
    def isFlowType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FlowType> */ Boolean = js.native
    
    def isFor(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.For> */ Boolean = js.native
    def isFor(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.For> */ Boolean = js.native
    
    def isForInStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ForInStatement> */ Boolean = js.native
    def isForInStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ForInStatement> */ Boolean = js.native
    
    def isForOfStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ForOfStatement> */ Boolean = js.native
    def isForOfStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ForOfStatement> */ Boolean = js.native
    
    def isForStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ForStatement> */ Boolean = js.native
    def isForStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ForStatement> */ Boolean = js.native
    
    def isForXStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ForXStatement> */ Boolean = js.native
    def isForXStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ForXStatement> */ Boolean = js.native
    
    def isFunction(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Function> */ Boolean = js.native
    def isFunction(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Function> */ Boolean = js.native
    
    def isFunctionDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionDeclaration> */ Boolean = js.native
    def isFunctionDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionDeclaration> */ Boolean = js.native
    
    def isFunctionExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionExpression> */ Boolean = js.native
    def isFunctionExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionExpression> */ Boolean = js.native
    
    def isFunctionParent(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionParent> */ Boolean = js.native
    def isFunctionParent(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionParent> */ Boolean = js.native
    
    def isFunctionTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionTypeAnnotation> */ Boolean = js.native
    def isFunctionTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionTypeAnnotation> */ Boolean = js.native
    
    def isFunctionTypeParam(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionTypeParam> */ Boolean = js.native
    def isFunctionTypeParam(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionTypeParam> */ Boolean = js.native
    
    def isGenerated(): Boolean = js.native
    def isGenerated(props: js.Object): Boolean = js.native
    
    def isGenericType(genericName: String): Boolean = js.native
    
    def isGenericTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.GenericTypeAnnotation> */ Boolean = js.native
    def isGenericTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.GenericTypeAnnotation> */ Boolean = js.native
    
    def isIdentifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Identifier> */ Boolean = js.native
    def isIdentifier(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Identifier> */ Boolean = js.native
    
    def isIfStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.IfStatement> */ Boolean = js.native
    def isIfStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.IfStatement> */ Boolean = js.native
    
    def isImmutable(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Immutable> */ Boolean = js.native
    def isImmutable(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Immutable> */ Boolean = js.native
    
    def isImport(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Import> */ Boolean = js.native
    def isImport(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Import> */ Boolean = js.native
    
    def isImportDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ImportDeclaration> */ Boolean = js.native
    def isImportDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ImportDeclaration> */ Boolean = js.native
    
    def isImportDefaultSpecifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ImportDefaultSpecifier> */ Boolean = js.native
    def isImportDefaultSpecifier(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ImportDefaultSpecifier> */ Boolean = js.native
    
    def isImportNamespaceSpecifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ImportNamespaceSpecifier> */ Boolean = js.native
    def isImportNamespaceSpecifier(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ImportNamespaceSpecifier> */ Boolean = js.native
    
    def isImportSpecifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ImportSpecifier> */ Boolean = js.native
    def isImportSpecifier(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ImportSpecifier> */ Boolean = js.native
    
    def isInferredPredicate(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InferredPredicate> */ Boolean = js.native
    def isInferredPredicate(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InferredPredicate> */ Boolean = js.native
    
    def isInterfaceDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InterfaceDeclaration> */ Boolean = js.native
    def isInterfaceDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InterfaceDeclaration> */ Boolean = js.native
    
    def isInterfaceExtends(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InterfaceExtends> */ Boolean = js.native
    def isInterfaceExtends(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InterfaceExtends> */ Boolean = js.native
    
    def isInterfaceTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InterfaceTypeAnnotation> */ Boolean = js.native
    def isInterfaceTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InterfaceTypeAnnotation> */ Boolean = js.native
    
    def isInterpreterDirective(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InterpreterDirective> */ Boolean = js.native
    def isInterpreterDirective(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InterpreterDirective> */ Boolean = js.native
    
    def isIntersectionTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.IntersectionTypeAnnotation> */ Boolean = js.native
    def isIntersectionTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.IntersectionTypeAnnotation> */ Boolean = js.native
    
    def isJSX(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSX> */ Boolean = js.native
    def isJSX(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSX> */ Boolean = js.native
    
    def isJSXAttribute(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXAttribute> */ Boolean = js.native
    def isJSXAttribute(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXAttribute> */ Boolean = js.native
    
    def isJSXClosingElement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXClosingElement> */ Boolean = js.native
    def isJSXClosingElement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXClosingElement> */ Boolean = js.native
    
    def isJSXClosingFragment(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXClosingFragment> */ Boolean = js.native
    def isJSXClosingFragment(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXClosingFragment> */ Boolean = js.native
    
    def isJSXElement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXElement> */ Boolean = js.native
    def isJSXElement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXElement> */ Boolean = js.native
    
    def isJSXEmptyExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXEmptyExpression> */ Boolean = js.native
    def isJSXEmptyExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXEmptyExpression> */ Boolean = js.native
    
    def isJSXExpressionContainer(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXExpressionContainer> */ Boolean = js.native
    def isJSXExpressionContainer(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXExpressionContainer> */ Boolean = js.native
    
    def isJSXFragment(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXFragment> */ Boolean = js.native
    def isJSXFragment(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXFragment> */ Boolean = js.native
    
    def isJSXIdentifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXIdentifier> */ Boolean = js.native
    def isJSXIdentifier(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXIdentifier> */ Boolean = js.native
    
    def isJSXMemberExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXMemberExpression> */ Boolean = js.native
    def isJSXMemberExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXMemberExpression> */ Boolean = js.native
    
    def isJSXNamespacedName(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXNamespacedName> */ Boolean = js.native
    def isJSXNamespacedName(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXNamespacedName> */ Boolean = js.native
    
    def isJSXOpeningElement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXOpeningElement> */ Boolean = js.native
    def isJSXOpeningElement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXOpeningElement> */ Boolean = js.native
    
    def isJSXOpeningFragment(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXOpeningFragment> */ Boolean = js.native
    def isJSXOpeningFragment(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXOpeningFragment> */ Boolean = js.native
    
    def isJSXSpreadAttribute(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXSpreadAttribute> */ Boolean = js.native
    def isJSXSpreadAttribute(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXSpreadAttribute> */ Boolean = js.native
    
    def isJSXSpreadChild(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXSpreadChild> */ Boolean = js.native
    def isJSXSpreadChild(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXSpreadChild> */ Boolean = js.native
    
    def isJSXText(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXText> */ Boolean = js.native
    def isJSXText(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXText> */ Boolean = js.native
    
    def isLVal(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.LVal> */ Boolean = js.native
    def isLVal(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.LVal> */ Boolean = js.native
    
    def isLabeledStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.LabeledStatement> */ Boolean = js.native
    def isLabeledStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.LabeledStatement> */ Boolean = js.native
    
    def isLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Literal> */ Boolean = js.native
    def isLiteral(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Literal> */ Boolean = js.native
    
    def isLogicalExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.LogicalExpression> */ Boolean = js.native
    def isLogicalExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.LogicalExpression> */ Boolean = js.native
    
    def isLoop(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Loop> */ Boolean = js.native
    def isLoop(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Loop> */ Boolean = js.native
    
    def isMemberExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.MemberExpression> */ Boolean = js.native
    def isMemberExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.MemberExpression> */ Boolean = js.native
    
    def isMetaProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.MetaProperty> */ Boolean = js.native
    def isMetaProperty(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.MetaProperty> */ Boolean = js.native
    
    def isMethod(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Method> */ Boolean = js.native
    def isMethod(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Method> */ Boolean = js.native
    
    def isMixedTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.MixedTypeAnnotation> */ Boolean = js.native
    def isMixedTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.MixedTypeAnnotation> */ Boolean = js.native
    
    def isModuleDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ModuleDeclaration> */ Boolean = js.native
    def isModuleDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ModuleDeclaration> */ Boolean = js.native
    
    def isModuleSpecifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ModuleSpecifier> */ Boolean = js.native
    def isModuleSpecifier(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ModuleSpecifier> */ Boolean = js.native
    
    def isNewExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NewExpression> */ Boolean = js.native
    def isNewExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NewExpression> */ Boolean = js.native
    
    /**
      * Check the type against our stored internal type of the node. This is handy when a node has
      * been removed yet we still internally know the type and need it to calculate node replacement.
      */
    def isNodeType(`type`: String): Boolean = js.native
    
    def isNoop(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Noop> */ Boolean = js.native
    def isNoop(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Noop> */ Boolean = js.native
    
    def isNullLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NullLiteral> */ Boolean = js.native
    def isNullLiteral(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NullLiteral> */ Boolean = js.native
    
    def isNullLiteralTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NullLiteralTypeAnnotation> */ Boolean = js.native
    def isNullLiteralTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NullLiteralTypeAnnotation> */ Boolean = js.native
    
    def isNullableTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NullableTypeAnnotation> */ Boolean = js.native
    def isNullableTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NullableTypeAnnotation> */ Boolean = js.native
    
    /** @deprecated Use `isNumericLiteral` */
    def isNumberLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NumericLiteral> */ Boolean = js.native
    def isNumberLiteral(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NumericLiteral> */ Boolean = js.native
    
    def isNumberLiteralTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NumberLiteralTypeAnnotation> */ Boolean = js.native
    def isNumberLiteralTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NumberLiteralTypeAnnotation> */ Boolean = js.native
    
    def isNumberTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NumberTypeAnnotation> */ Boolean = js.native
    def isNumberTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NumberTypeAnnotation> */ Boolean = js.native
    
    def isNumericLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NumericLiteral> */ Boolean = js.native
    def isNumericLiteral(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NumericLiteral> */ Boolean = js.native
    
    def isObjectExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectExpression> */ Boolean = js.native
    def isObjectExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectExpression> */ Boolean = js.native
    
    def isObjectMember(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectMember> */ Boolean = js.native
    def isObjectMember(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectMember> */ Boolean = js.native
    
    def isObjectMethod(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectMethod> */ Boolean = js.native
    def isObjectMethod(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectMethod> */ Boolean = js.native
    
    def isObjectPattern(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectPattern> */ Boolean = js.native
    def isObjectPattern(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectPattern> */ Boolean = js.native
    
    def isObjectProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectProperty> */ Boolean = js.native
    def isObjectProperty(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectProperty> */ Boolean = js.native
    
    def isObjectTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeAnnotation> */ Boolean = js.native
    def isObjectTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeAnnotation> */ Boolean = js.native
    
    def isObjectTypeCallProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeCallProperty> */ Boolean = js.native
    def isObjectTypeCallProperty(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeCallProperty> */ Boolean = js.native
    
    def isObjectTypeIndexer(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeIndexer> */ Boolean = js.native
    def isObjectTypeIndexer(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeIndexer> */ Boolean = js.native
    
    def isObjectTypeInternalSlot(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeInternalSlot> */ Boolean = js.native
    def isObjectTypeInternalSlot(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeInternalSlot> */ Boolean = js.native
    
    def isObjectTypeProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeProperty> */ Boolean = js.native
    def isObjectTypeProperty(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeProperty> */ Boolean = js.native
    
    def isObjectTypeSpreadProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeSpreadProperty> */ Boolean = js.native
    def isObjectTypeSpreadProperty(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeSpreadProperty> */ Boolean = js.native
    
    def isOpaqueType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.OpaqueType> */ Boolean = js.native
    def isOpaqueType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.OpaqueType> */ Boolean = js.native
    
    def isOptionalCallExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.OptionalCallExpression> */ Boolean = js.native
    def isOptionalCallExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.OptionalCallExpression> */ Boolean = js.native
    
    def isOptionalMemberExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.OptionalMemberExpression> */ Boolean = js.native
    def isOptionalMemberExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.OptionalMemberExpression> */ Boolean = js.native
    
    def isParenthesizedExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ParenthesizedExpression> */ Boolean = js.native
    def isParenthesizedExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ParenthesizedExpression> */ Boolean = js.native
    
    def isPattern(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Pattern> */ Boolean = js.native
    def isPattern(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Pattern> */ Boolean = js.native
    
    def isPatternLike(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PatternLike> */ Boolean = js.native
    def isPatternLike(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PatternLike> */ Boolean = js.native
    
    def isPipelineBareFunction(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PipelineBareFunction> */ Boolean = js.native
    def isPipelineBareFunction(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PipelineBareFunction> */ Boolean = js.native
    
    def isPipelinePrimaryTopicReference(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PipelinePrimaryTopicReference> */ Boolean = js.native
    def isPipelinePrimaryTopicReference(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PipelinePrimaryTopicReference> */ Boolean = js.native
    
    def isPipelineTopicExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PipelineTopicExpression> */ Boolean = js.native
    def isPipelineTopicExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PipelineTopicExpression> */ Boolean = js.native
    
    def isPrivate(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Private> */ Boolean = js.native
    def isPrivate(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Private> */ Boolean = js.native
    
    def isPrivateName(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PrivateName> */ Boolean = js.native
    def isPrivateName(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PrivateName> */ Boolean = js.native
    
    def isProgram(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Program> */ Boolean = js.native
    def isProgram(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Program> */ Boolean = js.native
    
    def isProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Property> */ Boolean = js.native
    def isProperty(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Property> */ Boolean = js.native
    
    def isPure(): Boolean = js.native
    def isPure(props: js.Object): Boolean = js.native
    
    def isPureish(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Pureish> */ Boolean = js.native
    def isPureish(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Pureish> */ Boolean = js.native
    
    def isQualifiedTypeIdentifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.QualifiedTypeIdentifier> */ Boolean = js.native
    def isQualifiedTypeIdentifier(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.QualifiedTypeIdentifier> */ Boolean = js.native
    
    def isReferenced(): Boolean = js.native
    def isReferenced(props: js.Object): Boolean = js.native
    
    def isReferencedIdentifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Identifier | @babel/types.@babel/types.JSXIdentifier> */ Boolean = js.native
    def isReferencedIdentifier(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Identifier | @babel/types.@babel/types.JSXIdentifier> */ Boolean = js.native
    
    def isReferencedMemberExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.MemberExpression> */ Boolean = js.native
    def isReferencedMemberExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.MemberExpression> */ Boolean = js.native
    
    def isRegExpLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.RegExpLiteral> */ Boolean = js.native
    def isRegExpLiteral(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.RegExpLiteral> */ Boolean = js.native
    
    /** @deprecated Use `isRegExpLiteral` */
    def isRegexLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.RegExpLiteral> */ Boolean = js.native
    def isRegexLiteral(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.RegExpLiteral> */ Boolean = js.native
    
    def isRestElement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.RestElement> */ Boolean = js.native
    def isRestElement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.RestElement> */ Boolean = js.native
    
    /** @deprecated Use `isRestElement` */
    def isRestProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.RestElement> */ Boolean = js.native
    def isRestProperty(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.RestElement> */ Boolean = js.native
    
    def isReturnStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ReturnStatement> */ Boolean = js.native
    def isReturnStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ReturnStatement> */ Boolean = js.native
    
    def isScopable(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Scopable> */ Boolean = js.native
    def isScopable(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Scopable> */ Boolean = js.native
    
    def isScope(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Scopable> */ Boolean = js.native
    def isScope(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Scopable> */ Boolean = js.native
    
    def isSequenceExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SequenceExpression> */ Boolean = js.native
    def isSequenceExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SequenceExpression> */ Boolean = js.native
    
    def isSpreadElement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SpreadElement> */ Boolean = js.native
    def isSpreadElement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SpreadElement> */ Boolean = js.native
    
    /** @deprecated Use `isSpreadElement` */
    def isSpreadProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SpreadElement> */ Boolean = js.native
    def isSpreadProperty(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SpreadElement> */ Boolean = js.native
    
    def isStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Statement> */ Boolean = js.native
    def isStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Statement> */ Boolean = js.native
    
    /**
      * Check whether or not the current `key` allows either a single statement or block statement
      * so we can explode it if necessary.
      */
    def isStatementOrBlock(): Boolean = js.native
    
    def isStatic(): Boolean = js.native
    
    def isStringLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.StringLiteral> */ Boolean = js.native
    def isStringLiteral(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.StringLiteral> */ Boolean = js.native
    
    def isStringLiteralTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.StringLiteralTypeAnnotation> */ Boolean = js.native
    def isStringLiteralTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.StringLiteralTypeAnnotation> */ Boolean = js.native
    
    def isStringTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.StringTypeAnnotation> */ Boolean = js.native
    def isStringTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.StringTypeAnnotation> */ Boolean = js.native
    
    def isSuper(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Super> */ Boolean = js.native
    def isSuper(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Super> */ Boolean = js.native
    
    def isSwitchCase(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SwitchCase> */ Boolean = js.native
    def isSwitchCase(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SwitchCase> */ Boolean = js.native
    
    def isSwitchStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SwitchStatement> */ Boolean = js.native
    def isSwitchStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SwitchStatement> */ Boolean = js.native
    
    def isTSAnyKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSAnyKeyword> */ Boolean = js.native
    def isTSAnyKeyword(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSAnyKeyword> */ Boolean = js.native
    
    def isTSArrayType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSArrayType> */ Boolean = js.native
    def isTSArrayType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSArrayType> */ Boolean = js.native
    
    def isTSAsExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSAsExpression> */ Boolean = js.native
    def isTSAsExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSAsExpression> */ Boolean = js.native
    
    def isTSBooleanKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSBooleanKeyword> */ Boolean = js.native
    def isTSBooleanKeyword(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSBooleanKeyword> */ Boolean = js.native
    
    def isTSCallSignatureDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSCallSignatureDeclaration> */ Boolean = js.native
    def isTSCallSignatureDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSCallSignatureDeclaration> */ Boolean = js.native
    
    def isTSConditionalType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSConditionalType> */ Boolean = js.native
    def isTSConditionalType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSConditionalType> */ Boolean = js.native
    
    def isTSConstructSignatureDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSConstructSignatureDeclaration> */ Boolean = js.native
    def isTSConstructSignatureDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSConstructSignatureDeclaration> */ Boolean = js.native
    
    def isTSConstructorType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSConstructorType> */ Boolean = js.native
    def isTSConstructorType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSConstructorType> */ Boolean = js.native
    
    def isTSDeclareFunction(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSDeclareFunction> */ Boolean = js.native
    def isTSDeclareFunction(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSDeclareFunction> */ Boolean = js.native
    
    def isTSDeclareMethod(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSDeclareMethod> */ Boolean = js.native
    def isTSDeclareMethod(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSDeclareMethod> */ Boolean = js.native
    
    def isTSEntityName(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSEntityName> */ Boolean = js.native
    def isTSEntityName(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSEntityName> */ Boolean = js.native
    
    def isTSEnumDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSEnumDeclaration> */ Boolean = js.native
    def isTSEnumDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSEnumDeclaration> */ Boolean = js.native
    
    def isTSEnumMember(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSEnumMember> */ Boolean = js.native
    def isTSEnumMember(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSEnumMember> */ Boolean = js.native
    
    def isTSExportAssignment(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSExportAssignment> */ Boolean = js.native
    def isTSExportAssignment(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSExportAssignment> */ Boolean = js.native
    
    def isTSExpressionWithTypeArguments(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSExpressionWithTypeArguments> */ Boolean = js.native
    def isTSExpressionWithTypeArguments(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSExpressionWithTypeArguments> */ Boolean = js.native
    
    def isTSExternalModuleReference(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSExternalModuleReference> */ Boolean = js.native
    def isTSExternalModuleReference(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSExternalModuleReference> */ Boolean = js.native
    
    def isTSFunctionType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSFunctionType> */ Boolean = js.native
    def isTSFunctionType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSFunctionType> */ Boolean = js.native
    
    def isTSImportEqualsDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSImportEqualsDeclaration> */ Boolean = js.native
    def isTSImportEqualsDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSImportEqualsDeclaration> */ Boolean = js.native
    
    def isTSImportType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSImportType> */ Boolean = js.native
    def isTSImportType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSImportType> */ Boolean = js.native
    
    def isTSIndexSignature(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSIndexSignature> */ Boolean = js.native
    def isTSIndexSignature(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSIndexSignature> */ Boolean = js.native
    
    def isTSIndexedAccessType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSIndexedAccessType> */ Boolean = js.native
    def isTSIndexedAccessType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSIndexedAccessType> */ Boolean = js.native
    
    def isTSInferType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSInferType> */ Boolean = js.native
    def isTSInferType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSInferType> */ Boolean = js.native
    
    def isTSInterfaceBody(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSInterfaceBody> */ Boolean = js.native
    def isTSInterfaceBody(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSInterfaceBody> */ Boolean = js.native
    
    def isTSInterfaceDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSInterfaceDeclaration> */ Boolean = js.native
    def isTSInterfaceDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSInterfaceDeclaration> */ Boolean = js.native
    
    def isTSIntersectionType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSIntersectionType> */ Boolean = js.native
    def isTSIntersectionType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSIntersectionType> */ Boolean = js.native
    
    def isTSLiteralType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSLiteralType> */ Boolean = js.native
    def isTSLiteralType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSLiteralType> */ Boolean = js.native
    
    def isTSMappedType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSMappedType> */ Boolean = js.native
    def isTSMappedType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSMappedType> */ Boolean = js.native
    
    def isTSMethodSignature(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSMethodSignature> */ Boolean = js.native
    def isTSMethodSignature(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSMethodSignature> */ Boolean = js.native
    
    def isTSModuleBlock(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSModuleBlock> */ Boolean = js.native
    def isTSModuleBlock(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSModuleBlock> */ Boolean = js.native
    
    def isTSModuleDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSModuleDeclaration> */ Boolean = js.native
    def isTSModuleDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSModuleDeclaration> */ Boolean = js.native
    
    def isTSNamespaceExportDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNamespaceExportDeclaration> */ Boolean = js.native
    def isTSNamespaceExportDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNamespaceExportDeclaration> */ Boolean = js.native
    
    def isTSNeverKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNeverKeyword> */ Boolean = js.native
    def isTSNeverKeyword(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNeverKeyword> */ Boolean = js.native
    
    def isTSNonNullExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNonNullExpression> */ Boolean = js.native
    def isTSNonNullExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNonNullExpression> */ Boolean = js.native
    
    def isTSNullKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNullKeyword> */ Boolean = js.native
    def isTSNullKeyword(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNullKeyword> */ Boolean = js.native
    
    def isTSNumberKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNumberKeyword> */ Boolean = js.native
    def isTSNumberKeyword(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNumberKeyword> */ Boolean = js.native
    
    def isTSObjectKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSObjectKeyword> */ Boolean = js.native
    def isTSObjectKeyword(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSObjectKeyword> */ Boolean = js.native
    
    def isTSOptionalType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSOptionalType> */ Boolean = js.native
    def isTSOptionalType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSOptionalType> */ Boolean = js.native
    
    def isTSParameterProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSParameterProperty> */ Boolean = js.native
    def isTSParameterProperty(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSParameterProperty> */ Boolean = js.native
    
    def isTSParenthesizedType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSParenthesizedType> */ Boolean = js.native
    def isTSParenthesizedType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSParenthesizedType> */ Boolean = js.native
    
    def isTSPropertySignature(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSPropertySignature> */ Boolean = js.native
    def isTSPropertySignature(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSPropertySignature> */ Boolean = js.native
    
    def isTSQualifiedName(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSQualifiedName> */ Boolean = js.native
    def isTSQualifiedName(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSQualifiedName> */ Boolean = js.native
    
    def isTSRestType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSRestType> */ Boolean = js.native
    def isTSRestType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSRestType> */ Boolean = js.native
    
    def isTSStringKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSStringKeyword> */ Boolean = js.native
    def isTSStringKeyword(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSStringKeyword> */ Boolean = js.native
    
    def isTSSymbolKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSSymbolKeyword> */ Boolean = js.native
    def isTSSymbolKeyword(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSSymbolKeyword> */ Boolean = js.native
    
    def isTSThisType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSThisType> */ Boolean = js.native
    def isTSThisType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSThisType> */ Boolean = js.native
    
    def isTSTupleType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTupleType> */ Boolean = js.native
    def isTSTupleType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTupleType> */ Boolean = js.native
    
    def isTSType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSType> */ Boolean = js.native
    def isTSType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSType> */ Boolean = js.native
    
    def isTSTypeAliasDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeAliasDeclaration> */ Boolean = js.native
    def isTSTypeAliasDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeAliasDeclaration> */ Boolean = js.native
    
    def isTSTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeAnnotation> */ Boolean = js.native
    def isTSTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeAnnotation> */ Boolean = js.native
    
    def isTSTypeAssertion(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeAssertion> */ Boolean = js.native
    def isTSTypeAssertion(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeAssertion> */ Boolean = js.native
    
    def isTSTypeElement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeElement> */ Boolean = js.native
    def isTSTypeElement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeElement> */ Boolean = js.native
    
    def isTSTypeLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeLiteral> */ Boolean = js.native
    def isTSTypeLiteral(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeLiteral> */ Boolean = js.native
    
    def isTSTypeOperator(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeOperator> */ Boolean = js.native
    def isTSTypeOperator(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeOperator> */ Boolean = js.native
    
    def isTSTypeParameter(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeParameter> */ Boolean = js.native
    def isTSTypeParameter(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeParameter> */ Boolean = js.native
    
    def isTSTypeParameterDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeParameterDeclaration> */ Boolean = js.native
    def isTSTypeParameterDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeParameterDeclaration> */ Boolean = js.native
    
    def isTSTypeParameterInstantiation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeParameterInstantiation> */ Boolean = js.native
    def isTSTypeParameterInstantiation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeParameterInstantiation> */ Boolean = js.native
    
    def isTSTypePredicate(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypePredicate> */ Boolean = js.native
    def isTSTypePredicate(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypePredicate> */ Boolean = js.native
    
    def isTSTypeQuery(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeQuery> */ Boolean = js.native
    def isTSTypeQuery(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeQuery> */ Boolean = js.native
    
    def isTSTypeReference(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeReference> */ Boolean = js.native
    def isTSTypeReference(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeReference> */ Boolean = js.native
    
    def isTSUndefinedKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSUndefinedKeyword> */ Boolean = js.native
    def isTSUndefinedKeyword(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSUndefinedKeyword> */ Boolean = js.native
    
    def isTSUnionType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSUnionType> */ Boolean = js.native
    def isTSUnionType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSUnionType> */ Boolean = js.native
    
    def isTSUnknownKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSUnknownKeyword> */ Boolean = js.native
    def isTSUnknownKeyword(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSUnknownKeyword> */ Boolean = js.native
    
    def isTSVoidKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSVoidKeyword> */ Boolean = js.native
    def isTSVoidKeyword(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSVoidKeyword> */ Boolean = js.native
    
    def isTaggedTemplateExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TaggedTemplateExpression> */ Boolean = js.native
    def isTaggedTemplateExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TaggedTemplateExpression> */ Boolean = js.native
    
    def isTemplateElement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TemplateElement> */ Boolean = js.native
    def isTemplateElement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TemplateElement> */ Boolean = js.native
    
    def isTemplateLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TemplateLiteral> */ Boolean = js.native
    def isTemplateLiteral(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TemplateLiteral> */ Boolean = js.native
    
    def isTerminatorless(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Terminatorless> */ Boolean = js.native
    def isTerminatorless(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Terminatorless> */ Boolean = js.native
    
    def isThisExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ThisExpression> */ Boolean = js.native
    def isThisExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ThisExpression> */ Boolean = js.native
    
    def isThisTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ThisTypeAnnotation> */ Boolean = js.native
    def isThisTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ThisTypeAnnotation> */ Boolean = js.native
    
    def isThrowStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ThrowStatement> */ Boolean = js.native
    def isThrowStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ThrowStatement> */ Boolean = js.native
    
    def isTryStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TryStatement> */ Boolean = js.native
    def isTryStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TryStatement> */ Boolean = js.native
    
    def isTupleTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TupleTypeAnnotation> */ Boolean = js.native
    def isTupleTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TupleTypeAnnotation> */ Boolean = js.native
    
    def isTypeAlias(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeAlias> */ Boolean = js.native
    def isTypeAlias(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeAlias> */ Boolean = js.native
    
    def isTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeAnnotation> */ Boolean = js.native
    def isTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeAnnotation> */ Boolean = js.native
    
    def isTypeCastExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeCastExpression> */ Boolean = js.native
    def isTypeCastExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeCastExpression> */ Boolean = js.native
    
    def isTypeParameter(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeParameter> */ Boolean = js.native
    def isTypeParameter(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeParameter> */ Boolean = js.native
    
    def isTypeParameterDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeParameterDeclaration> */ Boolean = js.native
    def isTypeParameterDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeParameterDeclaration> */ Boolean = js.native
    
    def isTypeParameterInstantiation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeParameterInstantiation> */ Boolean = js.native
    def isTypeParameterInstantiation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeParameterInstantiation> */ Boolean = js.native
    
    def isTypeofTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeofTypeAnnotation> */ Boolean = js.native
    def isTypeofTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeofTypeAnnotation> */ Boolean = js.native
    
    def isUnaryExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UnaryExpression> */ Boolean = js.native
    def isUnaryExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UnaryExpression> */ Boolean = js.native
    
    def isUnaryLike(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UnaryLike> */ Boolean = js.native
    def isUnaryLike(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UnaryLike> */ Boolean = js.native
    
    def isUnionTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UnionTypeAnnotation> */ Boolean = js.native
    def isUnionTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UnionTypeAnnotation> */ Boolean = js.native
    
    def isUpdateExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UpdateExpression> */ Boolean = js.native
    def isUpdateExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UpdateExpression> */ Boolean = js.native
    
    def isUser(): Boolean = js.native
    def isUser(props: js.Object): Boolean = js.native
    
    def isUserWhitespacable(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UserWhitespacable> */ Boolean = js.native
    def isUserWhitespacable(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UserWhitespacable> */ Boolean = js.native
    
    def isVar(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.VariableDeclaration> */ Boolean = js.native
    def isVar(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.VariableDeclaration> */ Boolean = js.native
    
    def isVariableDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.VariableDeclaration> */ Boolean = js.native
    def isVariableDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.VariableDeclaration> */ Boolean = js.native
    
    def isVariableDeclarator(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.VariableDeclarator> */ Boolean = js.native
    def isVariableDeclarator(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.VariableDeclarator> */ Boolean = js.native
    
    def isVariance(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Variance> */ Boolean = js.native
    def isVariance(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Variance> */ Boolean = js.native
    
    def isVoidTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.VoidTypeAnnotation> */ Boolean = js.native
    def isVoidTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.VoidTypeAnnotation> */ Boolean = js.native
    
    def isWhile(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.While> */ Boolean = js.native
    def isWhile(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.While> */ Boolean = js.native
    
    def isWhileStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.WhileStatement> */ Boolean = js.native
    def isWhileStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.WhileStatement> */ Boolean = js.native
    
    def isWithStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.WithStatement> */ Boolean = js.native
    def isWithStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.WithStatement> */ Boolean = js.native
    
    def isYieldExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.YieldExpression> */ Boolean = js.native
    def isYieldExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.YieldExpression> */ Boolean = js.native
    
    /** Opposite of `has`. */
    def isnt(key: String): Boolean = js.native
    
    var key: String | Double = js.native
    
    var listKey: String = js.native
    
    //#endregion
    //#region ------------------------- introspection -------------------------
    /**
      * Match the current node if it matches the provided `pattern`.
      *
      * For example, given the match `React.createClass` it would match the
      * parsed nodes of `React.createClass` and `React["createClass"]`.
      */
    def matchesPattern(pattern: String): Boolean = js.native
    def matchesPattern(pattern: String, allowPartial: Boolean): Boolean = js.native
    
    var node: T = js.native
    
    var opts: js.Object = js.native
    
    var parent: Node = js.native
    
    var parentKey: String = js.native
    
    var parentPath: /* import warning: importer.ImportType#apply Failed type conversion: T extends @babel/types.@babel/types.Program ? null : @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Node> */ js.Any = js.native
    
    def popContext(): Unit = js.native
    
    /**
      * Insert child nodes at the end of the current node.
      * @param listKey - The key at which the child nodes are stored (usually body).
      * @param nodes - the nodes to insert.
      */
    def pushContainer[Nodes /* <: Node | js.Array[Node] */](listKey: ArrayKeys[T], nodes: Nodes): NodePaths[Nodes] = js.native
    
    def pushContext(context: TraversalContext): Unit = js.native
    
    /** Check if the currently assigned path references the `importName` of `moduleSource`. */
    def referencesImport(moduleSource: String, importName: String): Boolean = js.native
    
    //#endregion
    //#region ------------------------- removal -------------------------
    def remove(): Unit = js.native
    
    var removed: Boolean = js.native
    
    /**
      * This method takes an array of statements nodes and then explodes it
      * into expressions. This method retains completion records which is
      * extremely important to retain original semantics.
      */
    def replaceExpressionWithStatements[Nodes /* <: js.Array[Node] */](nodes: Nodes): NodePaths[Nodes] = js.native
    
    def replaceInline[Nodes /* <: Node | js.Array[Node] */](nodes: Nodes): NodePaths[Nodes] = js.native
    
    /** Replace the current node with another. */
    def replaceWith[T /* <: Node */](replacement: T): js.Array[NodePath[T]] = js.native
    def replaceWith[T /* <: Node */](replacement: NodePath[T]): js.Array[NodePath[T]] = js.native
    
    //#endregion
    //#region ------------------------- replacement -------------------------
    /**
      * Replace a node with an array of multiple. This method performs the following steps:
      *
      *  - Inherit the comments of first provided node with that of the current node.
      *  - Insert the provided nodes after the current node.
      *  - Remove the current node.
      */
    def replaceWithMultiple[Nodes /* <: js.Array[Node] */](nodes: Nodes): NodePaths[Nodes] = js.native
    
    /**
      * Parse a string as an expression and replace the current node with the result.
      *
      * NOTE: This is typically not a good idea to use. Building source strings when
      * transforming ASTs is an antipattern and SHOULD NOT be encouraged. Even if it's
      * easier to use, your transforms will be extremely brittle.
      */
    def replaceWithSourceString(replacement: Any): js.Array[NodePath[Node]] = js.native
    
    var scope: Scope = js.native
    
    def set(key: String, node: Node): Unit = js.native
    
    def setContext(): this.type = js.native
    def setContext(context: TraversalContext): this.type = js.native
    
    def setData(key: String, `val`: Any): Any = js.native
    
    def setScope(): Unit = js.native
    
    //#endregion
    //#region ------------------------- comments -------------------------
    /** Share comments amongst siblings. */
    def shareCommentsWithSiblings(): Unit = js.native
    
    var shouldSkip: Boolean = js.native
    
    var shouldStop: Boolean = js.native
    
    def skip(): Unit = js.native
    
    def skipKey(key: String): Unit = js.native
    
    var skipKeys: js.Object = js.native
    
    var state: Any = js.native
    
    def stop(): Unit = js.native
    
    def traverse(visitor: Visitor[js.Object]): Unit = js.native
    def traverse[T](visitor: Visitor[T], state: T): Unit = js.native
    
    var `type`: /* import warning: importer.ImportType#apply Failed type conversion: T extends null | undefined ? undefined : T extends @babel/types.@babel/types.Node ? T['type'] : string | undefined */ js.Any = js.native
    
    var typeAnnotation: js.Object = js.native
    
    /**
      * Insert child nodes at the start of the current node.
      * @param listKey - The key at which the child nodes are stored (usually body).
      * @param nodes - the nodes to insert.
      */
    def unshiftContainer[Nodes /* <: Node | js.Array[Node] */](listKey: ArrayKeys[T], nodes: Nodes): NodePaths[Nodes] = js.native
    
    /** Update all sibling node paths after `fromIndex` by `incrementBy`. */
    def updateSiblingKeys(fromIndex: Double, incrementBy: Double): Unit = js.native
    
    def visit(): Boolean = js.native
    
    /** Check if the current path will maybe execute before another path */
    def willIMaybeExecuteBefore(path: NodePath[Node]): Boolean = js.native
  }
  /* static members */
  object NodePath {
    
    @JSImport("@babel/traverse", "NodePath")
    @js.native
    val ^ : js.Any = js.native
    
    inline def get[C /* <: Node */, K /* <: /* keyof C */ String */](opts: Container[C, K]): NodePath[
        /* import warning: importer.ImportType#apply Failed type conversion: C[K] */ js.Any
      ] = ^.asInstanceOf[js.Dynamic].applyDynamic("get")(opts.asInstanceOf[js.Any]).asInstanceOf[NodePath[
        /* import warning: importer.ImportType#apply Failed type conversion: C[K] */ js.Any
      ]]
  }
  
  @JSImport("@babel/traverse", "Scope")
  @js.native
  open class Scope protected () extends StObject {
    def this(path: NodePath[Node]) = this()
    def this(path: NodePath[Node], parentScope: Scope) = this()
    
    def addGlobal(node: Node): Unit = js.native
    
    def bindingIdentifierEquals(name: String, node: Node): Boolean = js.native
    
    var bindings: StringDictionary[Binding] = js.native
    
    var block: Node = js.native
    
    def buildUndefinedNode(): Node = js.native
    
    def checkBlockScopedCollisions(local: Binding, kind: BindingKind, name: String, id: js.Object): Unit = js.native
    
    def crawl(): Unit = js.native
    
    def dump(): Unit = js.native
    
    /** Generate a unique identifier and add it to the current scope. */
    def generateDeclaredUidIdentifier(): Identifier_ = js.native
    def generateDeclaredUidIdentifier(name: String): Identifier_ = js.native
    
    /** Generate a unique `_id1` binding. */
    def generateUid(): String = js.native
    def generateUid(name: String): String = js.native
    
    /** Generate a unique identifier. */
    def generateUidIdentifier(): Identifier_ = js.native
    def generateUidIdentifier(name: String): Identifier_ = js.native
    
    /** Generate a unique identifier based on a node. */
    def generateUidIdentifierBasedOnNode(parent: Node): Identifier_ = js.native
    def generateUidIdentifierBasedOnNode(parent: Node, defaultName: String): Identifier_ = js.native
    
    /** Walks the scope tree and gathers **all** bindings. */
    def getAllBindings(kinds: String*): js.Object = js.native
    
    def getBinding(name: String): js.UndefOr[Binding] = js.native
    
    def getBindingIdentifier(name: String): Identifier_ = js.native
    
    def getBlockParent(): Scope = js.native
    
    def getData(key: String): Any = js.native
    
    def getFunctionParent(): Scope | Null = js.native
    
    def getOwnBinding(name: String): js.UndefOr[Binding] = js.native
    
    def getOwnBindingIdentifier(name: String): Identifier_ = js.native
    
    def getProgramParent(): Scope = js.native
    
    def hasBinding(name: String): Boolean = js.native
    def hasBinding(name: String, noGlobals: Boolean): Boolean = js.native
    
    def hasGlobal(name: String): Boolean = js.native
    
    def hasOwnBinding(name: String): Boolean = js.native
    
    def hasReference(name: String): Boolean = js.native
    
    def hasUid(name: String): Boolean = js.native
    
    var hub: HubInterface = js.native
    
    def isPure(node: Node): Boolean = js.native
    def isPure(node: Node, constantsOnly: Boolean): Boolean = js.native
    
    /**
      * Determine whether evaluating the specific input `node` is a consequenceless reference. ie.
      * evaluating it wont result in potentially arbitrary code from being ran. The following are
      * whitelisted and determined not to cause side effects:
      *
      *  - `this` expressions
      *  - `super` expressions
      *  - Bound identifiers
      */
    def isStatic(node: Node): Boolean = js.native
    
    /** Possibly generate a memoised identifier if it is not static and has consequences. */
    def maybeGenerateMemoised(node: Node): Identifier_ = js.native
    def maybeGenerateMemoised(node: Node, dontPush: Boolean): Identifier_ = js.native
    
    /** Move a binding of `name` to another `scope`. */
    def moveBindingTo(name: String, scope: Scope): Unit = js.native
    
    var parent: Scope = js.native
    
    var parentBlock: Node = js.native
    
    def parentHasBinding(name: String): Boolean = js.native
    def parentHasBinding(name: String, noGlobals: Boolean): Boolean = js.native
    
    var path: NodePath[Node] = js.native
    
    def push(opts: Id): Unit = js.native
    
    def registerBinding(kind: String, path: NodePath[Node]): Unit = js.native
    def registerBinding(kind: String, path: NodePath[Node], bindingPath: NodePath[Node]): Unit = js.native
    
    def registerConstantViolation(path: NodePath[Node]): Unit = js.native
    
    def registerDeclaration(path: NodePath[Node]): Unit = js.native
    
    def removeBinding(name: String): Unit = js.native
    
    def removeData(key: String): Unit = js.native
    
    def removeOwnBinding(name: String): Unit = js.native
    
    def rename(oldName: String): Unit = js.native
    def rename(oldName: String, newName: String): Unit = js.native
    def rename(oldName: String, newName: String, block: Node): Unit = js.native
    def rename(oldName: String, newName: Unit, block: Node): Unit = js.native
    
    def setData(key: String, `val`: Any): Any = js.native
    
    def toArray(node: Node): Node = js.native
    def toArray(node: Node, i: Double): Node = js.native
    
    def traverse(node: js.Array[Node]): Unit = js.native
    def traverse(node: js.Array[Node], opts: Unit, state: Any): Unit = js.native
    def traverse(node: js.Array[Node], opts: TraverseOptions[Node]): Unit = js.native
    def traverse(node: js.Array[Node], opts: TraverseOptions[Node], state: Any): Unit = js.native
    def traverse(node: Node): Unit = js.native
    def traverse(node: Node, opts: Unit, state: Any): Unit = js.native
    def traverse(node: Node, opts: TraverseOptions[Node]): Unit = js.native
    def traverse(node: Node, opts: TraverseOptions[Node], state: Any): Unit = js.native
    @JSName("traverse")
    def traverse_S[S](node: js.Array[Node], opts: TraverseOptions[S], state: S): Unit = js.native
    /** Traverse node with current scope and path. */
    @JSName("traverse")
    def traverse_S[S](node: Node, opts: TraverseOptions[S], state: S): Unit = js.native
  }
  
  object visitors {
    
    @JSImport("@babel/traverse", "visitors")
    @js.native
    val ^ : js.Any = js.native
    
    /**
      * `explode()` will take a `Visitor` object with all of the various shorthands
      * that we support, and validates & normalizes it into a common format, ready
      * to be used in traversal.
      *
      * The various shorthands are:
      * - `Identifier() { ... }` -> `Identifier: { enter() { ... } }`
      * - `"Identifier|NumericLiteral": { ... }` -> `Identifier: { ... }, NumericLiteral: { ... }`
      * - Aliases in `@babel/types`: e.g. `Property: { ... }` -> `ObjectProperty: { ... }, ClassProperty: { ... }`
      *
      * Other normalizations are:
      * - Visitors of virtual types are wrapped, so that they are only visited when their dynamic check passes
      * - `enter` and `exit` functions are wrapped in arrays, to ease merging of visitors
      */
    inline def explode[S](visitor: Visitor[S]): /* import warning: importer.ImportType#apply Failed type conversion: {[ Type in 'ClassAccessorProperty' | 'AnyTypeAnnotation' | 'ArgumentPlaceholder' | 'ArrayExpression' | 'ArrayPattern' | 'ArrayTypeAnnotation' | 'ArrowFunctionExpression' | 'AssignmentExpression' | 'AssignmentPattern' | 'AwaitExpression' | 'BigIntLiteral' | 'BinaryExpression' | 'LogicalExpression' | 'BindExpression' | 'BlockStatement' | 'Program' | 'TSModuleBlock' | 'CatchClause' | 'DoWhileStatement' | 'ForInStatement' | 'ForStatement' | 'FunctionDeclaration' | 'FunctionExpression' | 'ObjectMethod' | 'SwitchStatement' | 'WhileStatement' | 'ForOfStatement' | 'ClassMethod' | 'ClassPrivateMethod' | 'StaticBlock' | 'BooleanLiteral' | 'BooleanLiteralTypeAnnotation' | 'BooleanTypeAnnotation' | 'BreakStatement' | 'CallExpression' | 'ClassExpression' | 'ClassDeclaration' | 'ClassBody' | 'ClassImplements' | 'ClassPrivateProperty' | 'ClassProperty' | 'ContinueStatement' | 'ReturnStatement' | 'ThrowStatement' | 'ConditionalExpression' | 'IfStatement' | 'DebuggerStatement' | 'DecimalLiteral' | 'VariableDeclaration' | 'ExportAllDeclaration' | 'ExportDefaultDeclaration' | 'ExportNamedDeclaration' | 'ImportDeclaration' | 'DeclareClass' | 'DeclareFunction' | 'DeclareInterface' | 'DeclareModule' | 'DeclareModuleExports' | 'DeclareTypeAlias' | 'DeclareOpaqueType' | 'DeclareVariable' | 'DeclareExportDeclaration' | 'DeclareExportAllDeclaration' | 'InterfaceDeclaration' | 'OpaqueType' | 'TypeAlias' | 'EnumDeclaration' | 'TSDeclareFunction' | 'TSInterfaceDeclaration' | 'TSTypeAliasDeclaration' | 'TSEnumDeclaration' | 'TSModuleDeclaration' | 'DeclaredPredicate' | 'Decorator' | 'Directive' | 'DirectiveLiteral' | 'DoExpression' | 'EmptyStatement' | 'EmptyTypeAnnotation' | 'EnumBooleanBody' | 'EnumNumberBody' | 'EnumStringBody' | 'EnumSymbolBody' | 'EnumBooleanMember' | 'EnumDefaultedMember' | 'EnumNumberMember' | 'EnumStringMember' | 'ExistsTypeAnnotation' | 'ExportDefaultSpecifier' | 'ExportNamespaceSpecifier' | 'ExportSpecifier' | 'Identifier' | 'StringLiteral' | 'NumericLiteral' | 'NullLiteral' | 'RegExpLiteral' | 'MemberExpression' | 'NewExpression' | 'ObjectExpression' | 'SequenceExpression' | 'ParenthesizedExpression' | 'ThisExpression' | 'UnaryExpression' | 'UpdateExpression' | 'MetaProperty' | 'Super' | 'TaggedTemplateExpression' | 'TemplateLiteral' | 'YieldExpression' | 'Import' | 'OptionalMemberExpression' | 'OptionalCallExpression' | 'TypeCastExpression' | 'JSXElement' | 'JSXFragment' | 'RecordExpression' | 'TupleExpression' | 'ModuleExpression' | 'TopicReference' | 'PipelineTopicExpression' | 'PipelineBareFunction' | 'PipelinePrimaryTopicReference' | 'TSInstantiationExpression' | 'TSAsExpression' | 'TSTypeAssertion' | 'TSNonNullExpression' | 'ExpressionStatement' | 'File' | 'NullLiteralTypeAnnotation' | 'FunctionTypeAnnotation' | 'FunctionTypeParam' | 'GenericTypeAnnotation' | 'InferredPredicate' | 'InterfaceExtends' | 'InterfaceTypeAnnotation' | 'IntersectionTypeAnnotation' | 'MixedTypeAnnotation' | 'NullableTypeAnnotation' | 'NumberLiteralTypeAnnotation' | 'NumberTypeAnnotation' | 'ObjectTypeAnnotation' | 'ObjectTypeInternalSlot' | 'ObjectTypeCallProperty' | 'ObjectTypeIndexer' | 'ObjectTypeProperty' | 'ObjectTypeSpreadProperty' | 'QualifiedTypeIdentifier' | 'StringLiteralTypeAnnotation' | 'StringTypeAnnotation' | 'SymbolTypeAnnotation' | 'ThisTypeAnnotation' | 'TupleTypeAnnotation' | 'TypeofTypeAnnotation' | 'TypeAnnotation' | 'TypeParameter' | 'TypeParameterDeclaration' | 'TypeParameterInstantiation' | 'UnionTypeAnnotation' | 'Variance' | 'VoidTypeAnnotation' | 'IndexedAccessType' | 'OptionalIndexedAccessType' | 'JSXAttribute' | 'JSXClosingElement' | 'JSXExpressionContainer' | 'JSXSpreadChild' | 'JSXOpeningElement' | 'JSXText' | 'JSXOpeningFragment' | 'JSXClosingFragment' | 'ImportAttribute' | 'ImportDefaultSpecifier' | 'ImportNamespaceSpecifier' | 'ImportSpecifier' | 'InterpreterDirective' | 'JSXEmptyExpression' | 'JSXIdentifier' | 'JSXMemberExpression' | 'JSXNamespacedName' | 'JSXSpreadAttribute' | 'RestElement' | 'ObjectPattern' | 'TSParameterProperty' | 'LabeledStatement' | 'Noop' | 'Placeholder' | 'V8IntrinsicIdentifier' | 'ObjectProperty' | 'PrivateName' | 'SpreadElement' | 'SwitchCase' | 'TryStatement' | 'VariableDeclarator' | 'WithStatement' | 'TemplateElement' | 'TSImportEqualsDeclaration' | 'TSExportAssignment' | 'TSNamespaceExportDeclaration' | 'TSAnyKeyword' | 'TSArrayType' | 'TSBooleanKeyword' | 'TSBigIntKeyword' | 'TSIntrinsicKeyword' | 'TSNeverKeyword' | 'TSNullKeyword' | 'TSNumberKeyword' | 'TSObjectKeyword' | 'TSStringKeyword' | 'TSSymbolKeyword' | 'TSUndefinedKeyword' | 'TSUnknownKeyword' | 'TSVoidKeyword' | 'TSThisType' | 'TSLiteralType' | 'TSCallSignatureDeclaration' | 'TSConditionalType' | 'TSConstructSignatureDeclaration' | 'TSConstructorType' | 'TSDeclareMethod' | 'TSQualifiedName' | 'TSEnumMember' | 'TSExpressionWithTypeArguments' | 'TSExternalModuleReference' | 'TSFunctionType' | 'TSImportType' | 'TSIndexSignature' | 'TSIndexedAccessType' | 'TSInferType' | 'TSInterfaceBody' | 'TSIntersectionType' | 'TSMappedType' | 'TSMethodSignature' | 'TSNamedTupleMember' | 'TSOptionalType' | 'TSParenthesizedType' | 'TSPropertySignature' | 'TSRestType' | 'TSTupleType' | 'TSTypeReference' | 'TSTypePredicate' | 'TSTypeQuery' | 'TSTypeLiteral' | 'TSUnionType' | 'TSTypeOperator' | 'TSTypeAnnotation' | 'TSTypeParameter' | 'TSTypeParameterDeclaration' | 'TSTypeParameterInstantiation' ]:? @babel/traverse.@babel/traverse.VisitNodeObject<S, std.Extract<@babel/types.@babel/types.Node, {  type :Type}>>} */ js.Any = ^.asInstanceOf[js.Dynamic].applyDynamic("explode")(visitor.asInstanceOf[js.Any]).asInstanceOf[/* import warning: importer.ImportType#apply Failed type conversion: {[ Type in 'ClassAccessorProperty' | 'AnyTypeAnnotation' | 'ArgumentPlaceholder' | 'ArrayExpression' | 'ArrayPattern' | 'ArrayTypeAnnotation' | 'ArrowFunctionExpression' | 'AssignmentExpression' | 'AssignmentPattern' | 'AwaitExpression' | 'BigIntLiteral' | 'BinaryExpression' | 'LogicalExpression' | 'BindExpression' | 'BlockStatement' | 'Program' | 'TSModuleBlock' | 'CatchClause' | 'DoWhileStatement' | 'ForInStatement' | 'ForStatement' | 'FunctionDeclaration' | 'FunctionExpression' | 'ObjectMethod' | 'SwitchStatement' | 'WhileStatement' | 'ForOfStatement' | 'ClassMethod' | 'ClassPrivateMethod' | 'StaticBlock' | 'BooleanLiteral' | 'BooleanLiteralTypeAnnotation' | 'BooleanTypeAnnotation' | 'BreakStatement' | 'CallExpression' | 'ClassExpression' | 'ClassDeclaration' | 'ClassBody' | 'ClassImplements' | 'ClassPrivateProperty' | 'ClassProperty' | 'ContinueStatement' | 'ReturnStatement' | 'ThrowStatement' | 'ConditionalExpression' | 'IfStatement' | 'DebuggerStatement' | 'DecimalLiteral' | 'VariableDeclaration' | 'ExportAllDeclaration' | 'ExportDefaultDeclaration' | 'ExportNamedDeclaration' | 'ImportDeclaration' | 'DeclareClass' | 'DeclareFunction' | 'DeclareInterface' | 'DeclareModule' | 'DeclareModuleExports' | 'DeclareTypeAlias' | 'DeclareOpaqueType' | 'DeclareVariable' | 'DeclareExportDeclaration' | 'DeclareExportAllDeclaration' | 'InterfaceDeclaration' | 'OpaqueType' | 'TypeAlias' | 'EnumDeclaration' | 'TSDeclareFunction' | 'TSInterfaceDeclaration' | 'TSTypeAliasDeclaration' | 'TSEnumDeclaration' | 'TSModuleDeclaration' | 'DeclaredPredicate' | 'Decorator' | 'Directive' | 'DirectiveLiteral' | 'DoExpression' | 'EmptyStatement' | 'EmptyTypeAnnotation' | 'EnumBooleanBody' | 'EnumNumberBody' | 'EnumStringBody' | 'EnumSymbolBody' | 'EnumBooleanMember' | 'EnumDefaultedMember' | 'EnumNumberMember' | 'EnumStringMember' | 'ExistsTypeAnnotation' | 'ExportDefaultSpecifier' | 'ExportNamespaceSpecifier' | 'ExportSpecifier' | 'Identifier' | 'StringLiteral' | 'NumericLiteral' | 'NullLiteral' | 'RegExpLiteral' | 'MemberExpression' | 'NewExpression' | 'ObjectExpression' | 'SequenceExpression' | 'ParenthesizedExpression' | 'ThisExpression' | 'UnaryExpression' | 'UpdateExpression' | 'MetaProperty' | 'Super' | 'TaggedTemplateExpression' | 'TemplateLiteral' | 'YieldExpression' | 'Import' | 'OptionalMemberExpression' | 'OptionalCallExpression' | 'TypeCastExpression' | 'JSXElement' | 'JSXFragment' | 'RecordExpression' | 'TupleExpression' | 'ModuleExpression' | 'TopicReference' | 'PipelineTopicExpression' | 'PipelineBareFunction' | 'PipelinePrimaryTopicReference' | 'TSInstantiationExpression' | 'TSAsExpression' | 'TSTypeAssertion' | 'TSNonNullExpression' | 'ExpressionStatement' | 'File' | 'NullLiteralTypeAnnotation' | 'FunctionTypeAnnotation' | 'FunctionTypeParam' | 'GenericTypeAnnotation' | 'InferredPredicate' | 'InterfaceExtends' | 'InterfaceTypeAnnotation' | 'IntersectionTypeAnnotation' | 'MixedTypeAnnotation' | 'NullableTypeAnnotation' | 'NumberLiteralTypeAnnotation' | 'NumberTypeAnnotation' | 'ObjectTypeAnnotation' | 'ObjectTypeInternalSlot' | 'ObjectTypeCallProperty' | 'ObjectTypeIndexer' | 'ObjectTypeProperty' | 'ObjectTypeSpreadProperty' | 'QualifiedTypeIdentifier' | 'StringLiteralTypeAnnotation' | 'StringTypeAnnotation' | 'SymbolTypeAnnotation' | 'ThisTypeAnnotation' | 'TupleTypeAnnotation' | 'TypeofTypeAnnotation' | 'TypeAnnotation' | 'TypeParameter' | 'TypeParameterDeclaration' | 'TypeParameterInstantiation' | 'UnionTypeAnnotation' | 'Variance' | 'VoidTypeAnnotation' | 'IndexedAccessType' | 'OptionalIndexedAccessType' | 'JSXAttribute' | 'JSXClosingElement' | 'JSXExpressionContainer' | 'JSXSpreadChild' | 'JSXOpeningElement' | 'JSXText' | 'JSXOpeningFragment' | 'JSXClosingFragment' | 'ImportAttribute' | 'ImportDefaultSpecifier' | 'ImportNamespaceSpecifier' | 'ImportSpecifier' | 'InterpreterDirective' | 'JSXEmptyExpression' | 'JSXIdentifier' | 'JSXMemberExpression' | 'JSXNamespacedName' | 'JSXSpreadAttribute' | 'RestElement' | 'ObjectPattern' | 'TSParameterProperty' | 'LabeledStatement' | 'Noop' | 'Placeholder' | 'V8IntrinsicIdentifier' | 'ObjectProperty' | 'PrivateName' | 'SpreadElement' | 'SwitchCase' | 'TryStatement' | 'VariableDeclarator' | 'WithStatement' | 'TemplateElement' | 'TSImportEqualsDeclaration' | 'TSExportAssignment' | 'TSNamespaceExportDeclaration' | 'TSAnyKeyword' | 'TSArrayType' | 'TSBooleanKeyword' | 'TSBigIntKeyword' | 'TSIntrinsicKeyword' | 'TSNeverKeyword' | 'TSNullKeyword' | 'TSNumberKeyword' | 'TSObjectKeyword' | 'TSStringKeyword' | 'TSSymbolKeyword' | 'TSUndefinedKeyword' | 'TSUnknownKeyword' | 'TSVoidKeyword' | 'TSThisType' | 'TSLiteralType' | 'TSCallSignatureDeclaration' | 'TSConditionalType' | 'TSConstructSignatureDeclaration' | 'TSConstructorType' | 'TSDeclareMethod' | 'TSQualifiedName' | 'TSEnumMember' | 'TSExpressionWithTypeArguments' | 'TSExternalModuleReference' | 'TSFunctionType' | 'TSImportType' | 'TSIndexSignature' | 'TSIndexedAccessType' | 'TSInferType' | 'TSInterfaceBody' | 'TSIntersectionType' | 'TSMappedType' | 'TSMethodSignature' | 'TSNamedTupleMember' | 'TSOptionalType' | 'TSParenthesizedType' | 'TSPropertySignature' | 'TSRestType' | 'TSTupleType' | 'TSTypeReference' | 'TSTypePredicate' | 'TSTypeQuery' | 'TSTypeLiteral' | 'TSUnionType' | 'TSTypeOperator' | 'TSTypeAnnotation' | 'TSTypeParameter' | 'TSTypeParameterDeclaration' | 'TSTypeParameterInstantiation' ]:? @babel/traverse.@babel/traverse.VisitNodeObject<S, std.Extract<@babel/types.@babel/types.Node, {  type :Type}>>} */ js.Any]
    
    inline def merge[S](visitors: js.Array[Visitor[S]]): Visitor[Any] = ^.asInstanceOf[js.Dynamic].applyDynamic("merge")(visitors.asInstanceOf[js.Any]).asInstanceOf[Visitor[Any]]
    inline def merge[S](visitors: js.Array[Visitor[S]], states: js.Array[S]): Visitor[Any] = (^.asInstanceOf[js.Dynamic].applyDynamic("merge")(visitors.asInstanceOf[js.Any], states.asInstanceOf[js.Any])).asInstanceOf[Visitor[Any]]
    
    inline def verify(visitor: Visitor[js.Object]): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("verify")(visitor.asInstanceOf[js.Any]).asInstanceOf[Unit]
  }
  
  type ArrayKeys[T] = /* keyof {[ P in keyof T as T[P] extends std.Array<any>? P : never ]: P} */ String
  
  /* Rewritten from type alias, can be one of: 
    - typings.babelTraverse.babelTraverseStrings.`var`
    - typings.babelTraverse.babelTraverseStrings.let
    - typings.babelTraverse.babelTraverseStrings.const
    - typings.babelTraverse.babelTraverseStrings.module
    - typings.babelTraverse.babelTraverseStrings.hoisted
    - typings.babelTraverse.babelTraverseStrings.param
    - typings.babelTraverse.babelTraverseStrings.local
    - typings.babelTraverse.babelTraverseStrings.unknown
  */
  trait BindingKind extends StObject
  object BindingKind {
    
    inline def const: typings.babelTraverse.babelTraverseStrings.const = "const".asInstanceOf[typings.babelTraverse.babelTraverseStrings.const]
    
    inline def hoisted: typings.babelTraverse.babelTraverseStrings.hoisted = "hoisted".asInstanceOf[typings.babelTraverse.babelTraverseStrings.hoisted]
    
    inline def let: typings.babelTraverse.babelTraverseStrings.let = "let".asInstanceOf[typings.babelTraverse.babelTraverseStrings.let]
    
    inline def local: typings.babelTraverse.babelTraverseStrings.local = "local".asInstanceOf[typings.babelTraverse.babelTraverseStrings.local]
    
    inline def module: typings.babelTraverse.babelTraverseStrings.module = "module".asInstanceOf[typings.babelTraverse.babelTraverseStrings.module]
    
    inline def param: typings.babelTraverse.babelTraverseStrings.param = "param".asInstanceOf[typings.babelTraverse.babelTraverseStrings.param]
    
    inline def unknown: typings.babelTraverse.babelTraverseStrings.unknown = "unknown".asInstanceOf[typings.babelTraverse.babelTraverseStrings.unknown]
    
    inline def `var`: typings.babelTraverse.babelTraverseStrings.`var` = "var".asInstanceOf[typings.babelTraverse.babelTraverseStrings.`var`]
  }
  
  trait HubInterface extends StObject {
    
    def addHelper(name: String): Any
    
    def buildError[E /* <: js.Error */](node: Node, msg: String, Error: Instantiable1[/* message */ js.UndefOr[String], E]): E
    
    def getCode(): js.UndefOr[String]
    
    def getScope(): js.UndefOr[Scope]
  }
  object HubInterface {
    
    inline def apply(
      addHelper: String => Any,
      buildError: (Node, String, Instantiable1[/* message */ js.UndefOr[String], Any]) => Any,
      getCode: () => js.UndefOr[String],
      getScope: () => js.UndefOr[Scope]
    ): HubInterface = {
      val __obj = js.Dynamic.literal(addHelper = js.Any.fromFunction1(addHelper), buildError = js.Any.fromFunction3(buildError), getCode = js.Any.fromFunction0(getCode), getScope = js.Any.fromFunction0(getScope))
      __obj.asInstanceOf[HubInterface]
    }
    
    extension [Self <: HubInterface](x: Self) {
      
      inline def setAddHelper(value: String => Any): Self = StObject.set(x, "addHelper", js.Any.fromFunction1(value))
      
      inline def setBuildError(value: (Node, String, Instantiable1[/* message */ js.UndefOr[String], Any]) => Any): Self = StObject.set(x, "buildError", js.Any.fromFunction3(value))
      
      inline def setGetCode(value: () => js.UndefOr[String]): Self = StObject.set(x, "getCode", js.Any.fromFunction0(value))
      
      inline def setGetScope(value: () => js.UndefOr[Scope]): Self = StObject.set(x, "getScope", js.Any.fromFunction0(value))
    }
  }
  
  type NodePathResult[T] = /* import warning: importer.ImportType#apply Failed type conversion: std.Extract<T, @babel/types.@babel/types.Node | null | undefined> extends never ? never : @babel/traverse.@babel/traverse.NodePath<std.Extract<T, @babel/types.@babel/types.Node | null | undefined>> */ js.Any
  
  /** NOTE: Conditional type definitions are impossible to translate to Scala.
    * See https://www.typescriptlang.org/docs/handbook/2/conditional-types.html for an intro.
    * You'll have to cast your way around this structure, unfortunately. 
    * TS definition: {{{
    T extends std.Array<@babel/types.@babel/types.Node> ? {-readonly [ K in keyof T ]: @babel/traverse.@babel/traverse.NodePath<std.Extract<T[K], @babel/types.@babel/types.Node>>} : T extends @babel/types.@babel/types.Node ? [@babel/traverse.@babel/traverse.NodePath<T>] : never
    }}}
    */
  @js.native
  trait NodePaths[T /* <: Node | js.Array[Node] */] extends StObject
  
  /* Inlined @babel/traverse.@babel/traverse.Node['type'] | keyof @babel/types.@babel/types.Aliases */
  /* Rewritten from type alias, can be one of: 
    - typings.babelTraverse.babelTraverseStrings.ClassExpression
    - typings.babelTraverse.babelTraverseStrings.TSArrayType
    - typings.babelTraverse.babelTraverseStrings.Loop
    - typings.babelTraverse.babelTraverseStrings.BreakStatement
    - typings.babelTraverse.babelTraverseStrings.StringTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.ExportDefaultSpecifier
    - typings.babelTraverse.babelTraverseStrings.EnumStringMember
    - typings.babelTraverse.babelTraverseStrings.ReturnStatement
    - typings.babelTraverse.babelTraverseStrings.TSInterfaceBody
    - typings.babelTraverse.babelTraverseStrings.TSAsExpression
    - typings.babelTraverse.babelTraverseStrings.InterfaceTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.BlockParent
    - typings.babelTraverse.babelTraverseStrings.TSAnyKeyword
    - typings.babelTraverse.babelTraverseStrings.TypeCastExpression
    - typings.babelTraverse.babelTraverseStrings.YieldExpression
    - typings.babelTraverse.babelTraverseStrings.ObjectTypeCallProperty
    - typings.babelTraverse.babelTraverseStrings.TupleTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.Standardized
    - typings.babelTraverse.babelTraverseStrings.TypeParameterDeclaration
    - typings.babelTraverse.babelTraverseStrings.TSModuleDeclaration
    - typings.babelTraverse.babelTraverseStrings.ForInStatement
    - typings.babelTraverse.babelTraverseStrings.EnumMember
    - typings.babelTraverse.babelTraverseStrings.TSConditionalType
    - typings.babelTraverse.babelTraverseStrings.ImportDefaultSpecifier
    - typings.babelTraverse.babelTraverseStrings.TSLiteralType
    - typings.babelTraverse.babelTraverseStrings.TSTypeParameterDeclaration
    - typings.babelTraverse.babelTraverseStrings.TypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.SpreadElement
    - typings.babelTraverse.babelTraverseStrings.TryStatement
    - typings.babelTraverse.babelTraverseStrings.BlockStatement
    - typings.babelTraverse.babelTraverseStrings.Pattern
    - typings.babelTraverse.babelTraverseStrings.RestElement
    - typings.babelTraverse.babelTraverseStrings.While
    - typings.babelTraverse.babelTraverseStrings.OptionalMemberExpression
    - typings.babelTraverse.babelTraverseStrings.JSX
    - typings.babelTraverse.babelTraverseStrings.File
    - typings.babelTraverse.babelTraverseStrings.TSIndexedAccessType
    - typings.babelTraverse.babelTraverseStrings.TSQualifiedName
    - typings.babelTraverse.babelTraverseStrings.UserWhitespacable
    - typings.babelTraverse.babelTraverseStrings.PipelinePrimaryTopicReference
    - typings.babelTraverse.babelTraverseStrings.JSXExpressionContainer
    - typings.babelTraverse.babelTraverseStrings.TSNullKeyword
    - typings.babelTraverse.babelTraverseStrings.Noop
    - typings.babelTraverse.babelTraverseStrings.DeclareModule
    - typings.babelTraverse.babelTraverseStrings.FlowType
    - typings.babelTraverse.babelTraverseStrings.LabeledStatement
    - typings.babelTraverse.babelTraverseStrings.ExportAllDeclaration
    - typings.babelTraverse.babelTraverseStrings.RegExpLiteral
    - typings.babelTraverse.babelTraverseStrings.WhileStatement
    - typings.babelTraverse.babelTraverseStrings.ContinueStatement
    - typings.babelTraverse.babelTraverseStrings.Accessor
    - typings.babelTraverse.babelTraverseStrings.FunctionTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.TSFunctionType
    - typings.babelTraverse.babelTraverseStrings.NullLiteralTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.SwitchStatement
    - typings.babelTraverse.babelTraverseStrings.OptionalCallExpression
    - typings.babelTraverse.babelTraverseStrings.ExportNamedDeclaration
    - typings.babelTraverse.babelTraverseStrings.CallExpression
    - typings.babelTraverse.babelTraverseStrings.InterfaceDeclaration
    - typings.babelTraverse.babelTraverseStrings.JSXSpreadAttribute
    - typings.babelTraverse.babelTraverseStrings.SymbolTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.ThisTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.TSTypeOperator
    - typings.babelTraverse.babelTraverseStrings.TSBigIntKeyword
    - typings.babelTraverse.babelTraverseStrings.SwitchCase
    - typings.babelTraverse.babelTraverseStrings.TSUnknownKeyword
    - typings.babelTraverse.babelTraverseStrings.ArrayExpression
    - typings.babelTraverse.babelTraverseStrings.MixedTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.ExportDeclaration
    - typings.babelTraverse.babelTraverseStrings.TSVoidKeyword
    - typings.babelTraverse.babelTraverseStrings.NewExpression
    - typings.babelTraverse.babelTraverseStrings.MemberExpression
    - typings.babelTraverse.babelTraverseStrings.RecordExpression
    - typings.babelTraverse.babelTraverseStrings.Flow
    - typings.babelTraverse.babelTraverseStrings.ExpressionStatement
    - typings.babelTraverse.babelTraverseStrings.Directive
    - typings.babelTraverse.babelTraverseStrings.AssignmentPattern
    - typings.babelTraverse.babelTraverseStrings.AnyTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.TSIntrinsicKeyword
    - typings.babelTraverse.babelTraverseStrings.EnumDeclaration
    - typings.babelTraverse.babelTraverseStrings.VariableDeclaration
    - typings.babelTraverse.babelTraverseStrings.IndexedAccessType
    - typings.babelTraverse.babelTraverseStrings.LogicalExpression
    - typings.babelTraverse.babelTraverseStrings.OpaqueType
    - typings.babelTraverse.babelTraverseStrings.TaggedTemplateExpression
    - typings.babelTraverse.babelTraverseStrings.JSXSpreadChild
    - typings.babelTraverse.babelTraverseStrings.JSXOpeningElement
    - typings.babelTraverse.babelTraverseStrings.QualifiedTypeIdentifier
    - typings.babelTraverse.babelTraverseStrings.TSTypeParameterInstantiation
    - typings.babelTraverse.babelTraverseStrings.TSDeclareMethod
    - typings.babelTraverse.babelTraverseStrings.TypeScript
    - typings.babelTraverse.babelTraverseStrings.TemplateLiteral
    - typings.babelTraverse.babelTraverseStrings.BindExpression
    - typings.babelTraverse.babelTraverseStrings.TSType
    - typings.babelTraverse.babelTraverseStrings.ExportDefaultDeclaration
    - typings.babelTraverse.babelTraverseStrings.ObjectTypeSpreadProperty
    - typings.babelTraverse.babelTraverseStrings.Decorator
    - typings.babelTraverse.babelTraverseStrings.MetaProperty
    - typings.babelTraverse.babelTraverseStrings.ObjectTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.IfStatement
    - typings.babelTraverse.babelTraverseStrings.ArrayTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.JSXIdentifier
    - typings.babelTraverse.babelTraverseStrings.InterpreterDirective
    - typings.babelTraverse.babelTraverseStrings.BinaryExpression
    - typings.babelTraverse.babelTraverseStrings.ForXStatement
    - typings.babelTraverse.babelTraverseStrings.TSNamespaceExportDeclaration
    - typings.babelTraverse.babelTraverseStrings.TSEnumDeclaration
    - typings.babelTraverse.babelTraverseStrings.TSTypeAliasDeclaration
    - typings.babelTraverse.babelTraverseStrings.TSUnionType
    - typings.babelTraverse.babelTraverseStrings.TSTypeParameter
    - typings.babelTraverse.babelTraverseStrings.PrivateName
    - typings.babelTraverse.babelTraverseStrings.WithStatement
    - typings.babelTraverse.babelTraverseStrings.TSNonNullExpression
    - typings.babelTraverse.babelTraverseStrings.NullableTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.Identifier
    - typings.babelTraverse.babelTraverseStrings.UpdateExpression
    - typings.babelTraverse.babelTraverseStrings.Terminatorless
    - typings.babelTraverse.babelTraverseStrings.TSStringKeyword
    - typings.babelTraverse.babelTraverseStrings.TopicReference
    - typings.babelTraverse.babelTraverseStrings.JSXAttribute
    - typings.babelTraverse.babelTraverseStrings.TSInferType
    - typings.babelTraverse.babelTraverseStrings.DeclareFunction
    - typings.babelTraverse.babelTraverseStrings.PatternLike
    - typings.babelTraverse.babelTraverseStrings.PipelineTopicExpression
    - typings.babelTraverse.babelTraverseStrings.VoidTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.Scopable
    - typings.babelTraverse.babelTraverseStrings.EmptyStatement
    - typings.babelTraverse.babelTraverseStrings.ClassDeclaration
    - typings.babelTraverse.babelTraverseStrings.DeclareExportAllDeclaration
    - typings.babelTraverse.babelTraverseStrings.StaticBlock
    - typings.babelTraverse.babelTraverseStrings.TSTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.AwaitExpression
    - typings.babelTraverse.babelTraverseStrings.ImportSpecifier
    - typings.babelTraverse.babelTraverseStrings.ArrayPattern
    - typings.babelTraverse.babelTraverseStrings.ExportSpecifier
    - typings.babelTraverse.babelTraverseStrings.EnumBooleanMember
    - typings.babelTraverse.babelTraverseStrings.TSPropertySignature
    - typings.babelTraverse.babelTraverseStrings.ExistsTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.TSTypeQuery
    - typings.babelTraverse.babelTraverseStrings.TSExternalModuleReference
    - typings.babelTraverse.babelTraverseStrings.TSConstructSignatureDeclaration
    - typings.babelTraverse.babelTraverseStrings.FlowPredicate
    - typings.babelTraverse.babelTraverseStrings.ImportAttribute
    - typings.babelTraverse.babelTraverseStrings.Method
    - typings.babelTraverse.babelTraverseStrings.ObjectExpression
    - typings.babelTraverse.babelTraverseStrings.JSXEmptyExpression
    - typings.babelTraverse.babelTraverseStrings.ObjectMethod
    - typings.babelTraverse.babelTraverseStrings.ModuleDeclaration
    - typings.babelTraverse.babelTraverseStrings.Pureish
    - typings.babelTraverse.babelTraverseStrings.TSTypeElement
    - typings.babelTraverse.babelTraverseStrings.TSSymbolKeyword
    - typings.babelTraverse.babelTraverseStrings.TSMappedType
    - typings.babelTraverse.babelTraverseStrings.JSXClosingElement
    - typings.babelTraverse.babelTraverseStrings.VariableDeclarator
    - typings.babelTraverse.babelTraverseStrings.TSEntityName
    - typings.babelTraverse.babelTraverseStrings.ObjectMember
    - typings.babelTraverse.babelTraverseStrings.StringLiteral
    - typings.babelTraverse.babelTraverseStrings.BooleanLiteral
    - typings.babelTraverse.babelTraverseStrings.TSEnumMember
    - typings.babelTraverse.babelTraverseStrings.InferredPredicate
    - typings.babelTraverse.babelTraverseStrings.AssignmentExpression
    - typings.babelTraverse.babelTraverseStrings.FunctionDeclaration
    - typings.babelTraverse.babelTraverseStrings.EnumBooleanBody
    - typings.babelTraverse.babelTraverseStrings.FlowBaseAnnotation
    - typings.babelTraverse.babelTraverseStrings.For
    - typings.babelTraverse.babelTraverseStrings.ModuleSpecifier
    - typings.babelTraverse.babelTraverseStrings.DebuggerStatement
    - typings.babelTraverse.babelTraverseStrings.InterfaceExtends
    - typings.babelTraverse.babelTraverseStrings.ThrowStatement
    - typings.babelTraverse.babelTraverseStrings.V8IntrinsicIdentifier
    - typings.babelTraverse.babelTraverseStrings.EmptyTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.Property
    - typings.babelTraverse.babelTraverseStrings.DirectiveLiteral
    - typings.babelTraverse.babelTraverseStrings.ObjectProperty
    - typings.babelTraverse.babelTraverseStrings.TSExportAssignment
    - typings.babelTraverse.babelTraverseStrings.OptionalIndexedAccessType
    - typings.babelTraverse.babelTraverseStrings.ArrowFunctionExpression
    - typings.babelTraverse.babelTraverseStrings.ModuleExpression
    - typings.babelTraverse.babelTraverseStrings.TSExpressionWithTypeArguments
    - typings.babelTraverse.babelTraverseStrings.TypeofTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.TSCallSignatureDeclaration
    - typings.babelTraverse.babelTraverseStrings.JSXFragment
    - typings.babelTraverse.babelTraverseStrings.Literal
    - typings.babelTraverse.babelTraverseStrings.Variance
    - typings.babelTraverse.babelTraverseStrings.Declaration
    - typings.babelTraverse.babelTraverseStrings.LVal
    - typings.babelTraverse.babelTraverseStrings.JSXNamespacedName
    - typings.babelTraverse.babelTraverseStrings.Program
    - typings.babelTraverse.babelTraverseStrings.TSTypeLiteral
    - typings.babelTraverse.babelTraverseStrings.NumberLiteralTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.DeclareExportDeclaration
    - typings.babelTraverse.babelTraverseStrings.ObjectTypeProperty
    - typings.babelTraverse.babelTraverseStrings.TSImportEqualsDeclaration
    - typings.babelTraverse.babelTraverseStrings.DeclareInterface
    - typings.babelTraverse.babelTraverseStrings.PipelineBareFunction
    - typings.babelTraverse.babelTraverseStrings.EnumStringBody
    - typings.babelTraverse.babelTraverseStrings.NumberTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.Super
    - typings.babelTraverse.babelTraverseStrings.ForOfStatement
    - typings.babelTraverse.babelTraverseStrings.DeclareTypeAlias
    - typings.babelTraverse.babelTraverseStrings.Placeholder
    - typings.babelTraverse.babelTraverseStrings.TSUndefinedKeyword
    - typings.babelTraverse.babelTraverseStrings.ConditionalExpression
    - typings.babelTraverse.babelTraverseStrings.Class
    - typings.babelTraverse.babelTraverseStrings.SequenceExpression
    - typings.babelTraverse.babelTraverseStrings.Import
    - typings.babelTraverse.babelTraverseStrings.TypeParameter
    - typings.babelTraverse.babelTraverseStrings.JSXElement
    - typings.babelTraverse.babelTraverseStrings.ObjectTypeIndexer
    - typings.babelTraverse.babelTraverseStrings.Function
    - typings.babelTraverse.babelTraverseStrings.CatchClause
    - typings.babelTraverse.babelTraverseStrings.Expression
    - typings.babelTraverse.babelTraverseStrings.UnaryExpression
    - typings.babelTraverse.babelTraverseStrings.BooleanLiteralTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.ExportNamespaceSpecifier
    - typings.babelTraverse.babelTraverseStrings.Miscellaneous
    - typings.babelTraverse.babelTraverseStrings.TypeAlias
    - typings.babelTraverse.babelTraverseStrings.TSNumberKeyword
    - typings.babelTraverse.babelTraverseStrings.Conditional
    - typings.babelTraverse.babelTraverseStrings.DeclareVariable
    - typings.babelTraverse.babelTraverseStrings.BooleanTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.BigIntLiteral
    - typings.babelTraverse.babelTraverseStrings.ExpressionWrapper
    - typings.babelTraverse.babelTraverseStrings.TSOptionalType
    - typings.babelTraverse.babelTraverseStrings.TSTypePredicate
    - typings.babelTraverse.babelTraverseStrings.TSInterfaceDeclaration
    - typings.babelTraverse.babelTraverseStrings.DeclaredPredicate
    - typings.babelTraverse.babelTraverseStrings.ClassMethod
    - typings.babelTraverse.babelTraverseStrings.ForStatement
    - typings.babelTraverse.babelTraverseStrings.Statement
    - typings.babelTraverse.babelTraverseStrings.UnaryLike
    - typings.babelTraverse.babelTraverseStrings.EnumDefaultedMember
    - typings.babelTraverse.babelTraverseStrings.ClassProperty
    - typings.babelTraverse.babelTraverseStrings.FunctionExpression
    - typings.babelTraverse.babelTraverseStrings.FunctionParent
    - typings.babelTraverse.babelTraverseStrings.TemplateElement
    - typings.babelTraverse.babelTraverseStrings.JSXText
    - typings.babelTraverse.babelTraverseStrings.TSParameterProperty
    - typings.babelTraverse.babelTraverseStrings.JSXMemberExpression
    - typings.babelTraverse.babelTraverseStrings.EnumSymbolBody
    - typings.babelTraverse.babelTraverseStrings.TSTupleType
    - typings.babelTraverse.babelTraverseStrings.DoWhileStatement
    - typings.babelTraverse.babelTraverseStrings.TSBaseType
    - typings.babelTraverse.babelTraverseStrings.TSDeclareFunction
    - typings.babelTraverse.babelTraverseStrings.ImportNamespaceSpecifier
    - typings.babelTraverse.babelTraverseStrings.TSMethodSignature
    - typings.babelTraverse.babelTraverseStrings.ParenthesizedExpression
    - typings.babelTraverse.babelTraverseStrings.EnumNumberMember
    - typings.babelTraverse.babelTraverseStrings.Private
    - typings.babelTraverse.babelTraverseStrings.DecimalLiteral
    - typings.babelTraverse.babelTraverseStrings.TSIndexSignature
    - typings.babelTraverse.babelTraverseStrings.Block
    - typings.babelTraverse.babelTraverseStrings.TSThisType
    - typings.babelTraverse.babelTraverseStrings.TupleExpression
    - typings.babelTraverse.babelTraverseStrings.TSRestType
    - typings.babelTraverse.babelTraverseStrings.JSXClosingFragment
    - typings.babelTraverse.babelTraverseStrings.ClassImplements
    - typings.babelTraverse.babelTraverseStrings.TSConstructorType
    - typings.babelTraverse.babelTraverseStrings.ClassAccessorProperty
    - typings.babelTraverse.babelTraverseStrings.IntersectionTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.TSInstantiationExpression
    - typings.babelTraverse.babelTraverseStrings.NumericLiteral
    - typings.babelTraverse.babelTraverseStrings.TSObjectKeyword
    - typings.babelTraverse.babelTraverseStrings.DoExpression
    - typings.babelTraverse.babelTraverseStrings.JSXOpeningFragment
    - typings.babelTraverse.babelTraverseStrings.UnionTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.TSNamedTupleMember
    - typings.babelTraverse.babelTraverseStrings.DeclareModuleExports
    - typings.babelTraverse.babelTraverseStrings.ObjectPattern
    - typings.babelTraverse.babelTraverseStrings.TSBooleanKeyword
    - typings.babelTraverse.babelTraverseStrings.StringLiteralTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.TSParenthesizedType
    - typings.babelTraverse.babelTraverseStrings.FunctionTypeParam
    - typings.babelTraverse.babelTraverseStrings.DeclareOpaqueType
    - typings.babelTraverse.babelTraverseStrings.ClassPrivateProperty
    - typings.babelTraverse.babelTraverseStrings.TSModuleBlock
    - typings.babelTraverse.babelTraverseStrings.ClassBody
    - typings.babelTraverse.babelTraverseStrings.ObjectTypeInternalSlot
    - typings.babelTraverse.babelTraverseStrings.ThisExpression
    - typings.babelTraverse.babelTraverseStrings.ClassPrivateMethod
    - typings.babelTraverse.babelTraverseStrings.TSTypeAssertion
    - typings.babelTraverse.babelTraverseStrings.Binary
    - typings.babelTraverse.babelTraverseStrings.TSNeverKeyword
    - typings.babelTraverse.babelTraverseStrings.TSIntersectionType
    - typings.babelTraverse.babelTraverseStrings.ArgumentPlaceholder
    - typings.babelTraverse.babelTraverseStrings.EnumNumberBody
    - typings.babelTraverse.babelTraverseStrings.TSImportType
    - typings.babelTraverse.babelTraverseStrings.FlowDeclaration
    - typings.babelTraverse.babelTraverseStrings.CompletionStatement
    - typings.babelTraverse.babelTraverseStrings.DeclareClass
    - typings.babelTraverse.babelTraverseStrings.ImportDeclaration
    - typings.babelTraverse.babelTraverseStrings.Immutable
    - typings.babelTraverse.babelTraverseStrings.GenericTypeAnnotation
    - typings.babelTraverse.babelTraverseStrings.EnumBody
    - typings.babelTraverse.babelTraverseStrings.NullLiteral
    - typings.babelTraverse.babelTraverseStrings.TypeParameterInstantiation
    - typings.babelTraverse.babelTraverseStrings.TSTypeReference
  */
  trait NodeType extends StObject
  object NodeType {
    
    inline def Accessor: typings.babelTraverse.babelTraverseStrings.Accessor = "Accessor".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Accessor]
    
    inline def AnyTypeAnnotation: typings.babelTraverse.babelTraverseStrings.AnyTypeAnnotation = "AnyTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.AnyTypeAnnotation]
    
    inline def ArgumentPlaceholder: typings.babelTraverse.babelTraverseStrings.ArgumentPlaceholder = "ArgumentPlaceholder".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ArgumentPlaceholder]
    
    inline def ArrayExpression: typings.babelTraverse.babelTraverseStrings.ArrayExpression = "ArrayExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ArrayExpression]
    
    inline def ArrayPattern: typings.babelTraverse.babelTraverseStrings.ArrayPattern = "ArrayPattern".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ArrayPattern]
    
    inline def ArrayTypeAnnotation: typings.babelTraverse.babelTraverseStrings.ArrayTypeAnnotation = "ArrayTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ArrayTypeAnnotation]
    
    inline def ArrowFunctionExpression: typings.babelTraverse.babelTraverseStrings.ArrowFunctionExpression = "ArrowFunctionExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ArrowFunctionExpression]
    
    inline def AssignmentExpression: typings.babelTraverse.babelTraverseStrings.AssignmentExpression = "AssignmentExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.AssignmentExpression]
    
    inline def AssignmentPattern: typings.babelTraverse.babelTraverseStrings.AssignmentPattern = "AssignmentPattern".asInstanceOf[typings.babelTraverse.babelTraverseStrings.AssignmentPattern]
    
    inline def AwaitExpression: typings.babelTraverse.babelTraverseStrings.AwaitExpression = "AwaitExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.AwaitExpression]
    
    inline def BigIntLiteral: typings.babelTraverse.babelTraverseStrings.BigIntLiteral = "BigIntLiteral".asInstanceOf[typings.babelTraverse.babelTraverseStrings.BigIntLiteral]
    
    inline def Binary: typings.babelTraverse.babelTraverseStrings.Binary = "Binary".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Binary]
    
    inline def BinaryExpression: typings.babelTraverse.babelTraverseStrings.BinaryExpression = "BinaryExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.BinaryExpression]
    
    inline def BindExpression: typings.babelTraverse.babelTraverseStrings.BindExpression = "BindExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.BindExpression]
    
    inline def Block: typings.babelTraverse.babelTraverseStrings.Block = "Block".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Block]
    
    inline def BlockParent: typings.babelTraverse.babelTraverseStrings.BlockParent = "BlockParent".asInstanceOf[typings.babelTraverse.babelTraverseStrings.BlockParent]
    
    inline def BlockStatement: typings.babelTraverse.babelTraverseStrings.BlockStatement = "BlockStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.BlockStatement]
    
    inline def BooleanLiteral: typings.babelTraverse.babelTraverseStrings.BooleanLiteral = "BooleanLiteral".asInstanceOf[typings.babelTraverse.babelTraverseStrings.BooleanLiteral]
    
    inline def BooleanLiteralTypeAnnotation: typings.babelTraverse.babelTraverseStrings.BooleanLiteralTypeAnnotation = "BooleanLiteralTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.BooleanLiteralTypeAnnotation]
    
    inline def BooleanTypeAnnotation: typings.babelTraverse.babelTraverseStrings.BooleanTypeAnnotation = "BooleanTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.BooleanTypeAnnotation]
    
    inline def BreakStatement: typings.babelTraverse.babelTraverseStrings.BreakStatement = "BreakStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.BreakStatement]
    
    inline def CallExpression: typings.babelTraverse.babelTraverseStrings.CallExpression = "CallExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.CallExpression]
    
    inline def CatchClause: typings.babelTraverse.babelTraverseStrings.CatchClause = "CatchClause".asInstanceOf[typings.babelTraverse.babelTraverseStrings.CatchClause]
    
    inline def Class: typings.babelTraverse.babelTraverseStrings.Class = "Class".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Class]
    
    inline def ClassAccessorProperty: typings.babelTraverse.babelTraverseStrings.ClassAccessorProperty = "ClassAccessorProperty".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ClassAccessorProperty]
    
    inline def ClassBody: typings.babelTraverse.babelTraverseStrings.ClassBody = "ClassBody".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ClassBody]
    
    inline def ClassDeclaration: typings.babelTraverse.babelTraverseStrings.ClassDeclaration = "ClassDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ClassDeclaration]
    
    inline def ClassExpression: typings.babelTraverse.babelTraverseStrings.ClassExpression = "ClassExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ClassExpression]
    
    inline def ClassImplements: typings.babelTraverse.babelTraverseStrings.ClassImplements = "ClassImplements".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ClassImplements]
    
    inline def ClassMethod: typings.babelTraverse.babelTraverseStrings.ClassMethod = "ClassMethod".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ClassMethod]
    
    inline def ClassPrivateMethod: typings.babelTraverse.babelTraverseStrings.ClassPrivateMethod = "ClassPrivateMethod".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ClassPrivateMethod]
    
    inline def ClassPrivateProperty: typings.babelTraverse.babelTraverseStrings.ClassPrivateProperty = "ClassPrivateProperty".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ClassPrivateProperty]
    
    inline def ClassProperty: typings.babelTraverse.babelTraverseStrings.ClassProperty = "ClassProperty".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ClassProperty]
    
    inline def CompletionStatement: typings.babelTraverse.babelTraverseStrings.CompletionStatement = "CompletionStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.CompletionStatement]
    
    inline def Conditional: typings.babelTraverse.babelTraverseStrings.Conditional = "Conditional".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Conditional]
    
    inline def ConditionalExpression: typings.babelTraverse.babelTraverseStrings.ConditionalExpression = "ConditionalExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ConditionalExpression]
    
    inline def ContinueStatement: typings.babelTraverse.babelTraverseStrings.ContinueStatement = "ContinueStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ContinueStatement]
    
    inline def DebuggerStatement: typings.babelTraverse.babelTraverseStrings.DebuggerStatement = "DebuggerStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DebuggerStatement]
    
    inline def DecimalLiteral: typings.babelTraverse.babelTraverseStrings.DecimalLiteral = "DecimalLiteral".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DecimalLiteral]
    
    inline def Declaration: typings.babelTraverse.babelTraverseStrings.Declaration = "Declaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Declaration]
    
    inline def DeclareClass: typings.babelTraverse.babelTraverseStrings.DeclareClass = "DeclareClass".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DeclareClass]
    
    inline def DeclareExportAllDeclaration: typings.babelTraverse.babelTraverseStrings.DeclareExportAllDeclaration = "DeclareExportAllDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DeclareExportAllDeclaration]
    
    inline def DeclareExportDeclaration: typings.babelTraverse.babelTraverseStrings.DeclareExportDeclaration = "DeclareExportDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DeclareExportDeclaration]
    
    inline def DeclareFunction: typings.babelTraverse.babelTraverseStrings.DeclareFunction = "DeclareFunction".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DeclareFunction]
    
    inline def DeclareInterface: typings.babelTraverse.babelTraverseStrings.DeclareInterface = "DeclareInterface".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DeclareInterface]
    
    inline def DeclareModule: typings.babelTraverse.babelTraverseStrings.DeclareModule = "DeclareModule".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DeclareModule]
    
    inline def DeclareModuleExports: typings.babelTraverse.babelTraverseStrings.DeclareModuleExports = "DeclareModuleExports".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DeclareModuleExports]
    
    inline def DeclareOpaqueType: typings.babelTraverse.babelTraverseStrings.DeclareOpaqueType = "DeclareOpaqueType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DeclareOpaqueType]
    
    inline def DeclareTypeAlias: typings.babelTraverse.babelTraverseStrings.DeclareTypeAlias = "DeclareTypeAlias".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DeclareTypeAlias]
    
    inline def DeclareVariable: typings.babelTraverse.babelTraverseStrings.DeclareVariable = "DeclareVariable".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DeclareVariable]
    
    inline def DeclaredPredicate: typings.babelTraverse.babelTraverseStrings.DeclaredPredicate = "DeclaredPredicate".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DeclaredPredicate]
    
    inline def Decorator: typings.babelTraverse.babelTraverseStrings.Decorator = "Decorator".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Decorator]
    
    inline def Directive: typings.babelTraverse.babelTraverseStrings.Directive = "Directive".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Directive]
    
    inline def DirectiveLiteral: typings.babelTraverse.babelTraverseStrings.DirectiveLiteral = "DirectiveLiteral".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DirectiveLiteral]
    
    inline def DoExpression: typings.babelTraverse.babelTraverseStrings.DoExpression = "DoExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DoExpression]
    
    inline def DoWhileStatement: typings.babelTraverse.babelTraverseStrings.DoWhileStatement = "DoWhileStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.DoWhileStatement]
    
    inline def EmptyStatement: typings.babelTraverse.babelTraverseStrings.EmptyStatement = "EmptyStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.EmptyStatement]
    
    inline def EmptyTypeAnnotation: typings.babelTraverse.babelTraverseStrings.EmptyTypeAnnotation = "EmptyTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.EmptyTypeAnnotation]
    
    inline def EnumBody: typings.babelTraverse.babelTraverseStrings.EnumBody = "EnumBody".asInstanceOf[typings.babelTraverse.babelTraverseStrings.EnumBody]
    
    inline def EnumBooleanBody: typings.babelTraverse.babelTraverseStrings.EnumBooleanBody = "EnumBooleanBody".asInstanceOf[typings.babelTraverse.babelTraverseStrings.EnumBooleanBody]
    
    inline def EnumBooleanMember: typings.babelTraverse.babelTraverseStrings.EnumBooleanMember = "EnumBooleanMember".asInstanceOf[typings.babelTraverse.babelTraverseStrings.EnumBooleanMember]
    
    inline def EnumDeclaration: typings.babelTraverse.babelTraverseStrings.EnumDeclaration = "EnumDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.EnumDeclaration]
    
    inline def EnumDefaultedMember: typings.babelTraverse.babelTraverseStrings.EnumDefaultedMember = "EnumDefaultedMember".asInstanceOf[typings.babelTraverse.babelTraverseStrings.EnumDefaultedMember]
    
    inline def EnumMember: typings.babelTraverse.babelTraverseStrings.EnumMember = "EnumMember".asInstanceOf[typings.babelTraverse.babelTraverseStrings.EnumMember]
    
    inline def EnumNumberBody: typings.babelTraverse.babelTraverseStrings.EnumNumberBody = "EnumNumberBody".asInstanceOf[typings.babelTraverse.babelTraverseStrings.EnumNumberBody]
    
    inline def EnumNumberMember: typings.babelTraverse.babelTraverseStrings.EnumNumberMember = "EnumNumberMember".asInstanceOf[typings.babelTraverse.babelTraverseStrings.EnumNumberMember]
    
    inline def EnumStringBody: typings.babelTraverse.babelTraverseStrings.EnumStringBody = "EnumStringBody".asInstanceOf[typings.babelTraverse.babelTraverseStrings.EnumStringBody]
    
    inline def EnumStringMember: typings.babelTraverse.babelTraverseStrings.EnumStringMember = "EnumStringMember".asInstanceOf[typings.babelTraverse.babelTraverseStrings.EnumStringMember]
    
    inline def EnumSymbolBody: typings.babelTraverse.babelTraverseStrings.EnumSymbolBody = "EnumSymbolBody".asInstanceOf[typings.babelTraverse.babelTraverseStrings.EnumSymbolBody]
    
    inline def ExistsTypeAnnotation: typings.babelTraverse.babelTraverseStrings.ExistsTypeAnnotation = "ExistsTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ExistsTypeAnnotation]
    
    inline def ExportAllDeclaration: typings.babelTraverse.babelTraverseStrings.ExportAllDeclaration = "ExportAllDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ExportAllDeclaration]
    
    inline def ExportDeclaration: typings.babelTraverse.babelTraverseStrings.ExportDeclaration = "ExportDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ExportDeclaration]
    
    inline def ExportDefaultDeclaration: typings.babelTraverse.babelTraverseStrings.ExportDefaultDeclaration = "ExportDefaultDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ExportDefaultDeclaration]
    
    inline def ExportDefaultSpecifier: typings.babelTraverse.babelTraverseStrings.ExportDefaultSpecifier = "ExportDefaultSpecifier".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ExportDefaultSpecifier]
    
    inline def ExportNamedDeclaration: typings.babelTraverse.babelTraverseStrings.ExportNamedDeclaration = "ExportNamedDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ExportNamedDeclaration]
    
    inline def ExportNamespaceSpecifier: typings.babelTraverse.babelTraverseStrings.ExportNamespaceSpecifier = "ExportNamespaceSpecifier".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ExportNamespaceSpecifier]
    
    inline def ExportSpecifier: typings.babelTraverse.babelTraverseStrings.ExportSpecifier = "ExportSpecifier".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ExportSpecifier]
    
    inline def Expression: typings.babelTraverse.babelTraverseStrings.Expression = "Expression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Expression]
    
    inline def ExpressionStatement: typings.babelTraverse.babelTraverseStrings.ExpressionStatement = "ExpressionStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ExpressionStatement]
    
    inline def ExpressionWrapper: typings.babelTraverse.babelTraverseStrings.ExpressionWrapper = "ExpressionWrapper".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ExpressionWrapper]
    
    inline def File: typings.babelTraverse.babelTraverseStrings.File = "File".asInstanceOf[typings.babelTraverse.babelTraverseStrings.File]
    
    inline def Flow: typings.babelTraverse.babelTraverseStrings.Flow = "Flow".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Flow]
    
    inline def FlowBaseAnnotation: typings.babelTraverse.babelTraverseStrings.FlowBaseAnnotation = "FlowBaseAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.FlowBaseAnnotation]
    
    inline def FlowDeclaration: typings.babelTraverse.babelTraverseStrings.FlowDeclaration = "FlowDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.FlowDeclaration]
    
    inline def FlowPredicate: typings.babelTraverse.babelTraverseStrings.FlowPredicate = "FlowPredicate".asInstanceOf[typings.babelTraverse.babelTraverseStrings.FlowPredicate]
    
    inline def FlowType: typings.babelTraverse.babelTraverseStrings.FlowType = "FlowType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.FlowType]
    
    inline def For: typings.babelTraverse.babelTraverseStrings.For = "For".asInstanceOf[typings.babelTraverse.babelTraverseStrings.For]
    
    inline def ForInStatement: typings.babelTraverse.babelTraverseStrings.ForInStatement = "ForInStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ForInStatement]
    
    inline def ForOfStatement: typings.babelTraverse.babelTraverseStrings.ForOfStatement = "ForOfStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ForOfStatement]
    
    inline def ForStatement: typings.babelTraverse.babelTraverseStrings.ForStatement = "ForStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ForStatement]
    
    inline def ForXStatement: typings.babelTraverse.babelTraverseStrings.ForXStatement = "ForXStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ForXStatement]
    
    inline def Function: typings.babelTraverse.babelTraverseStrings.Function = "Function".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Function]
    
    inline def FunctionDeclaration: typings.babelTraverse.babelTraverseStrings.FunctionDeclaration = "FunctionDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.FunctionDeclaration]
    
    inline def FunctionExpression: typings.babelTraverse.babelTraverseStrings.FunctionExpression = "FunctionExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.FunctionExpression]
    
    inline def FunctionParent: typings.babelTraverse.babelTraverseStrings.FunctionParent = "FunctionParent".asInstanceOf[typings.babelTraverse.babelTraverseStrings.FunctionParent]
    
    inline def FunctionTypeAnnotation: typings.babelTraverse.babelTraverseStrings.FunctionTypeAnnotation = "FunctionTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.FunctionTypeAnnotation]
    
    inline def FunctionTypeParam: typings.babelTraverse.babelTraverseStrings.FunctionTypeParam = "FunctionTypeParam".asInstanceOf[typings.babelTraverse.babelTraverseStrings.FunctionTypeParam]
    
    inline def GenericTypeAnnotation: typings.babelTraverse.babelTraverseStrings.GenericTypeAnnotation = "GenericTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.GenericTypeAnnotation]
    
    inline def Identifier: typings.babelTraverse.babelTraverseStrings.Identifier = "Identifier".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Identifier]
    
    inline def IfStatement: typings.babelTraverse.babelTraverseStrings.IfStatement = "IfStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.IfStatement]
    
    inline def Immutable: typings.babelTraverse.babelTraverseStrings.Immutable = "Immutable".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Immutable]
    
    inline def Import: typings.babelTraverse.babelTraverseStrings.Import = "Import".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Import]
    
    inline def ImportAttribute: typings.babelTraverse.babelTraverseStrings.ImportAttribute = "ImportAttribute".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ImportAttribute]
    
    inline def ImportDeclaration: typings.babelTraverse.babelTraverseStrings.ImportDeclaration = "ImportDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ImportDeclaration]
    
    inline def ImportDefaultSpecifier: typings.babelTraverse.babelTraverseStrings.ImportDefaultSpecifier = "ImportDefaultSpecifier".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ImportDefaultSpecifier]
    
    inline def ImportNamespaceSpecifier: typings.babelTraverse.babelTraverseStrings.ImportNamespaceSpecifier = "ImportNamespaceSpecifier".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ImportNamespaceSpecifier]
    
    inline def ImportSpecifier: typings.babelTraverse.babelTraverseStrings.ImportSpecifier = "ImportSpecifier".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ImportSpecifier]
    
    inline def IndexedAccessType: typings.babelTraverse.babelTraverseStrings.IndexedAccessType = "IndexedAccessType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.IndexedAccessType]
    
    inline def InferredPredicate: typings.babelTraverse.babelTraverseStrings.InferredPredicate = "InferredPredicate".asInstanceOf[typings.babelTraverse.babelTraverseStrings.InferredPredicate]
    
    inline def InterfaceDeclaration: typings.babelTraverse.babelTraverseStrings.InterfaceDeclaration = "InterfaceDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.InterfaceDeclaration]
    
    inline def InterfaceExtends: typings.babelTraverse.babelTraverseStrings.InterfaceExtends = "InterfaceExtends".asInstanceOf[typings.babelTraverse.babelTraverseStrings.InterfaceExtends]
    
    inline def InterfaceTypeAnnotation: typings.babelTraverse.babelTraverseStrings.InterfaceTypeAnnotation = "InterfaceTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.InterfaceTypeAnnotation]
    
    inline def InterpreterDirective: typings.babelTraverse.babelTraverseStrings.InterpreterDirective = "InterpreterDirective".asInstanceOf[typings.babelTraverse.babelTraverseStrings.InterpreterDirective]
    
    inline def IntersectionTypeAnnotation: typings.babelTraverse.babelTraverseStrings.IntersectionTypeAnnotation = "IntersectionTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.IntersectionTypeAnnotation]
    
    inline def JSX: typings.babelTraverse.babelTraverseStrings.JSX = "JSX".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSX]
    
    inline def JSXAttribute: typings.babelTraverse.babelTraverseStrings.JSXAttribute = "JSXAttribute".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXAttribute]
    
    inline def JSXClosingElement: typings.babelTraverse.babelTraverseStrings.JSXClosingElement = "JSXClosingElement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXClosingElement]
    
    inline def JSXClosingFragment: typings.babelTraverse.babelTraverseStrings.JSXClosingFragment = "JSXClosingFragment".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXClosingFragment]
    
    inline def JSXElement: typings.babelTraverse.babelTraverseStrings.JSXElement = "JSXElement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXElement]
    
    inline def JSXEmptyExpression: typings.babelTraverse.babelTraverseStrings.JSXEmptyExpression = "JSXEmptyExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXEmptyExpression]
    
    inline def JSXExpressionContainer: typings.babelTraverse.babelTraverseStrings.JSXExpressionContainer = "JSXExpressionContainer".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXExpressionContainer]
    
    inline def JSXFragment: typings.babelTraverse.babelTraverseStrings.JSXFragment = "JSXFragment".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXFragment]
    
    inline def JSXIdentifier: typings.babelTraverse.babelTraverseStrings.JSXIdentifier = "JSXIdentifier".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXIdentifier]
    
    inline def JSXMemberExpression: typings.babelTraverse.babelTraverseStrings.JSXMemberExpression = "JSXMemberExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXMemberExpression]
    
    inline def JSXNamespacedName: typings.babelTraverse.babelTraverseStrings.JSXNamespacedName = "JSXNamespacedName".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXNamespacedName]
    
    inline def JSXOpeningElement: typings.babelTraverse.babelTraverseStrings.JSXOpeningElement = "JSXOpeningElement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXOpeningElement]
    
    inline def JSXOpeningFragment: typings.babelTraverse.babelTraverseStrings.JSXOpeningFragment = "JSXOpeningFragment".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXOpeningFragment]
    
    inline def JSXSpreadAttribute: typings.babelTraverse.babelTraverseStrings.JSXSpreadAttribute = "JSXSpreadAttribute".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXSpreadAttribute]
    
    inline def JSXSpreadChild: typings.babelTraverse.babelTraverseStrings.JSXSpreadChild = "JSXSpreadChild".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXSpreadChild]
    
    inline def JSXText: typings.babelTraverse.babelTraverseStrings.JSXText = "JSXText".asInstanceOf[typings.babelTraverse.babelTraverseStrings.JSXText]
    
    inline def LVal: typings.babelTraverse.babelTraverseStrings.LVal = "LVal".asInstanceOf[typings.babelTraverse.babelTraverseStrings.LVal]
    
    inline def LabeledStatement: typings.babelTraverse.babelTraverseStrings.LabeledStatement = "LabeledStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.LabeledStatement]
    
    inline def Literal: typings.babelTraverse.babelTraverseStrings.Literal = "Literal".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Literal]
    
    inline def LogicalExpression: typings.babelTraverse.babelTraverseStrings.LogicalExpression = "LogicalExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.LogicalExpression]
    
    inline def Loop: typings.babelTraverse.babelTraverseStrings.Loop = "Loop".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Loop]
    
    inline def MemberExpression: typings.babelTraverse.babelTraverseStrings.MemberExpression = "MemberExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.MemberExpression]
    
    inline def MetaProperty: typings.babelTraverse.babelTraverseStrings.MetaProperty = "MetaProperty".asInstanceOf[typings.babelTraverse.babelTraverseStrings.MetaProperty]
    
    inline def Method: typings.babelTraverse.babelTraverseStrings.Method = "Method".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Method]
    
    inline def Miscellaneous: typings.babelTraverse.babelTraverseStrings.Miscellaneous = "Miscellaneous".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Miscellaneous]
    
    inline def MixedTypeAnnotation: typings.babelTraverse.babelTraverseStrings.MixedTypeAnnotation = "MixedTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.MixedTypeAnnotation]
    
    inline def ModuleDeclaration: typings.babelTraverse.babelTraverseStrings.ModuleDeclaration = "ModuleDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ModuleDeclaration]
    
    inline def ModuleExpression: typings.babelTraverse.babelTraverseStrings.ModuleExpression = "ModuleExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ModuleExpression]
    
    inline def ModuleSpecifier: typings.babelTraverse.babelTraverseStrings.ModuleSpecifier = "ModuleSpecifier".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ModuleSpecifier]
    
    inline def NewExpression: typings.babelTraverse.babelTraverseStrings.NewExpression = "NewExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.NewExpression]
    
    inline def Noop: typings.babelTraverse.babelTraverseStrings.Noop = "Noop".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Noop]
    
    inline def NullLiteral: typings.babelTraverse.babelTraverseStrings.NullLiteral = "NullLiteral".asInstanceOf[typings.babelTraverse.babelTraverseStrings.NullLiteral]
    
    inline def NullLiteralTypeAnnotation: typings.babelTraverse.babelTraverseStrings.NullLiteralTypeAnnotation = "NullLiteralTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.NullLiteralTypeAnnotation]
    
    inline def NullableTypeAnnotation: typings.babelTraverse.babelTraverseStrings.NullableTypeAnnotation = "NullableTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.NullableTypeAnnotation]
    
    inline def NumberLiteralTypeAnnotation: typings.babelTraverse.babelTraverseStrings.NumberLiteralTypeAnnotation = "NumberLiteralTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.NumberLiteralTypeAnnotation]
    
    inline def NumberTypeAnnotation: typings.babelTraverse.babelTraverseStrings.NumberTypeAnnotation = "NumberTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.NumberTypeAnnotation]
    
    inline def NumericLiteral: typings.babelTraverse.babelTraverseStrings.NumericLiteral = "NumericLiteral".asInstanceOf[typings.babelTraverse.babelTraverseStrings.NumericLiteral]
    
    inline def ObjectExpression: typings.babelTraverse.babelTraverseStrings.ObjectExpression = "ObjectExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ObjectExpression]
    
    inline def ObjectMember: typings.babelTraverse.babelTraverseStrings.ObjectMember = "ObjectMember".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ObjectMember]
    
    inline def ObjectMethod: typings.babelTraverse.babelTraverseStrings.ObjectMethod = "ObjectMethod".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ObjectMethod]
    
    inline def ObjectPattern: typings.babelTraverse.babelTraverseStrings.ObjectPattern = "ObjectPattern".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ObjectPattern]
    
    inline def ObjectProperty: typings.babelTraverse.babelTraverseStrings.ObjectProperty = "ObjectProperty".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ObjectProperty]
    
    inline def ObjectTypeAnnotation: typings.babelTraverse.babelTraverseStrings.ObjectTypeAnnotation = "ObjectTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ObjectTypeAnnotation]
    
    inline def ObjectTypeCallProperty: typings.babelTraverse.babelTraverseStrings.ObjectTypeCallProperty = "ObjectTypeCallProperty".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ObjectTypeCallProperty]
    
    inline def ObjectTypeIndexer: typings.babelTraverse.babelTraverseStrings.ObjectTypeIndexer = "ObjectTypeIndexer".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ObjectTypeIndexer]
    
    inline def ObjectTypeInternalSlot: typings.babelTraverse.babelTraverseStrings.ObjectTypeInternalSlot = "ObjectTypeInternalSlot".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ObjectTypeInternalSlot]
    
    inline def ObjectTypeProperty: typings.babelTraverse.babelTraverseStrings.ObjectTypeProperty = "ObjectTypeProperty".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ObjectTypeProperty]
    
    inline def ObjectTypeSpreadProperty: typings.babelTraverse.babelTraverseStrings.ObjectTypeSpreadProperty = "ObjectTypeSpreadProperty".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ObjectTypeSpreadProperty]
    
    inline def OpaqueType: typings.babelTraverse.babelTraverseStrings.OpaqueType = "OpaqueType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.OpaqueType]
    
    inline def OptionalCallExpression: typings.babelTraverse.babelTraverseStrings.OptionalCallExpression = "OptionalCallExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.OptionalCallExpression]
    
    inline def OptionalIndexedAccessType: typings.babelTraverse.babelTraverseStrings.OptionalIndexedAccessType = "OptionalIndexedAccessType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.OptionalIndexedAccessType]
    
    inline def OptionalMemberExpression: typings.babelTraverse.babelTraverseStrings.OptionalMemberExpression = "OptionalMemberExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.OptionalMemberExpression]
    
    inline def ParenthesizedExpression: typings.babelTraverse.babelTraverseStrings.ParenthesizedExpression = "ParenthesizedExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ParenthesizedExpression]
    
    inline def Pattern: typings.babelTraverse.babelTraverseStrings.Pattern = "Pattern".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Pattern]
    
    inline def PatternLike: typings.babelTraverse.babelTraverseStrings.PatternLike = "PatternLike".asInstanceOf[typings.babelTraverse.babelTraverseStrings.PatternLike]
    
    inline def PipelineBareFunction: typings.babelTraverse.babelTraverseStrings.PipelineBareFunction = "PipelineBareFunction".asInstanceOf[typings.babelTraverse.babelTraverseStrings.PipelineBareFunction]
    
    inline def PipelinePrimaryTopicReference: typings.babelTraverse.babelTraverseStrings.PipelinePrimaryTopicReference = "PipelinePrimaryTopicReference".asInstanceOf[typings.babelTraverse.babelTraverseStrings.PipelinePrimaryTopicReference]
    
    inline def PipelineTopicExpression: typings.babelTraverse.babelTraverseStrings.PipelineTopicExpression = "PipelineTopicExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.PipelineTopicExpression]
    
    inline def Placeholder: typings.babelTraverse.babelTraverseStrings.Placeholder = "Placeholder".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Placeholder]
    
    inline def Private: typings.babelTraverse.babelTraverseStrings.Private = "Private".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Private]
    
    inline def PrivateName: typings.babelTraverse.babelTraverseStrings.PrivateName = "PrivateName".asInstanceOf[typings.babelTraverse.babelTraverseStrings.PrivateName]
    
    inline def Program: typings.babelTraverse.babelTraverseStrings.Program = "Program".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Program]
    
    inline def Property: typings.babelTraverse.babelTraverseStrings.Property = "Property".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Property]
    
    inline def Pureish: typings.babelTraverse.babelTraverseStrings.Pureish = "Pureish".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Pureish]
    
    inline def QualifiedTypeIdentifier: typings.babelTraverse.babelTraverseStrings.QualifiedTypeIdentifier = "QualifiedTypeIdentifier".asInstanceOf[typings.babelTraverse.babelTraverseStrings.QualifiedTypeIdentifier]
    
    inline def RecordExpression: typings.babelTraverse.babelTraverseStrings.RecordExpression = "RecordExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.RecordExpression]
    
    inline def RegExpLiteral: typings.babelTraverse.babelTraverseStrings.RegExpLiteral = "RegExpLiteral".asInstanceOf[typings.babelTraverse.babelTraverseStrings.RegExpLiteral]
    
    inline def RestElement: typings.babelTraverse.babelTraverseStrings.RestElement = "RestElement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.RestElement]
    
    inline def ReturnStatement: typings.babelTraverse.babelTraverseStrings.ReturnStatement = "ReturnStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ReturnStatement]
    
    inline def Scopable: typings.babelTraverse.babelTraverseStrings.Scopable = "Scopable".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Scopable]
    
    inline def SequenceExpression: typings.babelTraverse.babelTraverseStrings.SequenceExpression = "SequenceExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.SequenceExpression]
    
    inline def SpreadElement: typings.babelTraverse.babelTraverseStrings.SpreadElement = "SpreadElement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.SpreadElement]
    
    inline def Standardized: typings.babelTraverse.babelTraverseStrings.Standardized = "Standardized".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Standardized]
    
    inline def Statement: typings.babelTraverse.babelTraverseStrings.Statement = "Statement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Statement]
    
    inline def StaticBlock: typings.babelTraverse.babelTraverseStrings.StaticBlock = "StaticBlock".asInstanceOf[typings.babelTraverse.babelTraverseStrings.StaticBlock]
    
    inline def StringLiteral: typings.babelTraverse.babelTraverseStrings.StringLiteral = "StringLiteral".asInstanceOf[typings.babelTraverse.babelTraverseStrings.StringLiteral]
    
    inline def StringLiteralTypeAnnotation: typings.babelTraverse.babelTraverseStrings.StringLiteralTypeAnnotation = "StringLiteralTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.StringLiteralTypeAnnotation]
    
    inline def StringTypeAnnotation: typings.babelTraverse.babelTraverseStrings.StringTypeAnnotation = "StringTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.StringTypeAnnotation]
    
    inline def Super: typings.babelTraverse.babelTraverseStrings.Super = "Super".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Super]
    
    inline def SwitchCase: typings.babelTraverse.babelTraverseStrings.SwitchCase = "SwitchCase".asInstanceOf[typings.babelTraverse.babelTraverseStrings.SwitchCase]
    
    inline def SwitchStatement: typings.babelTraverse.babelTraverseStrings.SwitchStatement = "SwitchStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.SwitchStatement]
    
    inline def SymbolTypeAnnotation: typings.babelTraverse.babelTraverseStrings.SymbolTypeAnnotation = "SymbolTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.SymbolTypeAnnotation]
    
    inline def TSAnyKeyword: typings.babelTraverse.babelTraverseStrings.TSAnyKeyword = "TSAnyKeyword".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSAnyKeyword]
    
    inline def TSArrayType: typings.babelTraverse.babelTraverseStrings.TSArrayType = "TSArrayType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSArrayType]
    
    inline def TSAsExpression: typings.babelTraverse.babelTraverseStrings.TSAsExpression = "TSAsExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSAsExpression]
    
    inline def TSBaseType: typings.babelTraverse.babelTraverseStrings.TSBaseType = "TSBaseType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSBaseType]
    
    inline def TSBigIntKeyword: typings.babelTraverse.babelTraverseStrings.TSBigIntKeyword = "TSBigIntKeyword".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSBigIntKeyword]
    
    inline def TSBooleanKeyword: typings.babelTraverse.babelTraverseStrings.TSBooleanKeyword = "TSBooleanKeyword".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSBooleanKeyword]
    
    inline def TSCallSignatureDeclaration: typings.babelTraverse.babelTraverseStrings.TSCallSignatureDeclaration = "TSCallSignatureDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSCallSignatureDeclaration]
    
    inline def TSConditionalType: typings.babelTraverse.babelTraverseStrings.TSConditionalType = "TSConditionalType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSConditionalType]
    
    inline def TSConstructSignatureDeclaration: typings.babelTraverse.babelTraverseStrings.TSConstructSignatureDeclaration = "TSConstructSignatureDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSConstructSignatureDeclaration]
    
    inline def TSConstructorType: typings.babelTraverse.babelTraverseStrings.TSConstructorType = "TSConstructorType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSConstructorType]
    
    inline def TSDeclareFunction: typings.babelTraverse.babelTraverseStrings.TSDeclareFunction = "TSDeclareFunction".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSDeclareFunction]
    
    inline def TSDeclareMethod: typings.babelTraverse.babelTraverseStrings.TSDeclareMethod = "TSDeclareMethod".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSDeclareMethod]
    
    inline def TSEntityName: typings.babelTraverse.babelTraverseStrings.TSEntityName = "TSEntityName".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSEntityName]
    
    inline def TSEnumDeclaration: typings.babelTraverse.babelTraverseStrings.TSEnumDeclaration = "TSEnumDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSEnumDeclaration]
    
    inline def TSEnumMember: typings.babelTraverse.babelTraverseStrings.TSEnumMember = "TSEnumMember".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSEnumMember]
    
    inline def TSExportAssignment: typings.babelTraverse.babelTraverseStrings.TSExportAssignment = "TSExportAssignment".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSExportAssignment]
    
    inline def TSExpressionWithTypeArguments: typings.babelTraverse.babelTraverseStrings.TSExpressionWithTypeArguments = "TSExpressionWithTypeArguments".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSExpressionWithTypeArguments]
    
    inline def TSExternalModuleReference: typings.babelTraverse.babelTraverseStrings.TSExternalModuleReference = "TSExternalModuleReference".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSExternalModuleReference]
    
    inline def TSFunctionType: typings.babelTraverse.babelTraverseStrings.TSFunctionType = "TSFunctionType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSFunctionType]
    
    inline def TSImportEqualsDeclaration: typings.babelTraverse.babelTraverseStrings.TSImportEqualsDeclaration = "TSImportEqualsDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSImportEqualsDeclaration]
    
    inline def TSImportType: typings.babelTraverse.babelTraverseStrings.TSImportType = "TSImportType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSImportType]
    
    inline def TSIndexSignature: typings.babelTraverse.babelTraverseStrings.TSIndexSignature = "TSIndexSignature".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSIndexSignature]
    
    inline def TSIndexedAccessType: typings.babelTraverse.babelTraverseStrings.TSIndexedAccessType = "TSIndexedAccessType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSIndexedAccessType]
    
    inline def TSInferType: typings.babelTraverse.babelTraverseStrings.TSInferType = "TSInferType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSInferType]
    
    inline def TSInstantiationExpression: typings.babelTraverse.babelTraverseStrings.TSInstantiationExpression = "TSInstantiationExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSInstantiationExpression]
    
    inline def TSInterfaceBody: typings.babelTraverse.babelTraverseStrings.TSInterfaceBody = "TSInterfaceBody".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSInterfaceBody]
    
    inline def TSInterfaceDeclaration: typings.babelTraverse.babelTraverseStrings.TSInterfaceDeclaration = "TSInterfaceDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSInterfaceDeclaration]
    
    inline def TSIntersectionType: typings.babelTraverse.babelTraverseStrings.TSIntersectionType = "TSIntersectionType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSIntersectionType]
    
    inline def TSIntrinsicKeyword: typings.babelTraverse.babelTraverseStrings.TSIntrinsicKeyword = "TSIntrinsicKeyword".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSIntrinsicKeyword]
    
    inline def TSLiteralType: typings.babelTraverse.babelTraverseStrings.TSLiteralType = "TSLiteralType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSLiteralType]
    
    inline def TSMappedType: typings.babelTraverse.babelTraverseStrings.TSMappedType = "TSMappedType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSMappedType]
    
    inline def TSMethodSignature: typings.babelTraverse.babelTraverseStrings.TSMethodSignature = "TSMethodSignature".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSMethodSignature]
    
    inline def TSModuleBlock: typings.babelTraverse.babelTraverseStrings.TSModuleBlock = "TSModuleBlock".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSModuleBlock]
    
    inline def TSModuleDeclaration: typings.babelTraverse.babelTraverseStrings.TSModuleDeclaration = "TSModuleDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSModuleDeclaration]
    
    inline def TSNamedTupleMember: typings.babelTraverse.babelTraverseStrings.TSNamedTupleMember = "TSNamedTupleMember".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSNamedTupleMember]
    
    inline def TSNamespaceExportDeclaration: typings.babelTraverse.babelTraverseStrings.TSNamespaceExportDeclaration = "TSNamespaceExportDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSNamespaceExportDeclaration]
    
    inline def TSNeverKeyword: typings.babelTraverse.babelTraverseStrings.TSNeverKeyword = "TSNeverKeyword".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSNeverKeyword]
    
    inline def TSNonNullExpression: typings.babelTraverse.babelTraverseStrings.TSNonNullExpression = "TSNonNullExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSNonNullExpression]
    
    inline def TSNullKeyword: typings.babelTraverse.babelTraverseStrings.TSNullKeyword = "TSNullKeyword".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSNullKeyword]
    
    inline def TSNumberKeyword: typings.babelTraverse.babelTraverseStrings.TSNumberKeyword = "TSNumberKeyword".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSNumberKeyword]
    
    inline def TSObjectKeyword: typings.babelTraverse.babelTraverseStrings.TSObjectKeyword = "TSObjectKeyword".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSObjectKeyword]
    
    inline def TSOptionalType: typings.babelTraverse.babelTraverseStrings.TSOptionalType = "TSOptionalType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSOptionalType]
    
    inline def TSParameterProperty: typings.babelTraverse.babelTraverseStrings.TSParameterProperty = "TSParameterProperty".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSParameterProperty]
    
    inline def TSParenthesizedType: typings.babelTraverse.babelTraverseStrings.TSParenthesizedType = "TSParenthesizedType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSParenthesizedType]
    
    inline def TSPropertySignature: typings.babelTraverse.babelTraverseStrings.TSPropertySignature = "TSPropertySignature".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSPropertySignature]
    
    inline def TSQualifiedName: typings.babelTraverse.babelTraverseStrings.TSQualifiedName = "TSQualifiedName".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSQualifiedName]
    
    inline def TSRestType: typings.babelTraverse.babelTraverseStrings.TSRestType = "TSRestType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSRestType]
    
    inline def TSStringKeyword: typings.babelTraverse.babelTraverseStrings.TSStringKeyword = "TSStringKeyword".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSStringKeyword]
    
    inline def TSSymbolKeyword: typings.babelTraverse.babelTraverseStrings.TSSymbolKeyword = "TSSymbolKeyword".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSSymbolKeyword]
    
    inline def TSThisType: typings.babelTraverse.babelTraverseStrings.TSThisType = "TSThisType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSThisType]
    
    inline def TSTupleType: typings.babelTraverse.babelTraverseStrings.TSTupleType = "TSTupleType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSTupleType]
    
    inline def TSType: typings.babelTraverse.babelTraverseStrings.TSType = "TSType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSType]
    
    inline def TSTypeAliasDeclaration: typings.babelTraverse.babelTraverseStrings.TSTypeAliasDeclaration = "TSTypeAliasDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSTypeAliasDeclaration]
    
    inline def TSTypeAnnotation: typings.babelTraverse.babelTraverseStrings.TSTypeAnnotation = "TSTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSTypeAnnotation]
    
    inline def TSTypeAssertion: typings.babelTraverse.babelTraverseStrings.TSTypeAssertion = "TSTypeAssertion".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSTypeAssertion]
    
    inline def TSTypeElement: typings.babelTraverse.babelTraverseStrings.TSTypeElement = "TSTypeElement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSTypeElement]
    
    inline def TSTypeLiteral: typings.babelTraverse.babelTraverseStrings.TSTypeLiteral = "TSTypeLiteral".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSTypeLiteral]
    
    inline def TSTypeOperator: typings.babelTraverse.babelTraverseStrings.TSTypeOperator = "TSTypeOperator".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSTypeOperator]
    
    inline def TSTypeParameter: typings.babelTraverse.babelTraverseStrings.TSTypeParameter = "TSTypeParameter".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSTypeParameter]
    
    inline def TSTypeParameterDeclaration: typings.babelTraverse.babelTraverseStrings.TSTypeParameterDeclaration = "TSTypeParameterDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSTypeParameterDeclaration]
    
    inline def TSTypeParameterInstantiation: typings.babelTraverse.babelTraverseStrings.TSTypeParameterInstantiation = "TSTypeParameterInstantiation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSTypeParameterInstantiation]
    
    inline def TSTypePredicate: typings.babelTraverse.babelTraverseStrings.TSTypePredicate = "TSTypePredicate".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSTypePredicate]
    
    inline def TSTypeQuery: typings.babelTraverse.babelTraverseStrings.TSTypeQuery = "TSTypeQuery".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSTypeQuery]
    
    inline def TSTypeReference: typings.babelTraverse.babelTraverseStrings.TSTypeReference = "TSTypeReference".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSTypeReference]
    
    inline def TSUndefinedKeyword: typings.babelTraverse.babelTraverseStrings.TSUndefinedKeyword = "TSUndefinedKeyword".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSUndefinedKeyword]
    
    inline def TSUnionType: typings.babelTraverse.babelTraverseStrings.TSUnionType = "TSUnionType".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSUnionType]
    
    inline def TSUnknownKeyword: typings.babelTraverse.babelTraverseStrings.TSUnknownKeyword = "TSUnknownKeyword".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSUnknownKeyword]
    
    inline def TSVoidKeyword: typings.babelTraverse.babelTraverseStrings.TSVoidKeyword = "TSVoidKeyword".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TSVoidKeyword]
    
    inline def TaggedTemplateExpression: typings.babelTraverse.babelTraverseStrings.TaggedTemplateExpression = "TaggedTemplateExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TaggedTemplateExpression]
    
    inline def TemplateElement: typings.babelTraverse.babelTraverseStrings.TemplateElement = "TemplateElement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TemplateElement]
    
    inline def TemplateLiteral: typings.babelTraverse.babelTraverseStrings.TemplateLiteral = "TemplateLiteral".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TemplateLiteral]
    
    inline def Terminatorless: typings.babelTraverse.babelTraverseStrings.Terminatorless = "Terminatorless".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Terminatorless]
    
    inline def ThisExpression: typings.babelTraverse.babelTraverseStrings.ThisExpression = "ThisExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ThisExpression]
    
    inline def ThisTypeAnnotation: typings.babelTraverse.babelTraverseStrings.ThisTypeAnnotation = "ThisTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ThisTypeAnnotation]
    
    inline def ThrowStatement: typings.babelTraverse.babelTraverseStrings.ThrowStatement = "ThrowStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.ThrowStatement]
    
    inline def TopicReference: typings.babelTraverse.babelTraverseStrings.TopicReference = "TopicReference".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TopicReference]
    
    inline def TryStatement: typings.babelTraverse.babelTraverseStrings.TryStatement = "TryStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TryStatement]
    
    inline def TupleExpression: typings.babelTraverse.babelTraverseStrings.TupleExpression = "TupleExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TupleExpression]
    
    inline def TupleTypeAnnotation: typings.babelTraverse.babelTraverseStrings.TupleTypeAnnotation = "TupleTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TupleTypeAnnotation]
    
    inline def TypeAlias: typings.babelTraverse.babelTraverseStrings.TypeAlias = "TypeAlias".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TypeAlias]
    
    inline def TypeAnnotation: typings.babelTraverse.babelTraverseStrings.TypeAnnotation = "TypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TypeAnnotation]
    
    inline def TypeCastExpression: typings.babelTraverse.babelTraverseStrings.TypeCastExpression = "TypeCastExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TypeCastExpression]
    
    inline def TypeParameter: typings.babelTraverse.babelTraverseStrings.TypeParameter = "TypeParameter".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TypeParameter]
    
    inline def TypeParameterDeclaration: typings.babelTraverse.babelTraverseStrings.TypeParameterDeclaration = "TypeParameterDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TypeParameterDeclaration]
    
    inline def TypeParameterInstantiation: typings.babelTraverse.babelTraverseStrings.TypeParameterInstantiation = "TypeParameterInstantiation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TypeParameterInstantiation]
    
    inline def TypeScript: typings.babelTraverse.babelTraverseStrings.TypeScript = "TypeScript".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TypeScript]
    
    inline def TypeofTypeAnnotation: typings.babelTraverse.babelTraverseStrings.TypeofTypeAnnotation = "TypeofTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.TypeofTypeAnnotation]
    
    inline def UnaryExpression: typings.babelTraverse.babelTraverseStrings.UnaryExpression = "UnaryExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.UnaryExpression]
    
    inline def UnaryLike: typings.babelTraverse.babelTraverseStrings.UnaryLike = "UnaryLike".asInstanceOf[typings.babelTraverse.babelTraverseStrings.UnaryLike]
    
    inline def UnionTypeAnnotation: typings.babelTraverse.babelTraverseStrings.UnionTypeAnnotation = "UnionTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.UnionTypeAnnotation]
    
    inline def UpdateExpression: typings.babelTraverse.babelTraverseStrings.UpdateExpression = "UpdateExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.UpdateExpression]
    
    inline def UserWhitespacable: typings.babelTraverse.babelTraverseStrings.UserWhitespacable = "UserWhitespacable".asInstanceOf[typings.babelTraverse.babelTraverseStrings.UserWhitespacable]
    
    inline def V8IntrinsicIdentifier: typings.babelTraverse.babelTraverseStrings.V8IntrinsicIdentifier = "V8IntrinsicIdentifier".asInstanceOf[typings.babelTraverse.babelTraverseStrings.V8IntrinsicIdentifier]
    
    inline def VariableDeclaration: typings.babelTraverse.babelTraverseStrings.VariableDeclaration = "VariableDeclaration".asInstanceOf[typings.babelTraverse.babelTraverseStrings.VariableDeclaration]
    
    inline def VariableDeclarator: typings.babelTraverse.babelTraverseStrings.VariableDeclarator = "VariableDeclarator".asInstanceOf[typings.babelTraverse.babelTraverseStrings.VariableDeclarator]
    
    inline def Variance: typings.babelTraverse.babelTraverseStrings.Variance = "Variance".asInstanceOf[typings.babelTraverse.babelTraverseStrings.Variance]
    
    inline def VoidTypeAnnotation: typings.babelTraverse.babelTraverseStrings.VoidTypeAnnotation = "VoidTypeAnnotation".asInstanceOf[typings.babelTraverse.babelTraverseStrings.VoidTypeAnnotation]
    
    inline def While: typings.babelTraverse.babelTraverseStrings.While = "While".asInstanceOf[typings.babelTraverse.babelTraverseStrings.While]
    
    inline def WhileStatement: typings.babelTraverse.babelTraverseStrings.WhileStatement = "WhileStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.WhileStatement]
    
    inline def WithStatement: typings.babelTraverse.babelTraverseStrings.WithStatement = "WithStatement".asInstanceOf[typings.babelTraverse.babelTraverseStrings.WithStatement]
    
    inline def YieldExpression: typings.babelTraverse.babelTraverseStrings.YieldExpression = "YieldExpression".asInstanceOf[typings.babelTraverse.babelTraverseStrings.YieldExpression]
  }
  
  trait TraversalContext extends StObject {
    
    var opts: Any
    
    var parentPath: NodePath[Node]
    
    var scope: Scope
    
    var state: Any
  }
  object TraversalContext {
    
    inline def apply(opts: Any, parentPath: NodePath[Node], scope: Scope, state: Any): TraversalContext = {
      val __obj = js.Dynamic.literal(opts = opts.asInstanceOf[js.Any], parentPath = parentPath.asInstanceOf[js.Any], scope = scope.asInstanceOf[js.Any], state = state.asInstanceOf[js.Any])
      __obj.asInstanceOf[TraversalContext]
    }
    
    extension [Self <: TraversalContext](x: Self) {
      
      inline def setOpts(value: Any): Self = StObject.set(x, "opts", value.asInstanceOf[js.Any])
      
      inline def setParentPath(value: NodePath[Node]): Self = StObject.set(x, "parentPath", value.asInstanceOf[js.Any])
      
      inline def setScope(value: Scope): Self = StObject.set(x, "scope", value.asInstanceOf[js.Any])
      
      inline def setState(value: Any): Self = StObject.set(x, "state", value.asInstanceOf[js.Any])
    }
  }
  
  trait TraverseOptions[S]
    extends StObject
       with Visitor[S] {
    
    var noScope: js.UndefOr[Boolean] = js.undefined
    
    var scope: js.UndefOr[Scope] = js.undefined
  }
  object TraverseOptions {
    
    inline def apply[S](): TraverseOptions[S] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[TraverseOptions[S]]
    }
    
    extension [Self <: TraverseOptions[?], S](x: Self & TraverseOptions[S]) {
      
      inline def setNoScope(value: Boolean): Self = StObject.set(x, "noScope", value.asInstanceOf[js.Any])
      
      inline def setNoScopeUndefined: Self = StObject.set(x, "noScope", js.undefined)
      
      inline def setScope(value: Scope): Self = StObject.set(x, "scope", value.asInstanceOf[js.Any])
      
      inline def setScopeUndefined: Self = StObject.set(x, "scope", js.undefined)
    }
  }
  
  type VisitNode[S, P /* <: Node */] = (VisitNodeFunction[S, P]) | (VisitNodeObject[S, P])
  
  type VisitNodeFunction[S, P /* <: Node */] = js.ThisFunction2[/* this */ S, /* path */ NodePath[P], /* state */ S, Unit]
  
  trait VisitNodeObject[S, P /* <: Node */] extends StObject {
    
    /**
      * @deprecated will be removed in Babel 8
      */
    var blacklist: js.UndefOr[js.Array[NodeType]] = js.undefined
    
    var denylist: js.UndefOr[js.Array[NodeType]] = js.undefined
    
    var enter: js.UndefOr[VisitNodeFunction[S, P]] = js.undefined
    
    var exit: js.UndefOr[VisitNodeFunction[S, P]] = js.undefined
  }
  object VisitNodeObject {
    
    inline def apply[S, P /* <: Node */](): VisitNodeObject[S, P] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[VisitNodeObject[S, P]]
    }
    
    extension [Self <: VisitNodeObject[?, ?], S, P /* <: Node */](x: Self & (VisitNodeObject[S, P])) {
      
      inline def setBlacklist(value: js.Array[NodeType]): Self = StObject.set(x, "blacklist", value.asInstanceOf[js.Any])
      
      inline def setBlacklistUndefined: Self = StObject.set(x, "blacklist", js.undefined)
      
      inline def setBlacklistVarargs(value: NodeType*): Self = StObject.set(x, "blacklist", js.Array(value*))
      
      inline def setDenylist(value: js.Array[NodeType]): Self = StObject.set(x, "denylist", value.asInstanceOf[js.Any])
      
      inline def setDenylistUndefined: Self = StObject.set(x, "denylist", js.undefined)
      
      inline def setDenylistVarargs(value: NodeType*): Self = StObject.set(x, "denylist", js.Array(value*))
      
      inline def setEnter(value: VisitNodeFunction[S, P]): Self = StObject.set(x, "enter", value.asInstanceOf[js.Any])
      
      inline def setEnterUndefined: Self = StObject.set(x, "enter", js.undefined)
      
      inline def setExit(value: VisitNodeFunction[S, P]): Self = StObject.set(x, "exit", value.asInstanceOf[js.Any])
      
      inline def setExitUndefined: Self = StObject.set(x, "exit", js.undefined)
    }
  }
  
  /* Inlined @babel/traverse.@babel/traverse.VisitNodeObject<S, @babel/traverse.@babel/traverse.Node> & {[ Type in @babel/traverse.@babel/traverse.Node['type'] ]:? @babel/traverse.@babel/traverse.VisitNode<S, std.Extract<@babel/traverse.@babel/traverse.Node, {  type :Type}>>} & {[ K in keyof @babel/types.@babel/types.Aliases ]:? @babel/traverse.@babel/traverse.VisitNode<S, @babel/types.@babel/types.Aliases[K]>} */
  trait Visitor[S] extends StObject {
    
    var Accessor: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Accessor]] = js.undefined
    
    var AnyTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `64`]]] = js.undefined
    
    var ArgumentPlaceholder: js.UndefOr[VisitNode[S, Extract[Node, `238`]]] = js.undefined
    
    var ArrayExpression: js.UndefOr[VisitNode[S, Extract[Node, `55`]]] = js.undefined
    
    var ArrayPattern: js.UndefOr[VisitNode[S, Extract[Node, `114`]]] = js.undefined
    
    var ArrayTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `85`]]] = js.undefined
    
    var ArrowFunctionExpression: js.UndefOr[VisitNode[S, Extract[Node, `146`]]] = js.undefined
    
    var AssignmentExpression: js.UndefOr[VisitNode[S, Extract[Node, `134`]]] = js.undefined
    
    var AssignmentPattern: js.UndefOr[VisitNode[S, Extract[Node, `63`]]] = js.undefined
    
    var AwaitExpression: js.UndefOr[VisitNode[S, Extract[Node, `112`]]] = js.undefined
    
    var BigIntLiteral: js.UndefOr[VisitNode[S, Extract[Node, `183`]]] = js.undefined
    
    var Binary: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Binary]] = js.undefined
    
    var BinaryExpression: js.UndefOr[VisitNode[S, Extract[Node, `88`]]] = js.undefined
    
    var BindExpression: js.UndefOr[VisitNode[S, Extract[Node, `78`]]] = js.undefined
    
    var Block: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Block]] = js.undefined
    
    var BlockParent: js.UndefOr[VisitNode[S, typings.babelTypes.mod.BlockParent]] = js.undefined
    
    var BlockStatement: js.UndefOr[VisitNode[S, Extract[Node, `24`]]] = js.undefined
    
    var BooleanLiteral: js.UndefOr[VisitNode[S, Extract[Node, `131`]]] = js.undefined
    
    var BooleanLiteralTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `177`]]] = js.undefined
    
    var BooleanTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `182`]]] = js.undefined
    
    var BreakStatement: js.UndefOr[VisitNode[S, Extract[Node, `1`]]] = js.undefined
    
    var CallExpression: js.UndefOr[VisitNode[S, Extract[Node, `46`]]] = js.undefined
    
    var CatchClause: js.UndefOr[VisitNode[S, Extract[Node, `175`]]] = js.undefined
    
    var Class: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Class]] = js.undefined
    
    var ClassAccessorProperty: js.UndefOr[VisitNode[S, Extract[Node, `213`]]] = js.undefined
    
    var ClassBody: js.UndefOr[VisitNode[S, Extract[Node, `231`]]] = js.undefined
    
    var ClassDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `108`]]] = js.undefined
    
    var ClassExpression: js.UndefOr[VisitNode[S, Extract[Node, Type]]] = js.undefined
    
    var ClassImplements: js.UndefOr[VisitNode[S, Extract[Node, `211`]]] = js.undefined
    
    var ClassMethod: js.UndefOr[VisitNode[S, Extract[Node, `188`]]] = js.undefined
    
    var ClassPrivateMethod: js.UndefOr[VisitNode[S, Extract[Node, `234`]]] = js.undefined
    
    var ClassPrivateProperty: js.UndefOr[VisitNode[S, Extract[Node, `229`]]] = js.undefined
    
    var ClassProperty: js.UndefOr[VisitNode[S, Extract[Node, `191`]]] = js.undefined
    
    var CompletionStatement: js.UndefOr[VisitNode[S, typings.babelTypes.mod.CompletionStatement]] = js.undefined
    
    var Conditional: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Conditional]] = js.undefined
    
    var ConditionalExpression: js.UndefOr[VisitNode[S, Extract[Node, `169`]]] = js.undefined
    
    var ContinueStatement: js.UndefOr[VisitNode[S, Extract[Node, `39`]]] = js.undefined
    
    var DebuggerStatement: js.UndefOr[VisitNode[S, Extract[Node, `137`]]] = js.undefined
    
    var DecimalLiteral: js.UndefOr[VisitNode[S, Extract[Node, `205`]]] = js.undefined
    
    var Declaration: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Declaration]] = js.undefined
    
    var DeclareClass: js.UndefOr[VisitNode[S, Extract[Node, `241`]]] = js.undefined
    
    var DeclareExportAllDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `109`]]] = js.undefined
    
    var DeclareExportDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `157`]]] = js.undefined
    
    var DeclareFunction: js.UndefOr[VisitNode[S, Extract[Node, `104`]]] = js.undefined
    
    var DeclareInterface: js.UndefOr[VisitNode[S, Extract[Node, `160`]]] = js.undefined
    
    var DeclareModule: js.UndefOr[VisitNode[S, Extract[Node, `34`]]] = js.undefined
    
    var DeclareModuleExports: js.UndefOr[VisitNode[S, Extract[Node, `222`]]] = js.undefined
    
    var DeclareOpaqueType: js.UndefOr[VisitNode[S, Extract[Node, `228`]]] = js.undefined
    
    var DeclareTypeAlias: js.UndefOr[VisitNode[S, Extract[Node, `166`]]] = js.undefined
    
    var DeclareVariable: js.UndefOr[VisitNode[S, Extract[Node, `181`]]] = js.undefined
    
    var DeclaredPredicate: js.UndefOr[VisitNode[S, Extract[Node, `187`]]] = js.undefined
    
    var Decorator: js.UndefOr[VisitNode[S, Extract[Node, `81`]]] = js.undefined
    
    var Directive: js.UndefOr[VisitNode[S, Extract[Node, `62`]]] = js.undefined
    
    var DirectiveLiteral: js.UndefOr[VisitNode[S, Extract[Node, `142`]]] = js.undefined
    
    var DoExpression: js.UndefOr[VisitNode[S, Extract[Node, `218`]]] = js.undefined
    
    var DoWhileStatement: js.UndefOr[VisitNode[S, Extract[Node, `199`]]] = js.undefined
    
    var EmptyStatement: js.UndefOr[VisitNode[S, Extract[Node, `107`]]] = js.undefined
    
    var EmptyTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `141`]]] = js.undefined
    
    var EnumBody: js.UndefOr[VisitNode[S, typings.babelTypes.mod.EnumBody]] = js.undefined
    
    var EnumBooleanBody: js.UndefOr[VisitNode[S, Extract[Node, `136`]]] = js.undefined
    
    var EnumBooleanMember: js.UndefOr[VisitNode[S, Extract[Node, `116`]]] = js.undefined
    
    var EnumDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `66`]]] = js.undefined
    
    var EnumDefaultedMember: js.UndefOr[VisitNode[S, Extract[Node, `190`]]] = js.undefined
    
    var EnumMember: js.UndefOr[VisitNode[S, typings.babelTypes.mod.EnumMember]] = js.undefined
    
    var EnumNumberBody: js.UndefOr[VisitNode[S, Extract[Node, `239`]]] = js.undefined
    
    var EnumNumberMember: js.UndefOr[VisitNode[S, Extract[Node, `204`]]] = js.undefined
    
    var EnumStringBody: js.UndefOr[VisitNode[S, Extract[Node, `162`]]] = js.undefined
    
    var EnumStringMember: js.UndefOr[VisitNode[S, Extract[Node, `4`]]] = js.undefined
    
    var EnumSymbolBody: js.UndefOr[VisitNode[S, Extract[Node, `197`]]] = js.undefined
    
    var ExistsTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `118`]]] = js.undefined
    
    var ExportAllDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `36`]]] = js.undefined
    
    var ExportDeclaration: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ExportDeclaration]] = js.undefined
    
    var ExportDefaultDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `79`]]] = js.undefined
    
    var ExportDefaultSpecifier: js.UndefOr[VisitNode[S, Extract[Node, `3`]]] = js.undefined
    
    var ExportNamedDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `45`]]] = js.undefined
    
    var ExportNamespaceSpecifier: js.UndefOr[VisitNode[S, Extract[Node, `178`]]] = js.undefined
    
    var ExportSpecifier: js.UndefOr[VisitNode[S, Extract[Node, `115`]]] = js.undefined
    
    var Expression: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Expression]] = js.undefined
    
    var ExpressionStatement: js.UndefOr[VisitNode[S, Extract[Node, `61`]]] = js.undefined
    
    var ExpressionWrapper: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ExpressionWrapper]] = js.undefined
    
    var File: js.UndefOr[VisitNode[S, Extract[Node, `27`]]] = js.undefined
    
    var Flow: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Flow]] = js.undefined
    
    var FlowBaseAnnotation: js.UndefOr[VisitNode[S, typings.babelTypes.mod.FlowBaseAnnotation]] = js.undefined
    
    var FlowDeclaration: js.UndefOr[VisitNode[S, typings.babelTypes.mod.FlowDeclaration]] = js.undefined
    
    var FlowPredicate: js.UndefOr[VisitNode[S, typings.babelTypes.mod.FlowPredicate]] = js.undefined
    
    var FlowType: js.UndefOr[VisitNode[S, typings.babelTypes.mod.FlowType]] = js.undefined
    
    var For: js.UndefOr[VisitNode[S, typings.babelTypes.mod.For]] = js.undefined
    
    var ForInStatement: js.UndefOr[VisitNode[S, Extract[Node, `16`]]] = js.undefined
    
    var ForOfStatement: js.UndefOr[VisitNode[S, Extract[Node, `165`]]] = js.undefined
    
    var ForStatement: js.UndefOr[VisitNode[S, Extract[Node, `189`]]] = js.undefined
    
    var ForXStatement: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ForXStatement]] = js.undefined
    
    var Function: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Function]] = js.undefined
    
    var FunctionDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `135`]]] = js.undefined
    
    var FunctionExpression: js.UndefOr[VisitNode[S, Extract[Node, `192`]]] = js.undefined
    
    var FunctionParent: js.UndefOr[VisitNode[S, typings.babelTypes.mod.FunctionParent]] = js.undefined
    
    var FunctionTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `40`]]] = js.undefined
    
    var FunctionTypeParam: js.UndefOr[VisitNode[S, Extract[Node, `227`]]] = js.undefined
    
    var GenericTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `243`]]] = js.undefined
    
    var Identifier: js.UndefOr[VisitNode[S, Extract[Node, `98`]]] = js.undefined
    
    var IfStatement: js.UndefOr[VisitNode[S, Extract[Node, `84`]]] = js.undefined
    
    var Immutable: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Immutable]] = js.undefined
    
    var Import: js.UndefOr[VisitNode[S, Extract[Node, `171`]]] = js.undefined
    
    var ImportAttribute: js.UndefOr[VisitNode[S, Extract[Node, `122`]]] = js.undefined
    
    var ImportDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `242`]]] = js.undefined
    
    var ImportDefaultSpecifier: js.UndefOr[VisitNode[S, Extract[Node, `18`]]] = js.undefined
    
    var ImportNamespaceSpecifier: js.UndefOr[VisitNode[S, Extract[Node, `201`]]] = js.undefined
    
    var ImportSpecifier: js.UndefOr[VisitNode[S, Extract[Node, `113`]]] = js.undefined
    
    var IndexedAccessType: js.UndefOr[VisitNode[S, Extract[Node, `68`]]] = js.undefined
    
    var InferredPredicate: js.UndefOr[VisitNode[S, Extract[Node, `133`]]] = js.undefined
    
    var InterfaceDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `47`]]] = js.undefined
    
    var InterfaceExtends: js.UndefOr[VisitNode[S, Extract[Node, `138`]]] = js.undefined
    
    var InterfaceTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `8`]]] = js.undefined
    
    var InterpreterDirective: js.UndefOr[VisitNode[S, Extract[Node, `87`]]] = js.undefined
    
    var IntersectionTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `214`]]] = js.undefined
    
    var JSX: js.UndefOr[VisitNode[S, typings.babelTypes.mod.JSX]] = js.undefined
    
    var JSXAttribute: js.UndefOr[VisitNode[S, Extract[Node, `102`]]] = js.undefined
    
    var JSXClosingElement: js.UndefOr[VisitNode[S, Extract[Node, `128`]]] = js.undefined
    
    var JSXClosingFragment: js.UndefOr[VisitNode[S, Extract[Node, `210`]]] = js.undefined
    
    var JSXElement: js.UndefOr[VisitNode[S, Extract[Node, `173`]]] = js.undefined
    
    var JSXEmptyExpression: js.UndefOr[VisitNode[S, Extract[Node, `124`]]] = js.undefined
    
    var JSXExpressionContainer: js.UndefOr[VisitNode[S, Extract[Node, `31`]]] = js.undefined
    
    var JSXFragment: js.UndefOr[VisitNode[S, Extract[Node, `151`]]] = js.undefined
    
    var JSXIdentifier: js.UndefOr[VisitNode[S, Extract[Node, `86`]]] = js.undefined
    
    var JSXMemberExpression: js.UndefOr[VisitNode[S, Extract[Node, `196`]]] = js.undefined
    
    var JSXNamespacedName: js.UndefOr[VisitNode[S, Extract[Node, `153`]]] = js.undefined
    
    var JSXOpeningElement: js.UndefOr[VisitNode[S, Extract[Node, `73`]]] = js.undefined
    
    var JSXOpeningFragment: js.UndefOr[VisitNode[S, Extract[Node, `219`]]] = js.undefined
    
    var JSXSpreadAttribute: js.UndefOr[VisitNode[S, Extract[Node, `48`]]] = js.undefined
    
    var JSXSpreadChild: js.UndefOr[VisitNode[S, Extract[Node, `72`]]] = js.undefined
    
    var JSXText: js.UndefOr[VisitNode[S, Extract[Node, `194`]]] = js.undefined
    
    var LVal: js.UndefOr[VisitNode[S, typings.babelTypes.mod.LVal]] = js.undefined
    
    var LabeledStatement: js.UndefOr[VisitNode[S, Extract[Node, `35`]]] = js.undefined
    
    var Literal: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Literal]] = js.undefined
    
    var LogicalExpression: js.UndefOr[VisitNode[S, Extract[Node, `69`]]] = js.undefined
    
    var Loop: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Loop]] = js.undefined
    
    var MemberExpression: js.UndefOr[VisitNode[S, Extract[Node, `59`]]] = js.undefined
    
    var MetaProperty: js.UndefOr[VisitNode[S, Extract[Node, `82`]]] = js.undefined
    
    var Method: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Method]] = js.undefined
    
    var Miscellaneous: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Miscellaneous]] = js.undefined
    
    var MixedTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `56`]]] = js.undefined
    
    var ModuleDeclaration: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ModuleDeclaration]] = js.undefined
    
    var ModuleExpression: js.UndefOr[VisitNode[S, Extract[Node, `147`]]] = js.undefined
    
    var ModuleSpecifier: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ModuleSpecifier]] = js.undefined
    
    var NewExpression: js.UndefOr[VisitNode[S, Extract[Node, `58`]]] = js.undefined
    
    var Noop: js.UndefOr[VisitNode[S, Extract[Node, `33`]]] = js.undefined
    
    var NullLiteral: js.UndefOr[VisitNode[S, Extract[Node, `244`]]] = js.undefined
    
    var NullLiteralTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `42`]]] = js.undefined
    
    var NullableTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `97`]]] = js.undefined
    
    var NumberLiteralTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `156`]]] = js.undefined
    
    var NumberTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `163`]]] = js.undefined
    
    var NumericLiteral: js.UndefOr[VisitNode[S, Extract[Node, `216`]]] = js.undefined
    
    var ObjectExpression: js.UndefOr[VisitNode[S, Extract[Node, `123`]]] = js.undefined
    
    var ObjectMember: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ObjectMember]] = js.undefined
    
    var ObjectMethod: js.UndefOr[VisitNode[S, Extract[Node, `125`]]] = js.undefined
    
    var ObjectPattern: js.UndefOr[VisitNode[S, Extract[Node, `223`]]] = js.undefined
    
    var ObjectProperty: js.UndefOr[VisitNode[S, Extract[Node, `143`]]] = js.undefined
    
    var ObjectTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `83`]]] = js.undefined
    
    var ObjectTypeCallProperty: js.UndefOr[VisitNode[S, Extract[Node, `12`]]] = js.undefined
    
    var ObjectTypeIndexer: js.UndefOr[VisitNode[S, Extract[Node, `174`]]] = js.undefined
    
    var ObjectTypeInternalSlot: js.UndefOr[VisitNode[S, Extract[Node, `232`]]] = js.undefined
    
    var ObjectTypeProperty: js.UndefOr[VisitNode[S, Extract[Node, `158`]]] = js.undefined
    
    var ObjectTypeSpreadProperty: js.UndefOr[VisitNode[S, Extract[Node, `80`]]] = js.undefined
    
    var OpaqueType: js.UndefOr[VisitNode[S, Extract[Node, `70`]]] = js.undefined
    
    var OptionalCallExpression: js.UndefOr[VisitNode[S, Extract[Node, `44`]]] = js.undefined
    
    var OptionalIndexedAccessType: js.UndefOr[VisitNode[S, Extract[Node, `145`]]] = js.undefined
    
    var OptionalMemberExpression: js.UndefOr[VisitNode[S, Extract[Node, `26`]]] = js.undefined
    
    var ParenthesizedExpression: js.UndefOr[VisitNode[S, Extract[Node, `203`]]] = js.undefined
    
    var Pattern: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Pattern]] = js.undefined
    
    var PatternLike: js.UndefOr[VisitNode[S, typings.babelTypes.mod.PatternLike]] = js.undefined
    
    var PipelineBareFunction: js.UndefOr[VisitNode[S, Extract[Node, `161`]]] = js.undefined
    
    var PipelinePrimaryTopicReference: js.UndefOr[VisitNode[S, Extract[Node, `30`]]] = js.undefined
    
    var PipelineTopicExpression: js.UndefOr[VisitNode[S, Extract[Node, `105`]]] = js.undefined
    
    var Placeholder: js.UndefOr[VisitNode[S, Extract[Node, `167`]]] = js.undefined
    
    var Private: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Private]] = js.undefined
    
    var PrivateName: js.UndefOr[VisitNode[S, Extract[Node, `94`]]] = js.undefined
    
    var Program: js.UndefOr[VisitNode[S, Extract[Node, `154`]]] = js.undefined
    
    var Property: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Property]] = js.undefined
    
    var Pureish: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Pureish]] = js.undefined
    
    var QualifiedTypeIdentifier: js.UndefOr[VisitNode[S, Extract[Node, `74`]]] = js.undefined
    
    var RecordExpression: js.UndefOr[VisitNode[S, Extract[Node, `60`]]] = js.undefined
    
    var RegExpLiteral: js.UndefOr[VisitNode[S, Extract[Node, `37`]]] = js.undefined
    
    var RestElement: js.UndefOr[VisitNode[S, Extract[Node, `25`]]] = js.undefined
    
    var ReturnStatement: js.UndefOr[VisitNode[S, Extract[Node, `5`]]] = js.undefined
    
    var Scopable: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Scopable]] = js.undefined
    
    var SequenceExpression: js.UndefOr[VisitNode[S, Extract[Node, `170`]]] = js.undefined
    
    var SpreadElement: js.UndefOr[VisitNode[S, Extract[Node, `22`]]] = js.undefined
    
    var Standardized: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Standardized]] = js.undefined
    
    var Statement: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Statement]] = js.undefined
    
    var StaticBlock: js.UndefOr[VisitNode[S, Extract[Node, `110`]]] = js.undefined
    
    var StringLiteral: js.UndefOr[VisitNode[S, Extract[Node, `130`]]] = js.undefined
    
    var StringLiteralTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `225`]]] = js.undefined
    
    var StringTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `2`]]] = js.undefined
    
    var Super: js.UndefOr[VisitNode[S, Extract[Node, `164`]]] = js.undefined
    
    var SwitchCase: js.UndefOr[VisitNode[S, Extract[Node, `53`]]] = js.undefined
    
    var SwitchStatement: js.UndefOr[VisitNode[S, Extract[Node, `43`]]] = js.undefined
    
    var SymbolTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `49`]]] = js.undefined
    
    var TSAnyKeyword: js.UndefOr[VisitNode[S, Extract[Node, `9`]]] = js.undefined
    
    var TSArrayType: js.UndefOr[VisitNode[S, Extract[Node, `0`]]] = js.undefined
    
    var TSAsExpression: js.UndefOr[VisitNode[S, Extract[Node, `7`]]] = js.undefined
    
    var TSBaseType: js.UndefOr[VisitNode[S, typings.babelTypes.mod.TSBaseType]] = js.undefined
    
    var TSBigIntKeyword: js.UndefOr[VisitNode[S, Extract[Node, `52`]]] = js.undefined
    
    var TSBooleanKeyword: js.UndefOr[VisitNode[S, Extract[Node, `224`]]] = js.undefined
    
    var TSCallSignatureDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `150`]]] = js.undefined
    
    var TSConditionalType: js.UndefOr[VisitNode[S, Extract[Node, `17`]]] = js.undefined
    
    var TSConstructSignatureDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `121`]]] = js.undefined
    
    var TSConstructorType: js.UndefOr[VisitNode[S, Extract[Node, `212`]]] = js.undefined
    
    var TSDeclareFunction: js.UndefOr[VisitNode[S, Extract[Node, `200`]]] = js.undefined
    
    var TSDeclareMethod: js.UndefOr[VisitNode[S, Extract[Node, `76`]]] = js.undefined
    
    var TSEntityName: js.UndefOr[VisitNode[S, typings.babelTypes.mod.TSEntityName]] = js.undefined
    
    var TSEnumDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `90`]]] = js.undefined
    
    var TSEnumMember: js.UndefOr[VisitNode[S, Extract[Node, `132`]]] = js.undefined
    
    var TSExportAssignment: js.UndefOr[VisitNode[S, Extract[Node, `144`]]] = js.undefined
    
    var TSExpressionWithTypeArguments: js.UndefOr[VisitNode[S, Extract[Node, `148`]]] = js.undefined
    
    var TSExternalModuleReference: js.UndefOr[VisitNode[S, Extract[Node, `120`]]] = js.undefined
    
    var TSFunctionType: js.UndefOr[VisitNode[S, Extract[Node, `41`]]] = js.undefined
    
    var TSImportEqualsDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `159`]]] = js.undefined
    
    var TSImportType: js.UndefOr[VisitNode[S, Extract[Node, `240`]]] = js.undefined
    
    var TSIndexSignature: js.UndefOr[VisitNode[S, Extract[Node, `206`]]] = js.undefined
    
    var TSIndexedAccessType: js.UndefOr[VisitNode[S, Extract[Node, `28`]]] = js.undefined
    
    var TSInferType: js.UndefOr[VisitNode[S, Extract[Node, `103`]]] = js.undefined
    
    var TSInstantiationExpression: js.UndefOr[VisitNode[S, Extract[Node, `215`]]] = js.undefined
    
    var TSInterfaceBody: js.UndefOr[VisitNode[S, Extract[Node, `6`]]] = js.undefined
    
    var TSInterfaceDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `186`]]] = js.undefined
    
    var TSIntersectionType: js.UndefOr[VisitNode[S, Extract[Node, `237`]]] = js.undefined
    
    var TSIntrinsicKeyword: js.UndefOr[VisitNode[S, Extract[Node, `65`]]] = js.undefined
    
    var TSLiteralType: js.UndefOr[VisitNode[S, Extract[Node, `19`]]] = js.undefined
    
    var TSMappedType: js.UndefOr[VisitNode[S, Extract[Node, `127`]]] = js.undefined
    
    var TSMethodSignature: js.UndefOr[VisitNode[S, Extract[Node, `202`]]] = js.undefined
    
    var TSModuleBlock: js.UndefOr[VisitNode[S, Extract[Node, `230`]]] = js.undefined
    
    var TSModuleDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `15`]]] = js.undefined
    
    var TSNamedTupleMember: js.UndefOr[VisitNode[S, Extract[Node, `221`]]] = js.undefined
    
    var TSNamespaceExportDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `89`]]] = js.undefined
    
    var TSNeverKeyword: js.UndefOr[VisitNode[S, Extract[Node, `236`]]] = js.undefined
    
    var TSNonNullExpression: js.UndefOr[VisitNode[S, Extract[Node, `96`]]] = js.undefined
    
    var TSNullKeyword: js.UndefOr[VisitNode[S, Extract[Node, `32`]]] = js.undefined
    
    var TSNumberKeyword: js.UndefOr[VisitNode[S, Extract[Node, `180`]]] = js.undefined
    
    var TSObjectKeyword: js.UndefOr[VisitNode[S, Extract[Node, `217`]]] = js.undefined
    
    var TSOptionalType: js.UndefOr[VisitNode[S, Extract[Node, `184`]]] = js.undefined
    
    var TSParameterProperty: js.UndefOr[VisitNode[S, Extract[Node, `195`]]] = js.undefined
    
    var TSParenthesizedType: js.UndefOr[VisitNode[S, Extract[Node, `226`]]] = js.undefined
    
    var TSPropertySignature: js.UndefOr[VisitNode[S, Extract[Node, `117`]]] = js.undefined
    
    var TSQualifiedName: js.UndefOr[VisitNode[S, Extract[Node, `29`]]] = js.undefined
    
    var TSRestType: js.UndefOr[VisitNode[S, Extract[Node, `209`]]] = js.undefined
    
    var TSStringKeyword: js.UndefOr[VisitNode[S, Extract[Node, `100`]]] = js.undefined
    
    var TSSymbolKeyword: js.UndefOr[VisitNode[S, Extract[Node, `126`]]] = js.undefined
    
    var TSThisType: js.UndefOr[VisitNode[S, Extract[Node, `207`]]] = js.undefined
    
    var TSTupleType: js.UndefOr[VisitNode[S, Extract[Node, `198`]]] = js.undefined
    
    var TSType: js.UndefOr[VisitNode[S, typings.babelTypes.mod.TSType]] = js.undefined
    
    var TSTypeAliasDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `91`]]] = js.undefined
    
    var TSTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `111`]]] = js.undefined
    
    var TSTypeAssertion: js.UndefOr[VisitNode[S, Extract[Node, `235`]]] = js.undefined
    
    var TSTypeElement: js.UndefOr[VisitNode[S, typings.babelTypes.mod.TSTypeElement]] = js.undefined
    
    var TSTypeLiteral: js.UndefOr[VisitNode[S, Extract[Node, `155`]]] = js.undefined
    
    var TSTypeOperator: js.UndefOr[VisitNode[S, Extract[Node, `51`]]] = js.undefined
    
    var TSTypeParameter: js.UndefOr[VisitNode[S, Extract[Node, `93`]]] = js.undefined
    
    var TSTypeParameterDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `20`]]] = js.undefined
    
    var TSTypeParameterInstantiation: js.UndefOr[VisitNode[S, Extract[Node, `75`]]] = js.undefined
    
    var TSTypePredicate: js.UndefOr[VisitNode[S, Extract[Node, `185`]]] = js.undefined
    
    var TSTypeQuery: js.UndefOr[VisitNode[S, Extract[Node, `119`]]] = js.undefined
    
    var TSTypeReference: js.UndefOr[VisitNode[S, Extract[Node, `246`]]] = js.undefined
    
    var TSUndefinedKeyword: js.UndefOr[VisitNode[S, Extract[Node, `168`]]] = js.undefined
    
    var TSUnionType: js.UndefOr[VisitNode[S, Extract[Node, `92`]]] = js.undefined
    
    var TSUnknownKeyword: js.UndefOr[VisitNode[S, Extract[Node, `54`]]] = js.undefined
    
    var TSVoidKeyword: js.UndefOr[VisitNode[S, Extract[Node, `57`]]] = js.undefined
    
    var TaggedTemplateExpression: js.UndefOr[VisitNode[S, Extract[Node, `71`]]] = js.undefined
    
    var TemplateElement: js.UndefOr[VisitNode[S, Extract[Node, `193`]]] = js.undefined
    
    var TemplateLiteral: js.UndefOr[VisitNode[S, Extract[Node, `77`]]] = js.undefined
    
    var Terminatorless: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Terminatorless]] = js.undefined
    
    var ThisExpression: js.UndefOr[VisitNode[S, Extract[Node, `233`]]] = js.undefined
    
    var ThisTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `50`]]] = js.undefined
    
    var ThrowStatement: js.UndefOr[VisitNode[S, Extract[Node, `139`]]] = js.undefined
    
    var TopicReference: js.UndefOr[VisitNode[S, Extract[Node, `101`]]] = js.undefined
    
    var TryStatement: js.UndefOr[VisitNode[S, Extract[Node, `23`]]] = js.undefined
    
    var TupleExpression: js.UndefOr[VisitNode[S, Extract[Node, `208`]]] = js.undefined
    
    var TupleTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `13`]]] = js.undefined
    
    var TypeAlias: js.UndefOr[VisitNode[S, Extract[Node, `179`]]] = js.undefined
    
    var TypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `21`]]] = js.undefined
    
    var TypeCastExpression: js.UndefOr[VisitNode[S, Extract[Node, `10`]]] = js.undefined
    
    var TypeParameter: js.UndefOr[VisitNode[S, Extract[Node, `172`]]] = js.undefined
    
    var TypeParameterDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `14`]]] = js.undefined
    
    var TypeParameterInstantiation: js.UndefOr[VisitNode[S, Extract[Node, `245`]]] = js.undefined
    
    var TypeScript: js.UndefOr[VisitNode[S, typings.babelTypes.mod.TypeScript]] = js.undefined
    
    var TypeofTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `149`]]] = js.undefined
    
    var UnaryExpression: js.UndefOr[VisitNode[S, Extract[Node, `176`]]] = js.undefined
    
    var UnaryLike: js.UndefOr[VisitNode[S, typings.babelTypes.mod.UnaryLike]] = js.undefined
    
    var UnionTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `220`]]] = js.undefined
    
    var UpdateExpression: js.UndefOr[VisitNode[S, Extract[Node, `99`]]] = js.undefined
    
    var UserWhitespacable: js.UndefOr[VisitNode[S, typings.babelTypes.mod.UserWhitespacable]] = js.undefined
    
    var V8IntrinsicIdentifier: js.UndefOr[VisitNode[S, Extract[Node, `140`]]] = js.undefined
    
    var VariableDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `67`]]] = js.undefined
    
    var VariableDeclarator: js.UndefOr[VisitNode[S, Extract[Node, `129`]]] = js.undefined
    
    var Variance: js.UndefOr[VisitNode[S, Extract[Node, `152`]]] = js.undefined
    
    var VoidTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `106`]]] = js.undefined
    
    var While: js.UndefOr[VisitNode[S, typings.babelTypes.mod.While]] = js.undefined
    
    var WhileStatement: js.UndefOr[VisitNode[S, Extract[Node, `38`]]] = js.undefined
    
    var WithStatement: js.UndefOr[VisitNode[S, Extract[Node, `95`]]] = js.undefined
    
    var YieldExpression: js.UndefOr[VisitNode[S, Extract[Node, `11`]]] = js.undefined
    
    /**
      * @deprecated will be removed in Babel 8
      */
    var blacklist: js.UndefOr[js.Array[NodeType]] = js.undefined
    
    var denylist: js.UndefOr[js.Array[NodeType]] = js.undefined
    
    var enter: js.UndefOr[VisitNodeFunction[S, Node]] = js.undefined
    
    var exit: js.UndefOr[VisitNodeFunction[S, Node]] = js.undefined
  }
  object Visitor {
    
    inline def apply[S](): Visitor[S] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[Visitor[S]]
    }
    
    extension [Self <: Visitor[?], S](x: Self & Visitor[S]) {
      
      inline def setAccessor(value: VisitNode[S, Accessor]): Self = StObject.set(x, "Accessor", value.asInstanceOf[js.Any])
      
      inline def setAccessorUndefined: Self = StObject.set(x, "Accessor", js.undefined)
      
      inline def setAnyTypeAnnotation(value: VisitNode[S, Extract[Node, `64`]]): Self = StObject.set(x, "AnyTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setAnyTypeAnnotationUndefined: Self = StObject.set(x, "AnyTypeAnnotation", js.undefined)
      
      inline def setArgumentPlaceholder(value: VisitNode[S, Extract[Node, `238`]]): Self = StObject.set(x, "ArgumentPlaceholder", value.asInstanceOf[js.Any])
      
      inline def setArgumentPlaceholderUndefined: Self = StObject.set(x, "ArgumentPlaceholder", js.undefined)
      
      inline def setArrayExpression(value: VisitNode[S, Extract[Node, `55`]]): Self = StObject.set(x, "ArrayExpression", value.asInstanceOf[js.Any])
      
      inline def setArrayExpressionUndefined: Self = StObject.set(x, "ArrayExpression", js.undefined)
      
      inline def setArrayPattern(value: VisitNode[S, Extract[Node, `114`]]): Self = StObject.set(x, "ArrayPattern", value.asInstanceOf[js.Any])
      
      inline def setArrayPatternUndefined: Self = StObject.set(x, "ArrayPattern", js.undefined)
      
      inline def setArrayTypeAnnotation(value: VisitNode[S, Extract[Node, `85`]]): Self = StObject.set(x, "ArrayTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setArrayTypeAnnotationUndefined: Self = StObject.set(x, "ArrayTypeAnnotation", js.undefined)
      
      inline def setArrowFunctionExpression(value: VisitNode[S, Extract[Node, `146`]]): Self = StObject.set(x, "ArrowFunctionExpression", value.asInstanceOf[js.Any])
      
      inline def setArrowFunctionExpressionUndefined: Self = StObject.set(x, "ArrowFunctionExpression", js.undefined)
      
      inline def setAssignmentExpression(value: VisitNode[S, Extract[Node, `134`]]): Self = StObject.set(x, "AssignmentExpression", value.asInstanceOf[js.Any])
      
      inline def setAssignmentExpressionUndefined: Self = StObject.set(x, "AssignmentExpression", js.undefined)
      
      inline def setAssignmentPattern(value: VisitNode[S, Extract[Node, `63`]]): Self = StObject.set(x, "AssignmentPattern", value.asInstanceOf[js.Any])
      
      inline def setAssignmentPatternUndefined: Self = StObject.set(x, "AssignmentPattern", js.undefined)
      
      inline def setAwaitExpression(value: VisitNode[S, Extract[Node, `112`]]): Self = StObject.set(x, "AwaitExpression", value.asInstanceOf[js.Any])
      
      inline def setAwaitExpressionUndefined: Self = StObject.set(x, "AwaitExpression", js.undefined)
      
      inline def setBigIntLiteral(value: VisitNode[S, Extract[Node, `183`]]): Self = StObject.set(x, "BigIntLiteral", value.asInstanceOf[js.Any])
      
      inline def setBigIntLiteralUndefined: Self = StObject.set(x, "BigIntLiteral", js.undefined)
      
      inline def setBinary(value: VisitNode[S, Binary]): Self = StObject.set(x, "Binary", value.asInstanceOf[js.Any])
      
      inline def setBinaryExpression(value: VisitNode[S, Extract[Node, `88`]]): Self = StObject.set(x, "BinaryExpression", value.asInstanceOf[js.Any])
      
      inline def setBinaryExpressionUndefined: Self = StObject.set(x, "BinaryExpression", js.undefined)
      
      inline def setBinaryUndefined: Self = StObject.set(x, "Binary", js.undefined)
      
      inline def setBindExpression(value: VisitNode[S, Extract[Node, `78`]]): Self = StObject.set(x, "BindExpression", value.asInstanceOf[js.Any])
      
      inline def setBindExpressionUndefined: Self = StObject.set(x, "BindExpression", js.undefined)
      
      inline def setBlacklist(value: js.Array[NodeType]): Self = StObject.set(x, "blacklist", value.asInstanceOf[js.Any])
      
      inline def setBlacklistUndefined: Self = StObject.set(x, "blacklist", js.undefined)
      
      inline def setBlacklistVarargs(value: NodeType*): Self = StObject.set(x, "blacklist", js.Array(value*))
      
      inline def setBlock(value: VisitNode[S, Block]): Self = StObject.set(x, "Block", value.asInstanceOf[js.Any])
      
      inline def setBlockParent(value: VisitNode[S, BlockParent]): Self = StObject.set(x, "BlockParent", value.asInstanceOf[js.Any])
      
      inline def setBlockParentUndefined: Self = StObject.set(x, "BlockParent", js.undefined)
      
      inline def setBlockStatement(value: VisitNode[S, Extract[Node, `24`]]): Self = StObject.set(x, "BlockStatement", value.asInstanceOf[js.Any])
      
      inline def setBlockStatementUndefined: Self = StObject.set(x, "BlockStatement", js.undefined)
      
      inline def setBlockUndefined: Self = StObject.set(x, "Block", js.undefined)
      
      inline def setBooleanLiteral(value: VisitNode[S, Extract[Node, `131`]]): Self = StObject.set(x, "BooleanLiteral", value.asInstanceOf[js.Any])
      
      inline def setBooleanLiteralTypeAnnotation(value: VisitNode[S, Extract[Node, `177`]]): Self = StObject.set(x, "BooleanLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setBooleanLiteralTypeAnnotationUndefined: Self = StObject.set(x, "BooleanLiteralTypeAnnotation", js.undefined)
      
      inline def setBooleanLiteralUndefined: Self = StObject.set(x, "BooleanLiteral", js.undefined)
      
      inline def setBooleanTypeAnnotation(value: VisitNode[S, Extract[Node, `182`]]): Self = StObject.set(x, "BooleanTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setBooleanTypeAnnotationUndefined: Self = StObject.set(x, "BooleanTypeAnnotation", js.undefined)
      
      inline def setBreakStatement(value: VisitNode[S, Extract[Node, `1`]]): Self = StObject.set(x, "BreakStatement", value.asInstanceOf[js.Any])
      
      inline def setBreakStatementUndefined: Self = StObject.set(x, "BreakStatement", js.undefined)
      
      inline def setCallExpression(value: VisitNode[S, Extract[Node, `46`]]): Self = StObject.set(x, "CallExpression", value.asInstanceOf[js.Any])
      
      inline def setCallExpressionUndefined: Self = StObject.set(x, "CallExpression", js.undefined)
      
      inline def setCatchClause(value: VisitNode[S, Extract[Node, `175`]]): Self = StObject.set(x, "CatchClause", value.asInstanceOf[js.Any])
      
      inline def setCatchClauseUndefined: Self = StObject.set(x, "CatchClause", js.undefined)
      
      inline def setClass(value: VisitNode[S, Class]): Self = StObject.set(x, "Class", value.asInstanceOf[js.Any])
      
      inline def setClassAccessorProperty(value: VisitNode[S, Extract[Node, `213`]]): Self = StObject.set(x, "ClassAccessorProperty", value.asInstanceOf[js.Any])
      
      inline def setClassAccessorPropertyUndefined: Self = StObject.set(x, "ClassAccessorProperty", js.undefined)
      
      inline def setClassBody(value: VisitNode[S, Extract[Node, `231`]]): Self = StObject.set(x, "ClassBody", value.asInstanceOf[js.Any])
      
      inline def setClassBodyUndefined: Self = StObject.set(x, "ClassBody", js.undefined)
      
      inline def setClassDeclaration(value: VisitNode[S, Extract[Node, `108`]]): Self = StObject.set(x, "ClassDeclaration", value.asInstanceOf[js.Any])
      
      inline def setClassDeclarationUndefined: Self = StObject.set(x, "ClassDeclaration", js.undefined)
      
      inline def setClassExpression(value: VisitNode[S, Extract[Node, Type]]): Self = StObject.set(x, "ClassExpression", value.asInstanceOf[js.Any])
      
      inline def setClassExpressionUndefined: Self = StObject.set(x, "ClassExpression", js.undefined)
      
      inline def setClassImplements(value: VisitNode[S, Extract[Node, `211`]]): Self = StObject.set(x, "ClassImplements", value.asInstanceOf[js.Any])
      
      inline def setClassImplementsUndefined: Self = StObject.set(x, "ClassImplements", js.undefined)
      
      inline def setClassMethod(value: VisitNode[S, Extract[Node, `188`]]): Self = StObject.set(x, "ClassMethod", value.asInstanceOf[js.Any])
      
      inline def setClassMethodUndefined: Self = StObject.set(x, "ClassMethod", js.undefined)
      
      inline def setClassPrivateMethod(value: VisitNode[S, Extract[Node, `234`]]): Self = StObject.set(x, "ClassPrivateMethod", value.asInstanceOf[js.Any])
      
      inline def setClassPrivateMethodUndefined: Self = StObject.set(x, "ClassPrivateMethod", js.undefined)
      
      inline def setClassPrivateProperty(value: VisitNode[S, Extract[Node, `229`]]): Self = StObject.set(x, "ClassPrivateProperty", value.asInstanceOf[js.Any])
      
      inline def setClassPrivatePropertyUndefined: Self = StObject.set(x, "ClassPrivateProperty", js.undefined)
      
      inline def setClassProperty(value: VisitNode[S, Extract[Node, `191`]]): Self = StObject.set(x, "ClassProperty", value.asInstanceOf[js.Any])
      
      inline def setClassPropertyUndefined: Self = StObject.set(x, "ClassProperty", js.undefined)
      
      inline def setClassUndefined: Self = StObject.set(x, "Class", js.undefined)
      
      inline def setCompletionStatement(value: VisitNode[S, CompletionStatement]): Self = StObject.set(x, "CompletionStatement", value.asInstanceOf[js.Any])
      
      inline def setCompletionStatementUndefined: Self = StObject.set(x, "CompletionStatement", js.undefined)
      
      inline def setConditional(value: VisitNode[S, Conditional]): Self = StObject.set(x, "Conditional", value.asInstanceOf[js.Any])
      
      inline def setConditionalExpression(value: VisitNode[S, Extract[Node, `169`]]): Self = StObject.set(x, "ConditionalExpression", value.asInstanceOf[js.Any])
      
      inline def setConditionalExpressionUndefined: Self = StObject.set(x, "ConditionalExpression", js.undefined)
      
      inline def setConditionalUndefined: Self = StObject.set(x, "Conditional", js.undefined)
      
      inline def setContinueStatement(value: VisitNode[S, Extract[Node, `39`]]): Self = StObject.set(x, "ContinueStatement", value.asInstanceOf[js.Any])
      
      inline def setContinueStatementUndefined: Self = StObject.set(x, "ContinueStatement", js.undefined)
      
      inline def setDebuggerStatement(value: VisitNode[S, Extract[Node, `137`]]): Self = StObject.set(x, "DebuggerStatement", value.asInstanceOf[js.Any])
      
      inline def setDebuggerStatementUndefined: Self = StObject.set(x, "DebuggerStatement", js.undefined)
      
      inline def setDecimalLiteral(value: VisitNode[S, Extract[Node, `205`]]): Self = StObject.set(x, "DecimalLiteral", value.asInstanceOf[js.Any])
      
      inline def setDecimalLiteralUndefined: Self = StObject.set(x, "DecimalLiteral", js.undefined)
      
      inline def setDeclaration(value: VisitNode[S, Declaration]): Self = StObject.set(x, "Declaration", value.asInstanceOf[js.Any])
      
      inline def setDeclarationUndefined: Self = StObject.set(x, "Declaration", js.undefined)
      
      inline def setDeclareClass(value: VisitNode[S, Extract[Node, `241`]]): Self = StObject.set(x, "DeclareClass", value.asInstanceOf[js.Any])
      
      inline def setDeclareClassUndefined: Self = StObject.set(x, "DeclareClass", js.undefined)
      
      inline def setDeclareExportAllDeclaration(value: VisitNode[S, Extract[Node, `109`]]): Self = StObject.set(x, "DeclareExportAllDeclaration", value.asInstanceOf[js.Any])
      
      inline def setDeclareExportAllDeclarationUndefined: Self = StObject.set(x, "DeclareExportAllDeclaration", js.undefined)
      
      inline def setDeclareExportDeclaration(value: VisitNode[S, Extract[Node, `157`]]): Self = StObject.set(x, "DeclareExportDeclaration", value.asInstanceOf[js.Any])
      
      inline def setDeclareExportDeclarationUndefined: Self = StObject.set(x, "DeclareExportDeclaration", js.undefined)
      
      inline def setDeclareFunction(value: VisitNode[S, Extract[Node, `104`]]): Self = StObject.set(x, "DeclareFunction", value.asInstanceOf[js.Any])
      
      inline def setDeclareFunctionUndefined: Self = StObject.set(x, "DeclareFunction", js.undefined)
      
      inline def setDeclareInterface(value: VisitNode[S, Extract[Node, `160`]]): Self = StObject.set(x, "DeclareInterface", value.asInstanceOf[js.Any])
      
      inline def setDeclareInterfaceUndefined: Self = StObject.set(x, "DeclareInterface", js.undefined)
      
      inline def setDeclareModule(value: VisitNode[S, Extract[Node, `34`]]): Self = StObject.set(x, "DeclareModule", value.asInstanceOf[js.Any])
      
      inline def setDeclareModuleExports(value: VisitNode[S, Extract[Node, `222`]]): Self = StObject.set(x, "DeclareModuleExports", value.asInstanceOf[js.Any])
      
      inline def setDeclareModuleExportsUndefined: Self = StObject.set(x, "DeclareModuleExports", js.undefined)
      
      inline def setDeclareModuleUndefined: Self = StObject.set(x, "DeclareModule", js.undefined)
      
      inline def setDeclareOpaqueType(value: VisitNode[S, Extract[Node, `228`]]): Self = StObject.set(x, "DeclareOpaqueType", value.asInstanceOf[js.Any])
      
      inline def setDeclareOpaqueTypeUndefined: Self = StObject.set(x, "DeclareOpaqueType", js.undefined)
      
      inline def setDeclareTypeAlias(value: VisitNode[S, Extract[Node, `166`]]): Self = StObject.set(x, "DeclareTypeAlias", value.asInstanceOf[js.Any])
      
      inline def setDeclareTypeAliasUndefined: Self = StObject.set(x, "DeclareTypeAlias", js.undefined)
      
      inline def setDeclareVariable(value: VisitNode[S, Extract[Node, `181`]]): Self = StObject.set(x, "DeclareVariable", value.asInstanceOf[js.Any])
      
      inline def setDeclareVariableUndefined: Self = StObject.set(x, "DeclareVariable", js.undefined)
      
      inline def setDeclaredPredicate(value: VisitNode[S, Extract[Node, `187`]]): Self = StObject.set(x, "DeclaredPredicate", value.asInstanceOf[js.Any])
      
      inline def setDeclaredPredicateUndefined: Self = StObject.set(x, "DeclaredPredicate", js.undefined)
      
      inline def setDecorator(value: VisitNode[S, Extract[Node, `81`]]): Self = StObject.set(x, "Decorator", value.asInstanceOf[js.Any])
      
      inline def setDecoratorUndefined: Self = StObject.set(x, "Decorator", js.undefined)
      
      inline def setDenylist(value: js.Array[NodeType]): Self = StObject.set(x, "denylist", value.asInstanceOf[js.Any])
      
      inline def setDenylistUndefined: Self = StObject.set(x, "denylist", js.undefined)
      
      inline def setDenylistVarargs(value: NodeType*): Self = StObject.set(x, "denylist", js.Array(value*))
      
      inline def setDirective(value: VisitNode[S, Extract[Node, `62`]]): Self = StObject.set(x, "Directive", value.asInstanceOf[js.Any])
      
      inline def setDirectiveLiteral(value: VisitNode[S, Extract[Node, `142`]]): Self = StObject.set(x, "DirectiveLiteral", value.asInstanceOf[js.Any])
      
      inline def setDirectiveLiteralUndefined: Self = StObject.set(x, "DirectiveLiteral", js.undefined)
      
      inline def setDirectiveUndefined: Self = StObject.set(x, "Directive", js.undefined)
      
      inline def setDoExpression(value: VisitNode[S, Extract[Node, `218`]]): Self = StObject.set(x, "DoExpression", value.asInstanceOf[js.Any])
      
      inline def setDoExpressionUndefined: Self = StObject.set(x, "DoExpression", js.undefined)
      
      inline def setDoWhileStatement(value: VisitNode[S, Extract[Node, `199`]]): Self = StObject.set(x, "DoWhileStatement", value.asInstanceOf[js.Any])
      
      inline def setDoWhileStatementUndefined: Self = StObject.set(x, "DoWhileStatement", js.undefined)
      
      inline def setEmptyStatement(value: VisitNode[S, Extract[Node, `107`]]): Self = StObject.set(x, "EmptyStatement", value.asInstanceOf[js.Any])
      
      inline def setEmptyStatementUndefined: Self = StObject.set(x, "EmptyStatement", js.undefined)
      
      inline def setEmptyTypeAnnotation(value: VisitNode[S, Extract[Node, `141`]]): Self = StObject.set(x, "EmptyTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setEmptyTypeAnnotationUndefined: Self = StObject.set(x, "EmptyTypeAnnotation", js.undefined)
      
      inline def setEnter(value: VisitNodeFunction[S, Node]): Self = StObject.set(x, "enter", value.asInstanceOf[js.Any])
      
      inline def setEnterUndefined: Self = StObject.set(x, "enter", js.undefined)
      
      inline def setEnumBody(value: VisitNode[S, EnumBody]): Self = StObject.set(x, "EnumBody", value.asInstanceOf[js.Any])
      
      inline def setEnumBodyUndefined: Self = StObject.set(x, "EnumBody", js.undefined)
      
      inline def setEnumBooleanBody(value: VisitNode[S, Extract[Node, `136`]]): Self = StObject.set(x, "EnumBooleanBody", value.asInstanceOf[js.Any])
      
      inline def setEnumBooleanBodyUndefined: Self = StObject.set(x, "EnumBooleanBody", js.undefined)
      
      inline def setEnumBooleanMember(value: VisitNode[S, Extract[Node, `116`]]): Self = StObject.set(x, "EnumBooleanMember", value.asInstanceOf[js.Any])
      
      inline def setEnumBooleanMemberUndefined: Self = StObject.set(x, "EnumBooleanMember", js.undefined)
      
      inline def setEnumDeclaration(value: VisitNode[S, Extract[Node, `66`]]): Self = StObject.set(x, "EnumDeclaration", value.asInstanceOf[js.Any])
      
      inline def setEnumDeclarationUndefined: Self = StObject.set(x, "EnumDeclaration", js.undefined)
      
      inline def setEnumDefaultedMember(value: VisitNode[S, Extract[Node, `190`]]): Self = StObject.set(x, "EnumDefaultedMember", value.asInstanceOf[js.Any])
      
      inline def setEnumDefaultedMemberUndefined: Self = StObject.set(x, "EnumDefaultedMember", js.undefined)
      
      inline def setEnumMember(value: VisitNode[S, EnumMember]): Self = StObject.set(x, "EnumMember", value.asInstanceOf[js.Any])
      
      inline def setEnumMemberUndefined: Self = StObject.set(x, "EnumMember", js.undefined)
      
      inline def setEnumNumberBody(value: VisitNode[S, Extract[Node, `239`]]): Self = StObject.set(x, "EnumNumberBody", value.asInstanceOf[js.Any])
      
      inline def setEnumNumberBodyUndefined: Self = StObject.set(x, "EnumNumberBody", js.undefined)
      
      inline def setEnumNumberMember(value: VisitNode[S, Extract[Node, `204`]]): Self = StObject.set(x, "EnumNumberMember", value.asInstanceOf[js.Any])
      
      inline def setEnumNumberMemberUndefined: Self = StObject.set(x, "EnumNumberMember", js.undefined)
      
      inline def setEnumStringBody(value: VisitNode[S, Extract[Node, `162`]]): Self = StObject.set(x, "EnumStringBody", value.asInstanceOf[js.Any])
      
      inline def setEnumStringBodyUndefined: Self = StObject.set(x, "EnumStringBody", js.undefined)
      
      inline def setEnumStringMember(value: VisitNode[S, Extract[Node, `4`]]): Self = StObject.set(x, "EnumStringMember", value.asInstanceOf[js.Any])
      
      inline def setEnumStringMemberUndefined: Self = StObject.set(x, "EnumStringMember", js.undefined)
      
      inline def setEnumSymbolBody(value: VisitNode[S, Extract[Node, `197`]]): Self = StObject.set(x, "EnumSymbolBody", value.asInstanceOf[js.Any])
      
      inline def setEnumSymbolBodyUndefined: Self = StObject.set(x, "EnumSymbolBody", js.undefined)
      
      inline def setExistsTypeAnnotation(value: VisitNode[S, Extract[Node, `118`]]): Self = StObject.set(x, "ExistsTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setExistsTypeAnnotationUndefined: Self = StObject.set(x, "ExistsTypeAnnotation", js.undefined)
      
      inline def setExit(value: VisitNodeFunction[S, Node]): Self = StObject.set(x, "exit", value.asInstanceOf[js.Any])
      
      inline def setExitUndefined: Self = StObject.set(x, "exit", js.undefined)
      
      inline def setExportAllDeclaration(value: VisitNode[S, Extract[Node, `36`]]): Self = StObject.set(x, "ExportAllDeclaration", value.asInstanceOf[js.Any])
      
      inline def setExportAllDeclarationUndefined: Self = StObject.set(x, "ExportAllDeclaration", js.undefined)
      
      inline def setExportDeclaration(value: VisitNode[S, ExportDeclaration]): Self = StObject.set(x, "ExportDeclaration", value.asInstanceOf[js.Any])
      
      inline def setExportDeclarationUndefined: Self = StObject.set(x, "ExportDeclaration", js.undefined)
      
      inline def setExportDefaultDeclaration(value: VisitNode[S, Extract[Node, `79`]]): Self = StObject.set(x, "ExportDefaultDeclaration", value.asInstanceOf[js.Any])
      
      inline def setExportDefaultDeclarationUndefined: Self = StObject.set(x, "ExportDefaultDeclaration", js.undefined)
      
      inline def setExportDefaultSpecifier(value: VisitNode[S, Extract[Node, `3`]]): Self = StObject.set(x, "ExportDefaultSpecifier", value.asInstanceOf[js.Any])
      
      inline def setExportDefaultSpecifierUndefined: Self = StObject.set(x, "ExportDefaultSpecifier", js.undefined)
      
      inline def setExportNamedDeclaration(value: VisitNode[S, Extract[Node, `45`]]): Self = StObject.set(x, "ExportNamedDeclaration", value.asInstanceOf[js.Any])
      
      inline def setExportNamedDeclarationUndefined: Self = StObject.set(x, "ExportNamedDeclaration", js.undefined)
      
      inline def setExportNamespaceSpecifier(value: VisitNode[S, Extract[Node, `178`]]): Self = StObject.set(x, "ExportNamespaceSpecifier", value.asInstanceOf[js.Any])
      
      inline def setExportNamespaceSpecifierUndefined: Self = StObject.set(x, "ExportNamespaceSpecifier", js.undefined)
      
      inline def setExportSpecifier(value: VisitNode[S, Extract[Node, `115`]]): Self = StObject.set(x, "ExportSpecifier", value.asInstanceOf[js.Any])
      
      inline def setExportSpecifierUndefined: Self = StObject.set(x, "ExportSpecifier", js.undefined)
      
      inline def setExpression(value: VisitNode[S, Expression]): Self = StObject.set(x, "Expression", value.asInstanceOf[js.Any])
      
      inline def setExpressionStatement(value: VisitNode[S, Extract[Node, `61`]]): Self = StObject.set(x, "ExpressionStatement", value.asInstanceOf[js.Any])
      
      inline def setExpressionStatementUndefined: Self = StObject.set(x, "ExpressionStatement", js.undefined)
      
      inline def setExpressionUndefined: Self = StObject.set(x, "Expression", js.undefined)
      
      inline def setExpressionWrapper(value: VisitNode[S, ExpressionWrapper]): Self = StObject.set(x, "ExpressionWrapper", value.asInstanceOf[js.Any])
      
      inline def setExpressionWrapperUndefined: Self = StObject.set(x, "ExpressionWrapper", js.undefined)
      
      inline def setFile(value: VisitNode[S, Extract[Node, `27`]]): Self = StObject.set(x, "File", value.asInstanceOf[js.Any])
      
      inline def setFileUndefined: Self = StObject.set(x, "File", js.undefined)
      
      inline def setFlow(value: VisitNode[S, Flow]): Self = StObject.set(x, "Flow", value.asInstanceOf[js.Any])
      
      inline def setFlowBaseAnnotation(value: VisitNode[S, FlowBaseAnnotation]): Self = StObject.set(x, "FlowBaseAnnotation", value.asInstanceOf[js.Any])
      
      inline def setFlowBaseAnnotationUndefined: Self = StObject.set(x, "FlowBaseAnnotation", js.undefined)
      
      inline def setFlowDeclaration(value: VisitNode[S, FlowDeclaration]): Self = StObject.set(x, "FlowDeclaration", value.asInstanceOf[js.Any])
      
      inline def setFlowDeclarationUndefined: Self = StObject.set(x, "FlowDeclaration", js.undefined)
      
      inline def setFlowPredicate(value: VisitNode[S, FlowPredicate]): Self = StObject.set(x, "FlowPredicate", value.asInstanceOf[js.Any])
      
      inline def setFlowPredicateUndefined: Self = StObject.set(x, "FlowPredicate", js.undefined)
      
      inline def setFlowType(value: VisitNode[S, FlowType]): Self = StObject.set(x, "FlowType", value.asInstanceOf[js.Any])
      
      inline def setFlowTypeUndefined: Self = StObject.set(x, "FlowType", js.undefined)
      
      inline def setFlowUndefined: Self = StObject.set(x, "Flow", js.undefined)
      
      inline def setFor(value: VisitNode[S, For]): Self = StObject.set(x, "For", value.asInstanceOf[js.Any])
      
      inline def setForInStatement(value: VisitNode[S, Extract[Node, `16`]]): Self = StObject.set(x, "ForInStatement", value.asInstanceOf[js.Any])
      
      inline def setForInStatementUndefined: Self = StObject.set(x, "ForInStatement", js.undefined)
      
      inline def setForOfStatement(value: VisitNode[S, Extract[Node, `165`]]): Self = StObject.set(x, "ForOfStatement", value.asInstanceOf[js.Any])
      
      inline def setForOfStatementUndefined: Self = StObject.set(x, "ForOfStatement", js.undefined)
      
      inline def setForStatement(value: VisitNode[S, Extract[Node, `189`]]): Self = StObject.set(x, "ForStatement", value.asInstanceOf[js.Any])
      
      inline def setForStatementUndefined: Self = StObject.set(x, "ForStatement", js.undefined)
      
      inline def setForUndefined: Self = StObject.set(x, "For", js.undefined)
      
      inline def setForXStatement(value: VisitNode[S, ForXStatement]): Self = StObject.set(x, "ForXStatement", value.asInstanceOf[js.Any])
      
      inline def setForXStatementUndefined: Self = StObject.set(x, "ForXStatement", js.undefined)
      
      inline def setFunction(value: VisitNode[S, Function]): Self = StObject.set(x, "Function", value.asInstanceOf[js.Any])
      
      inline def setFunctionDeclaration(value: VisitNode[S, Extract[Node, `135`]]): Self = StObject.set(x, "FunctionDeclaration", value.asInstanceOf[js.Any])
      
      inline def setFunctionDeclarationUndefined: Self = StObject.set(x, "FunctionDeclaration", js.undefined)
      
      inline def setFunctionExpression(value: VisitNode[S, Extract[Node, `192`]]): Self = StObject.set(x, "FunctionExpression", value.asInstanceOf[js.Any])
      
      inline def setFunctionExpressionUndefined: Self = StObject.set(x, "FunctionExpression", js.undefined)
      
      inline def setFunctionParent(value: VisitNode[S, FunctionParent]): Self = StObject.set(x, "FunctionParent", value.asInstanceOf[js.Any])
      
      inline def setFunctionParentUndefined: Self = StObject.set(x, "FunctionParent", js.undefined)
      
      inline def setFunctionTypeAnnotation(value: VisitNode[S, Extract[Node, `40`]]): Self = StObject.set(x, "FunctionTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setFunctionTypeAnnotationUndefined: Self = StObject.set(x, "FunctionTypeAnnotation", js.undefined)
      
      inline def setFunctionTypeParam(value: VisitNode[S, Extract[Node, `227`]]): Self = StObject.set(x, "FunctionTypeParam", value.asInstanceOf[js.Any])
      
      inline def setFunctionTypeParamUndefined: Self = StObject.set(x, "FunctionTypeParam", js.undefined)
      
      inline def setFunctionUndefined: Self = StObject.set(x, "Function", js.undefined)
      
      inline def setGenericTypeAnnotation(value: VisitNode[S, Extract[Node, `243`]]): Self = StObject.set(x, "GenericTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setGenericTypeAnnotationUndefined: Self = StObject.set(x, "GenericTypeAnnotation", js.undefined)
      
      inline def setIdentifier(value: VisitNode[S, Extract[Node, `98`]]): Self = StObject.set(x, "Identifier", value.asInstanceOf[js.Any])
      
      inline def setIdentifierUndefined: Self = StObject.set(x, "Identifier", js.undefined)
      
      inline def setIfStatement(value: VisitNode[S, Extract[Node, `84`]]): Self = StObject.set(x, "IfStatement", value.asInstanceOf[js.Any])
      
      inline def setIfStatementUndefined: Self = StObject.set(x, "IfStatement", js.undefined)
      
      inline def setImmutable(value: VisitNode[S, Immutable]): Self = StObject.set(x, "Immutable", value.asInstanceOf[js.Any])
      
      inline def setImmutableUndefined: Self = StObject.set(x, "Immutable", js.undefined)
      
      inline def setImport(value: VisitNode[S, Extract[Node, `171`]]): Self = StObject.set(x, "Import", value.asInstanceOf[js.Any])
      
      inline def setImportAttribute(value: VisitNode[S, Extract[Node, `122`]]): Self = StObject.set(x, "ImportAttribute", value.asInstanceOf[js.Any])
      
      inline def setImportAttributeUndefined: Self = StObject.set(x, "ImportAttribute", js.undefined)
      
      inline def setImportDeclaration(value: VisitNode[S, Extract[Node, `242`]]): Self = StObject.set(x, "ImportDeclaration", value.asInstanceOf[js.Any])
      
      inline def setImportDeclarationUndefined: Self = StObject.set(x, "ImportDeclaration", js.undefined)
      
      inline def setImportDefaultSpecifier(value: VisitNode[S, Extract[Node, `18`]]): Self = StObject.set(x, "ImportDefaultSpecifier", value.asInstanceOf[js.Any])
      
      inline def setImportDefaultSpecifierUndefined: Self = StObject.set(x, "ImportDefaultSpecifier", js.undefined)
      
      inline def setImportNamespaceSpecifier(value: VisitNode[S, Extract[Node, `201`]]): Self = StObject.set(x, "ImportNamespaceSpecifier", value.asInstanceOf[js.Any])
      
      inline def setImportNamespaceSpecifierUndefined: Self = StObject.set(x, "ImportNamespaceSpecifier", js.undefined)
      
      inline def setImportSpecifier(value: VisitNode[S, Extract[Node, `113`]]): Self = StObject.set(x, "ImportSpecifier", value.asInstanceOf[js.Any])
      
      inline def setImportSpecifierUndefined: Self = StObject.set(x, "ImportSpecifier", js.undefined)
      
      inline def setImportUndefined: Self = StObject.set(x, "Import", js.undefined)
      
      inline def setIndexedAccessType(value: VisitNode[S, Extract[Node, `68`]]): Self = StObject.set(x, "IndexedAccessType", value.asInstanceOf[js.Any])
      
      inline def setIndexedAccessTypeUndefined: Self = StObject.set(x, "IndexedAccessType", js.undefined)
      
      inline def setInferredPredicate(value: VisitNode[S, Extract[Node, `133`]]): Self = StObject.set(x, "InferredPredicate", value.asInstanceOf[js.Any])
      
      inline def setInferredPredicateUndefined: Self = StObject.set(x, "InferredPredicate", js.undefined)
      
      inline def setInterfaceDeclaration(value: VisitNode[S, Extract[Node, `47`]]): Self = StObject.set(x, "InterfaceDeclaration", value.asInstanceOf[js.Any])
      
      inline def setInterfaceDeclarationUndefined: Self = StObject.set(x, "InterfaceDeclaration", js.undefined)
      
      inline def setInterfaceExtends(value: VisitNode[S, Extract[Node, `138`]]): Self = StObject.set(x, "InterfaceExtends", value.asInstanceOf[js.Any])
      
      inline def setInterfaceExtendsUndefined: Self = StObject.set(x, "InterfaceExtends", js.undefined)
      
      inline def setInterfaceTypeAnnotation(value: VisitNode[S, Extract[Node, `8`]]): Self = StObject.set(x, "InterfaceTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setInterfaceTypeAnnotationUndefined: Self = StObject.set(x, "InterfaceTypeAnnotation", js.undefined)
      
      inline def setInterpreterDirective(value: VisitNode[S, Extract[Node, `87`]]): Self = StObject.set(x, "InterpreterDirective", value.asInstanceOf[js.Any])
      
      inline def setInterpreterDirectiveUndefined: Self = StObject.set(x, "InterpreterDirective", js.undefined)
      
      inline def setIntersectionTypeAnnotation(value: VisitNode[S, Extract[Node, `214`]]): Self = StObject.set(x, "IntersectionTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setIntersectionTypeAnnotationUndefined: Self = StObject.set(x, "IntersectionTypeAnnotation", js.undefined)
      
      inline def setJSX(value: VisitNode[S, JSX]): Self = StObject.set(x, "JSX", value.asInstanceOf[js.Any])
      
      inline def setJSXAttribute(value: VisitNode[S, Extract[Node, `102`]]): Self = StObject.set(x, "JSXAttribute", value.asInstanceOf[js.Any])
      
      inline def setJSXAttributeUndefined: Self = StObject.set(x, "JSXAttribute", js.undefined)
      
      inline def setJSXClosingElement(value: VisitNode[S, Extract[Node, `128`]]): Self = StObject.set(x, "JSXClosingElement", value.asInstanceOf[js.Any])
      
      inline def setJSXClosingElementUndefined: Self = StObject.set(x, "JSXClosingElement", js.undefined)
      
      inline def setJSXClosingFragment(value: VisitNode[S, Extract[Node, `210`]]): Self = StObject.set(x, "JSXClosingFragment", value.asInstanceOf[js.Any])
      
      inline def setJSXClosingFragmentUndefined: Self = StObject.set(x, "JSXClosingFragment", js.undefined)
      
      inline def setJSXElement(value: VisitNode[S, Extract[Node, `173`]]): Self = StObject.set(x, "JSXElement", value.asInstanceOf[js.Any])
      
      inline def setJSXElementUndefined: Self = StObject.set(x, "JSXElement", js.undefined)
      
      inline def setJSXEmptyExpression(value: VisitNode[S, Extract[Node, `124`]]): Self = StObject.set(x, "JSXEmptyExpression", value.asInstanceOf[js.Any])
      
      inline def setJSXEmptyExpressionUndefined: Self = StObject.set(x, "JSXEmptyExpression", js.undefined)
      
      inline def setJSXExpressionContainer(value: VisitNode[S, Extract[Node, `31`]]): Self = StObject.set(x, "JSXExpressionContainer", value.asInstanceOf[js.Any])
      
      inline def setJSXExpressionContainerUndefined: Self = StObject.set(x, "JSXExpressionContainer", js.undefined)
      
      inline def setJSXFragment(value: VisitNode[S, Extract[Node, `151`]]): Self = StObject.set(x, "JSXFragment", value.asInstanceOf[js.Any])
      
      inline def setJSXFragmentUndefined: Self = StObject.set(x, "JSXFragment", js.undefined)
      
      inline def setJSXIdentifier(value: VisitNode[S, Extract[Node, `86`]]): Self = StObject.set(x, "JSXIdentifier", value.asInstanceOf[js.Any])
      
      inline def setJSXIdentifierUndefined: Self = StObject.set(x, "JSXIdentifier", js.undefined)
      
      inline def setJSXMemberExpression(value: VisitNode[S, Extract[Node, `196`]]): Self = StObject.set(x, "JSXMemberExpression", value.asInstanceOf[js.Any])
      
      inline def setJSXMemberExpressionUndefined: Self = StObject.set(x, "JSXMemberExpression", js.undefined)
      
      inline def setJSXNamespacedName(value: VisitNode[S, Extract[Node, `153`]]): Self = StObject.set(x, "JSXNamespacedName", value.asInstanceOf[js.Any])
      
      inline def setJSXNamespacedNameUndefined: Self = StObject.set(x, "JSXNamespacedName", js.undefined)
      
      inline def setJSXOpeningElement(value: VisitNode[S, Extract[Node, `73`]]): Self = StObject.set(x, "JSXOpeningElement", value.asInstanceOf[js.Any])
      
      inline def setJSXOpeningElementUndefined: Self = StObject.set(x, "JSXOpeningElement", js.undefined)
      
      inline def setJSXOpeningFragment(value: VisitNode[S, Extract[Node, `219`]]): Self = StObject.set(x, "JSXOpeningFragment", value.asInstanceOf[js.Any])
      
      inline def setJSXOpeningFragmentUndefined: Self = StObject.set(x, "JSXOpeningFragment", js.undefined)
      
      inline def setJSXSpreadAttribute(value: VisitNode[S, Extract[Node, `48`]]): Self = StObject.set(x, "JSXSpreadAttribute", value.asInstanceOf[js.Any])
      
      inline def setJSXSpreadAttributeUndefined: Self = StObject.set(x, "JSXSpreadAttribute", js.undefined)
      
      inline def setJSXSpreadChild(value: VisitNode[S, Extract[Node, `72`]]): Self = StObject.set(x, "JSXSpreadChild", value.asInstanceOf[js.Any])
      
      inline def setJSXSpreadChildUndefined: Self = StObject.set(x, "JSXSpreadChild", js.undefined)
      
      inline def setJSXText(value: VisitNode[S, Extract[Node, `194`]]): Self = StObject.set(x, "JSXText", value.asInstanceOf[js.Any])
      
      inline def setJSXTextUndefined: Self = StObject.set(x, "JSXText", js.undefined)
      
      inline def setJSXUndefined: Self = StObject.set(x, "JSX", js.undefined)
      
      inline def setLVal(value: VisitNode[S, LVal]): Self = StObject.set(x, "LVal", value.asInstanceOf[js.Any])
      
      inline def setLValUndefined: Self = StObject.set(x, "LVal", js.undefined)
      
      inline def setLabeledStatement(value: VisitNode[S, Extract[Node, `35`]]): Self = StObject.set(x, "LabeledStatement", value.asInstanceOf[js.Any])
      
      inline def setLabeledStatementUndefined: Self = StObject.set(x, "LabeledStatement", js.undefined)
      
      inline def setLiteral(value: VisitNode[S, Literal]): Self = StObject.set(x, "Literal", value.asInstanceOf[js.Any])
      
      inline def setLiteralUndefined: Self = StObject.set(x, "Literal", js.undefined)
      
      inline def setLogicalExpression(value: VisitNode[S, Extract[Node, `69`]]): Self = StObject.set(x, "LogicalExpression", value.asInstanceOf[js.Any])
      
      inline def setLogicalExpressionUndefined: Self = StObject.set(x, "LogicalExpression", js.undefined)
      
      inline def setLoop(value: VisitNode[S, Loop]): Self = StObject.set(x, "Loop", value.asInstanceOf[js.Any])
      
      inline def setLoopUndefined: Self = StObject.set(x, "Loop", js.undefined)
      
      inline def setMemberExpression(value: VisitNode[S, Extract[Node, `59`]]): Self = StObject.set(x, "MemberExpression", value.asInstanceOf[js.Any])
      
      inline def setMemberExpressionUndefined: Self = StObject.set(x, "MemberExpression", js.undefined)
      
      inline def setMetaProperty(value: VisitNode[S, Extract[Node, `82`]]): Self = StObject.set(x, "MetaProperty", value.asInstanceOf[js.Any])
      
      inline def setMetaPropertyUndefined: Self = StObject.set(x, "MetaProperty", js.undefined)
      
      inline def setMethod(value: VisitNode[S, Method]): Self = StObject.set(x, "Method", value.asInstanceOf[js.Any])
      
      inline def setMethodUndefined: Self = StObject.set(x, "Method", js.undefined)
      
      inline def setMiscellaneous(value: VisitNode[S, Miscellaneous]): Self = StObject.set(x, "Miscellaneous", value.asInstanceOf[js.Any])
      
      inline def setMiscellaneousUndefined: Self = StObject.set(x, "Miscellaneous", js.undefined)
      
      inline def setMixedTypeAnnotation(value: VisitNode[S, Extract[Node, `56`]]): Self = StObject.set(x, "MixedTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setMixedTypeAnnotationUndefined: Self = StObject.set(x, "MixedTypeAnnotation", js.undefined)
      
      inline def setModuleDeclaration(value: VisitNode[S, ModuleDeclaration]): Self = StObject.set(x, "ModuleDeclaration", value.asInstanceOf[js.Any])
      
      inline def setModuleDeclarationUndefined: Self = StObject.set(x, "ModuleDeclaration", js.undefined)
      
      inline def setModuleExpression(value: VisitNode[S, Extract[Node, `147`]]): Self = StObject.set(x, "ModuleExpression", value.asInstanceOf[js.Any])
      
      inline def setModuleExpressionUndefined: Self = StObject.set(x, "ModuleExpression", js.undefined)
      
      inline def setModuleSpecifier(value: VisitNode[S, ModuleSpecifier]): Self = StObject.set(x, "ModuleSpecifier", value.asInstanceOf[js.Any])
      
      inline def setModuleSpecifierUndefined: Self = StObject.set(x, "ModuleSpecifier", js.undefined)
      
      inline def setNewExpression(value: VisitNode[S, Extract[Node, `58`]]): Self = StObject.set(x, "NewExpression", value.asInstanceOf[js.Any])
      
      inline def setNewExpressionUndefined: Self = StObject.set(x, "NewExpression", js.undefined)
      
      inline def setNoop(value: VisitNode[S, Extract[Node, `33`]]): Self = StObject.set(x, "Noop", value.asInstanceOf[js.Any])
      
      inline def setNoopUndefined: Self = StObject.set(x, "Noop", js.undefined)
      
      inline def setNullLiteral(value: VisitNode[S, Extract[Node, `244`]]): Self = StObject.set(x, "NullLiteral", value.asInstanceOf[js.Any])
      
      inline def setNullLiteralTypeAnnotation(value: VisitNode[S, Extract[Node, `42`]]): Self = StObject.set(x, "NullLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setNullLiteralTypeAnnotationUndefined: Self = StObject.set(x, "NullLiteralTypeAnnotation", js.undefined)
      
      inline def setNullLiteralUndefined: Self = StObject.set(x, "NullLiteral", js.undefined)
      
      inline def setNullableTypeAnnotation(value: VisitNode[S, Extract[Node, `97`]]): Self = StObject.set(x, "NullableTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setNullableTypeAnnotationUndefined: Self = StObject.set(x, "NullableTypeAnnotation", js.undefined)
      
      inline def setNumberLiteralTypeAnnotation(value: VisitNode[S, Extract[Node, `156`]]): Self = StObject.set(x, "NumberLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setNumberLiteralTypeAnnotationUndefined: Self = StObject.set(x, "NumberLiteralTypeAnnotation", js.undefined)
      
      inline def setNumberTypeAnnotation(value: VisitNode[S, Extract[Node, `163`]]): Self = StObject.set(x, "NumberTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setNumberTypeAnnotationUndefined: Self = StObject.set(x, "NumberTypeAnnotation", js.undefined)
      
      inline def setNumericLiteral(value: VisitNode[S, Extract[Node, `216`]]): Self = StObject.set(x, "NumericLiteral", value.asInstanceOf[js.Any])
      
      inline def setNumericLiteralUndefined: Self = StObject.set(x, "NumericLiteral", js.undefined)
      
      inline def setObjectExpression(value: VisitNode[S, Extract[Node, `123`]]): Self = StObject.set(x, "ObjectExpression", value.asInstanceOf[js.Any])
      
      inline def setObjectExpressionUndefined: Self = StObject.set(x, "ObjectExpression", js.undefined)
      
      inline def setObjectMember(value: VisitNode[S, ObjectMember]): Self = StObject.set(x, "ObjectMember", value.asInstanceOf[js.Any])
      
      inline def setObjectMemberUndefined: Self = StObject.set(x, "ObjectMember", js.undefined)
      
      inline def setObjectMethod(value: VisitNode[S, Extract[Node, `125`]]): Self = StObject.set(x, "ObjectMethod", value.asInstanceOf[js.Any])
      
      inline def setObjectMethodUndefined: Self = StObject.set(x, "ObjectMethod", js.undefined)
      
      inline def setObjectPattern(value: VisitNode[S, Extract[Node, `223`]]): Self = StObject.set(x, "ObjectPattern", value.asInstanceOf[js.Any])
      
      inline def setObjectPatternUndefined: Self = StObject.set(x, "ObjectPattern", js.undefined)
      
      inline def setObjectProperty(value: VisitNode[S, Extract[Node, `143`]]): Self = StObject.set(x, "ObjectProperty", value.asInstanceOf[js.Any])
      
      inline def setObjectPropertyUndefined: Self = StObject.set(x, "ObjectProperty", js.undefined)
      
      inline def setObjectTypeAnnotation(value: VisitNode[S, Extract[Node, `83`]]): Self = StObject.set(x, "ObjectTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setObjectTypeAnnotationUndefined: Self = StObject.set(x, "ObjectTypeAnnotation", js.undefined)
      
      inline def setObjectTypeCallProperty(value: VisitNode[S, Extract[Node, `12`]]): Self = StObject.set(x, "ObjectTypeCallProperty", value.asInstanceOf[js.Any])
      
      inline def setObjectTypeCallPropertyUndefined: Self = StObject.set(x, "ObjectTypeCallProperty", js.undefined)
      
      inline def setObjectTypeIndexer(value: VisitNode[S, Extract[Node, `174`]]): Self = StObject.set(x, "ObjectTypeIndexer", value.asInstanceOf[js.Any])
      
      inline def setObjectTypeIndexerUndefined: Self = StObject.set(x, "ObjectTypeIndexer", js.undefined)
      
      inline def setObjectTypeInternalSlot(value: VisitNode[S, Extract[Node, `232`]]): Self = StObject.set(x, "ObjectTypeInternalSlot", value.asInstanceOf[js.Any])
      
      inline def setObjectTypeInternalSlotUndefined: Self = StObject.set(x, "ObjectTypeInternalSlot", js.undefined)
      
      inline def setObjectTypeProperty(value: VisitNode[S, Extract[Node, `158`]]): Self = StObject.set(x, "ObjectTypeProperty", value.asInstanceOf[js.Any])
      
      inline def setObjectTypePropertyUndefined: Self = StObject.set(x, "ObjectTypeProperty", js.undefined)
      
      inline def setObjectTypeSpreadProperty(value: VisitNode[S, Extract[Node, `80`]]): Self = StObject.set(x, "ObjectTypeSpreadProperty", value.asInstanceOf[js.Any])
      
      inline def setObjectTypeSpreadPropertyUndefined: Self = StObject.set(x, "ObjectTypeSpreadProperty", js.undefined)
      
      inline def setOpaqueType(value: VisitNode[S, Extract[Node, `70`]]): Self = StObject.set(x, "OpaqueType", value.asInstanceOf[js.Any])
      
      inline def setOpaqueTypeUndefined: Self = StObject.set(x, "OpaqueType", js.undefined)
      
      inline def setOptionalCallExpression(value: VisitNode[S, Extract[Node, `44`]]): Self = StObject.set(x, "OptionalCallExpression", value.asInstanceOf[js.Any])
      
      inline def setOptionalCallExpressionUndefined: Self = StObject.set(x, "OptionalCallExpression", js.undefined)
      
      inline def setOptionalIndexedAccessType(value: VisitNode[S, Extract[Node, `145`]]): Self = StObject.set(x, "OptionalIndexedAccessType", value.asInstanceOf[js.Any])
      
      inline def setOptionalIndexedAccessTypeUndefined: Self = StObject.set(x, "OptionalIndexedAccessType", js.undefined)
      
      inline def setOptionalMemberExpression(value: VisitNode[S, Extract[Node, `26`]]): Self = StObject.set(x, "OptionalMemberExpression", value.asInstanceOf[js.Any])
      
      inline def setOptionalMemberExpressionUndefined: Self = StObject.set(x, "OptionalMemberExpression", js.undefined)
      
      inline def setParenthesizedExpression(value: VisitNode[S, Extract[Node, `203`]]): Self = StObject.set(x, "ParenthesizedExpression", value.asInstanceOf[js.Any])
      
      inline def setParenthesizedExpressionUndefined: Self = StObject.set(x, "ParenthesizedExpression", js.undefined)
      
      inline def setPattern(value: VisitNode[S, Pattern]): Self = StObject.set(x, "Pattern", value.asInstanceOf[js.Any])
      
      inline def setPatternLike(value: VisitNode[S, PatternLike]): Self = StObject.set(x, "PatternLike", value.asInstanceOf[js.Any])
      
      inline def setPatternLikeUndefined: Self = StObject.set(x, "PatternLike", js.undefined)
      
      inline def setPatternUndefined: Self = StObject.set(x, "Pattern", js.undefined)
      
      inline def setPipelineBareFunction(value: VisitNode[S, Extract[Node, `161`]]): Self = StObject.set(x, "PipelineBareFunction", value.asInstanceOf[js.Any])
      
      inline def setPipelineBareFunctionUndefined: Self = StObject.set(x, "PipelineBareFunction", js.undefined)
      
      inline def setPipelinePrimaryTopicReference(value: VisitNode[S, Extract[Node, `30`]]): Self = StObject.set(x, "PipelinePrimaryTopicReference", value.asInstanceOf[js.Any])
      
      inline def setPipelinePrimaryTopicReferenceUndefined: Self = StObject.set(x, "PipelinePrimaryTopicReference", js.undefined)
      
      inline def setPipelineTopicExpression(value: VisitNode[S, Extract[Node, `105`]]): Self = StObject.set(x, "PipelineTopicExpression", value.asInstanceOf[js.Any])
      
      inline def setPipelineTopicExpressionUndefined: Self = StObject.set(x, "PipelineTopicExpression", js.undefined)
      
      inline def setPlaceholder(value: VisitNode[S, Extract[Node, `167`]]): Self = StObject.set(x, "Placeholder", value.asInstanceOf[js.Any])
      
      inline def setPlaceholderUndefined: Self = StObject.set(x, "Placeholder", js.undefined)
      
      inline def setPrivate(value: VisitNode[S, Private]): Self = StObject.set(x, "Private", value.asInstanceOf[js.Any])
      
      inline def setPrivateName(value: VisitNode[S, Extract[Node, `94`]]): Self = StObject.set(x, "PrivateName", value.asInstanceOf[js.Any])
      
      inline def setPrivateNameUndefined: Self = StObject.set(x, "PrivateName", js.undefined)
      
      inline def setPrivateUndefined: Self = StObject.set(x, "Private", js.undefined)
      
      inline def setProgram(value: VisitNode[S, Extract[Node, `154`]]): Self = StObject.set(x, "Program", value.asInstanceOf[js.Any])
      
      inline def setProgramUndefined: Self = StObject.set(x, "Program", js.undefined)
      
      inline def setProperty(value: VisitNode[S, Property]): Self = StObject.set(x, "Property", value.asInstanceOf[js.Any])
      
      inline def setPropertyUndefined: Self = StObject.set(x, "Property", js.undefined)
      
      inline def setPureish(value: VisitNode[S, Pureish]): Self = StObject.set(x, "Pureish", value.asInstanceOf[js.Any])
      
      inline def setPureishUndefined: Self = StObject.set(x, "Pureish", js.undefined)
      
      inline def setQualifiedTypeIdentifier(value: VisitNode[S, Extract[Node, `74`]]): Self = StObject.set(x, "QualifiedTypeIdentifier", value.asInstanceOf[js.Any])
      
      inline def setQualifiedTypeIdentifierUndefined: Self = StObject.set(x, "QualifiedTypeIdentifier", js.undefined)
      
      inline def setRecordExpression(value: VisitNode[S, Extract[Node, `60`]]): Self = StObject.set(x, "RecordExpression", value.asInstanceOf[js.Any])
      
      inline def setRecordExpressionUndefined: Self = StObject.set(x, "RecordExpression", js.undefined)
      
      inline def setRegExpLiteral(value: VisitNode[S, Extract[Node, `37`]]): Self = StObject.set(x, "RegExpLiteral", value.asInstanceOf[js.Any])
      
      inline def setRegExpLiteralUndefined: Self = StObject.set(x, "RegExpLiteral", js.undefined)
      
      inline def setRestElement(value: VisitNode[S, Extract[Node, `25`]]): Self = StObject.set(x, "RestElement", value.asInstanceOf[js.Any])
      
      inline def setRestElementUndefined: Self = StObject.set(x, "RestElement", js.undefined)
      
      inline def setReturnStatement(value: VisitNode[S, Extract[Node, `5`]]): Self = StObject.set(x, "ReturnStatement", value.asInstanceOf[js.Any])
      
      inline def setReturnStatementUndefined: Self = StObject.set(x, "ReturnStatement", js.undefined)
      
      inline def setScopable(value: VisitNode[S, Scopable]): Self = StObject.set(x, "Scopable", value.asInstanceOf[js.Any])
      
      inline def setScopableUndefined: Self = StObject.set(x, "Scopable", js.undefined)
      
      inline def setSequenceExpression(value: VisitNode[S, Extract[Node, `170`]]): Self = StObject.set(x, "SequenceExpression", value.asInstanceOf[js.Any])
      
      inline def setSequenceExpressionUndefined: Self = StObject.set(x, "SequenceExpression", js.undefined)
      
      inline def setSpreadElement(value: VisitNode[S, Extract[Node, `22`]]): Self = StObject.set(x, "SpreadElement", value.asInstanceOf[js.Any])
      
      inline def setSpreadElementUndefined: Self = StObject.set(x, "SpreadElement", js.undefined)
      
      inline def setStandardized(value: VisitNode[S, Standardized]): Self = StObject.set(x, "Standardized", value.asInstanceOf[js.Any])
      
      inline def setStandardizedUndefined: Self = StObject.set(x, "Standardized", js.undefined)
      
      inline def setStatement(value: VisitNode[S, Statement]): Self = StObject.set(x, "Statement", value.asInstanceOf[js.Any])
      
      inline def setStatementUndefined: Self = StObject.set(x, "Statement", js.undefined)
      
      inline def setStaticBlock(value: VisitNode[S, Extract[Node, `110`]]): Self = StObject.set(x, "StaticBlock", value.asInstanceOf[js.Any])
      
      inline def setStaticBlockUndefined: Self = StObject.set(x, "StaticBlock", js.undefined)
      
      inline def setStringLiteral(value: VisitNode[S, Extract[Node, `130`]]): Self = StObject.set(x, "StringLiteral", value.asInstanceOf[js.Any])
      
      inline def setStringLiteralTypeAnnotation(value: VisitNode[S, Extract[Node, `225`]]): Self = StObject.set(x, "StringLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setStringLiteralTypeAnnotationUndefined: Self = StObject.set(x, "StringLiteralTypeAnnotation", js.undefined)
      
      inline def setStringLiteralUndefined: Self = StObject.set(x, "StringLiteral", js.undefined)
      
      inline def setStringTypeAnnotation(value: VisitNode[S, Extract[Node, `2`]]): Self = StObject.set(x, "StringTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setStringTypeAnnotationUndefined: Self = StObject.set(x, "StringTypeAnnotation", js.undefined)
      
      inline def setSuper(value: VisitNode[S, Extract[Node, `164`]]): Self = StObject.set(x, "Super", value.asInstanceOf[js.Any])
      
      inline def setSuperUndefined: Self = StObject.set(x, "Super", js.undefined)
      
      inline def setSwitchCase(value: VisitNode[S, Extract[Node, `53`]]): Self = StObject.set(x, "SwitchCase", value.asInstanceOf[js.Any])
      
      inline def setSwitchCaseUndefined: Self = StObject.set(x, "SwitchCase", js.undefined)
      
      inline def setSwitchStatement(value: VisitNode[S, Extract[Node, `43`]]): Self = StObject.set(x, "SwitchStatement", value.asInstanceOf[js.Any])
      
      inline def setSwitchStatementUndefined: Self = StObject.set(x, "SwitchStatement", js.undefined)
      
      inline def setSymbolTypeAnnotation(value: VisitNode[S, Extract[Node, `49`]]): Self = StObject.set(x, "SymbolTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setSymbolTypeAnnotationUndefined: Self = StObject.set(x, "SymbolTypeAnnotation", js.undefined)
      
      inline def setTSAnyKeyword(value: VisitNode[S, Extract[Node, `9`]]): Self = StObject.set(x, "TSAnyKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSAnyKeywordUndefined: Self = StObject.set(x, "TSAnyKeyword", js.undefined)
      
      inline def setTSArrayType(value: VisitNode[S, Extract[Node, `0`]]): Self = StObject.set(x, "TSArrayType", value.asInstanceOf[js.Any])
      
      inline def setTSArrayTypeUndefined: Self = StObject.set(x, "TSArrayType", js.undefined)
      
      inline def setTSAsExpression(value: VisitNode[S, Extract[Node, `7`]]): Self = StObject.set(x, "TSAsExpression", value.asInstanceOf[js.Any])
      
      inline def setTSAsExpressionUndefined: Self = StObject.set(x, "TSAsExpression", js.undefined)
      
      inline def setTSBaseType(value: VisitNode[S, TSBaseType]): Self = StObject.set(x, "TSBaseType", value.asInstanceOf[js.Any])
      
      inline def setTSBaseTypeUndefined: Self = StObject.set(x, "TSBaseType", js.undefined)
      
      inline def setTSBigIntKeyword(value: VisitNode[S, Extract[Node, `52`]]): Self = StObject.set(x, "TSBigIntKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSBigIntKeywordUndefined: Self = StObject.set(x, "TSBigIntKeyword", js.undefined)
      
      inline def setTSBooleanKeyword(value: VisitNode[S, Extract[Node, `224`]]): Self = StObject.set(x, "TSBooleanKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSBooleanKeywordUndefined: Self = StObject.set(x, "TSBooleanKeyword", js.undefined)
      
      inline def setTSCallSignatureDeclaration(value: VisitNode[S, Extract[Node, `150`]]): Self = StObject.set(x, "TSCallSignatureDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSCallSignatureDeclarationUndefined: Self = StObject.set(x, "TSCallSignatureDeclaration", js.undefined)
      
      inline def setTSConditionalType(value: VisitNode[S, Extract[Node, `17`]]): Self = StObject.set(x, "TSConditionalType", value.asInstanceOf[js.Any])
      
      inline def setTSConditionalTypeUndefined: Self = StObject.set(x, "TSConditionalType", js.undefined)
      
      inline def setTSConstructSignatureDeclaration(value: VisitNode[S, Extract[Node, `121`]]): Self = StObject.set(x, "TSConstructSignatureDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSConstructSignatureDeclarationUndefined: Self = StObject.set(x, "TSConstructSignatureDeclaration", js.undefined)
      
      inline def setTSConstructorType(value: VisitNode[S, Extract[Node, `212`]]): Self = StObject.set(x, "TSConstructorType", value.asInstanceOf[js.Any])
      
      inline def setTSConstructorTypeUndefined: Self = StObject.set(x, "TSConstructorType", js.undefined)
      
      inline def setTSDeclareFunction(value: VisitNode[S, Extract[Node, `200`]]): Self = StObject.set(x, "TSDeclareFunction", value.asInstanceOf[js.Any])
      
      inline def setTSDeclareFunctionUndefined: Self = StObject.set(x, "TSDeclareFunction", js.undefined)
      
      inline def setTSDeclareMethod(value: VisitNode[S, Extract[Node, `76`]]): Self = StObject.set(x, "TSDeclareMethod", value.asInstanceOf[js.Any])
      
      inline def setTSDeclareMethodUndefined: Self = StObject.set(x, "TSDeclareMethod", js.undefined)
      
      inline def setTSEntityName(value: VisitNode[S, TSEntityName]): Self = StObject.set(x, "TSEntityName", value.asInstanceOf[js.Any])
      
      inline def setTSEntityNameUndefined: Self = StObject.set(x, "TSEntityName", js.undefined)
      
      inline def setTSEnumDeclaration(value: VisitNode[S, Extract[Node, `90`]]): Self = StObject.set(x, "TSEnumDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSEnumDeclarationUndefined: Self = StObject.set(x, "TSEnumDeclaration", js.undefined)
      
      inline def setTSEnumMember(value: VisitNode[S, Extract[Node, `132`]]): Self = StObject.set(x, "TSEnumMember", value.asInstanceOf[js.Any])
      
      inline def setTSEnumMemberUndefined: Self = StObject.set(x, "TSEnumMember", js.undefined)
      
      inline def setTSExportAssignment(value: VisitNode[S, Extract[Node, `144`]]): Self = StObject.set(x, "TSExportAssignment", value.asInstanceOf[js.Any])
      
      inline def setTSExportAssignmentUndefined: Self = StObject.set(x, "TSExportAssignment", js.undefined)
      
      inline def setTSExpressionWithTypeArguments(value: VisitNode[S, Extract[Node, `148`]]): Self = StObject.set(x, "TSExpressionWithTypeArguments", value.asInstanceOf[js.Any])
      
      inline def setTSExpressionWithTypeArgumentsUndefined: Self = StObject.set(x, "TSExpressionWithTypeArguments", js.undefined)
      
      inline def setTSExternalModuleReference(value: VisitNode[S, Extract[Node, `120`]]): Self = StObject.set(x, "TSExternalModuleReference", value.asInstanceOf[js.Any])
      
      inline def setTSExternalModuleReferenceUndefined: Self = StObject.set(x, "TSExternalModuleReference", js.undefined)
      
      inline def setTSFunctionType(value: VisitNode[S, Extract[Node, `41`]]): Self = StObject.set(x, "TSFunctionType", value.asInstanceOf[js.Any])
      
      inline def setTSFunctionTypeUndefined: Self = StObject.set(x, "TSFunctionType", js.undefined)
      
      inline def setTSImportEqualsDeclaration(value: VisitNode[S, Extract[Node, `159`]]): Self = StObject.set(x, "TSImportEqualsDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSImportEqualsDeclarationUndefined: Self = StObject.set(x, "TSImportEqualsDeclaration", js.undefined)
      
      inline def setTSImportType(value: VisitNode[S, Extract[Node, `240`]]): Self = StObject.set(x, "TSImportType", value.asInstanceOf[js.Any])
      
      inline def setTSImportTypeUndefined: Self = StObject.set(x, "TSImportType", js.undefined)
      
      inline def setTSIndexSignature(value: VisitNode[S, Extract[Node, `206`]]): Self = StObject.set(x, "TSIndexSignature", value.asInstanceOf[js.Any])
      
      inline def setTSIndexSignatureUndefined: Self = StObject.set(x, "TSIndexSignature", js.undefined)
      
      inline def setTSIndexedAccessType(value: VisitNode[S, Extract[Node, `28`]]): Self = StObject.set(x, "TSIndexedAccessType", value.asInstanceOf[js.Any])
      
      inline def setTSIndexedAccessTypeUndefined: Self = StObject.set(x, "TSIndexedAccessType", js.undefined)
      
      inline def setTSInferType(value: VisitNode[S, Extract[Node, `103`]]): Self = StObject.set(x, "TSInferType", value.asInstanceOf[js.Any])
      
      inline def setTSInferTypeUndefined: Self = StObject.set(x, "TSInferType", js.undefined)
      
      inline def setTSInstantiationExpression(value: VisitNode[S, Extract[Node, `215`]]): Self = StObject.set(x, "TSInstantiationExpression", value.asInstanceOf[js.Any])
      
      inline def setTSInstantiationExpressionUndefined: Self = StObject.set(x, "TSInstantiationExpression", js.undefined)
      
      inline def setTSInterfaceBody(value: VisitNode[S, Extract[Node, `6`]]): Self = StObject.set(x, "TSInterfaceBody", value.asInstanceOf[js.Any])
      
      inline def setTSInterfaceBodyUndefined: Self = StObject.set(x, "TSInterfaceBody", js.undefined)
      
      inline def setTSInterfaceDeclaration(value: VisitNode[S, Extract[Node, `186`]]): Self = StObject.set(x, "TSInterfaceDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSInterfaceDeclarationUndefined: Self = StObject.set(x, "TSInterfaceDeclaration", js.undefined)
      
      inline def setTSIntersectionType(value: VisitNode[S, Extract[Node, `237`]]): Self = StObject.set(x, "TSIntersectionType", value.asInstanceOf[js.Any])
      
      inline def setTSIntersectionTypeUndefined: Self = StObject.set(x, "TSIntersectionType", js.undefined)
      
      inline def setTSIntrinsicKeyword(value: VisitNode[S, Extract[Node, `65`]]): Self = StObject.set(x, "TSIntrinsicKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSIntrinsicKeywordUndefined: Self = StObject.set(x, "TSIntrinsicKeyword", js.undefined)
      
      inline def setTSLiteralType(value: VisitNode[S, Extract[Node, `19`]]): Self = StObject.set(x, "TSLiteralType", value.asInstanceOf[js.Any])
      
      inline def setTSLiteralTypeUndefined: Self = StObject.set(x, "TSLiteralType", js.undefined)
      
      inline def setTSMappedType(value: VisitNode[S, Extract[Node, `127`]]): Self = StObject.set(x, "TSMappedType", value.asInstanceOf[js.Any])
      
      inline def setTSMappedTypeUndefined: Self = StObject.set(x, "TSMappedType", js.undefined)
      
      inline def setTSMethodSignature(value: VisitNode[S, Extract[Node, `202`]]): Self = StObject.set(x, "TSMethodSignature", value.asInstanceOf[js.Any])
      
      inline def setTSMethodSignatureUndefined: Self = StObject.set(x, "TSMethodSignature", js.undefined)
      
      inline def setTSModuleBlock(value: VisitNode[S, Extract[Node, `230`]]): Self = StObject.set(x, "TSModuleBlock", value.asInstanceOf[js.Any])
      
      inline def setTSModuleBlockUndefined: Self = StObject.set(x, "TSModuleBlock", js.undefined)
      
      inline def setTSModuleDeclaration(value: VisitNode[S, Extract[Node, `15`]]): Self = StObject.set(x, "TSModuleDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSModuleDeclarationUndefined: Self = StObject.set(x, "TSModuleDeclaration", js.undefined)
      
      inline def setTSNamedTupleMember(value: VisitNode[S, Extract[Node, `221`]]): Self = StObject.set(x, "TSNamedTupleMember", value.asInstanceOf[js.Any])
      
      inline def setTSNamedTupleMemberUndefined: Self = StObject.set(x, "TSNamedTupleMember", js.undefined)
      
      inline def setTSNamespaceExportDeclaration(value: VisitNode[S, Extract[Node, `89`]]): Self = StObject.set(x, "TSNamespaceExportDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSNamespaceExportDeclarationUndefined: Self = StObject.set(x, "TSNamespaceExportDeclaration", js.undefined)
      
      inline def setTSNeverKeyword(value: VisitNode[S, Extract[Node, `236`]]): Self = StObject.set(x, "TSNeverKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSNeverKeywordUndefined: Self = StObject.set(x, "TSNeverKeyword", js.undefined)
      
      inline def setTSNonNullExpression(value: VisitNode[S, Extract[Node, `96`]]): Self = StObject.set(x, "TSNonNullExpression", value.asInstanceOf[js.Any])
      
      inline def setTSNonNullExpressionUndefined: Self = StObject.set(x, "TSNonNullExpression", js.undefined)
      
      inline def setTSNullKeyword(value: VisitNode[S, Extract[Node, `32`]]): Self = StObject.set(x, "TSNullKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSNullKeywordUndefined: Self = StObject.set(x, "TSNullKeyword", js.undefined)
      
      inline def setTSNumberKeyword(value: VisitNode[S, Extract[Node, `180`]]): Self = StObject.set(x, "TSNumberKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSNumberKeywordUndefined: Self = StObject.set(x, "TSNumberKeyword", js.undefined)
      
      inline def setTSObjectKeyword(value: VisitNode[S, Extract[Node, `217`]]): Self = StObject.set(x, "TSObjectKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSObjectKeywordUndefined: Self = StObject.set(x, "TSObjectKeyword", js.undefined)
      
      inline def setTSOptionalType(value: VisitNode[S, Extract[Node, `184`]]): Self = StObject.set(x, "TSOptionalType", value.asInstanceOf[js.Any])
      
      inline def setTSOptionalTypeUndefined: Self = StObject.set(x, "TSOptionalType", js.undefined)
      
      inline def setTSParameterProperty(value: VisitNode[S, Extract[Node, `195`]]): Self = StObject.set(x, "TSParameterProperty", value.asInstanceOf[js.Any])
      
      inline def setTSParameterPropertyUndefined: Self = StObject.set(x, "TSParameterProperty", js.undefined)
      
      inline def setTSParenthesizedType(value: VisitNode[S, Extract[Node, `226`]]): Self = StObject.set(x, "TSParenthesizedType", value.asInstanceOf[js.Any])
      
      inline def setTSParenthesizedTypeUndefined: Self = StObject.set(x, "TSParenthesizedType", js.undefined)
      
      inline def setTSPropertySignature(value: VisitNode[S, Extract[Node, `117`]]): Self = StObject.set(x, "TSPropertySignature", value.asInstanceOf[js.Any])
      
      inline def setTSPropertySignatureUndefined: Self = StObject.set(x, "TSPropertySignature", js.undefined)
      
      inline def setTSQualifiedName(value: VisitNode[S, Extract[Node, `29`]]): Self = StObject.set(x, "TSQualifiedName", value.asInstanceOf[js.Any])
      
      inline def setTSQualifiedNameUndefined: Self = StObject.set(x, "TSQualifiedName", js.undefined)
      
      inline def setTSRestType(value: VisitNode[S, Extract[Node, `209`]]): Self = StObject.set(x, "TSRestType", value.asInstanceOf[js.Any])
      
      inline def setTSRestTypeUndefined: Self = StObject.set(x, "TSRestType", js.undefined)
      
      inline def setTSStringKeyword(value: VisitNode[S, Extract[Node, `100`]]): Self = StObject.set(x, "TSStringKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSStringKeywordUndefined: Self = StObject.set(x, "TSStringKeyword", js.undefined)
      
      inline def setTSSymbolKeyword(value: VisitNode[S, Extract[Node, `126`]]): Self = StObject.set(x, "TSSymbolKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSSymbolKeywordUndefined: Self = StObject.set(x, "TSSymbolKeyword", js.undefined)
      
      inline def setTSThisType(value: VisitNode[S, Extract[Node, `207`]]): Self = StObject.set(x, "TSThisType", value.asInstanceOf[js.Any])
      
      inline def setTSThisTypeUndefined: Self = StObject.set(x, "TSThisType", js.undefined)
      
      inline def setTSTupleType(value: VisitNode[S, Extract[Node, `198`]]): Self = StObject.set(x, "TSTupleType", value.asInstanceOf[js.Any])
      
      inline def setTSTupleTypeUndefined: Self = StObject.set(x, "TSTupleType", js.undefined)
      
      inline def setTSType(value: VisitNode[S, TSType]): Self = StObject.set(x, "TSType", value.asInstanceOf[js.Any])
      
      inline def setTSTypeAliasDeclaration(value: VisitNode[S, Extract[Node, `91`]]): Self = StObject.set(x, "TSTypeAliasDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSTypeAliasDeclarationUndefined: Self = StObject.set(x, "TSTypeAliasDeclaration", js.undefined)
      
      inline def setTSTypeAnnotation(value: VisitNode[S, Extract[Node, `111`]]): Self = StObject.set(x, "TSTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setTSTypeAnnotationUndefined: Self = StObject.set(x, "TSTypeAnnotation", js.undefined)
      
      inline def setTSTypeAssertion(value: VisitNode[S, Extract[Node, `235`]]): Self = StObject.set(x, "TSTypeAssertion", value.asInstanceOf[js.Any])
      
      inline def setTSTypeAssertionUndefined: Self = StObject.set(x, "TSTypeAssertion", js.undefined)
      
      inline def setTSTypeElement(value: VisitNode[S, TSTypeElement]): Self = StObject.set(x, "TSTypeElement", value.asInstanceOf[js.Any])
      
      inline def setTSTypeElementUndefined: Self = StObject.set(x, "TSTypeElement", js.undefined)
      
      inline def setTSTypeLiteral(value: VisitNode[S, Extract[Node, `155`]]): Self = StObject.set(x, "TSTypeLiteral", value.asInstanceOf[js.Any])
      
      inline def setTSTypeLiteralUndefined: Self = StObject.set(x, "TSTypeLiteral", js.undefined)
      
      inline def setTSTypeOperator(value: VisitNode[S, Extract[Node, `51`]]): Self = StObject.set(x, "TSTypeOperator", value.asInstanceOf[js.Any])
      
      inline def setTSTypeOperatorUndefined: Self = StObject.set(x, "TSTypeOperator", js.undefined)
      
      inline def setTSTypeParameter(value: VisitNode[S, Extract[Node, `93`]]): Self = StObject.set(x, "TSTypeParameter", value.asInstanceOf[js.Any])
      
      inline def setTSTypeParameterDeclaration(value: VisitNode[S, Extract[Node, `20`]]): Self = StObject.set(x, "TSTypeParameterDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTSTypeParameterDeclarationUndefined: Self = StObject.set(x, "TSTypeParameterDeclaration", js.undefined)
      
      inline def setTSTypeParameterInstantiation(value: VisitNode[S, Extract[Node, `75`]]): Self = StObject.set(x, "TSTypeParameterInstantiation", value.asInstanceOf[js.Any])
      
      inline def setTSTypeParameterInstantiationUndefined: Self = StObject.set(x, "TSTypeParameterInstantiation", js.undefined)
      
      inline def setTSTypeParameterUndefined: Self = StObject.set(x, "TSTypeParameter", js.undefined)
      
      inline def setTSTypePredicate(value: VisitNode[S, Extract[Node, `185`]]): Self = StObject.set(x, "TSTypePredicate", value.asInstanceOf[js.Any])
      
      inline def setTSTypePredicateUndefined: Self = StObject.set(x, "TSTypePredicate", js.undefined)
      
      inline def setTSTypeQuery(value: VisitNode[S, Extract[Node, `119`]]): Self = StObject.set(x, "TSTypeQuery", value.asInstanceOf[js.Any])
      
      inline def setTSTypeQueryUndefined: Self = StObject.set(x, "TSTypeQuery", js.undefined)
      
      inline def setTSTypeReference(value: VisitNode[S, Extract[Node, `246`]]): Self = StObject.set(x, "TSTypeReference", value.asInstanceOf[js.Any])
      
      inline def setTSTypeReferenceUndefined: Self = StObject.set(x, "TSTypeReference", js.undefined)
      
      inline def setTSTypeUndefined: Self = StObject.set(x, "TSType", js.undefined)
      
      inline def setTSUndefinedKeyword(value: VisitNode[S, Extract[Node, `168`]]): Self = StObject.set(x, "TSUndefinedKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSUndefinedKeywordUndefined: Self = StObject.set(x, "TSUndefinedKeyword", js.undefined)
      
      inline def setTSUnionType(value: VisitNode[S, Extract[Node, `92`]]): Self = StObject.set(x, "TSUnionType", value.asInstanceOf[js.Any])
      
      inline def setTSUnionTypeUndefined: Self = StObject.set(x, "TSUnionType", js.undefined)
      
      inline def setTSUnknownKeyword(value: VisitNode[S, Extract[Node, `54`]]): Self = StObject.set(x, "TSUnknownKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSUnknownKeywordUndefined: Self = StObject.set(x, "TSUnknownKeyword", js.undefined)
      
      inline def setTSVoidKeyword(value: VisitNode[S, Extract[Node, `57`]]): Self = StObject.set(x, "TSVoidKeyword", value.asInstanceOf[js.Any])
      
      inline def setTSVoidKeywordUndefined: Self = StObject.set(x, "TSVoidKeyword", js.undefined)
      
      inline def setTaggedTemplateExpression(value: VisitNode[S, Extract[Node, `71`]]): Self = StObject.set(x, "TaggedTemplateExpression", value.asInstanceOf[js.Any])
      
      inline def setTaggedTemplateExpressionUndefined: Self = StObject.set(x, "TaggedTemplateExpression", js.undefined)
      
      inline def setTemplateElement(value: VisitNode[S, Extract[Node, `193`]]): Self = StObject.set(x, "TemplateElement", value.asInstanceOf[js.Any])
      
      inline def setTemplateElementUndefined: Self = StObject.set(x, "TemplateElement", js.undefined)
      
      inline def setTemplateLiteral(value: VisitNode[S, Extract[Node, `77`]]): Self = StObject.set(x, "TemplateLiteral", value.asInstanceOf[js.Any])
      
      inline def setTemplateLiteralUndefined: Self = StObject.set(x, "TemplateLiteral", js.undefined)
      
      inline def setTerminatorless(value: VisitNode[S, Terminatorless]): Self = StObject.set(x, "Terminatorless", value.asInstanceOf[js.Any])
      
      inline def setTerminatorlessUndefined: Self = StObject.set(x, "Terminatorless", js.undefined)
      
      inline def setThisExpression(value: VisitNode[S, Extract[Node, `233`]]): Self = StObject.set(x, "ThisExpression", value.asInstanceOf[js.Any])
      
      inline def setThisExpressionUndefined: Self = StObject.set(x, "ThisExpression", js.undefined)
      
      inline def setThisTypeAnnotation(value: VisitNode[S, Extract[Node, `50`]]): Self = StObject.set(x, "ThisTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setThisTypeAnnotationUndefined: Self = StObject.set(x, "ThisTypeAnnotation", js.undefined)
      
      inline def setThrowStatement(value: VisitNode[S, Extract[Node, `139`]]): Self = StObject.set(x, "ThrowStatement", value.asInstanceOf[js.Any])
      
      inline def setThrowStatementUndefined: Self = StObject.set(x, "ThrowStatement", js.undefined)
      
      inline def setTopicReference(value: VisitNode[S, Extract[Node, `101`]]): Self = StObject.set(x, "TopicReference", value.asInstanceOf[js.Any])
      
      inline def setTopicReferenceUndefined: Self = StObject.set(x, "TopicReference", js.undefined)
      
      inline def setTryStatement(value: VisitNode[S, Extract[Node, `23`]]): Self = StObject.set(x, "TryStatement", value.asInstanceOf[js.Any])
      
      inline def setTryStatementUndefined: Self = StObject.set(x, "TryStatement", js.undefined)
      
      inline def setTupleExpression(value: VisitNode[S, Extract[Node, `208`]]): Self = StObject.set(x, "TupleExpression", value.asInstanceOf[js.Any])
      
      inline def setTupleExpressionUndefined: Self = StObject.set(x, "TupleExpression", js.undefined)
      
      inline def setTupleTypeAnnotation(value: VisitNode[S, Extract[Node, `13`]]): Self = StObject.set(x, "TupleTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setTupleTypeAnnotationUndefined: Self = StObject.set(x, "TupleTypeAnnotation", js.undefined)
      
      inline def setTypeAlias(value: VisitNode[S, Extract[Node, `179`]]): Self = StObject.set(x, "TypeAlias", value.asInstanceOf[js.Any])
      
      inline def setTypeAliasUndefined: Self = StObject.set(x, "TypeAlias", js.undefined)
      
      inline def setTypeAnnotation(value: VisitNode[S, Extract[Node, `21`]]): Self = StObject.set(x, "TypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setTypeAnnotationUndefined: Self = StObject.set(x, "TypeAnnotation", js.undefined)
      
      inline def setTypeCastExpression(value: VisitNode[S, Extract[Node, `10`]]): Self = StObject.set(x, "TypeCastExpression", value.asInstanceOf[js.Any])
      
      inline def setTypeCastExpressionUndefined: Self = StObject.set(x, "TypeCastExpression", js.undefined)
      
      inline def setTypeParameter(value: VisitNode[S, Extract[Node, `172`]]): Self = StObject.set(x, "TypeParameter", value.asInstanceOf[js.Any])
      
      inline def setTypeParameterDeclaration(value: VisitNode[S, Extract[Node, `14`]]): Self = StObject.set(x, "TypeParameterDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTypeParameterDeclarationUndefined: Self = StObject.set(x, "TypeParameterDeclaration", js.undefined)
      
      inline def setTypeParameterInstantiation(value: VisitNode[S, Extract[Node, `245`]]): Self = StObject.set(x, "TypeParameterInstantiation", value.asInstanceOf[js.Any])
      
      inline def setTypeParameterInstantiationUndefined: Self = StObject.set(x, "TypeParameterInstantiation", js.undefined)
      
      inline def setTypeParameterUndefined: Self = StObject.set(x, "TypeParameter", js.undefined)
      
      inline def setTypeScript(value: VisitNode[S, TypeScript]): Self = StObject.set(x, "TypeScript", value.asInstanceOf[js.Any])
      
      inline def setTypeScriptUndefined: Self = StObject.set(x, "TypeScript", js.undefined)
      
      inline def setTypeofTypeAnnotation(value: VisitNode[S, Extract[Node, `149`]]): Self = StObject.set(x, "TypeofTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setTypeofTypeAnnotationUndefined: Self = StObject.set(x, "TypeofTypeAnnotation", js.undefined)
      
      inline def setUnaryExpression(value: VisitNode[S, Extract[Node, `176`]]): Self = StObject.set(x, "UnaryExpression", value.asInstanceOf[js.Any])
      
      inline def setUnaryExpressionUndefined: Self = StObject.set(x, "UnaryExpression", js.undefined)
      
      inline def setUnaryLike(value: VisitNode[S, UnaryLike]): Self = StObject.set(x, "UnaryLike", value.asInstanceOf[js.Any])
      
      inline def setUnaryLikeUndefined: Self = StObject.set(x, "UnaryLike", js.undefined)
      
      inline def setUnionTypeAnnotation(value: VisitNode[S, Extract[Node, `220`]]): Self = StObject.set(x, "UnionTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setUnionTypeAnnotationUndefined: Self = StObject.set(x, "UnionTypeAnnotation", js.undefined)
      
      inline def setUpdateExpression(value: VisitNode[S, Extract[Node, `99`]]): Self = StObject.set(x, "UpdateExpression", value.asInstanceOf[js.Any])
      
      inline def setUpdateExpressionUndefined: Self = StObject.set(x, "UpdateExpression", js.undefined)
      
      inline def setUserWhitespacable(value: VisitNode[S, UserWhitespacable]): Self = StObject.set(x, "UserWhitespacable", value.asInstanceOf[js.Any])
      
      inline def setUserWhitespacableUndefined: Self = StObject.set(x, "UserWhitespacable", js.undefined)
      
      inline def setV8IntrinsicIdentifier(value: VisitNode[S, Extract[Node, `140`]]): Self = StObject.set(x, "V8IntrinsicIdentifier", value.asInstanceOf[js.Any])
      
      inline def setV8IntrinsicIdentifierUndefined: Self = StObject.set(x, "V8IntrinsicIdentifier", js.undefined)
      
      inline def setVariableDeclaration(value: VisitNode[S, Extract[Node, `67`]]): Self = StObject.set(x, "VariableDeclaration", value.asInstanceOf[js.Any])
      
      inline def setVariableDeclarationUndefined: Self = StObject.set(x, "VariableDeclaration", js.undefined)
      
      inline def setVariableDeclarator(value: VisitNode[S, Extract[Node, `129`]]): Self = StObject.set(x, "VariableDeclarator", value.asInstanceOf[js.Any])
      
      inline def setVariableDeclaratorUndefined: Self = StObject.set(x, "VariableDeclarator", js.undefined)
      
      inline def setVariance(value: VisitNode[S, Extract[Node, `152`]]): Self = StObject.set(x, "Variance", value.asInstanceOf[js.Any])
      
      inline def setVarianceUndefined: Self = StObject.set(x, "Variance", js.undefined)
      
      inline def setVoidTypeAnnotation(value: VisitNode[S, Extract[Node, `106`]]): Self = StObject.set(x, "VoidTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setVoidTypeAnnotationUndefined: Self = StObject.set(x, "VoidTypeAnnotation", js.undefined)
      
      inline def setWhile(value: VisitNode[S, While]): Self = StObject.set(x, "While", value.asInstanceOf[js.Any])
      
      inline def setWhileStatement(value: VisitNode[S, Extract[Node, `38`]]): Self = StObject.set(x, "WhileStatement", value.asInstanceOf[js.Any])
      
      inline def setWhileStatementUndefined: Self = StObject.set(x, "WhileStatement", js.undefined)
      
      inline def setWhileUndefined: Self = StObject.set(x, "While", js.undefined)
      
      inline def setWithStatement(value: VisitNode[S, Extract[Node, `95`]]): Self = StObject.set(x, "WithStatement", value.asInstanceOf[js.Any])
      
      inline def setWithStatementUndefined: Self = StObject.set(x, "WithStatement", js.undefined)
      
      inline def setYieldExpression(value: VisitNode[S, Extract[Node, `11`]]): Self = StObject.set(x, "YieldExpression", value.asInstanceOf[js.Any])
      
      inline def setYieldExpressionUndefined: Self = StObject.set(x, "YieldExpression", js.undefined)
    }
  }
}
