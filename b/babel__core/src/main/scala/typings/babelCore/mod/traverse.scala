package typings.babelCore.mod

import typings.babelTraverse.anon.FnCall
import typings.babelTraverse.anon.Typeofcache
import typings.babelTraverse.anon.Typeofvisitors
import typings.babelTraverse.mod.Scope
import typings.babelTraverse.mod.TraverseOptions
import typings.babelTraverse.mod.Visitor
import typings.std.Record
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object traverse {
  
  inline def apply(parent: typings.babelTypes.mod.Node): Unit = ^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any]).asInstanceOf[Unit]
  inline def apply(parent: typings.babelTypes.mod.Node, opts: Unit, scope: Unit, state: Any): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def apply(
    parent: typings.babelTypes.mod.Node,
    opts: Unit,
    scope: Unit,
    state: Any,
    parentPath: typings.babelTraverse.mod.NodePath[typings.babelTypes.mod.Node]
  ): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def apply(
    parent: typings.babelTypes.mod.Node,
    opts: Unit,
    scope: Unit,
    state: Unit,
    parentPath: typings.babelTraverse.mod.NodePath[typings.babelTypes.mod.Node]
  ): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def apply(parent: typings.babelTypes.mod.Node, opts: Unit, scope: Scope): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def apply(parent: typings.babelTypes.mod.Node, opts: Unit, scope: Scope, state: Any): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def apply(
    parent: typings.babelTypes.mod.Node,
    opts: Unit,
    scope: Scope,
    state: Any,
    parentPath: typings.babelTraverse.mod.NodePath[typings.babelTypes.mod.Node]
  ): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def apply(
    parent: typings.babelTypes.mod.Node,
    opts: Unit,
    scope: Scope,
    state: Unit,
    parentPath: typings.babelTraverse.mod.NodePath[typings.babelTypes.mod.Node]
  ): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def apply(parent: typings.babelTypes.mod.Node, opts: TraverseOptions[typings.babelTypes.mod.Node]): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def apply(
    parent: typings.babelTypes.mod.Node,
    opts: TraverseOptions[typings.babelTypes.mod.Node],
    scope: Unit,
    state: Any
  ): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def apply(
    parent: typings.babelTypes.mod.Node,
    opts: TraverseOptions[typings.babelTypes.mod.Node],
    scope: Unit,
    state: Any,
    parentPath: typings.babelTraverse.mod.NodePath[typings.babelTypes.mod.Node]
  ): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def apply(
    parent: typings.babelTypes.mod.Node,
    opts: TraverseOptions[typings.babelTypes.mod.Node],
    scope: Unit,
    state: Unit,
    parentPath: typings.babelTraverse.mod.NodePath[typings.babelTypes.mod.Node]
  ): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def apply(
    parent: typings.babelTypes.mod.Node,
    opts: TraverseOptions[typings.babelTypes.mod.Node],
    scope: Scope
  ): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def apply(
    parent: typings.babelTypes.mod.Node,
    opts: TraverseOptions[typings.babelTypes.mod.Node],
    scope: Scope,
    state: Any
  ): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def apply(
    parent: typings.babelTypes.mod.Node,
    opts: TraverseOptions[typings.babelTypes.mod.Node],
    scope: Scope,
    state: Any,
    parentPath: typings.babelTraverse.mod.NodePath[typings.babelTypes.mod.Node]
  ): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def apply(
    parent: typings.babelTypes.mod.Node,
    opts: TraverseOptions[typings.babelTypes.mod.Node],
    scope: Scope,
    state: Unit,
    parentPath: typings.babelTraverse.mod.NodePath[typings.babelTypes.mod.Node]
  ): Unit = (^.asInstanceOf[js.Dynamic].apply(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  @JSImport("@babel/core", "traverse")
  @js.native
  val ^ : js.Any = js.native
  
  @JSImport("@babel/core", "traverse.cache")
  @js.native
  def cache: Typeofcache = js.native
  inline def cache_=(x: Typeofcache): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("cache")(x.asInstanceOf[js.Any])
  
  inline def cheap(
    node: typings.babelTypes.mod.Node,
    enter: js.Function1[/* node */ typings.babelTypes.mod.Node, Unit]
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cheap")(node.asInstanceOf[js.Any], enter.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def clearNode(node: typings.babelTypes.mod.Node): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("clearNode")(node.asInstanceOf[js.Any]).asInstanceOf[Unit]
  inline def clearNode(
    node: typings.babelTypes.mod.Node,
    opts: /* import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify RemovePropertiesOptions */ Any
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("clearNode")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  @JSImport("@babel/core", "traverse.explode")
  @js.native
  def explode: FnCall = js.native
  inline def explode[S](visitor: Visitor[S]): /* import warning: importer.ImportType#apply Failed type conversion: {[ Type in std.Exclude<@babel/types.@babel/types.Node, / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify t.DeprecatedAliases * / any>['type'] ]:? @babel/traverse.@babel/traverse.VisitNodeObject<S, std.Extract<@babel/types.@babel/types.Node, {  type :Type}>>} */ js.Any = ^.asInstanceOf[js.Dynamic].applyDynamic("explode")(visitor.asInstanceOf[js.Any]).asInstanceOf[/* import warning: importer.ImportType#apply Failed type conversion: {[ Type in std.Exclude<@babel/types.@babel/types.Node, / * import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify t.DeprecatedAliases * / any>['type'] ]:? @babel/traverse.@babel/traverse.VisitNodeObject<S, std.Extract<@babel/types.@babel/types.Node, {  type :Type}>>} */ js.Any]
  inline def explode_=(x: FnCall): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("explode")(x.asInstanceOf[js.Any])
  
  inline def hasType(
    tree: typings.babelTypes.mod.Node,
    `type`: /* import warning: LimitUnionLength.leaveTypeRef Was union type with length 249, starting with typings.babelCore.babelCoreStrings.ClassAccessorProperty, typings.babelCore.babelCoreStrings.AnyTypeAnnotation, typings.babelCore.babelCoreStrings.ArgumentPlaceholder */ Any
  ): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("hasType")(tree.asInstanceOf[js.Any], `type`.asInstanceOf[js.Any])).asInstanceOf[Boolean]
  inline def hasType(
    tree: typings.babelTypes.mod.Node,
    `type`: /* import warning: LimitUnionLength.leaveTypeRef Was union type with length 249, starting with typings.babelCore.babelCoreStrings.ClassAccessorProperty, typings.babelCore.babelCoreStrings.AnyTypeAnnotation, typings.babelCore.babelCoreStrings.ArgumentPlaceholder */ Any,
    denylistTypes: js.Array[String]
  ): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("hasType")(tree.asInstanceOf[js.Any], `type`.asInstanceOf[js.Any], denylistTypes.asInstanceOf[js.Any])).asInstanceOf[Boolean]
  
  inline def node(node: typings.babelTypes.mod.Node, opts: TraverseOptions[typings.babelTypes.mod.Node]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def node(
    node: typings.babelTypes.mod.Node,
    opts: TraverseOptions[typings.babelTypes.mod.Node],
    scope: Unit,
    state: Any
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def node(
    node: typings.babelTypes.mod.Node,
    opts: TraverseOptions[typings.babelTypes.mod.Node],
    scope: Unit,
    state: Any,
    path: Unit,
    skipKeys: Record[String, Boolean]
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], path.asInstanceOf[js.Any], skipKeys.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def node(
    node: typings.babelTypes.mod.Node,
    opts: TraverseOptions[typings.babelTypes.mod.Node],
    scope: Unit,
    state: Any,
    path: typings.babelTraverse.mod.NodePath[typings.babelTypes.mod.Node]
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], path.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def node(
    node: typings.babelTypes.mod.Node,
    opts: TraverseOptions[typings.babelTypes.mod.Node],
    scope: Unit,
    state: Any,
    path: typings.babelTraverse.mod.NodePath[typings.babelTypes.mod.Node],
    skipKeys: Record[String, Boolean]
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], path.asInstanceOf[js.Any], skipKeys.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def node(
    node: typings.babelTypes.mod.Node,
    opts: TraverseOptions[typings.babelTypes.mod.Node],
    scope: Unit,
    state: Unit,
    path: Unit,
    skipKeys: Record[String, Boolean]
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], path.asInstanceOf[js.Any], skipKeys.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def node(
    node: typings.babelTypes.mod.Node,
    opts: TraverseOptions[typings.babelTypes.mod.Node],
    scope: Unit,
    state: Unit,
    path: typings.babelTraverse.mod.NodePath[typings.babelTypes.mod.Node]
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], path.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def node(
    node: typings.babelTypes.mod.Node,
    opts: TraverseOptions[typings.babelTypes.mod.Node],
    scope: Unit,
    state: Unit,
    path: typings.babelTraverse.mod.NodePath[typings.babelTypes.mod.Node],
    skipKeys: Record[String, Boolean]
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], path.asInstanceOf[js.Any], skipKeys.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def node(
    node: typings.babelTypes.mod.Node,
    opts: TraverseOptions[typings.babelTypes.mod.Node],
    scope: Scope
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def node(
    node: typings.babelTypes.mod.Node,
    opts: TraverseOptions[typings.babelTypes.mod.Node],
    scope: Scope,
    state: Any
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def node(
    node: typings.babelTypes.mod.Node,
    opts: TraverseOptions[typings.babelTypes.mod.Node],
    scope: Scope,
    state: Any,
    path: Unit,
    skipKeys: Record[String, Boolean]
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], path.asInstanceOf[js.Any], skipKeys.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def node(
    node: typings.babelTypes.mod.Node,
    opts: TraverseOptions[typings.babelTypes.mod.Node],
    scope: Scope,
    state: Any,
    path: typings.babelTraverse.mod.NodePath[typings.babelTypes.mod.Node]
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], path.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def node(
    node: typings.babelTypes.mod.Node,
    opts: TraverseOptions[typings.babelTypes.mod.Node],
    scope: Scope,
    state: Any,
    path: typings.babelTraverse.mod.NodePath[typings.babelTypes.mod.Node],
    skipKeys: Record[String, Boolean]
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], path.asInstanceOf[js.Any], skipKeys.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def node(
    node: typings.babelTypes.mod.Node,
    opts: TraverseOptions[typings.babelTypes.mod.Node],
    scope: Scope,
    state: Unit,
    path: Unit,
    skipKeys: Record[String, Boolean]
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], path.asInstanceOf[js.Any], skipKeys.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def node(
    node: typings.babelTypes.mod.Node,
    opts: TraverseOptions[typings.babelTypes.mod.Node],
    scope: Scope,
    state: Unit,
    path: typings.babelTraverse.mod.NodePath[typings.babelTypes.mod.Node]
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], path.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def node(
    node: typings.babelTypes.mod.Node,
    opts: TraverseOptions[typings.babelTypes.mod.Node],
    scope: Scope,
    state: Unit,
    path: typings.babelTraverse.mod.NodePath[typings.babelTypes.mod.Node],
    skipKeys: Record[String, Boolean]
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("node")(node.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], path.asInstanceOf[js.Any], skipKeys.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def removeProperties(tree: typings.babelTypes.mod.Node): typings.babelTypes.mod.Node = ^.asInstanceOf[js.Dynamic].applyDynamic("removeProperties")(tree.asInstanceOf[js.Any]).asInstanceOf[typings.babelTypes.mod.Node]
  inline def removeProperties(
    tree: typings.babelTypes.mod.Node,
    opts: /* import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify RemovePropertiesOptions */ Any
  ): typings.babelTypes.mod.Node = (^.asInstanceOf[js.Dynamic].applyDynamic("removeProperties")(tree.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[typings.babelTypes.mod.Node]
  
  @JSImport("@babel/core", "traverse.verify")
  @js.native
  def verify: js.Function1[/* visitor */ Visitor[Any], Unit] = js.native
  inline def verify(visitor: Visitor[Any]): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("verify")(visitor.asInstanceOf[js.Any]).asInstanceOf[Unit]
  inline def verify_=(x: js.Function1[/* visitor */ Visitor[Any], Unit]): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("verify")(x.asInstanceOf[js.Any])
  
  @JSImport("@babel/core", "traverse.visitors")
  @js.native
  def visitors: Typeofvisitors = js.native
  inline def visitors_=(x: Typeofvisitors): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("visitors")(x.asInstanceOf[js.Any])
}
