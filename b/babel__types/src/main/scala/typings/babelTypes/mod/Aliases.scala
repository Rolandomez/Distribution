package typings.babelTypes.mod

import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

trait Aliases extends StObject {
  
  var Binary: typings.babelTypes.mod.Binary
  
  var Block: typings.babelTypes.mod.Block
  
  var BlockParent: typings.babelTypes.mod.BlockParent
  
  var Class: typings.babelTypes.mod.Class
  
  var CompletionStatement: typings.babelTypes.mod.CompletionStatement
  
  var Conditional: typings.babelTypes.mod.Conditional
  
  var Declaration: typings.babelTypes.mod.Declaration
  
  var EnumBody: typings.babelTypes.mod.EnumBody
  
  var EnumMember: typings.babelTypes.mod.EnumMember
  
  var ExportDeclaration: typings.babelTypes.mod.ExportDeclaration
  
  var Expression: typings.babelTypes.mod.Expression
  
  var ExpressionWrapper: typings.babelTypes.mod.ExpressionWrapper
  
  var Flow: typings.babelTypes.mod.Flow
  
  var FlowBaseAnnotation: typings.babelTypes.mod.FlowBaseAnnotation
  
  var FlowDeclaration: typings.babelTypes.mod.FlowDeclaration
  
  var FlowPredicate: typings.babelTypes.mod.FlowPredicate
  
  var FlowType: typings.babelTypes.mod.FlowType
  
  var For: typings.babelTypes.mod.For
  
  var ForXStatement: typings.babelTypes.mod.ForXStatement
  
  var Function: typings.babelTypes.mod.Function
  
  var FunctionParent: typings.babelTypes.mod.FunctionParent
  
  var Immutable: typings.babelTypes.mod.Immutable
  
  var JSX: typings.babelTypes.mod.JSX
  
  var LVal: typings.babelTypes.mod.LVal
  
  var Literal: typings.babelTypes.mod.Literal
  
  var Loop: typings.babelTypes.mod.Loop
  
  var Method: typings.babelTypes.mod.Method
  
  var ModuleDeclaration: typings.babelTypes.mod.ModuleDeclaration
  
  var ModuleSpecifier: typings.babelTypes.mod.ModuleSpecifier
  
  var ObjectMember: typings.babelTypes.mod.ObjectMember
  
  var Pattern: typings.babelTypes.mod.Pattern
  
  var PatternLike: typings.babelTypes.mod.PatternLike
  
  var Private: typings.babelTypes.mod.Private
  
  var Property: typings.babelTypes.mod.Property
  
  var Pureish: typings.babelTypes.mod.Pureish
  
  var Scopable: typings.babelTypes.mod.Scopable
  
  var Statement: typings.babelTypes.mod.Statement
  
  var TSBaseType: typings.babelTypes.mod.TSBaseType
  
  var TSEntityName: typings.babelTypes.mod.TSEntityName
  
  var TSType: typings.babelTypes.mod.TSType
  
  var TSTypeElement: typings.babelTypes.mod.TSTypeElement
  
  var Terminatorless: typings.babelTypes.mod.Terminatorless
  
  var UnaryLike: typings.babelTypes.mod.UnaryLike
  
  var UserWhitespacable: typings.babelTypes.mod.UserWhitespacable
  
  var While: typings.babelTypes.mod.While
}
object Aliases {
  
  @scala.inline
  def apply(
    Binary: Binary,
    Block: Block,
    BlockParent: BlockParent,
    Class: Class,
    CompletionStatement: CompletionStatement,
    Conditional: Conditional,
    Declaration: Declaration,
    EnumBody: EnumBody,
    EnumMember: EnumMember,
    ExportDeclaration: ExportDeclaration,
    Expression: Expression,
    ExpressionWrapper: ExpressionWrapper,
    Flow: Flow,
    FlowBaseAnnotation: FlowBaseAnnotation,
    FlowDeclaration: FlowDeclaration,
    FlowPredicate: FlowPredicate,
    FlowType: FlowType,
    For: For,
    ForXStatement: ForXStatement,
    Function: Function,
    FunctionParent: FunctionParent,
    Immutable: Immutable,
    JSX: JSX,
    LVal: LVal,
    Literal: Literal,
    Loop: Loop,
    Method: Method,
    ModuleDeclaration: ModuleDeclaration,
    ModuleSpecifier: ModuleSpecifier,
    ObjectMember: ObjectMember,
    Pattern: Pattern,
    PatternLike: PatternLike,
    Private: Private,
    Property: Property,
    Pureish: Pureish,
    Scopable: Scopable,
    Statement: Statement,
    TSBaseType: TSBaseType,
    TSEntityName: TSEntityName,
    TSType: TSType,
    TSTypeElement: TSTypeElement,
    Terminatorless: Terminatorless,
    UnaryLike: UnaryLike,
    UserWhitespacable: UserWhitespacable,
    While: While
  ): Aliases = {
    val __obj = js.Dynamic.literal(Binary = Binary.asInstanceOf[js.Any], Block = Block.asInstanceOf[js.Any], BlockParent = BlockParent.asInstanceOf[js.Any], Class = Class.asInstanceOf[js.Any], CompletionStatement = CompletionStatement.asInstanceOf[js.Any], Conditional = Conditional.asInstanceOf[js.Any], Declaration = Declaration.asInstanceOf[js.Any], EnumBody = EnumBody.asInstanceOf[js.Any], EnumMember = EnumMember.asInstanceOf[js.Any], ExportDeclaration = ExportDeclaration.asInstanceOf[js.Any], Expression = Expression.asInstanceOf[js.Any], ExpressionWrapper = ExpressionWrapper.asInstanceOf[js.Any], Flow = Flow.asInstanceOf[js.Any], FlowBaseAnnotation = FlowBaseAnnotation.asInstanceOf[js.Any], FlowDeclaration = FlowDeclaration.asInstanceOf[js.Any], FlowPredicate = FlowPredicate.asInstanceOf[js.Any], FlowType = FlowType.asInstanceOf[js.Any], For = For.asInstanceOf[js.Any], ForXStatement = ForXStatement.asInstanceOf[js.Any], Function = Function.asInstanceOf[js.Any], FunctionParent = FunctionParent.asInstanceOf[js.Any], Immutable = Immutable.asInstanceOf[js.Any], JSX = JSX.asInstanceOf[js.Any], LVal = LVal.asInstanceOf[js.Any], Literal = Literal.asInstanceOf[js.Any], Loop = Loop.asInstanceOf[js.Any], Method = Method.asInstanceOf[js.Any], ModuleDeclaration = ModuleDeclaration.asInstanceOf[js.Any], ModuleSpecifier = ModuleSpecifier.asInstanceOf[js.Any], ObjectMember = ObjectMember.asInstanceOf[js.Any], Pattern = Pattern.asInstanceOf[js.Any], PatternLike = PatternLike.asInstanceOf[js.Any], Private = Private.asInstanceOf[js.Any], Property = Property.asInstanceOf[js.Any], Pureish = Pureish.asInstanceOf[js.Any], Scopable = Scopable.asInstanceOf[js.Any], Statement = Statement.asInstanceOf[js.Any], TSBaseType = TSBaseType.asInstanceOf[js.Any], TSEntityName = TSEntityName.asInstanceOf[js.Any], TSType = TSType.asInstanceOf[js.Any], TSTypeElement = TSTypeElement.asInstanceOf[js.Any], Terminatorless = Terminatorless.asInstanceOf[js.Any], UnaryLike = UnaryLike.asInstanceOf[js.Any], UserWhitespacable = UserWhitespacable.asInstanceOf[js.Any], While = While.asInstanceOf[js.Any])
    __obj.asInstanceOf[Aliases]
  }
  
  @scala.inline
  implicit class AliasesMutableBuilder[Self <: Aliases] (val x: Self) extends AnyVal {
    
    @scala.inline
    def setBinary(value: Binary): Self = StObject.set(x, "Binary", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setBlock(value: Block): Self = StObject.set(x, "Block", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setBlockParent(value: BlockParent): Self = StObject.set(x, "BlockParent", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setClass(value: Class): Self = StObject.set(x, "Class", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setCompletionStatement(value: CompletionStatement): Self = StObject.set(x, "CompletionStatement", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setConditional(value: Conditional): Self = StObject.set(x, "Conditional", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setDeclaration(value: Declaration): Self = StObject.set(x, "Declaration", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setEnumBody(value: EnumBody): Self = StObject.set(x, "EnumBody", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setEnumMember(value: EnumMember): Self = StObject.set(x, "EnumMember", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setExportDeclaration(value: ExportDeclaration): Self = StObject.set(x, "ExportDeclaration", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setExpression(value: Expression): Self = StObject.set(x, "Expression", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setExpressionWrapper(value: ExpressionWrapper): Self = StObject.set(x, "ExpressionWrapper", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setFlow(value: Flow): Self = StObject.set(x, "Flow", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setFlowBaseAnnotation(value: FlowBaseAnnotation): Self = StObject.set(x, "FlowBaseAnnotation", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setFlowDeclaration(value: FlowDeclaration): Self = StObject.set(x, "FlowDeclaration", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setFlowPredicate(value: FlowPredicate): Self = StObject.set(x, "FlowPredicate", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setFlowType(value: FlowType): Self = StObject.set(x, "FlowType", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setFor(value: For): Self = StObject.set(x, "For", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setForXStatement(value: ForXStatement): Self = StObject.set(x, "ForXStatement", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setFunction(value: Function): Self = StObject.set(x, "Function", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setFunctionParent(value: FunctionParent): Self = StObject.set(x, "FunctionParent", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setImmutable(value: Immutable): Self = StObject.set(x, "Immutable", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setJSX(value: JSX): Self = StObject.set(x, "JSX", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setLVal(value: LVal): Self = StObject.set(x, "LVal", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setLiteral(value: Literal): Self = StObject.set(x, "Literal", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setLoop(value: Loop): Self = StObject.set(x, "Loop", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setMethod(value: Method): Self = StObject.set(x, "Method", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setModuleDeclaration(value: ModuleDeclaration): Self = StObject.set(x, "ModuleDeclaration", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setModuleSpecifier(value: ModuleSpecifier): Self = StObject.set(x, "ModuleSpecifier", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setObjectMember(value: ObjectMember): Self = StObject.set(x, "ObjectMember", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setPattern(value: Pattern): Self = StObject.set(x, "Pattern", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setPatternLike(value: PatternLike): Self = StObject.set(x, "PatternLike", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setPrivate(value: Private): Self = StObject.set(x, "Private", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setProperty(value: Property): Self = StObject.set(x, "Property", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setPureish(value: Pureish): Self = StObject.set(x, "Pureish", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setScopable(value: Scopable): Self = StObject.set(x, "Scopable", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setStatement(value: Statement): Self = StObject.set(x, "Statement", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setTSBaseType(value: TSBaseType): Self = StObject.set(x, "TSBaseType", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setTSEntityName(value: TSEntityName): Self = StObject.set(x, "TSEntityName", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setTSType(value: TSType): Self = StObject.set(x, "TSType", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setTSTypeElement(value: TSTypeElement): Self = StObject.set(x, "TSTypeElement", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setTerminatorless(value: Terminatorless): Self = StObject.set(x, "Terminatorless", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setUnaryLike(value: UnaryLike): Self = StObject.set(x, "UnaryLike", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setUserWhitespacable(value: UserWhitespacable): Self = StObject.set(x, "UserWhitespacable", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setWhile(value: While): Self = StObject.set(x, "While", value.asInstanceOf[js.Any])
  }
}
