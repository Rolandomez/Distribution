package typings.babelTypes.libMod

import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

/* Inlined std.Partial<{[ Prop in keyof Object ]: Object[Prop] extends @babel/types.@babel/types/lib.Node? @babel/types.@babel/types/lib.Node | Object[Prop] : Object[Prop] extends std.Array<@babel/types.@babel/types/lib.Node>? std.Array<@babel/types.@babel/types/lib.Node> | Object[Prop] : Object[Prop]}> */
trait Opts[Object] extends StObject {
  
  var constructor: js.UndefOr[
    /* import warning: importer.ImportType#apply Failed type conversion: std.Function extends @babel/types.@babel/types/lib.Node ? @babel/types.@babel/types/lib.Node | std.Function : std.Function extends std.Array<@babel/types.@babel/types/lib.Node> ? std.Array<@babel/types.@babel/types/lib.Node> | std.Function : std.Function */ js.Any
  ] = js.undefined
  
  @JSName("hasOwnProperty")
  var hasOwnProperty_FOpts: js.UndefOr[
    /* import warning: importer.ImportType#apply Failed type conversion: (v : std.PropertyKey): boolean extends @babel/types.@babel/types/lib.Node ? @babel/types.@babel/types/lib.Node | (v : std.PropertyKey): boolean : (v : std.PropertyKey): boolean extends std.Array<@babel/types.@babel/types/lib.Node> ? std.Array<@babel/types.@babel/types/lib.Node> | (v : std.PropertyKey): boolean : (v : std.PropertyKey): boolean */ js.Any
  ] = js.undefined
  
  @JSName("isPrototypeOf")
  var isPrototypeOf_FOpts: js.UndefOr[
    /* import warning: importer.ImportType#apply Failed type conversion: (v : std.Object): boolean extends @babel/types.@babel/types/lib.Node ? @babel/types.@babel/types/lib.Node | (v : std.Object): boolean : (v : std.Object): boolean extends std.Array<@babel/types.@babel/types/lib.Node> ? std.Array<@babel/types.@babel/types/lib.Node> | (v : std.Object): boolean : (v : std.Object): boolean */ js.Any
  ] = js.undefined
  
  @JSName("propertyIsEnumerable")
  var propertyIsEnumerable_FOpts: js.UndefOr[
    /* import warning: importer.ImportType#apply Failed type conversion: (v : std.PropertyKey): boolean extends @babel/types.@babel/types/lib.Node ? @babel/types.@babel/types/lib.Node | (v : std.PropertyKey): boolean : (v : std.PropertyKey): boolean extends std.Array<@babel/types.@babel/types/lib.Node> ? std.Array<@babel/types.@babel/types/lib.Node> | (v : std.PropertyKey): boolean : (v : std.PropertyKey): boolean */ js.Any
  ] = js.undefined
  
  @JSName("toLocaleString")
  var toLocaleString_FOpts: js.UndefOr[
    /* import warning: importer.ImportType#apply Failed type conversion: (): string extends @babel/types.@babel/types/lib.Node ? @babel/types.@babel/types/lib.Node | (): string : (): string extends std.Array<@babel/types.@babel/types/lib.Node> ? std.Array<@babel/types.@babel/types/lib.Node> | (): string : (): string */ js.Any
  ] = js.undefined
  
  @JSName("toString")
  var toString_FOpts: js.UndefOr[
    /* import warning: importer.ImportType#apply Failed type conversion: (): string extends @babel/types.@babel/types/lib.Node ? @babel/types.@babel/types/lib.Node | (): string : (): string extends std.Array<@babel/types.@babel/types/lib.Node> ? std.Array<@babel/types.@babel/types/lib.Node> | (): string : (): string */ js.Any
  ] = js.undefined
  
  @JSName("valueOf")
  var valueOf_FOpts: js.UndefOr[
    /* import warning: importer.ImportType#apply Failed type conversion: (): std.Object extends @babel/types.@babel/types/lib.Node ? @babel/types.@babel/types/lib.Node | (): std.Object : (): std.Object extends std.Array<@babel/types.@babel/types/lib.Node> ? std.Array<@babel/types.@babel/types/lib.Node> | (): std.Object : (): std.Object */ js.Any
  ] = js.undefined
}
object Opts {
  
  inline def apply[Object](): Opts[Object] = {
    val __obj = js.Dynamic.literal()
    __obj.asInstanceOf[Opts[Object]]
  }
  
  @scala.inline
  implicit open class MutableBuilder[Self <: Opts[?], Object] (val x: Self & Opts[Object]) extends AnyVal {
    
    inline def setConstructor(
      value: /* import warning: importer.ImportType#apply Failed type conversion: std.Function extends @babel/types.@babel/types/lib.Node ? @babel/types.@babel/types/lib.Node | std.Function : std.Function extends std.Array<@babel/types.@babel/types/lib.Node> ? std.Array<@babel/types.@babel/types/lib.Node> | std.Function : std.Function */ js.Any
    ): Self = StObject.set(x, "constructor", value.asInstanceOf[js.Any])
    
    inline def setConstructorUndefined: Self = StObject.set(x, "constructor", js.undefined)
    
    inline def setHasOwnProperty(
      value: /* import warning: importer.ImportType#apply Failed type conversion: (v : std.PropertyKey): boolean extends @babel/types.@babel/types/lib.Node ? @babel/types.@babel/types/lib.Node | (v : std.PropertyKey): boolean : (v : std.PropertyKey): boolean extends std.Array<@babel/types.@babel/types/lib.Node> ? std.Array<@babel/types.@babel/types/lib.Node> | (v : std.PropertyKey): boolean : (v : std.PropertyKey): boolean */ js.Any
    ): Self = StObject.set(x, "hasOwnProperty", value.asInstanceOf[js.Any])
    
    inline def setHasOwnPropertyUndefined: Self = StObject.set(x, "hasOwnProperty", js.undefined)
    
    inline def setIsPrototypeOf(
      value: /* import warning: importer.ImportType#apply Failed type conversion: (v : std.Object): boolean extends @babel/types.@babel/types/lib.Node ? @babel/types.@babel/types/lib.Node | (v : std.Object): boolean : (v : std.Object): boolean extends std.Array<@babel/types.@babel/types/lib.Node> ? std.Array<@babel/types.@babel/types/lib.Node> | (v : std.Object): boolean : (v : std.Object): boolean */ js.Any
    ): Self = StObject.set(x, "isPrototypeOf", value.asInstanceOf[js.Any])
    
    inline def setIsPrototypeOfUndefined: Self = StObject.set(x, "isPrototypeOf", js.undefined)
    
    inline def setPropertyIsEnumerable(
      value: /* import warning: importer.ImportType#apply Failed type conversion: (v : std.PropertyKey): boolean extends @babel/types.@babel/types/lib.Node ? @babel/types.@babel/types/lib.Node | (v : std.PropertyKey): boolean : (v : std.PropertyKey): boolean extends std.Array<@babel/types.@babel/types/lib.Node> ? std.Array<@babel/types.@babel/types/lib.Node> | (v : std.PropertyKey): boolean : (v : std.PropertyKey): boolean */ js.Any
    ): Self = StObject.set(x, "propertyIsEnumerable", value.asInstanceOf[js.Any])
    
    inline def setPropertyIsEnumerableUndefined: Self = StObject.set(x, "propertyIsEnumerable", js.undefined)
    
    inline def setToLocaleString(
      value: /* import warning: importer.ImportType#apply Failed type conversion: (): string extends @babel/types.@babel/types/lib.Node ? @babel/types.@babel/types/lib.Node | (): string : (): string extends std.Array<@babel/types.@babel/types/lib.Node> ? std.Array<@babel/types.@babel/types/lib.Node> | (): string : (): string */ js.Any
    ): Self = StObject.set(x, "toLocaleString", value.asInstanceOf[js.Any])
    
    inline def setToLocaleStringUndefined: Self = StObject.set(x, "toLocaleString", js.undefined)
    
    inline def setToString_(
      value: /* import warning: importer.ImportType#apply Failed type conversion: (): string extends @babel/types.@babel/types/lib.Node ? @babel/types.@babel/types/lib.Node | (): string : (): string extends std.Array<@babel/types.@babel/types/lib.Node> ? std.Array<@babel/types.@babel/types/lib.Node> | (): string : (): string */ js.Any
    ): Self = StObject.set(x, "toString", value.asInstanceOf[js.Any])
    
    inline def setToString_Undefined: Self = StObject.set(x, "toString", js.undefined)
    
    inline def setValueOf(
      value: /* import warning: importer.ImportType#apply Failed type conversion: (): std.Object extends @babel/types.@babel/types/lib.Node ? @babel/types.@babel/types/lib.Node | (): std.Object : (): std.Object extends std.Array<@babel/types.@babel/types/lib.Node> ? std.Array<@babel/types.@babel/types/lib.Node> | (): std.Object : (): std.Object */ js.Any
    ): Self = StObject.set(x, "valueOf", value.asInstanceOf[js.Any])
    
    inline def setValueOfUndefined: Self = StObject.set(x, "valueOf", js.undefined)
  }
}
