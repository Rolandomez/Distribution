package typings.mirada

import typings.mirada.distSrcTypesOpencvHacksMod.double
import typings.mirada.distSrcTypesOpencvHacksMod.int
import typings.mirada.distSrcTypesOpencvTypesMod.InputArray
import typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray
import typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
import typings.mirada.distSrcTypesOpencvTypesMod.Point
import typings.mirada.distSrcTypesOpencvTypesMod.Rect
import typings.mirada.distSrcTypesOpencvTypesMod.Scalar
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object distSrcTypesOpencvImgprocMiscMod {
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", JSImport.Namespace)
  @js.native
  val ^ : js.Any = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "ADAPTIVE_THRESH_GAUSSIAN_C")
  @js.native
  val ADAPTIVE_THRESH_GAUSSIAN_C: AdaptiveThresholdTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "ADAPTIVE_THRESH_MEAN_C")
  @js.native
  val ADAPTIVE_THRESH_MEAN_C: AdaptiveThresholdTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "DIST_C")
  @js.native
  val DIST_C: DistanceTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "DIST_FAIR")
  @js.native
  val DIST_FAIR: DistanceTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "DIST_HUBER")
  @js.native
  val DIST_HUBER: DistanceTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "DIST_L1")
  @js.native
  val DIST_L1: DistanceTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "DIST_L12")
  @js.native
  val DIST_L12: DistanceTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "DIST_L2")
  @js.native
  val DIST_L2: DistanceTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "DIST_LABEL_CCOMP")
  @js.native
  val DIST_LABEL_CCOMP: DistanceTransformLabelTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "DIST_LABEL_PIXEL")
  @js.native
  val DIST_LABEL_PIXEL: DistanceTransformLabelTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "DIST_MASK_3")
  @js.native
  val DIST_MASK_3: DistanceTransformMasks = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "DIST_MASK_5")
  @js.native
  val DIST_MASK_5: DistanceTransformMasks = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "DIST_MASK_PRECISE")
  @js.native
  val DIST_MASK_PRECISE: DistanceTransformMasks = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "DIST_USER")
  @js.native
  val DIST_USER: DistanceTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "DIST_WELSCH")
  @js.native
  val DIST_WELSCH: DistanceTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "FLOODFILL_FIXED_RANGE")
  @js.native
  val FLOODFILL_FIXED_RANGE: FloodFillFlags = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "FLOODFILL_MASK_ONLY")
  @js.native
  val FLOODFILL_MASK_ONLY: FloodFillFlags = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "GC_BGD")
  @js.native
  val GC_BGD: GrabCutClasses = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "GC_EVAL")
  @js.native
  val GC_EVAL: GrabCutModes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "GC_EVAL_FREEZE_MODEL")
  @js.native
  val GC_EVAL_FREEZE_MODEL: GrabCutModes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "GC_FGD")
  @js.native
  val GC_FGD: GrabCutClasses = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "GC_INIT_WITH_MASK")
  @js.native
  val GC_INIT_WITH_MASK: GrabCutModes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "GC_INIT_WITH_RECT")
  @js.native
  val GC_INIT_WITH_RECT: GrabCutModes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "GC_PR_BGD")
  @js.native
  val GC_PR_BGD: GrabCutClasses = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "GC_PR_FGD")
  @js.native
  val GC_PR_FGD: GrabCutClasses = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "THRESH_BINARY")
  @js.native
  val THRESH_BINARY: ThresholdTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "THRESH_BINARY_INV")
  @js.native
  val THRESH_BINARY_INV: ThresholdTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "THRESH_MASK")
  @js.native
  val THRESH_MASK: ThresholdTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "THRESH_OTSU")
  @js.native
  val THRESH_OTSU: ThresholdTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "THRESH_TOZERO")
  @js.native
  val THRESH_TOZERO: ThresholdTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "THRESH_TOZERO_INV")
  @js.native
  val THRESH_TOZERO_INV: ThresholdTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "THRESH_TRIANGLE")
  @js.native
  val THRESH_TRIANGLE: ThresholdTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/imgproc_misc", "THRESH_TRUNC")
  @js.native
  val THRESH_TRUNC: ThresholdTypes = js.native
  
  inline def adaptiveThreshold(
    src: InputArray,
    dst: OutputArray,
    maxValue: double,
    adaptiveMethod: int,
    thresholdType: int,
    blockSize: int,
    C: double
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("adaptiveThreshold")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], maxValue.asInstanceOf[js.Any], adaptiveMethod.asInstanceOf[js.Any], thresholdType.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], C.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def blendLinear(src1: InputArray, src2: InputArray, weights1: InputArray, weights2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("blendLinear")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], weights1.asInstanceOf[js.Any], weights2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def distanceTransform(src: InputArray, dst: OutputArray, distanceType: int, maskSize: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("distanceTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], distanceType.asInstanceOf[js.Any], maskSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def distanceTransform(src: InputArray, dst: OutputArray, distanceType: int, maskSize: int, dstType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("distanceTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], distanceType.asInstanceOf[js.Any], maskSize.asInstanceOf[js.Any], dstType.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def distanceTransform(src: InputArray, dst: OutputArray, labels: OutputArray, distanceType: int, maskSize: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("distanceTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], labels.asInstanceOf[js.Any], distanceType.asInstanceOf[js.Any], maskSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def distanceTransform(
    src: InputArray,
    dst: OutputArray,
    labels: OutputArray,
    distanceType: int,
    maskSize: int,
    labelType: int
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("distanceTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], labels.asInstanceOf[js.Any], distanceType.asInstanceOf[js.Any], maskSize.asInstanceOf[js.Any], labelType.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def floodFill(image: InputOutputArray, mask: InputOutputArray, seedPoint: Point, newVal: Scalar): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(image: InputOutputArray, mask: InputOutputArray, seedPoint: Point, newVal: Scalar, rect: Any): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(
    image: InputOutputArray,
    mask: InputOutputArray,
    seedPoint: Point,
    newVal: Scalar,
    rect: Any,
    loDiff: Unit,
    upDiff: Unit,
    flags: int
  ): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(
    image: InputOutputArray,
    mask: InputOutputArray,
    seedPoint: Point,
    newVal: Scalar,
    rect: Any,
    loDiff: Unit,
    upDiff: Scalar
  ): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(
    image: InputOutputArray,
    mask: InputOutputArray,
    seedPoint: Point,
    newVal: Scalar,
    rect: Any,
    loDiff: Unit,
    upDiff: Scalar,
    flags: int
  ): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(
    image: InputOutputArray,
    mask: InputOutputArray,
    seedPoint: Point,
    newVal: Scalar,
    rect: Any,
    loDiff: Scalar
  ): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(
    image: InputOutputArray,
    mask: InputOutputArray,
    seedPoint: Point,
    newVal: Scalar,
    rect: Any,
    loDiff: Scalar,
    upDiff: Unit,
    flags: int
  ): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(
    image: InputOutputArray,
    mask: InputOutputArray,
    seedPoint: Point,
    newVal: Scalar,
    rect: Any,
    loDiff: Scalar,
    upDiff: Scalar
  ): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(
    image: InputOutputArray,
    mask: InputOutputArray,
    seedPoint: Point,
    newVal: Scalar,
    rect: Any,
    loDiff: Scalar,
    upDiff: Scalar,
    flags: int
  ): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(
    image: InputOutputArray,
    mask: InputOutputArray,
    seedPoint: Point,
    newVal: Scalar,
    rect: Unit,
    loDiff: Unit,
    upDiff: Unit,
    flags: int
  ): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(
    image: InputOutputArray,
    mask: InputOutputArray,
    seedPoint: Point,
    newVal: Scalar,
    rect: Unit,
    loDiff: Unit,
    upDiff: Scalar
  ): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(
    image: InputOutputArray,
    mask: InputOutputArray,
    seedPoint: Point,
    newVal: Scalar,
    rect: Unit,
    loDiff: Unit,
    upDiff: Scalar,
    flags: int
  ): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(
    image: InputOutputArray,
    mask: InputOutputArray,
    seedPoint: Point,
    newVal: Scalar,
    rect: Unit,
    loDiff: Scalar
  ): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(
    image: InputOutputArray,
    mask: InputOutputArray,
    seedPoint: Point,
    newVal: Scalar,
    rect: Unit,
    loDiff: Scalar,
    upDiff: Unit,
    flags: int
  ): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(
    image: InputOutputArray,
    mask: InputOutputArray,
    seedPoint: Point,
    newVal: Scalar,
    rect: Unit,
    loDiff: Scalar,
    upDiff: Scalar
  ): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(
    image: InputOutputArray,
    mask: InputOutputArray,
    seedPoint: Point,
    newVal: Scalar,
    rect: Unit,
    loDiff: Scalar,
    upDiff: Scalar,
    flags: int
  ): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(image: InputOutputArray, seedPoint: Point, newVal: Scalar): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(image: InputOutputArray, seedPoint: Point, newVal: Scalar, rect: Any): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(
    image: InputOutputArray,
    seedPoint: Point,
    newVal: Scalar,
    rect: Any,
    loDiff: Unit,
    upDiff: Unit,
    flags: int
  ): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(image: InputOutputArray, seedPoint: Point, newVal: Scalar, rect: Any, loDiff: Unit, upDiff: Scalar): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(
    image: InputOutputArray,
    seedPoint: Point,
    newVal: Scalar,
    rect: Any,
    loDiff: Unit,
    upDiff: Scalar,
    flags: int
  ): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(image: InputOutputArray, seedPoint: Point, newVal: Scalar, rect: Any, loDiff: Scalar): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(
    image: InputOutputArray,
    seedPoint: Point,
    newVal: Scalar,
    rect: Any,
    loDiff: Scalar,
    upDiff: Unit,
    flags: int
  ): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(
    image: InputOutputArray,
    seedPoint: Point,
    newVal: Scalar,
    rect: Any,
    loDiff: Scalar,
    upDiff: Scalar
  ): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(
    image: InputOutputArray,
    seedPoint: Point,
    newVal: Scalar,
    rect: Any,
    loDiff: Scalar,
    upDiff: Scalar,
    flags: int
  ): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(
    image: InputOutputArray,
    seedPoint: Point,
    newVal: Scalar,
    rect: Unit,
    loDiff: Unit,
    upDiff: Unit,
    flags: int
  ): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(
    image: InputOutputArray,
    seedPoint: Point,
    newVal: Scalar,
    rect: Unit,
    loDiff: Unit,
    upDiff: Scalar
  ): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(
    image: InputOutputArray,
    seedPoint: Point,
    newVal: Scalar,
    rect: Unit,
    loDiff: Unit,
    upDiff: Scalar,
    flags: int
  ): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(image: InputOutputArray, seedPoint: Point, newVal: Scalar, rect: Unit, loDiff: Scalar): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(
    image: InputOutputArray,
    seedPoint: Point,
    newVal: Scalar,
    rect: Unit,
    loDiff: Scalar,
    upDiff: Unit,
    flags: int
  ): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(
    image: InputOutputArray,
    seedPoint: Point,
    newVal: Scalar,
    rect: Unit,
    loDiff: Scalar,
    upDiff: Scalar
  ): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any])).asInstanceOf[int]
  inline def floodFill(
    image: InputOutputArray,
    seedPoint: Point,
    newVal: Scalar,
    rect: Unit,
    loDiff: Scalar,
    upDiff: Scalar,
    flags: int
  ): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
  
  inline def grabCut(
    img: InputArray,
    mask: InputOutputArray,
    rect: Rect,
    bgdModel: InputOutputArray,
    fgdModel: InputOutputArray,
    iterCount: int
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("grabCut")(img.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], bgdModel.asInstanceOf[js.Any], fgdModel.asInstanceOf[js.Any], iterCount.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def grabCut(
    img: InputArray,
    mask: InputOutputArray,
    rect: Rect,
    bgdModel: InputOutputArray,
    fgdModel: InputOutputArray,
    iterCount: int,
    mode: int
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("grabCut")(img.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], bgdModel.asInstanceOf[js.Any], fgdModel.asInstanceOf[js.Any], iterCount.asInstanceOf[js.Any], mode.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def integral(src: InputArray, sum: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def integral(src: InputArray, sum: OutputArray, sdepth: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sdepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def integral(src: InputArray, sum: OutputArray, sqsum: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sqsum.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def integral(src: InputArray, sum: OutputArray, sqsum: OutputArray, sdepth: Unit, sqdepth: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sqsum.asInstanceOf[js.Any], sdepth.asInstanceOf[js.Any], sqdepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def integral(src: InputArray, sum: OutputArray, sqsum: OutputArray, sdepth: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sqsum.asInstanceOf[js.Any], sdepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def integral(src: InputArray, sum: OutputArray, sqsum: OutputArray, sdepth: int, sqdepth: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sqsum.asInstanceOf[js.Any], sdepth.asInstanceOf[js.Any], sqdepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def integral(src: InputArray, sum: OutputArray, sqsum: OutputArray, tilted: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sqsum.asInstanceOf[js.Any], tilted.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def integral(
    src: InputArray,
    sum: OutputArray,
    sqsum: OutputArray,
    tilted: OutputArray,
    sdepth: Unit,
    sqdepth: int
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sqsum.asInstanceOf[js.Any], tilted.asInstanceOf[js.Any], sdepth.asInstanceOf[js.Any], sqdepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def integral(src: InputArray, sum: OutputArray, sqsum: OutputArray, tilted: OutputArray, sdepth: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sqsum.asInstanceOf[js.Any], tilted.asInstanceOf[js.Any], sdepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def integral(
    src: InputArray,
    sum: OutputArray,
    sqsum: OutputArray,
    tilted: OutputArray,
    sdepth: int,
    sqdepth: int
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sqsum.asInstanceOf[js.Any], tilted.asInstanceOf[js.Any], sdepth.asInstanceOf[js.Any], sqdepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def threshold(src: InputArray, dst: OutputArray, thresh: double, maxval: double, `type`: int): double = (^.asInstanceOf[js.Dynamic].applyDynamic("threshold")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], thresh.asInstanceOf[js.Any], maxval.asInstanceOf[js.Any], `type`.asInstanceOf[js.Any])).asInstanceOf[double]
  
  inline def watershed(image: InputArray, markers: InputOutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("watershed")(image.asInstanceOf[js.Any], markers.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  type AdaptiveThresholdTypes = Any
  
  type DistanceTransformLabelTypes = Any
  
  type DistanceTransformMasks = Any
  
  type DistanceTypes = Any
  
  type FloodFillFlags = Any
  
  type GrabCutClasses = Any
  
  type GrabCutModes = Any
  
  type ThresholdTypes = Any
}
