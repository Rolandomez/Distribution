package typings.mirada.distSrcTypesOpencvTypesMod

import typings.mirada.distSrcTypesOpencvCalib3dMod.HandEyeCalibrationMethod
import typings.mirada.distSrcTypesOpencvCalib3dMod.SolvePnPMethod
import typings.mirada.distSrcTypesOpencvCalib3dMod.UndistortTypes
import typings.mirada.distSrcTypesOpencvCoreArrayMod.BorderTypes
import typings.mirada.distSrcTypesOpencvCoreArrayMod.CmpTypes
import typings.mirada.distSrcTypesOpencvCoreArrayMod.DecompTypes
import typings.mirada.distSrcTypesOpencvCoreArrayMod.DftFlags
import typings.mirada.distSrcTypesOpencvCoreArrayMod.GemmFlags
import typings.mirada.distSrcTypesOpencvCoreArrayMod.NormTypes
import typings.mirada.distSrcTypesOpencvCoreArrayMod.RotateFlags
import typings.mirada.distSrcTypesOpencvCoreUtilsMod.CpuFeatures
import typings.mirada.distSrcTypesOpencvCoreUtilsMod.SortFlags
import typings.mirada.distSrcTypesOpencvDescriptorMatcherMod.MatcherType
import typings.mirada.distSrcTypesOpencvDnnMod.Backend
import typings.mirada.distSrcTypesOpencvDnnMod.Target
import typings.mirada.distSrcTypesOpencvFeatures2dDrawMod.DrawMatchesFlags
import typings.mirada.distSrcTypesOpencvHacksMod.AsyncArray
import typings.mirada.distSrcTypesOpencvHacksMod.CVDataType
import typings.mirada.distSrcTypesOpencvHacksMod.EqPredicate
import typings.mirada.distSrcTypesOpencvHacksMod.ErrorCallback
import typings.mirada.distSrcTypesOpencvHacksMod.Moments
import typings.mirada.distSrcTypesOpencvHacksMod.Net
import typings.mirada.distSrcTypesOpencvHacksMod.Tp
import typings.mirada.distSrcTypesOpencvHacksMod.bool
import typings.mirada.distSrcTypesOpencvHacksMod.cvhalDFT
import typings.mirada.distSrcTypesOpencvHacksMod.double
import typings.mirada.distSrcTypesOpencvHacksMod.float
import typings.mirada.distSrcTypesOpencvHacksMod.float16T
import typings.mirada.distSrcTypesOpencvHacksMod.int
import typings.mirada.distSrcTypesOpencvHacksMod.int64
import typings.mirada.distSrcTypesOpencvHacksMod.schar
import typings.mirada.distSrcTypesOpencvHacksMod.short
import typings.mirada.distSrcTypesOpencvHacksMod.sizeT
import typings.mirada.distSrcTypesOpencvHacksMod.uchar
import typings.mirada.distSrcTypesOpencvHacksMod.uint64
import typings.mirada.distSrcTypesOpencvHacksMod.unsigned
import typings.mirada.distSrcTypesOpencvHacksMod.ushort
import typings.mirada.distSrcTypesOpencvHogdescriptorMod.DescriptorStorageFormat
import typings.mirada.distSrcTypesOpencvHogdescriptorMod.HistogramNormType
import typings.mirada.distSrcTypesOpencvImgprocColorConversionsMod.ColorConversionCodes
import typings.mirada.distSrcTypesOpencvImgprocDrawMod.HersheyFonts
import typings.mirada.distSrcTypesOpencvImgprocDrawMod.LineTypes
import typings.mirada.distSrcTypesOpencvImgprocDrawMod.MarkerTypes
import typings.mirada.distSrcTypesOpencvImgprocFeatureMod.HoughModes
import typings.mirada.distSrcTypesOpencvImgprocFeatureMod.LineSegmentDetectorModes
import typings.mirada.distSrcTypesOpencvImgprocFilterMod.MorphShapes
import typings.mirada.distSrcTypesOpencvImgprocFilterMod.MorphTypes
import typings.mirada.distSrcTypesOpencvImgprocFilterMod.SpecialFilter
import typings.mirada.distSrcTypesOpencvImgprocHistMod.HistCompMethods
import typings.mirada.distSrcTypesOpencvImgprocMiscMod.AdaptiveThresholdTypes
import typings.mirada.distSrcTypesOpencvImgprocMiscMod.DistanceTransformLabelTypes
import typings.mirada.distSrcTypesOpencvImgprocMiscMod.DistanceTransformMasks
import typings.mirada.distSrcTypesOpencvImgprocMiscMod.DistanceTypes
import typings.mirada.distSrcTypesOpencvImgprocMiscMod.FloodFillFlags
import typings.mirada.distSrcTypesOpencvImgprocMiscMod.GrabCutClasses
import typings.mirada.distSrcTypesOpencvImgprocMiscMod.GrabCutModes
import typings.mirada.distSrcTypesOpencvImgprocMiscMod.ThresholdTypes
import typings.mirada.distSrcTypesOpencvImgprocObjectMod.TemplateMatchModes
import typings.mirada.distSrcTypesOpencvImgprocShapeMod.ConnectedComponentsAlgorithmsTypes
import typings.mirada.distSrcTypesOpencvImgprocShapeMod.ConnectedComponentsTypes
import typings.mirada.distSrcTypesOpencvImgprocShapeMod.ContourApproximationModes
import typings.mirada.distSrcTypesOpencvImgprocShapeMod.RectanglesIntersectTypes
import typings.mirada.distSrcTypesOpencvImgprocShapeMod.RetrievalModes
import typings.mirada.distSrcTypesOpencvImgprocShapeMod.ShapeMatchModes
import typings.mirada.distSrcTypesOpencvImgprocTransformMod.InterpolationFlags
import typings.mirada.distSrcTypesOpencvImgprocTransformMod.InterpolationMasks
import typings.mirada.distSrcTypesOpencvImgprocTransformMod.WarpPolarMode
import typings.mirada.distSrcTypesOpencvLshTableMod.SpeedLevel
import typings.mirada.distSrcTypesOpencvPcaMod.Flags
import typings.mirada.distSrcTypesOpencvTypesMod.^
import typings.std.HTMLElement
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}


inline def ADAPTIVE_THRESH_GAUSSIAN_C: AdaptiveThresholdTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("ADAPTIVE_THRESH_GAUSSIAN_C").asInstanceOf[AdaptiveThresholdTypes]

inline def ADAPTIVE_THRESH_MEAN_C: AdaptiveThresholdTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("ADAPTIVE_THRESH_MEAN_C").asInstanceOf[AdaptiveThresholdTypes]

inline def AUTO_STEP: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("AUTO_STEP").asInstanceOf[Any]

inline def BORDER_CONSTANT: BorderTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("BORDER_CONSTANT").asInstanceOf[BorderTypes]

inline def BORDER_DEFAULT: BorderTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("BORDER_DEFAULT").asInstanceOf[BorderTypes]

inline def BORDER_ISOLATED: BorderTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("BORDER_ISOLATED").asInstanceOf[BorderTypes]

inline def BORDER_REFLECT: BorderTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("BORDER_REFLECT").asInstanceOf[BorderTypes]

inline def BORDER_REFLECT101: BorderTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("BORDER_REFLECT101").asInstanceOf[BorderTypes]

inline def BORDER_REFLECT_101: BorderTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("BORDER_REFLECT_101").asInstanceOf[BorderTypes]

inline def BORDER_REPLICATE: BorderTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("BORDER_REPLICATE").asInstanceOf[BorderTypes]

inline def BORDER_TRANSPARENT: BorderTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("BORDER_TRANSPARENT").asInstanceOf[BorderTypes]

inline def BORDER_WRAP: BorderTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("BORDER_WRAP").asInstanceOf[BorderTypes]

inline def BRUTEFORCE: MatcherType = ^.asInstanceOf[js.Dynamic].selectDynamic("BRUTEFORCE").asInstanceOf[MatcherType]

inline def BRUTEFORCE_HAMMING: MatcherType = ^.asInstanceOf[js.Dynamic].selectDynamic("BRUTEFORCE_HAMMING").asInstanceOf[MatcherType]

inline def BRUTEFORCE_HAMMINGLUT: MatcherType = ^.asInstanceOf[js.Dynamic].selectDynamic("BRUTEFORCE_HAMMINGLUT").asInstanceOf[MatcherType]

inline def BRUTEFORCE_L1: MatcherType = ^.asInstanceOf[js.Dynamic].selectDynamic("BRUTEFORCE_L1").asInstanceOf[MatcherType]

inline def BRUTEFORCE_SL2: MatcherType = ^.asInstanceOf[js.Dynamic].selectDynamic("BRUTEFORCE_SL2").asInstanceOf[MatcherType]

inline def CALIB_CB_ACCURACY: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_CB_ACCURACY").asInstanceOf[Any]

inline def CALIB_CB_ADAPTIVE_THRESH: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_CB_ADAPTIVE_THRESH").asInstanceOf[Any]

inline def CALIB_CB_ASYMMETRIC_GRID: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_CB_ASYMMETRIC_GRID").asInstanceOf[Any]

inline def CALIB_CB_CLUSTERING: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_CB_CLUSTERING").asInstanceOf[Any]

inline def CALIB_CB_EXHAUSTIVE: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_CB_EXHAUSTIVE").asInstanceOf[Any]

inline def CALIB_CB_FAST_CHECK: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_CB_FAST_CHECK").asInstanceOf[Any]

inline def CALIB_CB_FILTER_QUADS: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_CB_FILTER_QUADS").asInstanceOf[Any]

inline def CALIB_CB_NORMALIZE_IMAGE: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_CB_NORMALIZE_IMAGE").asInstanceOf[Any]

inline def CALIB_CB_SYMMETRIC_GRID: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_CB_SYMMETRIC_GRID").asInstanceOf[Any]

inline def CALIB_FIX_ASPECT_RATIO: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_FIX_ASPECT_RATIO").asInstanceOf[Any]

inline def CALIB_FIX_FOCAL_LENGTH: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_FIX_FOCAL_LENGTH").asInstanceOf[Any]

inline def CALIB_FIX_INTRINSIC: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_FIX_INTRINSIC").asInstanceOf[Any]

inline def CALIB_FIX_K1: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_FIX_K1").asInstanceOf[Any]

inline def CALIB_FIX_K2: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_FIX_K2").asInstanceOf[Any]

inline def CALIB_FIX_K3: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_FIX_K3").asInstanceOf[Any]

inline def CALIB_FIX_K4: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_FIX_K4").asInstanceOf[Any]

inline def CALIB_FIX_K5: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_FIX_K5").asInstanceOf[Any]

inline def CALIB_FIX_K6: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_FIX_K6").asInstanceOf[Any]

inline def CALIB_FIX_PRINCIPAL_POINT: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_FIX_PRINCIPAL_POINT").asInstanceOf[Any]

inline def CALIB_FIX_S1_S2_S3_S4: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_FIX_S1_S2_S3_S4").asInstanceOf[Any]

inline def CALIB_FIX_TANGENT_DIST: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_FIX_TANGENT_DIST").asInstanceOf[Any]

inline def CALIB_FIX_TAUX_TAUY: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_FIX_TAUX_TAUY").asInstanceOf[Any]

inline def CALIB_HAND_EYE_ANDREFF: HandEyeCalibrationMethod = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_HAND_EYE_ANDREFF").asInstanceOf[HandEyeCalibrationMethod]

inline def CALIB_HAND_EYE_DANIILIDIS: HandEyeCalibrationMethod = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_HAND_EYE_DANIILIDIS").asInstanceOf[HandEyeCalibrationMethod]

inline def CALIB_HAND_EYE_HORAUD: HandEyeCalibrationMethod = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_HAND_EYE_HORAUD").asInstanceOf[HandEyeCalibrationMethod]

inline def CALIB_HAND_EYE_PARK: HandEyeCalibrationMethod = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_HAND_EYE_PARK").asInstanceOf[HandEyeCalibrationMethod]

inline def CALIB_HAND_EYE_TSAI: HandEyeCalibrationMethod = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_HAND_EYE_TSAI").asInstanceOf[HandEyeCalibrationMethod]

inline def CALIB_NINTRINSIC: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_NINTRINSIC").asInstanceOf[Any]

inline def CALIB_RATIONAL_MODEL: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_RATIONAL_MODEL").asInstanceOf[Any]

inline def CALIB_SAME_FOCAL_LENGTH: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_SAME_FOCAL_LENGTH").asInstanceOf[Any]

inline def CALIB_THIN_PRISM_MODEL: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_THIN_PRISM_MODEL").asInstanceOf[Any]

inline def CALIB_TILTED_MODEL: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_TILTED_MODEL").asInstanceOf[Any]

inline def CALIB_USE_EXTRINSIC_GUESS: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_USE_EXTRINSIC_GUESS").asInstanceOf[Any]

inline def CALIB_USE_INTRINSIC_GUESS: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_USE_INTRINSIC_GUESS").asInstanceOf[Any]

inline def CALIB_USE_LU: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_USE_LU").asInstanceOf[Any]

inline def CALIB_USE_QR: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_USE_QR").asInstanceOf[Any]

inline def CALIB_ZERO_DISPARITY: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_ZERO_DISPARITY").asInstanceOf[Any]

inline def CALIB_ZERO_TANGENT_DIST: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_ZERO_TANGENT_DIST").asInstanceOf[Any]

inline def CASCADE_DO_CANNY_PRUNING: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CASCADE_DO_CANNY_PRUNING").asInstanceOf[Any]

inline def CASCADE_DO_ROUGH_SEARCH: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CASCADE_DO_ROUGH_SEARCH").asInstanceOf[Any]

inline def CASCADE_FIND_BIGGEST_OBJECT: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CASCADE_FIND_BIGGEST_OBJECT").asInstanceOf[Any]

inline def CASCADE_SCALE_IMAGE: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CASCADE_SCALE_IMAGE").asInstanceOf[Any]

inline def CCL_DEFAULT: ConnectedComponentsAlgorithmsTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CCL_DEFAULT").asInstanceOf[ConnectedComponentsAlgorithmsTypes]

inline def CCL_GRANA: ConnectedComponentsAlgorithmsTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CCL_GRANA").asInstanceOf[ConnectedComponentsAlgorithmsTypes]

inline def CCL_WU: ConnectedComponentsAlgorithmsTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CCL_WU").asInstanceOf[ConnectedComponentsAlgorithmsTypes]

inline def CC_STAT_AREA: ConnectedComponentsTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CC_STAT_AREA").asInstanceOf[ConnectedComponentsTypes]

inline def CC_STAT_HEIGHT: ConnectedComponentsTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CC_STAT_HEIGHT").asInstanceOf[ConnectedComponentsTypes]

inline def CC_STAT_LEFT: ConnectedComponentsTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CC_STAT_LEFT").asInstanceOf[ConnectedComponentsTypes]

inline def CC_STAT_MAX: ConnectedComponentsTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CC_STAT_MAX").asInstanceOf[ConnectedComponentsTypes]

inline def CC_STAT_TOP: ConnectedComponentsTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CC_STAT_TOP").asInstanceOf[ConnectedComponentsTypes]

inline def CC_STAT_WIDTH: ConnectedComponentsTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CC_STAT_WIDTH").asInstanceOf[ConnectedComponentsTypes]

inline def CHAIN_APPROX_NONE: ContourApproximationModes = ^.asInstanceOf[js.Dynamic].selectDynamic("CHAIN_APPROX_NONE").asInstanceOf[ContourApproximationModes]

inline def CHAIN_APPROX_SIMPLE: ContourApproximationModes = ^.asInstanceOf[js.Dynamic].selectDynamic("CHAIN_APPROX_SIMPLE").asInstanceOf[ContourApproximationModes]

inline def CHAIN_APPROX_TC89_KCOS: ContourApproximationModes = ^.asInstanceOf[js.Dynamic].selectDynamic("CHAIN_APPROX_TC89_KCOS").asInstanceOf[ContourApproximationModes]

inline def CHAIN_APPROX_TC89_L1: ContourApproximationModes = ^.asInstanceOf[js.Dynamic].selectDynamic("CHAIN_APPROX_TC89_L1").asInstanceOf[ContourApproximationModes]

inline def CMP_EQ: CmpTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CMP_EQ").asInstanceOf[CmpTypes]

inline def CMP_GE: CmpTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CMP_GE").asInstanceOf[CmpTypes]

inline def CMP_GT: CmpTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CMP_GT").asInstanceOf[CmpTypes]

inline def CMP_LE: CmpTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CMP_LE").asInstanceOf[CmpTypes]

inline def CMP_LT: CmpTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CMP_LT").asInstanceOf[CmpTypes]

inline def CMP_NE: CmpTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CMP_NE").asInstanceOf[CmpTypes]

inline def COLORBGR2Lab: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2Lab").asInstanceOf[ColorConversionCodes]

inline def COLORBGR2Luv: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2Luv").asInstanceOf[ColorConversionCodes]

inline def COLORBGR2YCrCb: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2YCrCb").asInstanceOf[ColorConversionCodes]

inline def COLORBayerBG2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerBG2BGR").asInstanceOf[ColorConversionCodes]

inline def COLORBayerBG2BGRA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerBG2BGRA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerBG2BGREA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerBG2BGR_EA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerBG2BGRVNG: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerBG2BGR_VNG").asInstanceOf[ColorConversionCodes]

inline def COLORBayerBG2GRAY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerBG2GRAY").asInstanceOf[ColorConversionCodes]

inline def COLORBayerBG2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerBG2RGB").asInstanceOf[ColorConversionCodes]

inline def COLORBayerBG2RGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerBG2RGBA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerBG2RGBEA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerBG2RGB_EA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerBG2RGBVNG: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerBG2RGB_VNG").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGB2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGB2BGR").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGB2BGRA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGB2BGRA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGB2BGREA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGB2BGR_EA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGB2BGRVNG: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGB2BGR_VNG").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGB2GRAY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGB2GRAY").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGB2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGB2RGB").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGB2RGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGB2RGBA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGB2RGBEA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGB2RGB_EA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGB2RGBVNG: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGB2RGB_VNG").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGR2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGR2BGR").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGR2BGRA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGR2BGRA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGR2BGREA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGR2BGR_EA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGR2BGRVNG: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGR2BGR_VNG").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGR2GRAY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGR2GRAY").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGR2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGR2RGB").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGR2RGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGR2RGBA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGR2RGBEA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGR2RGB_EA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGR2RGBVNG: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGR2RGB_VNG").asInstanceOf[ColorConversionCodes]

inline def COLORBayerRG2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerRG2BGR").asInstanceOf[ColorConversionCodes]

inline def COLORBayerRG2BGRA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerRG2BGRA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerRG2BGREA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerRG2BGR_EA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerRG2BGRVNG: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerRG2BGR_VNG").asInstanceOf[ColorConversionCodes]

inline def COLORBayerRG2GRAY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerRG2GRAY").asInstanceOf[ColorConversionCodes]

inline def COLORBayerRG2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerRG2RGB").asInstanceOf[ColorConversionCodes]

inline def COLORBayerRG2RGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerRG2RGBA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerRG2RGBEA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerRG2RGB_EA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerRG2RGBVNG: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerRG2RGB_VNG").asInstanceOf[ColorConversionCodes]

inline def COLORLBGR2Lab: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_LBGR2Lab").asInstanceOf[ColorConversionCodes]

inline def COLORLBGR2Luv: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_LBGR2Luv").asInstanceOf[ColorConversionCodes]

inline def COLORLRGB2Lab: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_LRGB2Lab").asInstanceOf[ColorConversionCodes]

inline def COLORLRGB2Luv: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_LRGB2Luv").asInstanceOf[ColorConversionCodes]

inline def COLORLab2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_Lab2BGR").asInstanceOf[ColorConversionCodes]

inline def COLORLab2LBGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_Lab2LBGR").asInstanceOf[ColorConversionCodes]

inline def COLORLab2LRGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_Lab2LRGB").asInstanceOf[ColorConversionCodes]

inline def COLORLab2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_Lab2RGB").asInstanceOf[ColorConversionCodes]

inline def COLORLuv2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_Luv2BGR").asInstanceOf[ColorConversionCodes]

inline def COLORLuv2LBGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_Luv2LBGR").asInstanceOf[ColorConversionCodes]

inline def COLORLuv2LRGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_Luv2LRGB").asInstanceOf[ColorConversionCodes]

inline def COLORLuv2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_Luv2RGB").asInstanceOf[ColorConversionCodes]

inline def COLORMRGBA2RGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_mRGBA2RGBA").asInstanceOf[ColorConversionCodes]

inline def COLORRGB2Lab: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2Lab").asInstanceOf[ColorConversionCodes]

inline def COLORRGB2Luv: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2Luv").asInstanceOf[ColorConversionCodes]

inline def COLORRGB2YCrCb: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2YCrCb").asInstanceOf[ColorConversionCodes]

inline def COLORRGBA2mRGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGBA2mRGBA").asInstanceOf[ColorConversionCodes]

inline def COLORYCrCb2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YCrCb2BGR").asInstanceOf[ColorConversionCodes]

inline def COLORYCrCb2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YCrCb2RGB").asInstanceOf[ColorConversionCodes]

inline def COLORYUV420p2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV420p2BGR").asInstanceOf[ColorConversionCodes]

inline def COLORYUV420p2BGRA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV420p2BGRA").asInstanceOf[ColorConversionCodes]

inline def COLORYUV420p2GRAY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV420p2GRAY").asInstanceOf[ColorConversionCodes]

inline def COLORYUV420p2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV420p2RGB").asInstanceOf[ColorConversionCodes]

inline def COLORYUV420p2RGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV420p2RGBA").asInstanceOf[ColorConversionCodes]

inline def COLORYUV420sp2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV420sp2BGR").asInstanceOf[ColorConversionCodes]

inline def COLORYUV420sp2BGRA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV420sp2BGRA").asInstanceOf[ColorConversionCodes]

inline def COLORYUV420sp2GRAY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV420sp2GRAY").asInstanceOf[ColorConversionCodes]

inline def COLORYUV420sp2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV420sp2RGB").asInstanceOf[ColorConversionCodes]

inline def COLORYUV420sp2RGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV420sp2RGBA").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2BGR555: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2BGR555").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2BGR565: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2BGR565").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2BGRA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2BGRA").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2GRAY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2GRAY").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2HLS: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2HLS").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2HLS_FULL: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2HLS_FULL").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2HSV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2HSV").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2HSV_FULL: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2HSV_FULL").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2RGB").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2RGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2RGBA").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2XYZ: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2XYZ").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2YUV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2YUV").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2YUV_I420: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2YUV_I420").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2YUV_IYUV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2YUV_IYUV").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2YUV_YV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2YUV_YV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR5552BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR5552BGR").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR5552BGRA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR5552BGRA").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR5552GRAY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR5552GRAY").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR5552RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR5552RGB").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR5552RGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR5552RGBA").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR5652BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR5652BGR").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR5652BGRA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR5652BGRA").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR5652GRAY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR5652GRAY").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR5652RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR5652RGB").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR5652RGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR5652RGBA").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGRA2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGRA2BGR").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGRA2BGR555: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGRA2BGR555").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGRA2BGR565: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGRA2BGR565").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGRA2GRAY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGRA2GRAY").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGRA2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGRA2RGB").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGRA2RGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGRA2RGBA").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGRA2YUV_I420: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGRA2YUV_I420").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGRA2YUV_IYUV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGRA2YUV_IYUV").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGRA2YUV_YV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGRA2YUV_YV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_COLORCVT_MAX: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_COLORCVT_MAX").asInstanceOf[ColorConversionCodes]

inline def COLOR_GRAY2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_GRAY2BGR").asInstanceOf[ColorConversionCodes]

inline def COLOR_GRAY2BGR555: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_GRAY2BGR555").asInstanceOf[ColorConversionCodes]

inline def COLOR_GRAY2BGR565: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_GRAY2BGR565").asInstanceOf[ColorConversionCodes]

inline def COLOR_GRAY2BGRA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_GRAY2BGRA").asInstanceOf[ColorConversionCodes]

inline def COLOR_GRAY2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_GRAY2RGB").asInstanceOf[ColorConversionCodes]

inline def COLOR_GRAY2RGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_GRAY2RGBA").asInstanceOf[ColorConversionCodes]

inline def COLOR_HLS2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_HLS2BGR").asInstanceOf[ColorConversionCodes]

inline def COLOR_HLS2BGR_FULL: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_HLS2BGR_FULL").asInstanceOf[ColorConversionCodes]

inline def COLOR_HLS2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_HLS2RGB").asInstanceOf[ColorConversionCodes]

inline def COLOR_HLS2RGB_FULL: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_HLS2RGB_FULL").asInstanceOf[ColorConversionCodes]

inline def COLOR_HSV2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_HSV2BGR").asInstanceOf[ColorConversionCodes]

inline def COLOR_HSV2BGR_FULL: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_HSV2BGR_FULL").asInstanceOf[ColorConversionCodes]

inline def COLOR_HSV2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_HSV2RGB").asInstanceOf[ColorConversionCodes]

inline def COLOR_HSV2RGB_FULL: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_HSV2RGB_FULL").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2BGR").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2BGR555: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2BGR555").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2BGR565: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2BGR565").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2BGRA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2BGRA").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2GRAY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2GRAY").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2HLS: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2HLS").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2HLS_FULL: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2HLS_FULL").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2HSV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2HSV").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2HSV_FULL: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2HSV_FULL").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2RGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2RGBA").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2XYZ: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2XYZ").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2YUV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2YUV").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2YUV_I420: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2YUV_I420").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2YUV_IYUV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2YUV_IYUV").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2YUV_YV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2YUV_YV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGBA2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGBA2BGR").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGBA2BGR555: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGBA2BGR555").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGBA2BGR565: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGBA2BGR565").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGBA2BGRA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGBA2BGRA").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGBA2GRAY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGBA2GRAY").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGBA2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGBA2RGB").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGBA2YUV_I420: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGBA2YUV_I420").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGBA2YUV_IYUV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGBA2YUV_IYUV").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGBA2YUV_YV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGBA2YUV_YV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_XYZ2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_XYZ2BGR").asInstanceOf[ColorConversionCodes]

inline def COLOR_XYZ2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_XYZ2RGB").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGR").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGRA_I420: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGRA_I420").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGRA_IYUV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGRA_IYUV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGRA_NV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGRA_NV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGRA_NV21: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGRA_NV21").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGRA_UYNV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGRA_UYNV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGRA_UYVY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGRA_UYVY").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGRA_Y422: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGRA_Y422").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGRA_YUNV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGRA_YUNV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGRA_YUY2: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGRA_YUY2").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGRA_YUYV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGRA_YUYV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGRA_YV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGRA_YV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGRA_YVYU: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGRA_YVYU").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGR_I420: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGR_I420").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGR_IYUV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGR_IYUV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGR_NV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGR_NV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGR_NV21: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGR_NV21").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGR_UYNV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGR_UYNV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGR_UYVY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGR_UYVY").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGR_Y422: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGR_Y422").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGR_YUNV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGR_YUNV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGR_YUY2: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGR_YUY2").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGR_YUYV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGR_YUYV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGR_YV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGR_YV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGR_YVYU: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGR_YVYU").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2GRAY_420: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2GRAY_420").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2GRAY_I420: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2GRAY_I420").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2GRAY_IYUV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2GRAY_IYUV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2GRAY_NV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2GRAY_NV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2GRAY_NV21: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2GRAY_NV21").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2GRAY_UYNV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2GRAY_UYNV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2GRAY_UYVY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2GRAY_UYVY").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2GRAY_Y422: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2GRAY_Y422").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2GRAY_YUNV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2GRAY_YUNV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2GRAY_YUY2: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2GRAY_YUY2").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2GRAY_YUYV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2GRAY_YUYV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2GRAY_YV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2GRAY_YV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2GRAY_YVYU: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2GRAY_YVYU").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGB").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGBA_I420: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGBA_I420").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGBA_IYUV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGBA_IYUV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGBA_NV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGBA_NV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGBA_NV21: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGBA_NV21").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGBA_UYNV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGBA_UYNV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGBA_UYVY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGBA_UYVY").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGBA_Y422: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGBA_Y422").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGBA_YUNV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGBA_YUNV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGBA_YUY2: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGBA_YUY2").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGBA_YUYV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGBA_YUYV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGBA_YV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGBA_YV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGBA_YVYU: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGBA_YVYU").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGB_I420: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGB_I420").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGB_IYUV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGB_IYUV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGB_NV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGB_NV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGB_NV21: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGB_NV21").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGB_UYNV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGB_UYNV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGB_UYVY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGB_UYVY").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGB_Y422: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGB_Y422").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGB_YUNV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGB_YUNV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGB_YUY2: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGB_YUY2").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGB_YUYV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGB_YUYV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGB_YV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGB_YV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGB_YVYU: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGB_YVYU").asInstanceOf[ColorConversionCodes]

inline def CONTINUOUS_FLAG: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CONTINUOUS_FLAG").asInstanceOf[Any]

inline def CONTOURS_MATCH_I1: ShapeMatchModes = ^.asInstanceOf[js.Dynamic].selectDynamic("CONTOURS_MATCH_I1").asInstanceOf[ShapeMatchModes]

inline def CONTOURS_MATCH_I2: ShapeMatchModes = ^.asInstanceOf[js.Dynamic].selectDynamic("CONTOURS_MATCH_I2").asInstanceOf[ShapeMatchModes]

inline def CONTOURS_MATCH_I3: ShapeMatchModes = ^.asInstanceOf[js.Dynamic].selectDynamic("CONTOURS_MATCH_I3").asInstanceOf[ShapeMatchModes]

inline def CPU_AVX: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX").asInstanceOf[CpuFeatures]

inline def CPU_AVX2: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX2").asInstanceOf[CpuFeatures]

inline def CPU_AVX512_CEL: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX512_CEL").asInstanceOf[CpuFeatures]

inline def CPU_AVX512_CNL: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX512_CNL").asInstanceOf[CpuFeatures]

inline def CPU_AVX512_COMMON: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX512_COMMON").asInstanceOf[CpuFeatures]

inline def CPU_AVX512_ICL: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX512_ICL").asInstanceOf[CpuFeatures]

inline def CPU_AVX512_KNL: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX512_KNL").asInstanceOf[CpuFeatures]

inline def CPU_AVX512_KNM: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX512_KNM").asInstanceOf[CpuFeatures]

inline def CPU_AVX512_SKX: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX512_SKX").asInstanceOf[CpuFeatures]

inline def CPU_AVX_5124FMAPS: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_5124FMAPS").asInstanceOf[CpuFeatures]

inline def CPU_AVX_5124VNNIW: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_5124VNNIW").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512BITALG: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512BITALG").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512BW: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512BW").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512CD: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512CD").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512DQ: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512DQ").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512ER: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512ER").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512F: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512F").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512IFMA: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512IFMA").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512IFMA512: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512IFMA512").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512PF: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512PF").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512VBMI: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512VBMI").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512VBMI2: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512VBMI2").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512VL: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512VL").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512VNNI: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512VNNI").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512VPOPCNTDQ: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512VPOPCNTDQ").asInstanceOf[CpuFeatures]

inline def CPU_FMA3: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_FMA3").asInstanceOf[CpuFeatures]

inline def CPU_FP16: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_FP16").asInstanceOf[CpuFeatures]

inline def CPU_MAX_FEATURE: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_MAX_FEATURE").asInstanceOf[CpuFeatures]

inline def CPU_MMX: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_MMX").asInstanceOf[CpuFeatures]

inline def CPU_NEON: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_NEON").asInstanceOf[CpuFeatures]

inline def CPU_POPCNT: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_POPCNT").asInstanceOf[CpuFeatures]

inline def CPU_SSE: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_SSE").asInstanceOf[CpuFeatures]

inline def CPU_SSE2: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_SSE2").asInstanceOf[CpuFeatures]

inline def CPU_SSE3: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_SSE3").asInstanceOf[CpuFeatures]

inline def CPU_SSE4_1: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_SSE4_1").asInstanceOf[CpuFeatures]

inline def CPU_SSE4_2: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_SSE4_2").asInstanceOf[CpuFeatures]

inline def CPU_SSSE3: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_SSSE3").asInstanceOf[CpuFeatures]

inline def CPU_VSX: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_VSX").asInstanceOf[CpuFeatures]

inline def CPU_VSX3: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_VSX3").asInstanceOf[CpuFeatures]

inline def CV_16S: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_16S").asInstanceOf[CVDataType]

inline def CV_16SC1: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_16SC1").asInstanceOf[CVDataType]

inline def CV_16SC2: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_16SC2").asInstanceOf[CVDataType]

inline def CV_16SC3: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_16SC3").asInstanceOf[CVDataType]

inline def CV_16SC4: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_16SC4").asInstanceOf[CVDataType]

inline def CV_16U: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_16U").asInstanceOf[CVDataType]

inline def CV_16UC1: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_16UC1").asInstanceOf[CVDataType]

inline def CV_16UC2: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_16UC2").asInstanceOf[CVDataType]

inline def CV_16UC3: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_16UC3").asInstanceOf[CVDataType]

inline def CV_16UC4: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_16UC4").asInstanceOf[CVDataType]

inline def CV_32F: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_32F").asInstanceOf[CVDataType]

inline def CV_32FC1: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_32FC1").asInstanceOf[CVDataType]

inline def CV_32FC2: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_32FC2").asInstanceOf[CVDataType]

inline def CV_32FC3: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_32FC3").asInstanceOf[CVDataType]

inline def CV_32FC4: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_32FC4").asInstanceOf[CVDataType]

inline def CV_32S: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_32S").asInstanceOf[CVDataType]

inline def CV_32SC1: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_32SC1").asInstanceOf[CVDataType]

inline def CV_32SC2: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_32SC2").asInstanceOf[CVDataType]

inline def CV_32SC3: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_32SC3").asInstanceOf[CVDataType]

inline def CV_32SC4: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_32SC4").asInstanceOf[CVDataType]

inline def CV_64F: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_64F").asInstanceOf[CVDataType]

inline def CV_64FC1: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_64FC1").asInstanceOf[CVDataType]

inline def CV_64FC2: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_64FC2").asInstanceOf[CVDataType]

inline def CV_64FC3: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_64FC3").asInstanceOf[CVDataType]

inline def CV_64FC4: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_64FC4").asInstanceOf[CVDataType]

inline def CV_8S: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_8S").asInstanceOf[CVDataType]

inline def CV_8SC1: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_8SC1").asInstanceOf[CVDataType]

inline def CV_8SC2: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_8SC2").asInstanceOf[CVDataType]

inline def CV_8SC3: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_8SC3").asInstanceOf[CVDataType]

inline def CV_8SC4: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_8SC4").asInstanceOf[CVDataType]

inline def CV_8U: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_8U").asInstanceOf[CVDataType]

inline def CV_8UC1: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_8UC1").asInstanceOf[CVDataType]

inline def CV_8UC2: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_8UC2").asInstanceOf[CVDataType]

inline def CV_8UC3: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_8UC3").asInstanceOf[CVDataType]

inline def CV_8UC4: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_8UC4").asInstanceOf[CVDataType]

inline def CV_XADD(addr: Any, delta: int): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("CV_XADD")(addr.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Any]

inline def CamShift(probImage: InputArray, window: Any, criteria: TermCriteria): RotatedRect = (^.asInstanceOf[js.Dynamic].applyDynamic("CamShift")(probImage.asInstanceOf[js.Any], window.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[RotatedRect]

inline def Canny(dx: InputArray, dy: InputArray, edges: OutputArray, threshold1: double, threshold2: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Canny")(dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], edges.asInstanceOf[js.Any], threshold1.asInstanceOf[js.Any], threshold2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Canny(
  dx: InputArray,
  dy: InputArray,
  edges: OutputArray,
  threshold1: double,
  threshold2: double,
  L2gradient: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Canny")(dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], edges.asInstanceOf[js.Any], threshold1.asInstanceOf[js.Any], threshold2.asInstanceOf[js.Any], L2gradient.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Canny(image: InputArray, edges: OutputArray, threshold1: double, threshold2: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Canny")(image.asInstanceOf[js.Any], edges.asInstanceOf[js.Any], threshold1.asInstanceOf[js.Any], threshold2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Canny(
  image: InputArray,
  edges: OutputArray,
  threshold1: double,
  threshold2: double,
  apertureSize: Unit,
  L2gradient: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Canny")(image.asInstanceOf[js.Any], edges.asInstanceOf[js.Any], threshold1.asInstanceOf[js.Any], threshold2.asInstanceOf[js.Any], apertureSize.asInstanceOf[js.Any], L2gradient.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Canny(image: InputArray, edges: OutputArray, threshold1: double, threshold2: double, apertureSize: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Canny")(image.asInstanceOf[js.Any], edges.asInstanceOf[js.Any], threshold1.asInstanceOf[js.Any], threshold2.asInstanceOf[js.Any], apertureSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Canny(
  image: InputArray,
  edges: OutputArray,
  threshold1: double,
  threshold2: double,
  apertureSize: int,
  L2gradient: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Canny")(image.asInstanceOf[js.Any], edges.asInstanceOf[js.Any], threshold1.asInstanceOf[js.Any], threshold2.asInstanceOf[js.Any], apertureSize.asInstanceOf[js.Any], L2gradient.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def Cholesky(A: Any, astep: sizeT, m: int, b: Any, bstep: sizeT, n: int): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("Cholesky")(A.asInstanceOf[js.Any], astep.asInstanceOf[js.Any], m.asInstanceOf[js.Any], b.asInstanceOf[js.Any], bstep.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def DATA_AS_COL: Flags = ^.asInstanceOf[js.Dynamic].selectDynamic("DATA_AS_COL").asInstanceOf[Flags]

inline def DATA_AS_ROW: Flags = ^.asInstanceOf[js.Dynamic].selectDynamic("DATA_AS_ROW").asInstanceOf[Flags]

inline def DCT_INVERSE: DftFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("DCT_INVERSE").asInstanceOf[DftFlags]

inline def DCT_ROWS: DftFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("DCT_ROWS").asInstanceOf[DftFlags]

inline def DECOMP_CHOLESKY: DecompTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DECOMP_CHOLESKY").asInstanceOf[DecompTypes]

inline def DECOMP_EIG: DecompTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DECOMP_EIG").asInstanceOf[DecompTypes]

inline def DECOMP_LU: DecompTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DECOMP_LU").asInstanceOf[DecompTypes]

inline def DECOMP_NORMAL: DecompTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DECOMP_NORMAL").asInstanceOf[DecompTypes]

inline def DECOMP_QR: DecompTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DECOMP_QR").asInstanceOf[DecompTypes]

inline def DECOMP_SVD: DecompTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DECOMP_SVD").asInstanceOf[DecompTypes]

inline def DEFAULT: DrawMatchesFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("DEFAULT").asInstanceOf[DrawMatchesFlags]

inline def DEFAULT_NLEVELS: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("DEFAULT_NLEVELS").asInstanceOf[Any]

inline def DEPTH_MASK: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("DEPTH_MASK").asInstanceOf[Any]

inline def DESCR_FORMAT_COL_BY_COL: DescriptorStorageFormat = ^.asInstanceOf[js.Dynamic].selectDynamic("DESCR_FORMAT_COL_BY_COL").asInstanceOf[DescriptorStorageFormat]

inline def DESCR_FORMAT_ROW_BY_ROW: DescriptorStorageFormat = ^.asInstanceOf[js.Dynamic].selectDynamic("DESCR_FORMAT_ROW_BY_ROW").asInstanceOf[DescriptorStorageFormat]

inline def DFT_COMPLEX_INPUT: DftFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("DFT_COMPLEX_INPUT").asInstanceOf[DftFlags]

inline def DFT_COMPLEX_OUTPUT: DftFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("DFT_COMPLEX_OUTPUT").asInstanceOf[DftFlags]

inline def DFT_INVERSE: DftFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("DFT_INVERSE").asInstanceOf[DftFlags]

inline def DFT_REAL_OUTPUT: DftFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("DFT_REAL_OUTPUT").asInstanceOf[DftFlags]

inline def DFT_ROWS: DftFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("DFT_ROWS").asInstanceOf[DftFlags]

inline def DFT_SCALE: DftFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("DFT_SCALE").asInstanceOf[DftFlags]

inline def DIST_C: DistanceTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DIST_C").asInstanceOf[DistanceTypes]

inline def DIST_FAIR: DistanceTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DIST_FAIR").asInstanceOf[DistanceTypes]

inline def DIST_HUBER: DistanceTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DIST_HUBER").asInstanceOf[DistanceTypes]

inline def DIST_L1: DistanceTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DIST_L1").asInstanceOf[DistanceTypes]

inline def DIST_L12: DistanceTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DIST_L12").asInstanceOf[DistanceTypes]

inline def DIST_L2: DistanceTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DIST_L2").asInstanceOf[DistanceTypes]

inline def DIST_LABEL_CCOMP: DistanceTransformLabelTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DIST_LABEL_CCOMP").asInstanceOf[DistanceTransformLabelTypes]

inline def DIST_LABEL_PIXEL: DistanceTransformLabelTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DIST_LABEL_PIXEL").asInstanceOf[DistanceTransformLabelTypes]

inline def DIST_MASK_3: DistanceTransformMasks = ^.asInstanceOf[js.Dynamic].selectDynamic("DIST_MASK_3").asInstanceOf[DistanceTransformMasks]

inline def DIST_MASK_5: DistanceTransformMasks = ^.asInstanceOf[js.Dynamic].selectDynamic("DIST_MASK_5").asInstanceOf[DistanceTransformMasks]

inline def DIST_MASK_PRECISE: DistanceTransformMasks = ^.asInstanceOf[js.Dynamic].selectDynamic("DIST_MASK_PRECISE").asInstanceOf[DistanceTransformMasks]

inline def DIST_USER: DistanceTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DIST_USER").asInstanceOf[DistanceTypes]

inline def DIST_WELSCH: DistanceTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DIST_WELSCH").asInstanceOf[DistanceTypes]

inline def DNN_BACKEND_DEFAULT: Backend = ^.asInstanceOf[js.Dynamic].selectDynamic("DNN_BACKEND_DEFAULT").asInstanceOf[Backend]

inline def DNN_BACKEND_HALIDE: Backend = ^.asInstanceOf[js.Dynamic].selectDynamic("DNN_BACKEND_HALIDE").asInstanceOf[Backend]

inline def DNN_BACKEND_INFERENCE_ENGINE: Backend = ^.asInstanceOf[js.Dynamic].selectDynamic("DNN_BACKEND_INFERENCE_ENGINE").asInstanceOf[Backend]

inline def DNN_BACKEND_OPENCV: Backend = ^.asInstanceOf[js.Dynamic].selectDynamic("DNN_BACKEND_OPENCV").asInstanceOf[Backend]

inline def DNN_BACKEND_VKCOM: Backend = ^.asInstanceOf[js.Dynamic].selectDynamic("DNN_BACKEND_VKCOM").asInstanceOf[Backend]

inline def DNN_TARGET_CPU: Target = ^.asInstanceOf[js.Dynamic].selectDynamic("DNN_TARGET_CPU").asInstanceOf[Target]

inline def DNN_TARGET_FPGA: Target = ^.asInstanceOf[js.Dynamic].selectDynamic("DNN_TARGET_FPGA").asInstanceOf[Target]

inline def DNN_TARGET_MYRIAD: Target = ^.asInstanceOf[js.Dynamic].selectDynamic("DNN_TARGET_MYRIAD").asInstanceOf[Target]

inline def DNN_TARGET_OPENCL: Target = ^.asInstanceOf[js.Dynamic].selectDynamic("DNN_TARGET_OPENCL").asInstanceOf[Target]

inline def DNN_TARGET_OPENCL_FP16: Target = ^.asInstanceOf[js.Dynamic].selectDynamic("DNN_TARGET_OPENCL_FP16").asInstanceOf[Target]

inline def DNN_TARGET_VULKAN: Target = ^.asInstanceOf[js.Dynamic].selectDynamic("DNN_TARGET_VULKAN").asInstanceOf[Target]

inline def DRAW_OVER_OUTIMG: DrawMatchesFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("DRAW_OVER_OUTIMG").asInstanceOf[DrawMatchesFlags]

inline def DRAW_RICH_KEYPOINTS: DrawMatchesFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("DRAW_RICH_KEYPOINTS").asInstanceOf[DrawMatchesFlags]

inline def EMD(signature1: InputArray, signature2: InputArray, distType: int): float = (^.asInstanceOf[js.Dynamic].applyDynamic("EMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any])).asInstanceOf[float]
inline def EMD(signature1: InputArray, signature2: InputArray, distType: int, cost: Unit, lowerBound: Any): float = (^.asInstanceOf[js.Dynamic].applyDynamic("EMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], lowerBound.asInstanceOf[js.Any])).asInstanceOf[float]
inline def EMD(
  signature1: InputArray,
  signature2: InputArray,
  distType: int,
  cost: Unit,
  lowerBound: Any,
  flow: OutputArray
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("EMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], lowerBound.asInstanceOf[js.Any], flow.asInstanceOf[js.Any])).asInstanceOf[float]
inline def EMD(
  signature1: InputArray,
  signature2: InputArray,
  distType: int,
  cost: Unit,
  lowerBound: Unit,
  flow: OutputArray
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("EMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], lowerBound.asInstanceOf[js.Any], flow.asInstanceOf[js.Any])).asInstanceOf[float]
inline def EMD(signature1: InputArray, signature2: InputArray, distType: int, cost: InputArray): float = (^.asInstanceOf[js.Dynamic].applyDynamic("EMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any])).asInstanceOf[float]
inline def EMD(signature1: InputArray, signature2: InputArray, distType: int, cost: InputArray, lowerBound: Any): float = (^.asInstanceOf[js.Dynamic].applyDynamic("EMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], lowerBound.asInstanceOf[js.Any])).asInstanceOf[float]
inline def EMD(
  signature1: InputArray,
  signature2: InputArray,
  distType: int,
  cost: InputArray,
  lowerBound: Any,
  flow: OutputArray
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("EMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], lowerBound.asInstanceOf[js.Any], flow.asInstanceOf[js.Any])).asInstanceOf[float]
inline def EMD(
  signature1: InputArray,
  signature2: InputArray,
  distType: int,
  cost: InputArray,
  lowerBound: Unit,
  flow: OutputArray
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("EMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], lowerBound.asInstanceOf[js.Any], flow.asInstanceOf[js.Any])).asInstanceOf[float]

inline def FILLED: LineTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("FILLED").asInstanceOf[LineTypes]

inline def FILTER_SCHARR: SpecialFilter = ^.asInstanceOf[js.Dynamic].selectDynamic("FILTER_SCHARR").asInstanceOf[SpecialFilter]

inline def FLANNBASED: MatcherType = ^.asInstanceOf[js.Dynamic].selectDynamic("FLANNBASED").asInstanceOf[MatcherType]

inline def FLOODFILL_FIXED_RANGE: FloodFillFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("FLOODFILL_FIXED_RANGE").asInstanceOf[FloodFillFlags]

inline def FLOODFILL_MASK_ONLY: FloodFillFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("FLOODFILL_MASK_ONLY").asInstanceOf[FloodFillFlags]

inline def FM_7POINT: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("FM_7POINT").asInstanceOf[Any]

inline def FM_8POINT: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("FM_8POINT").asInstanceOf[Any]

inline def FM_LMEDS: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("FM_LMEDS").asInstanceOf[Any]

inline def FM_RANSAC: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("FM_RANSAC").asInstanceOf[Any]

inline def FONT_HERSHEY_COMPLEX: HersheyFonts = ^.asInstanceOf[js.Dynamic].selectDynamic("FONT_HERSHEY_COMPLEX").asInstanceOf[HersheyFonts]

inline def FONT_HERSHEY_COMPLEX_SMALL: HersheyFonts = ^.asInstanceOf[js.Dynamic].selectDynamic("FONT_HERSHEY_COMPLEX_SMALL").asInstanceOf[HersheyFonts]

inline def FONT_HERSHEY_DUPLEX: HersheyFonts = ^.asInstanceOf[js.Dynamic].selectDynamic("FONT_HERSHEY_DUPLEX").asInstanceOf[HersheyFonts]

inline def FONT_HERSHEY_PLAIN: HersheyFonts = ^.asInstanceOf[js.Dynamic].selectDynamic("FONT_HERSHEY_PLAIN").asInstanceOf[HersheyFonts]

inline def FONT_HERSHEY_SCRIPT_COMPLEX: HersheyFonts = ^.asInstanceOf[js.Dynamic].selectDynamic("FONT_HERSHEY_SCRIPT_COMPLEX").asInstanceOf[HersheyFonts]

inline def FONT_HERSHEY_SCRIPT_SIMPLEX: HersheyFonts = ^.asInstanceOf[js.Dynamic].selectDynamic("FONT_HERSHEY_SCRIPT_SIMPLEX").asInstanceOf[HersheyFonts]

inline def FONT_HERSHEY_SIMPLEX: HersheyFonts = ^.asInstanceOf[js.Dynamic].selectDynamic("FONT_HERSHEY_SIMPLEX").asInstanceOf[HersheyFonts]

inline def FONT_HERSHEY_TRIPLEX: HersheyFonts = ^.asInstanceOf[js.Dynamic].selectDynamic("FONT_HERSHEY_TRIPLEX").asInstanceOf[HersheyFonts]

inline def FONT_ITALIC: HersheyFonts = ^.asInstanceOf[js.Dynamic].selectDynamic("FONT_ITALIC").asInstanceOf[HersheyFonts]

inline def FSCreateDataFile(
  arg0: String,
  path: String,
  data: js.typedarray.Uint8Array,
  arg3: Boolean,
  arg4: Boolean,
  arg5: Boolean
): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("FS_createDataFile")(arg0.asInstanceOf[js.Any], path.asInstanceOf[js.Any], data.asInstanceOf[js.Any], arg3.asInstanceOf[js.Any], arg4.asInstanceOf[js.Any], arg5.asInstanceOf[js.Any])).asInstanceOf[Any]

inline def GC_BGD: GrabCutClasses = ^.asInstanceOf[js.Dynamic].selectDynamic("GC_BGD").asInstanceOf[GrabCutClasses]

inline def GC_EVAL: GrabCutModes = ^.asInstanceOf[js.Dynamic].selectDynamic("GC_EVAL").asInstanceOf[GrabCutModes]

inline def GC_EVAL_FREEZE_MODEL: GrabCutModes = ^.asInstanceOf[js.Dynamic].selectDynamic("GC_EVAL_FREEZE_MODEL").asInstanceOf[GrabCutModes]

inline def GC_FGD: GrabCutClasses = ^.asInstanceOf[js.Dynamic].selectDynamic("GC_FGD").asInstanceOf[GrabCutClasses]

inline def GC_INIT_WITH_MASK: GrabCutModes = ^.asInstanceOf[js.Dynamic].selectDynamic("GC_INIT_WITH_MASK").asInstanceOf[GrabCutModes]

inline def GC_INIT_WITH_RECT: GrabCutModes = ^.asInstanceOf[js.Dynamic].selectDynamic("GC_INIT_WITH_RECT").asInstanceOf[GrabCutModes]

inline def GC_PR_BGD: GrabCutClasses = ^.asInstanceOf[js.Dynamic].selectDynamic("GC_PR_BGD").asInstanceOf[GrabCutClasses]

inline def GC_PR_FGD: GrabCutClasses = ^.asInstanceOf[js.Dynamic].selectDynamic("GC_PR_FGD").asInstanceOf[GrabCutClasses]

inline def GEMM_1_T: GemmFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("GEMM_1_T").asInstanceOf[GemmFlags]

inline def GEMM_2_T: GemmFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("GEMM_2_T").asInstanceOf[GemmFlags]

inline def GEMM_3_T: GemmFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("GEMM_3_T").asInstanceOf[GemmFlags]

inline def GaussianBlur(src: InputArray, dst: OutputArray, ksize: Size, sigmaX: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("GaussianBlur")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], sigmaX.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def GaussianBlur(src: InputArray, dst: OutputArray, ksize: Size, sigmaX: double, sigmaY: Unit, borderType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("GaussianBlur")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], sigmaX.asInstanceOf[js.Any], sigmaY.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def GaussianBlur(src: InputArray, dst: OutputArray, ksize: Size, sigmaX: double, sigmaY: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("GaussianBlur")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], sigmaX.asInstanceOf[js.Any], sigmaY.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def GaussianBlur(src: InputArray, dst: OutputArray, ksize: Size, sigmaX: double, sigmaY: double, borderType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("GaussianBlur")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], sigmaX.asInstanceOf[js.Any], sigmaY.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def HISTCMP_BHATTACHARYYA: HistCompMethods = ^.asInstanceOf[js.Dynamic].selectDynamic("HISTCMP_BHATTACHARYYA").asInstanceOf[HistCompMethods]

inline def HISTCMP_CHISQR: HistCompMethods = ^.asInstanceOf[js.Dynamic].selectDynamic("HISTCMP_CHISQR").asInstanceOf[HistCompMethods]

inline def HISTCMP_CHISQR_ALT: HistCompMethods = ^.asInstanceOf[js.Dynamic].selectDynamic("HISTCMP_CHISQR_ALT").asInstanceOf[HistCompMethods]

inline def HISTCMP_CORREL: HistCompMethods = ^.asInstanceOf[js.Dynamic].selectDynamic("HISTCMP_CORREL").asInstanceOf[HistCompMethods]

inline def HISTCMP_HELLINGER: HistCompMethods = ^.asInstanceOf[js.Dynamic].selectDynamic("HISTCMP_HELLINGER").asInstanceOf[HistCompMethods]

inline def HISTCMP_INTERSECT: HistCompMethods = ^.asInstanceOf[js.Dynamic].selectDynamic("HISTCMP_INTERSECT").asInstanceOf[HistCompMethods]

inline def HISTCMP_KL_DIV: HistCompMethods = ^.asInstanceOf[js.Dynamic].selectDynamic("HISTCMP_KL_DIV").asInstanceOf[HistCompMethods]

inline def HOUGH_GRADIENT: HoughModes = ^.asInstanceOf[js.Dynamic].selectDynamic("HOUGH_GRADIENT").asInstanceOf[HoughModes]

inline def HOUGH_MULTI_SCALE: HoughModes = ^.asInstanceOf[js.Dynamic].selectDynamic("HOUGH_MULTI_SCALE").asInstanceOf[HoughModes]

inline def HOUGH_PROBABILISTIC: HoughModes = ^.asInstanceOf[js.Dynamic].selectDynamic("HOUGH_PROBABILISTIC").asInstanceOf[HoughModes]

inline def HOUGH_STANDARD: HoughModes = ^.asInstanceOf[js.Dynamic].selectDynamic("HOUGH_STANDARD").asInstanceOf[HoughModes]

inline def HoughCircles(image: InputArray, circles: OutputArray, method: int, dp: double, minDist: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: InputArray,
  circles: OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: Unit,
  param2: Unit,
  minRadius: Unit,
  maxRadius: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any], minRadius.asInstanceOf[js.Any], maxRadius.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: InputArray,
  circles: OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: Unit,
  param2: Unit,
  minRadius: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any], minRadius.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: InputArray,
  circles: OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: Unit,
  param2: Unit,
  minRadius: int,
  maxRadius: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any], minRadius.asInstanceOf[js.Any], maxRadius.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: InputArray,
  circles: OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: Unit,
  param2: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: InputArray,
  circles: OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: Unit,
  param2: double,
  minRadius: Unit,
  maxRadius: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any], minRadius.asInstanceOf[js.Any], maxRadius.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: InputArray,
  circles: OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: Unit,
  param2: double,
  minRadius: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any], minRadius.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: InputArray,
  circles: OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: Unit,
  param2: double,
  minRadius: int,
  maxRadius: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any], minRadius.asInstanceOf[js.Any], maxRadius.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(image: InputArray, circles: OutputArray, method: int, dp: double, minDist: double, param1: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: InputArray,
  circles: OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: double,
  param2: Unit,
  minRadius: Unit,
  maxRadius: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any], minRadius.asInstanceOf[js.Any], maxRadius.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: InputArray,
  circles: OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: double,
  param2: Unit,
  minRadius: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any], minRadius.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: InputArray,
  circles: OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: double,
  param2: Unit,
  minRadius: int,
  maxRadius: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any], minRadius.asInstanceOf[js.Any], maxRadius.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: InputArray,
  circles: OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: double,
  param2: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: InputArray,
  circles: OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: double,
  param2: double,
  minRadius: Unit,
  maxRadius: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any], minRadius.asInstanceOf[js.Any], maxRadius.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: InputArray,
  circles: OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: double,
  param2: double,
  minRadius: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any], minRadius.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: InputArray,
  circles: OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: double,
  param2: double,
  minRadius: int,
  maxRadius: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any], minRadius.asInstanceOf[js.Any], maxRadius.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def HoughLines(image: InputArray, lines: OutputArray, rho: double, theta: double, threshold: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: InputArray,
  lines: OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: Unit,
  stn: Unit,
  min_theta: Unit,
  max_theta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any], min_theta.asInstanceOf[js.Any], max_theta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: InputArray,
  lines: OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: Unit,
  stn: Unit,
  min_theta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any], min_theta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: InputArray,
  lines: OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: Unit,
  stn: Unit,
  min_theta: double,
  max_theta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any], min_theta.asInstanceOf[js.Any], max_theta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: InputArray,
  lines: OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: Unit,
  stn: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: InputArray,
  lines: OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: Unit,
  stn: double,
  min_theta: Unit,
  max_theta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any], min_theta.asInstanceOf[js.Any], max_theta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: InputArray,
  lines: OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: Unit,
  stn: double,
  min_theta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any], min_theta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: InputArray,
  lines: OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: Unit,
  stn: double,
  min_theta: double,
  max_theta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any], min_theta.asInstanceOf[js.Any], max_theta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(image: InputArray, lines: OutputArray, rho: double, theta: double, threshold: int, srn: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: InputArray,
  lines: OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: double,
  stn: Unit,
  min_theta: Unit,
  max_theta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any], min_theta.asInstanceOf[js.Any], max_theta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: InputArray,
  lines: OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: double,
  stn: Unit,
  min_theta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any], min_theta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: InputArray,
  lines: OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: double,
  stn: Unit,
  min_theta: double,
  max_theta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any], min_theta.asInstanceOf[js.Any], max_theta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: InputArray,
  lines: OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: double,
  stn: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: InputArray,
  lines: OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: double,
  stn: double,
  min_theta: Unit,
  max_theta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any], min_theta.asInstanceOf[js.Any], max_theta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: InputArray,
  lines: OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: double,
  stn: double,
  min_theta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any], min_theta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: InputArray,
  lines: OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: double,
  stn: double,
  min_theta: double,
  max_theta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any], min_theta.asInstanceOf[js.Any], max_theta.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def HoughLinesP(image: InputArray, lines: OutputArray, rho: double, theta: double, threshold: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLinesP")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLinesP(
  image: InputArray,
  lines: OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  minLineLength: Unit,
  maxLineGap: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLinesP")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], minLineLength.asInstanceOf[js.Any], maxLineGap.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLinesP(
  image: InputArray,
  lines: OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  minLineLength: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLinesP")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], minLineLength.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLinesP(
  image: InputArray,
  lines: OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  minLineLength: double,
  maxLineGap: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLinesP")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], minLineLength.asInstanceOf[js.Any], maxLineGap.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def HoughLinesPointSet(
  _point: InputArray,
  _lines: OutputArray,
  lines_max: int,
  threshold: int,
  min_rho: double,
  max_rho: double,
  rho_step: double,
  min_theta: double,
  max_theta: double,
  theta_step: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLinesPointSet")(_point.asInstanceOf[js.Any], _lines.asInstanceOf[js.Any], lines_max.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], min_rho.asInstanceOf[js.Any], max_rho.asInstanceOf[js.Any], rho_step.asInstanceOf[js.Any], min_theta.asInstanceOf[js.Any], max_theta.asInstanceOf[js.Any], theta_step.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def HuMoments(moments: Any, hu: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HuMoments")(moments.asInstanceOf[js.Any], hu.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HuMoments(m: Any, hu: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HuMoments")(m.asInstanceOf[js.Any], hu.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def INPAINT_NS: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("INPAINT_NS").asInstanceOf[Any]

inline def INPAINT_TELEA: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("INPAINT_TELEA").asInstanceOf[Any]

inline def INTERSECT_FULL: RectanglesIntersectTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("INTERSECT_FULL").asInstanceOf[RectanglesIntersectTypes]

inline def INTERSECT_NONE: RectanglesIntersectTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("INTERSECT_NONE").asInstanceOf[RectanglesIntersectTypes]

inline def INTERSECT_PARTIAL: RectanglesIntersectTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("INTERSECT_PARTIAL").asInstanceOf[RectanglesIntersectTypes]

inline def INTER_AREA: InterpolationFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("INTER_AREA").asInstanceOf[InterpolationFlags]

inline def INTER_BITS: InterpolationMasks = ^.asInstanceOf[js.Dynamic].selectDynamic("INTER_BITS").asInstanceOf[InterpolationMasks]

inline def INTER_BITS2: InterpolationMasks = ^.asInstanceOf[js.Dynamic].selectDynamic("INTER_BITS2").asInstanceOf[InterpolationMasks]

inline def INTER_CUBIC: InterpolationFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("INTER_CUBIC").asInstanceOf[InterpolationFlags]

inline def INTER_LANCZOS4: InterpolationFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("INTER_LANCZOS4").asInstanceOf[InterpolationFlags]

inline def INTER_LINEAR: InterpolationFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("INTER_LINEAR").asInstanceOf[InterpolationFlags]

inline def INTER_LINEAR_EXACT: InterpolationFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("INTER_LINEAR_EXACT").asInstanceOf[InterpolationFlags]

inline def INTER_MAX: InterpolationFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("INTER_MAX").asInstanceOf[InterpolationFlags]

inline def INTER_NEAREST: InterpolationFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("INTER_NEAREST").asInstanceOf[InterpolationFlags]

inline def INTER_TAB_SIZE: InterpolationMasks = ^.asInstanceOf[js.Dynamic].selectDynamic("INTER_TAB_SIZE").asInstanceOf[InterpolationMasks]

inline def INTER_TAB_SIZE2: InterpolationMasks = ^.asInstanceOf[js.Dynamic].selectDynamic("INTER_TAB_SIZE2").asInstanceOf[InterpolationMasks]

inline def L2Hys: HistogramNormType = ^.asInstanceOf[js.Dynamic].selectDynamic("L2Hys").asInstanceOf[HistogramNormType]

inline def LINE_4: LineTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("LINE_4").asInstanceOf[LineTypes]

inline def LINE_8: LineTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("LINE_8").asInstanceOf[LineTypes]

inline def LINE_AA: LineTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("LINE_AA").asInstanceOf[LineTypes]

inline def LMEDS: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("LMEDS").asInstanceOf[Any]

inline def LSD_REFINE_ADV: LineSegmentDetectorModes = ^.asInstanceOf[js.Dynamic].selectDynamic("LSD_REFINE_ADV").asInstanceOf[LineSegmentDetectorModes]

inline def LSD_REFINE_NONE: LineSegmentDetectorModes = ^.asInstanceOf[js.Dynamic].selectDynamic("LSD_REFINE_NONE").asInstanceOf[LineSegmentDetectorModes]

inline def LSD_REFINE_STD: LineSegmentDetectorModes = ^.asInstanceOf[js.Dynamic].selectDynamic("LSD_REFINE_STD").asInstanceOf[LineSegmentDetectorModes]

inline def LU(A: Any, astep: sizeT, m: int, b: Any, bstep: sizeT, n: int): int = (^.asInstanceOf[js.Dynamic].applyDynamic("LU")(A.asInstanceOf[js.Any], astep.asInstanceOf[js.Any], m.asInstanceOf[js.Any], b.asInstanceOf[js.Any], bstep.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[int]

inline def LUT(src: InputArray, lut: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("LUT")(src.asInstanceOf[js.Any], lut.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def Laplacian(src: InputArray, dst: OutputArray, ddepth: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  ksize: Unit,
  scale: Unit,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(src: InputArray, dst: OutputArray, ddepth: int, ksize: Unit, scale: Unit, delta: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  ksize: Unit,
  scale: Unit,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(src: InputArray, dst: OutputArray, ddepth: int, ksize: Unit, scale: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  ksize: Unit,
  scale: double,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(src: InputArray, dst: OutputArray, ddepth: int, ksize: Unit, scale: double, delta: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  ksize: Unit,
  scale: double,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(src: InputArray, dst: OutputArray, ddepth: int, ksize: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  ksize: int,
  scale: Unit,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(src: InputArray, dst: OutputArray, ddepth: int, ksize: int, scale: Unit, delta: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  ksize: int,
  scale: Unit,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(src: InputArray, dst: OutputArray, ddepth: int, ksize: int, scale: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  ksize: int,
  scale: double,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(src: InputArray, dst: OutputArray, ddepth: int, ksize: int, scale: double, delta: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  ksize: int,
  scale: double,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def MAGIC_MASK: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("MAGIC_MASK").asInstanceOf[Any]

inline def MAGIC_VAL: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("MAGIC_VAL").asInstanceOf[Any]

inline def MARKER_CROSS: MarkerTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MARKER_CROSS").asInstanceOf[MarkerTypes]

inline def MARKER_DIAMOND: MarkerTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MARKER_DIAMOND").asInstanceOf[MarkerTypes]

inline def MARKER_SQUARE: MarkerTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MARKER_SQUARE").asInstanceOf[MarkerTypes]

inline def MARKER_STAR: MarkerTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MARKER_STAR").asInstanceOf[MarkerTypes]

inline def MARKER_TILTED_CROSS: MarkerTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MARKER_TILTED_CROSS").asInstanceOf[MarkerTypes]

inline def MARKER_TRIANGLE_DOWN: MarkerTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MARKER_TRIANGLE_DOWN").asInstanceOf[MarkerTypes]

inline def MARKER_TRIANGLE_UP: MarkerTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MARKER_TRIANGLE_UP").asInstanceOf[MarkerTypes]

inline def MORPH_BLACKHAT: MorphTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MORPH_BLACKHAT").asInstanceOf[MorphTypes]

inline def MORPH_CLOSE: MorphTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MORPH_CLOSE").asInstanceOf[MorphTypes]

inline def MORPH_CROSS: MorphShapes = ^.asInstanceOf[js.Dynamic].selectDynamic("MORPH_CROSS").asInstanceOf[MorphShapes]

inline def MORPH_DILATE: MorphTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MORPH_DILATE").asInstanceOf[MorphTypes]

inline def MORPH_ELLIPSE: MorphShapes = ^.asInstanceOf[js.Dynamic].selectDynamic("MORPH_ELLIPSE").asInstanceOf[MorphShapes]

inline def MORPH_ERODE: MorphTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MORPH_ERODE").asInstanceOf[MorphTypes]

inline def MORPH_GRADIENT: MorphTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MORPH_GRADIENT").asInstanceOf[MorphTypes]

inline def MORPH_HITMISS: MorphTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MORPH_HITMISS").asInstanceOf[MorphTypes]

inline def MORPH_OPEN: MorphTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MORPH_OPEN").asInstanceOf[MorphTypes]

inline def MORPH_RECT: MorphShapes = ^.asInstanceOf[js.Dynamic].selectDynamic("MORPH_RECT").asInstanceOf[MorphShapes]

inline def MORPH_TOPHAT: MorphTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MORPH_TOPHAT").asInstanceOf[MorphTypes]

inline def MOTION_AFFINE: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("MOTION_AFFINE").asInstanceOf[Any]

inline def MOTION_EUCLIDEAN: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("MOTION_EUCLIDEAN").asInstanceOf[Any]

inline def MOTION_HOMOGRAPHY: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("MOTION_HOMOGRAPHY").asInstanceOf[Any]

inline def MOTION_TRANSLATION: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("MOTION_TRANSLATION").asInstanceOf[Any]

inline def Mahalanobis(v1: InputArray, v2: InputArray, icovar: InputArray): double = (^.asInstanceOf[js.Dynamic].applyDynamic("Mahalanobis")(v1.asInstanceOf[js.Any], v2.asInstanceOf[js.Any], icovar.asInstanceOf[js.Any])).asInstanceOf[double]

inline def NMSBoxes(bboxes: Any, scores: Any, score_threshold: Any, nms_threshold: Any, indices: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("NMSBoxes")(bboxes.asInstanceOf[js.Any], scores.asInstanceOf[js.Any], score_threshold.asInstanceOf[js.Any], nms_threshold.asInstanceOf[js.Any], indices.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def NMSBoxes(bboxes: Any, scores: Any, score_threshold: Any, nms_threshold: Any, indices: Any, eta: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("NMSBoxes")(bboxes.asInstanceOf[js.Any], scores.asInstanceOf[js.Any], score_threshold.asInstanceOf[js.Any], nms_threshold.asInstanceOf[js.Any], indices.asInstanceOf[js.Any], eta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def NMSBoxes(
  bboxes: Any,
  scores: Any,
  score_threshold: Any,
  nms_threshold: Any,
  indices: Any,
  eta: Any,
  top_k: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("NMSBoxes")(bboxes.asInstanceOf[js.Any], scores.asInstanceOf[js.Any], score_threshold.asInstanceOf[js.Any], nms_threshold.asInstanceOf[js.Any], indices.asInstanceOf[js.Any], eta.asInstanceOf[js.Any], top_k.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def NMSBoxes(
  bboxes: Any,
  scores: Any,
  score_threshold: Any,
  nms_threshold: Any,
  indices: Any,
  eta: Unit,
  top_k: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("NMSBoxes")(bboxes.asInstanceOf[js.Any], scores.asInstanceOf[js.Any], score_threshold.asInstanceOf[js.Any], nms_threshold.asInstanceOf[js.Any], indices.asInstanceOf[js.Any], eta.asInstanceOf[js.Any], top_k.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def NORM_HAMMING: NormTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("NORM_HAMMING").asInstanceOf[NormTypes]

inline def NORM_HAMMING2: NormTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("NORM_HAMMING2").asInstanceOf[NormTypes]

inline def NORM_INF: NormTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("NORM_INF").asInstanceOf[NormTypes]

inline def NORM_L1: NormTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("NORM_L1").asInstanceOf[NormTypes]

inline def NORM_L2: NormTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("NORM_L2").asInstanceOf[NormTypes]

inline def NORM_L2SQR: NormTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("NORM_L2SQR").asInstanceOf[NormTypes]

inline def NORM_MINMAX: NormTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("NORM_MINMAX").asInstanceOf[NormTypes]

inline def NORM_RELATIVE: NormTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("NORM_RELATIVE").asInstanceOf[NormTypes]

inline def NORM_TYPE_MASK: NormTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("NORM_TYPE_MASK").asInstanceOf[NormTypes]

inline def NOT_DRAW_SINGLE_POINTS: DrawMatchesFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("NOT_DRAW_SINGLE_POINTS").asInstanceOf[DrawMatchesFlags]

inline def OPTFLOW_FARNEBACK_GAUSSIAN: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("OPTFLOW_FARNEBACK_GAUSSIAN").asInstanceOf[Any]

inline def OPTFLOW_LK_GET_MIN_EIGENVALS: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("OPTFLOW_LK_GET_MIN_EIGENVALS").asInstanceOf[Any]

inline def OPTFLOW_USE_INITIAL_FLOW: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("OPTFLOW_USE_INITIAL_FLOW").asInstanceOf[Any]

inline def PCABackProject(data: InputArray, mean: InputArray, eigenvectors: InputArray, result: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("PCABackProject")(data.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], eigenvectors.asInstanceOf[js.Any], result.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def PCACompute(data: InputArray, mean: InputOutputArray, eigenvectors: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("PCACompute")(data.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], eigenvectors.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def PCACompute(data: InputArray, mean: InputOutputArray, eigenvectors: OutputArray, eigenvalues: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("PCACompute")(data.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], eigenvectors.asInstanceOf[js.Any], eigenvalues.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def PCACompute(
  data: InputArray,
  mean: InputOutputArray,
  eigenvectors: OutputArray,
  eigenvalues: OutputArray,
  maxComponents: double | int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("PCACompute")(data.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], eigenvectors.asInstanceOf[js.Any], eigenvalues.asInstanceOf[js.Any], maxComponents.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def PCACompute(data: InputArray, mean: InputOutputArray, eigenvectors: OutputArray, maxComponents: double | int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("PCACompute")(data.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], eigenvectors.asInstanceOf[js.Any], maxComponents.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def PCAProject(data: InputArray, mean: InputArray, eigenvectors: InputArray, result: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("PCAProject")(data.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], eigenvectors.asInstanceOf[js.Any], result.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def PROJ_SPHERICAL_EQRECT: UndistortTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("PROJ_SPHERICAL_EQRECT").asInstanceOf[UndistortTypes]

inline def PROJ_SPHERICAL_ORTHO: UndistortTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("PROJ_SPHERICAL_ORTHO").asInstanceOf[UndistortTypes]

inline def PSNR(src1: InputArray, src2: InputArray): double = (^.asInstanceOf[js.Dynamic].applyDynamic("PSNR")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any])).asInstanceOf[double]
inline def PSNR(src1: InputArray, src2: InputArray, R: double): double = (^.asInstanceOf[js.Dynamic].applyDynamic("PSNR")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], R.asInstanceOf[js.Any])).asInstanceOf[double]

inline def RANSAC: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("RANSAC").asInstanceOf[Any]

inline def RETR_CCOMP: RetrievalModes = ^.asInstanceOf[js.Dynamic].selectDynamic("RETR_CCOMP").asInstanceOf[RetrievalModes]

inline def RETR_EXTERNAL: RetrievalModes = ^.asInstanceOf[js.Dynamic].selectDynamic("RETR_EXTERNAL").asInstanceOf[RetrievalModes]

inline def RETR_FLOODFILL: RetrievalModes = ^.asInstanceOf[js.Dynamic].selectDynamic("RETR_FLOODFILL").asInstanceOf[RetrievalModes]

inline def RETR_LIST: RetrievalModes = ^.asInstanceOf[js.Dynamic].selectDynamic("RETR_LIST").asInstanceOf[RetrievalModes]

inline def RETR_TREE: RetrievalModes = ^.asInstanceOf[js.Dynamic].selectDynamic("RETR_TREE").asInstanceOf[RetrievalModes]

inline def RHO: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("RHO").asInstanceOf[Any]

inline def ROTATE_180: RotateFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("ROTATE_180").asInstanceOf[RotateFlags]

inline def ROTATE_90_CLOCKWISE: RotateFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("ROTATE_90_CLOCKWISE").asInstanceOf[RotateFlags]

inline def ROTATE_90_COUNTERCLOCKWISE: RotateFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("ROTATE_90_COUNTERCLOCKWISE").asInstanceOf[RotateFlags]

inline def RQDecomp3x3(src: InputArray, mtxR: OutputArray, mtxQ: OutputArray): Vec3d = (^.asInstanceOf[js.Dynamic].applyDynamic("RQDecomp3x3")(src.asInstanceOf[js.Any], mtxR.asInstanceOf[js.Any], mtxQ.asInstanceOf[js.Any])).asInstanceOf[Vec3d]
inline def RQDecomp3x3(src: InputArray, mtxR: OutputArray, mtxQ: OutputArray, Qx: Unit, Qy: Unit, Qz: OutputArray): Vec3d = (^.asInstanceOf[js.Dynamic].applyDynamic("RQDecomp3x3")(src.asInstanceOf[js.Any], mtxR.asInstanceOf[js.Any], mtxQ.asInstanceOf[js.Any], Qx.asInstanceOf[js.Any], Qy.asInstanceOf[js.Any], Qz.asInstanceOf[js.Any])).asInstanceOf[Vec3d]
inline def RQDecomp3x3(src: InputArray, mtxR: OutputArray, mtxQ: OutputArray, Qx: Unit, Qy: OutputArray): Vec3d = (^.asInstanceOf[js.Dynamic].applyDynamic("RQDecomp3x3")(src.asInstanceOf[js.Any], mtxR.asInstanceOf[js.Any], mtxQ.asInstanceOf[js.Any], Qx.asInstanceOf[js.Any], Qy.asInstanceOf[js.Any])).asInstanceOf[Vec3d]
inline def RQDecomp3x3(src: InputArray, mtxR: OutputArray, mtxQ: OutputArray, Qx: Unit, Qy: OutputArray, Qz: OutputArray): Vec3d = (^.asInstanceOf[js.Dynamic].applyDynamic("RQDecomp3x3")(src.asInstanceOf[js.Any], mtxR.asInstanceOf[js.Any], mtxQ.asInstanceOf[js.Any], Qx.asInstanceOf[js.Any], Qy.asInstanceOf[js.Any], Qz.asInstanceOf[js.Any])).asInstanceOf[Vec3d]
inline def RQDecomp3x3(src: InputArray, mtxR: OutputArray, mtxQ: OutputArray, Qx: OutputArray): Vec3d = (^.asInstanceOf[js.Dynamic].applyDynamic("RQDecomp3x3")(src.asInstanceOf[js.Any], mtxR.asInstanceOf[js.Any], mtxQ.asInstanceOf[js.Any], Qx.asInstanceOf[js.Any])).asInstanceOf[Vec3d]
inline def RQDecomp3x3(src: InputArray, mtxR: OutputArray, mtxQ: OutputArray, Qx: OutputArray, Qy: Unit, Qz: OutputArray): Vec3d = (^.asInstanceOf[js.Dynamic].applyDynamic("RQDecomp3x3")(src.asInstanceOf[js.Any], mtxR.asInstanceOf[js.Any], mtxQ.asInstanceOf[js.Any], Qx.asInstanceOf[js.Any], Qy.asInstanceOf[js.Any], Qz.asInstanceOf[js.Any])).asInstanceOf[Vec3d]
inline def RQDecomp3x3(src: InputArray, mtxR: OutputArray, mtxQ: OutputArray, Qx: OutputArray, Qy: OutputArray): Vec3d = (^.asInstanceOf[js.Dynamic].applyDynamic("RQDecomp3x3")(src.asInstanceOf[js.Any], mtxR.asInstanceOf[js.Any], mtxQ.asInstanceOf[js.Any], Qx.asInstanceOf[js.Any], Qy.asInstanceOf[js.Any])).asInstanceOf[Vec3d]
inline def RQDecomp3x3(
  src: InputArray,
  mtxR: OutputArray,
  mtxQ: OutputArray,
  Qx: OutputArray,
  Qy: OutputArray,
  Qz: OutputArray
): Vec3d = (^.asInstanceOf[js.Dynamic].applyDynamic("RQDecomp3x3")(src.asInstanceOf[js.Any], mtxR.asInstanceOf[js.Any], mtxQ.asInstanceOf[js.Any], Qx.asInstanceOf[js.Any], Qy.asInstanceOf[js.Any], Qz.asInstanceOf[js.Any])).asInstanceOf[Vec3d]

inline def Rodrigues(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Rodrigues")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Rodrigues(src: InputArray, dst: OutputArray, jacobian: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Rodrigues")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], jacobian.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def SOLVEPNP_AP3P: SolvePnPMethod = ^.asInstanceOf[js.Dynamic].selectDynamic("SOLVEPNP_AP3P").asInstanceOf[SolvePnPMethod]

inline def SOLVEPNP_DLS: SolvePnPMethod = ^.asInstanceOf[js.Dynamic].selectDynamic("SOLVEPNP_DLS").asInstanceOf[SolvePnPMethod]

inline def SOLVEPNP_EPNP: SolvePnPMethod = ^.asInstanceOf[js.Dynamic].selectDynamic("SOLVEPNP_EPNP").asInstanceOf[SolvePnPMethod]

inline def SOLVEPNP_IPPE: SolvePnPMethod = ^.asInstanceOf[js.Dynamic].selectDynamic("SOLVEPNP_IPPE").asInstanceOf[SolvePnPMethod]

inline def SOLVEPNP_IPPE_SQUARE: SolvePnPMethod = ^.asInstanceOf[js.Dynamic].selectDynamic("SOLVEPNP_IPPE_SQUARE").asInstanceOf[SolvePnPMethod]

inline def SOLVEPNP_ITERATIVE: SolvePnPMethod = ^.asInstanceOf[js.Dynamic].selectDynamic("SOLVEPNP_ITERATIVE").asInstanceOf[SolvePnPMethod]

inline def SOLVEPNP_P3P: SolvePnPMethod = ^.asInstanceOf[js.Dynamic].selectDynamic("SOLVEPNP_P3P").asInstanceOf[SolvePnPMethod]

inline def SOLVEPNP_UPNP: SolvePnPMethod = ^.asInstanceOf[js.Dynamic].selectDynamic("SOLVEPNP_UPNP").asInstanceOf[SolvePnPMethod]

inline def SORT_ASCENDING: SortFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("SORT_ASCENDING").asInstanceOf[SortFlags]

inline def SORT_DESCENDING: SortFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("SORT_DESCENDING").asInstanceOf[SortFlags]

inline def SORT_EVERY_COLUMN: SortFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("SORT_EVERY_COLUMN").asInstanceOf[SortFlags]

inline def SORT_EVERY_ROW: SortFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("SORT_EVERY_ROW").asInstanceOf[SortFlags]

inline def SUBMATRIX_FLAG: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("SUBMATRIX_FLAG").asInstanceOf[Any]

inline def SVBackSubst(w: InputArray, u: InputArray, vt: InputArray, rhs: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("SVBackSubst")(w.asInstanceOf[js.Any], u.asInstanceOf[js.Any], vt.asInstanceOf[js.Any], rhs.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def SVDecomp(src: InputArray, w: OutputArray, u: OutputArray, vt: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("SVDecomp")(src.asInstanceOf[js.Any], w.asInstanceOf[js.Any], u.asInstanceOf[js.Any], vt.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def SVDecomp(src: InputArray, w: OutputArray, u: OutputArray, vt: OutputArray, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("SVDecomp")(src.asInstanceOf[js.Any], w.asInstanceOf[js.Any], u.asInstanceOf[js.Any], vt.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def Scharr(src: InputArray, dst: OutputArray, ddepth: int, dx: int, dy: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Scharr")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Scharr(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  scale: Unit,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Scharr")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Scharr(src: InputArray, dst: OutputArray, ddepth: int, dx: int, dy: int, scale: Unit, delta: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Scharr")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Scharr(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  scale: Unit,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Scharr")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Scharr(src: InputArray, dst: OutputArray, ddepth: int, dx: int, dy: int, scale: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Scharr")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Scharr(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  scale: double,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Scharr")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Scharr(src: InputArray, dst: OutputArray, ddepth: int, dx: int, dy: int, scale: double, delta: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Scharr")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Scharr(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  scale: double,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Scharr")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def Sobel(src: InputArray, dst: OutputArray, ddepth: int, dx: int, dy: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: Unit,
  scale: Unit,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: Unit,
  scale: Unit,
  delta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: Unit,
  scale: Unit,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(src: InputArray, dst: OutputArray, ddepth: int, dx: int, dy: int, ksize: Unit, scale: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: Unit,
  scale: double,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: Unit,
  scale: double,
  delta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: Unit,
  scale: double,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(src: InputArray, dst: OutputArray, ddepth: int, dx: int, dy: int, ksize: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: int,
  scale: Unit,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: int,
  scale: Unit,
  delta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: int,
  scale: Unit,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(src: InputArray, dst: OutputArray, ddepth: int, dx: int, dy: int, ksize: int, scale: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: int,
  scale: double,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: int,
  scale: double,
  delta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: int,
  scale: double,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def THRESH_BINARY: ThresholdTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("THRESH_BINARY").asInstanceOf[ThresholdTypes]

inline def THRESH_BINARY_INV: ThresholdTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("THRESH_BINARY_INV").asInstanceOf[ThresholdTypes]

inline def THRESH_MASK: ThresholdTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("THRESH_MASK").asInstanceOf[ThresholdTypes]

inline def THRESH_OTSU: ThresholdTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("THRESH_OTSU").asInstanceOf[ThresholdTypes]

inline def THRESH_TOZERO: ThresholdTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("THRESH_TOZERO").asInstanceOf[ThresholdTypes]

inline def THRESH_TOZERO_INV: ThresholdTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("THRESH_TOZERO_INV").asInstanceOf[ThresholdTypes]

inline def THRESH_TRIANGLE: ThresholdTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("THRESH_TRIANGLE").asInstanceOf[ThresholdTypes]

inline def THRESH_TRUNC: ThresholdTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("THRESH_TRUNC").asInstanceOf[ThresholdTypes]

inline def TM_CCOEFF: TemplateMatchModes = ^.asInstanceOf[js.Dynamic].selectDynamic("TM_CCOEFF").asInstanceOf[TemplateMatchModes]

inline def TM_CCOEFF_NORMED: TemplateMatchModes = ^.asInstanceOf[js.Dynamic].selectDynamic("TM_CCOEFF_NORMED").asInstanceOf[TemplateMatchModes]

inline def TM_CCORR: TemplateMatchModes = ^.asInstanceOf[js.Dynamic].selectDynamic("TM_CCORR").asInstanceOf[TemplateMatchModes]

inline def TM_CCORR_NORMED: TemplateMatchModes = ^.asInstanceOf[js.Dynamic].selectDynamic("TM_CCORR_NORMED").asInstanceOf[TemplateMatchModes]

inline def TM_SQDIFF: TemplateMatchModes = ^.asInstanceOf[js.Dynamic].selectDynamic("TM_SQDIFF").asInstanceOf[TemplateMatchModes]

inline def TM_SQDIFF_NORMED: TemplateMatchModes = ^.asInstanceOf[js.Dynamic].selectDynamic("TM_SQDIFF_NORMED").asInstanceOf[TemplateMatchModes]

inline def TYPE_MASK: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("TYPE_MASK").asInstanceOf[Any]

inline def TermCriteriaCOUNT: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("TermCriteria_COUNT").asInstanceOf[Any]

inline def TermCriteriaEPS: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("TermCriteria_EPS").asInstanceOf[Any]

inline def TermCriteriaMAXITER: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("TermCriteria_MAX_ITER").asInstanceOf[Any]

inline def USE_AVG: Flags = ^.asInstanceOf[js.Dynamic].selectDynamic("USE_AVG").asInstanceOf[Flags]

inline def WARP_FILL_OUTLIERS: InterpolationFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("WARP_FILL_OUTLIERS").asInstanceOf[InterpolationFlags]

inline def WARP_INVERSE_MAP: InterpolationFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("WARP_INVERSE_MAP").asInstanceOf[InterpolationFlags]

inline def WARP_POLAR_LINEAR: WarpPolarMode = ^.asInstanceOf[js.Dynamic].selectDynamic("WARP_POLAR_LINEAR").asInstanceOf[WarpPolarMode]

inline def WARP_POLAR_LOG: WarpPolarMode = ^.asInstanceOf[js.Dynamic].selectDynamic("WARP_POLAR_LOG").asInstanceOf[WarpPolarMode]

inline def absdiff(src1: InputArray, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("absdiff")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def adaptiveThreshold(
  src: InputArray,
  dst: OutputArray,
  maxValue: double,
  adaptiveMethod: int,
  thresholdType: int,
  blockSize: int,
  C: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("adaptiveThreshold")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], maxValue.asInstanceOf[js.Any], adaptiveMethod.asInstanceOf[js.Any], thresholdType.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], C.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def add(src1: InputArray, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("add")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def add(src1: InputArray, src2: InputArray, dst: OutputArray, mask: Unit, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("add")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def add(src1: InputArray, src2: InputArray, dst: OutputArray, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("add")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def add(src1: InputArray, src2: InputArray, dst: OutputArray, mask: InputArray, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("add")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def addWeighted(src1: InputArray, alpha: double, src2: InputArray, beta: double, gamma: double, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("addWeighted")(src1.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], gamma.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def addWeighted(
  src1: InputArray,
  alpha: double,
  src2: InputArray,
  beta: double,
  gamma: double,
  dst: OutputArray,
  dtype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("addWeighted")(src1.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], gamma.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def alignPtr(arg92: Any, ptr: Any): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("alignPtr")(arg92.asInstanceOf[js.Any], ptr.asInstanceOf[js.Any])).asInstanceOf[Any]
inline def alignPtr(arg92: Any, ptr: Any, n: int): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("alignPtr")(arg92.asInstanceOf[js.Any], ptr.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[Any]

inline def alignSize(sz: sizeT, n: int): sizeT = (^.asInstanceOf[js.Dynamic].applyDynamic("alignSize")(sz.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[sizeT]

inline def approxPolyDP(curve: InputArray, approxCurve: OutputArray, epsilon: double, closed: bool): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("approxPolyDP")(curve.asInstanceOf[js.Any], approxCurve.asInstanceOf[js.Any], epsilon.asInstanceOf[js.Any], closed.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def arcLength(curve: InputArray, closed: bool): double = (^.asInstanceOf[js.Dynamic].applyDynamic("arcLength")(curve.asInstanceOf[js.Any], closed.asInstanceOf[js.Any])).asInstanceOf[double]

inline def arrowedLine(img: InputOutputArray, pt1: Point, pt2: Point, color: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: InputOutputArray,
  pt1: Point,
  pt2: Point,
  color: Any,
  thickness: Unit,
  line_type: Unit,
  shift: Unit,
  tipLength: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], tipLength.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: InputOutputArray,
  pt1: Point,
  pt2: Point,
  color: Any,
  thickness: Unit,
  line_type: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: InputOutputArray,
  pt1: Point,
  pt2: Point,
  color: Any,
  thickness: Unit,
  line_type: Unit,
  shift: int,
  tipLength: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], tipLength.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(img: InputOutputArray, pt1: Point, pt2: Point, color: Any, thickness: Unit, line_type: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: InputOutputArray,
  pt1: Point,
  pt2: Point,
  color: Any,
  thickness: Unit,
  line_type: int,
  shift: Unit,
  tipLength: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], tipLength.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: InputOutputArray,
  pt1: Point,
  pt2: Point,
  color: Any,
  thickness: Unit,
  line_type: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: InputOutputArray,
  pt1: Point,
  pt2: Point,
  color: Any,
  thickness: Unit,
  line_type: int,
  shift: int,
  tipLength: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], tipLength.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(img: InputOutputArray, pt1: Point, pt2: Point, color: Any, thickness: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: InputOutputArray,
  pt1: Point,
  pt2: Point,
  color: Any,
  thickness: int,
  line_type: Unit,
  shift: Unit,
  tipLength: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], tipLength.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: InputOutputArray,
  pt1: Point,
  pt2: Point,
  color: Any,
  thickness: int,
  line_type: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: InputOutputArray,
  pt1: Point,
  pt2: Point,
  color: Any,
  thickness: int,
  line_type: Unit,
  shift: int,
  tipLength: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], tipLength.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(img: InputOutputArray, pt1: Point, pt2: Point, color: Any, thickness: int, line_type: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: InputOutputArray,
  pt1: Point,
  pt2: Point,
  color: Any,
  thickness: int,
  line_type: int,
  shift: Unit,
  tipLength: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], tipLength.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: InputOutputArray,
  pt1: Point,
  pt2: Point,
  color: Any,
  thickness: int,
  line_type: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: InputOutputArray,
  pt1: Point,
  pt2: Point,
  color: Any,
  thickness: int,
  line_type: int,
  shift: int,
  tipLength: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], tipLength.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def batchDistance(src1: InputArray, src2: InputArray, dist: OutputArray, dtype: int, nidx: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: Unit,
  K: Unit,
  mask: Unit,
  update: Unit,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: Unit,
  K: Unit,
  mask: Unit,
  update: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: Unit,
  K: Unit,
  mask: Unit,
  update: int,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: Unit,
  K: Unit,
  mask: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: Unit,
  K: Unit,
  mask: InputArray,
  update: Unit,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: Unit,
  K: Unit,
  mask: InputArray,
  update: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: Unit,
  K: Unit,
  mask: InputArray,
  update: int,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: Unit,
  K: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: Unit,
  K: int,
  mask: Unit,
  update: Unit,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: Unit,
  K: int,
  mask: Unit,
  update: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: Unit,
  K: int,
  mask: Unit,
  update: int,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: Unit,
  K: int,
  mask: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: Unit,
  K: int,
  mask: InputArray,
  update: Unit,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: Unit,
  K: int,
  mask: InputArray,
  update: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: Unit,
  K: int,
  mask: InputArray,
  update: int,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: int,
  K: Unit,
  mask: Unit,
  update: Unit,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: int,
  K: Unit,
  mask: Unit,
  update: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: int,
  K: Unit,
  mask: Unit,
  update: int,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: int,
  K: Unit,
  mask: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: int,
  K: Unit,
  mask: InputArray,
  update: Unit,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: int,
  K: Unit,
  mask: InputArray,
  update: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: int,
  K: Unit,
  mask: InputArray,
  update: int,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: int,
  K: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: int,
  K: int,
  mask: Unit,
  update: Unit,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: int,
  K: int,
  mask: Unit,
  update: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: int,
  K: int,
  mask: Unit,
  update: int,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: int,
  K: int,
  mask: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: int,
  K: int,
  mask: InputArray,
  update: Unit,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: int,
  K: int,
  mask: InputArray,
  update: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: InputArray,
  src2: InputArray,
  dist: OutputArray,
  dtype: int,
  nidx: OutputArray,
  normType: int,
  K: int,
  mask: InputArray,
  update: int,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def bilateralFilter(src: InputArray, dst: OutputArray, d: int, sigmaColor: double, sigmaSpace: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bilateralFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], d.asInstanceOf[js.Any], sigmaColor.asInstanceOf[js.Any], sigmaSpace.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def bilateralFilter(src: InputArray, dst: OutputArray, d: int, sigmaColor: double, sigmaSpace: double, borderType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bilateralFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], d.asInstanceOf[js.Any], sigmaColor.asInstanceOf[js.Any], sigmaSpace.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def bitwiseAnd(src1: InputArray, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bitwise_and")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def bitwiseAnd(src1: InputArray, src2: InputArray, dst: OutputArray, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bitwise_and")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def bitwiseNot(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bitwise_not")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def bitwiseNot(src: InputArray, dst: OutputArray, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bitwise_not")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def bitwiseOr(src1: InputArray, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bitwise_or")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def bitwiseOr(src1: InputArray, src2: InputArray, dst: OutputArray, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bitwise_or")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def bitwiseXor(src1: InputArray, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bitwise_xor")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def bitwiseXor(src1: InputArray, src2: InputArray, dst: OutputArray, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bitwise_xor")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def blendLinear(src1: InputArray, src2: InputArray, weights1: InputArray, weights2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("blendLinear")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], weights1.asInstanceOf[js.Any], weights2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def blobFromImage(
  image: InputArray,
  blob: OutputArray,
  scalefactor: js.UndefOr[double],
  size: js.UndefOr[Any],
  mean: js.UndefOr[Any],
  swapRB: js.UndefOr[bool],
  crop: js.UndefOr[bool],
  ddepth: js.UndefOr[int]
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("blobFromImage")(image.asInstanceOf[js.Any], blob.asInstanceOf[js.Any], scalefactor.asInstanceOf[js.Any], size.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], swapRB.asInstanceOf[js.Any], crop.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def blobFromImage(
  image: InputArray,
  scalefactor: js.UndefOr[double],
  size: js.UndefOr[Any],
  mean: js.UndefOr[Any],
  swapRB: js.UndefOr[bool],
  crop: js.UndefOr[bool],
  ddepth: js.UndefOr[int]
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("blobFromImage")(image.asInstanceOf[js.Any], scalefactor.asInstanceOf[js.Any], size.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], swapRB.asInstanceOf[js.Any], crop.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any])).asInstanceOf[Mat]

inline def blobFromImages(
  images: InputArrayOfArrays,
  blob: OutputArray,
  scalefactor: js.UndefOr[double],
  size: js.UndefOr[Size],
  mean: js.UndefOr[Any],
  swapRB: js.UndefOr[bool],
  crop: js.UndefOr[bool],
  ddepth: js.UndefOr[int]
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("blobFromImages")(images.asInstanceOf[js.Any], blob.asInstanceOf[js.Any], scalefactor.asInstanceOf[js.Any], size.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], swapRB.asInstanceOf[js.Any], crop.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def blobFromImages(
  images: InputArrayOfArrays,
  scalefactor: js.UndefOr[double],
  size: js.UndefOr[Size],
  mean: js.UndefOr[Any],
  swapRB: js.UndefOr[bool],
  crop: js.UndefOr[bool],
  ddepth: js.UndefOr[int]
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("blobFromImages")(images.asInstanceOf[js.Any], scalefactor.asInstanceOf[js.Any], size.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], swapRB.asInstanceOf[js.Any], crop.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any])).asInstanceOf[Mat]

inline def blur(src: InputArray, dst: OutputArray, ksize: Size): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("blur")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def blur(src: InputArray, dst: OutputArray, ksize: Size, anchor: Unit, borderType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("blur")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def blur(src: InputArray, dst: OutputArray, ksize: Size, anchor: Point): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("blur")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def blur(src: InputArray, dst: OutputArray, ksize: Size, anchor: Point, borderType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("blur")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def borderInterpolate(p: int, len: int, borderType: int): int = (^.asInstanceOf[js.Dynamic].applyDynamic("borderInterpolate")(p.asInstanceOf[js.Any], len.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[int]

inline def boundingRect(array: InputArray): Rect = ^.asInstanceOf[js.Dynamic].applyDynamic("boundingRect")(array.asInstanceOf[js.Any]).asInstanceOf[Rect]

inline def boxFilter(src: InputArray, dst: OutputArray, ddepth: int, ksize: Size): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("boxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def boxFilter(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  ksize: Size,
  anchor: Unit,
  normalize: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("boxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def boxFilter(src: InputArray, dst: OutputArray, ddepth: int, ksize: Size, anchor: Unit, normalize: bool): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("boxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def boxFilter(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  ksize: Size,
  anchor: Unit,
  normalize: bool,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("boxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def boxFilter(src: InputArray, dst: OutputArray, ddepth: int, ksize: Size, anchor: Point): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("boxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def boxFilter(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  ksize: Size,
  anchor: Point,
  normalize: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("boxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def boxFilter(src: InputArray, dst: OutputArray, ddepth: int, ksize: Size, anchor: Point, normalize: bool): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("boxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def boxFilter(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  ksize: Size,
  anchor: Point,
  normalize: bool,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("boxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def boxPoints(box: RotatedRect, points: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("boxPoints")(box.asInstanceOf[js.Any], points.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def buildOpticalFlowPyramid(img: InputArray, pyramid: OutputArrayOfArrays, winSize: Size, maxLevel: int): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: InputArray,
  pyramid: OutputArrayOfArrays,
  winSize: Size,
  maxLevel: int,
  withDerivatives: Unit,
  pyrBorder: Unit,
  derivBorder: Unit,
  tryReuseInputImage: bool
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any], derivBorder.asInstanceOf[js.Any], tryReuseInputImage.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: InputArray,
  pyramid: OutputArrayOfArrays,
  winSize: Size,
  maxLevel: int,
  withDerivatives: Unit,
  pyrBorder: Unit,
  derivBorder: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any], derivBorder.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: InputArray,
  pyramid: OutputArrayOfArrays,
  winSize: Size,
  maxLevel: int,
  withDerivatives: Unit,
  pyrBorder: Unit,
  derivBorder: int,
  tryReuseInputImage: bool
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any], derivBorder.asInstanceOf[js.Any], tryReuseInputImage.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: InputArray,
  pyramid: OutputArrayOfArrays,
  winSize: Size,
  maxLevel: int,
  withDerivatives: Unit,
  pyrBorder: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: InputArray,
  pyramid: OutputArrayOfArrays,
  winSize: Size,
  maxLevel: int,
  withDerivatives: Unit,
  pyrBorder: int,
  derivBorder: Unit,
  tryReuseInputImage: bool
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any], derivBorder.asInstanceOf[js.Any], tryReuseInputImage.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: InputArray,
  pyramid: OutputArrayOfArrays,
  winSize: Size,
  maxLevel: int,
  withDerivatives: Unit,
  pyrBorder: int,
  derivBorder: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any], derivBorder.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: InputArray,
  pyramid: OutputArrayOfArrays,
  winSize: Size,
  maxLevel: int,
  withDerivatives: Unit,
  pyrBorder: int,
  derivBorder: int,
  tryReuseInputImage: bool
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any], derivBorder.asInstanceOf[js.Any], tryReuseInputImage.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(img: InputArray, pyramid: OutputArrayOfArrays, winSize: Size, maxLevel: int, withDerivatives: bool): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: InputArray,
  pyramid: OutputArrayOfArrays,
  winSize: Size,
  maxLevel: int,
  withDerivatives: bool,
  pyrBorder: Unit,
  derivBorder: Unit,
  tryReuseInputImage: bool
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any], derivBorder.asInstanceOf[js.Any], tryReuseInputImage.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: InputArray,
  pyramid: OutputArrayOfArrays,
  winSize: Size,
  maxLevel: int,
  withDerivatives: bool,
  pyrBorder: Unit,
  derivBorder: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any], derivBorder.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: InputArray,
  pyramid: OutputArrayOfArrays,
  winSize: Size,
  maxLevel: int,
  withDerivatives: bool,
  pyrBorder: Unit,
  derivBorder: int,
  tryReuseInputImage: bool
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any], derivBorder.asInstanceOf[js.Any], tryReuseInputImage.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: InputArray,
  pyramid: OutputArrayOfArrays,
  winSize: Size,
  maxLevel: int,
  withDerivatives: bool,
  pyrBorder: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: InputArray,
  pyramid: OutputArrayOfArrays,
  winSize: Size,
  maxLevel: int,
  withDerivatives: bool,
  pyrBorder: int,
  derivBorder: Unit,
  tryReuseInputImage: bool
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any], derivBorder.asInstanceOf[js.Any], tryReuseInputImage.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: InputArray,
  pyramid: OutputArrayOfArrays,
  winSize: Size,
  maxLevel: int,
  withDerivatives: bool,
  pyrBorder: int,
  derivBorder: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any], derivBorder.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: InputArray,
  pyramid: OutputArrayOfArrays,
  winSize: Size,
  maxLevel: int,
  withDerivatives: bool,
  pyrBorder: int,
  derivBorder: int,
  tryReuseInputImage: bool
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any], derivBorder.asInstanceOf[js.Any], tryReuseInputImage.asInstanceOf[js.Any])).asInstanceOf[int]

inline def buildPyramid(src: InputArray, dst: OutputArrayOfArrays, maxlevel: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("buildPyramid")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], maxlevel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def buildPyramid(src: InputArray, dst: OutputArrayOfArrays, maxlevel: int, borderType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("buildPyramid")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], maxlevel.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def calcBackProject(images: Any, nimages: int, channels: Any, hist: Any, backProject: OutputArray, ranges: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcBackProject")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], backProject.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcBackProject(
  images: Any,
  nimages: int,
  channels: Any,
  hist: Any,
  backProject: OutputArray,
  ranges: Any,
  scale: Unit,
  uniform: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcBackProject")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], backProject.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], uniform.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcBackProject(
  images: Any,
  nimages: int,
  channels: Any,
  hist: Any,
  backProject: OutputArray,
  ranges: Any,
  scale: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcBackProject")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], backProject.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcBackProject(
  images: Any,
  nimages: int,
  channels: Any,
  hist: Any,
  backProject: OutputArray,
  ranges: Any,
  scale: double,
  uniform: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcBackProject")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], backProject.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], uniform.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcBackProject(images: Any, nimages: int, channels: Any, hist: InputArray, backProject: OutputArray, ranges: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcBackProject")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], backProject.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcBackProject(
  images: Any,
  nimages: int,
  channels: Any,
  hist: InputArray,
  backProject: OutputArray,
  ranges: Any,
  scale: Unit,
  uniform: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcBackProject")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], backProject.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], uniform.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcBackProject(
  images: Any,
  nimages: int,
  channels: Any,
  hist: InputArray,
  backProject: OutputArray,
  ranges: Any,
  scale: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcBackProject")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], backProject.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcBackProject(
  images: Any,
  nimages: int,
  channels: Any,
  hist: InputArray,
  backProject: OutputArray,
  ranges: Any,
  scale: double,
  uniform: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcBackProject")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], backProject.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], uniform.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcBackProject(
  images: InputArrayOfArrays,
  channels: Any,
  hist: InputArray,
  dst: OutputArray,
  ranges: Any,
  scale: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcBackProject")(images.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def calcCovarMatrix(samples: Any, nsamples: int, covar: Any, mean: Any, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcCovarMatrix")(samples.asInstanceOf[js.Any], nsamples.asInstanceOf[js.Any], covar.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcCovarMatrix(samples: Any, nsamples: int, covar: Any, mean: Any, flags: int, ctype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcCovarMatrix")(samples.asInstanceOf[js.Any], nsamples.asInstanceOf[js.Any], covar.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], ctype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcCovarMatrix(samples: InputArray, covar: OutputArray, mean: InputOutputArray, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcCovarMatrix")(samples.asInstanceOf[js.Any], covar.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcCovarMatrix(samples: InputArray, covar: OutputArray, mean: InputOutputArray, flags: int, ctype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcCovarMatrix")(samples.asInstanceOf[js.Any], covar.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], ctype.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def calcHist(
  images: Any,
  nimages: int,
  channels: Any,
  mask: InputArray,
  hist: Any,
  dims: int,
  histSize: Any,
  ranges: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcHist")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], dims.asInstanceOf[js.Any], histSize.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcHist(
  images: Any,
  nimages: int,
  channels: Any,
  mask: InputArray,
  hist: Any,
  dims: int,
  histSize: Any,
  ranges: Any,
  uniform: Unit,
  accumulate: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcHist")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], dims.asInstanceOf[js.Any], histSize.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], uniform.asInstanceOf[js.Any], accumulate.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcHist(
  images: Any,
  nimages: int,
  channels: Any,
  mask: InputArray,
  hist: Any,
  dims: int,
  histSize: Any,
  ranges: Any,
  uniform: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcHist")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], dims.asInstanceOf[js.Any], histSize.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], uniform.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcHist(
  images: Any,
  nimages: int,
  channels: Any,
  mask: InputArray,
  hist: Any,
  dims: int,
  histSize: Any,
  ranges: Any,
  uniform: bool,
  accumulate: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcHist")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], dims.asInstanceOf[js.Any], histSize.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], uniform.asInstanceOf[js.Any], accumulate.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcHist(
  images: Any,
  nimages: int,
  channels: Any,
  mask: InputArray,
  hist: OutputArray,
  dims: int,
  histSize: Any,
  ranges: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcHist")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], dims.asInstanceOf[js.Any], histSize.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcHist(
  images: Any,
  nimages: int,
  channels: Any,
  mask: InputArray,
  hist: OutputArray,
  dims: int,
  histSize: Any,
  ranges: Any,
  uniform: Unit,
  accumulate: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcHist")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], dims.asInstanceOf[js.Any], histSize.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], uniform.asInstanceOf[js.Any], accumulate.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcHist(
  images: Any,
  nimages: int,
  channels: Any,
  mask: InputArray,
  hist: OutputArray,
  dims: int,
  histSize: Any,
  ranges: Any,
  uniform: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcHist")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], dims.asInstanceOf[js.Any], histSize.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], uniform.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcHist(
  images: Any,
  nimages: int,
  channels: Any,
  mask: InputArray,
  hist: OutputArray,
  dims: int,
  histSize: Any,
  ranges: Any,
  uniform: bool,
  accumulate: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcHist")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], dims.asInstanceOf[js.Any], histSize.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], uniform.asInstanceOf[js.Any], accumulate.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcHist(
  images: InputArrayOfArrays,
  channels: Any,
  mask: InputArray,
  hist: OutputArray,
  histSize: Any,
  ranges: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcHist")(images.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], histSize.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcHist(
  images: InputArrayOfArrays,
  channels: Any,
  mask: InputArray,
  hist: OutputArray,
  histSize: Any,
  ranges: Any,
  accumulate: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcHist")(images.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], histSize.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], accumulate.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def calcOpticalFlowFarneback(
  prev: InputArray,
  next: InputArray,
  flow: InputOutputArray,
  pyr_scale: double,
  levels: int,
  winsize: int,
  iterations: int,
  poly_n: int,
  poly_sigma: double,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowFarneback")(prev.asInstanceOf[js.Any], next.asInstanceOf[js.Any], flow.asInstanceOf[js.Any], pyr_scale.asInstanceOf[js.Any], levels.asInstanceOf[js.Any], winsize.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], poly_n.asInstanceOf[js.Any], poly_sigma.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Unit,
  maxLevel: Unit,
  criteria: Unit,
  flags: Unit,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Unit,
  maxLevel: Unit,
  criteria: Unit,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Unit,
  maxLevel: Unit,
  criteria: Unit,
  flags: int,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Unit,
  maxLevel: Unit,
  criteria: TermCriteria
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Unit,
  maxLevel: Unit,
  criteria: TermCriteria,
  flags: Unit,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Unit,
  maxLevel: Unit,
  criteria: TermCriteria,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Unit,
  maxLevel: Unit,
  criteria: TermCriteria,
  flags: int,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Unit,
  maxLevel: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Unit,
  maxLevel: int,
  criteria: Unit,
  flags: Unit,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Unit,
  maxLevel: int,
  criteria: Unit,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Unit,
  maxLevel: int,
  criteria: Unit,
  flags: int,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Unit,
  maxLevel: int,
  criteria: TermCriteria
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Unit,
  maxLevel: int,
  criteria: TermCriteria,
  flags: Unit,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Unit,
  maxLevel: int,
  criteria: TermCriteria,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Unit,
  maxLevel: int,
  criteria: TermCriteria,
  flags: int,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Size
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Size,
  maxLevel: Unit,
  criteria: Unit,
  flags: Unit,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Size,
  maxLevel: Unit,
  criteria: Unit,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Size,
  maxLevel: Unit,
  criteria: Unit,
  flags: int,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Size,
  maxLevel: Unit,
  criteria: TermCriteria
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Size,
  maxLevel: Unit,
  criteria: TermCriteria,
  flags: Unit,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Size,
  maxLevel: Unit,
  criteria: TermCriteria,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Size,
  maxLevel: Unit,
  criteria: TermCriteria,
  flags: int,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Size,
  maxLevel: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Size,
  maxLevel: int,
  criteria: Unit,
  flags: Unit,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Size,
  maxLevel: int,
  criteria: Unit,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Size,
  maxLevel: int,
  criteria: Unit,
  flags: int,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Size,
  maxLevel: int,
  criteria: TermCriteria
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Size,
  maxLevel: int,
  criteria: TermCriteria,
  flags: Unit,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Size,
  maxLevel: int,
  criteria: TermCriteria,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: InputArray,
  nextImg: InputArray,
  prevPts: InputArray,
  nextPts: InputOutputArray,
  status: OutputArray,
  err: OutputArray,
  winSize: Size,
  maxLevel: int,
  criteria: TermCriteria,
  flags: int,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def calibrateCamera(
  objectPoints: InputArrayOfArrays,
  imagePoints: InputArrayOfArrays,
  imageSize: Size,
  cameraMatrix: InputOutputArray,
  distCoeffs: InputOutputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCamera")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCamera(
  objectPoints: InputArrayOfArrays,
  imagePoints: InputArrayOfArrays,
  imageSize: Size,
  cameraMatrix: InputOutputArray,
  distCoeffs: InputOutputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  flags: Unit,
  criteria: TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCamera")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCamera(
  objectPoints: InputArrayOfArrays,
  imagePoints: InputArrayOfArrays,
  imageSize: Size,
  cameraMatrix: InputOutputArray,
  distCoeffs: InputOutputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  flags: int
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCamera")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCamera(
  objectPoints: InputArrayOfArrays,
  imagePoints: InputArrayOfArrays,
  imageSize: Size,
  cameraMatrix: InputOutputArray,
  distCoeffs: InputOutputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  flags: int,
  criteria: TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCamera")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCamera(
  objectPoints: InputArrayOfArrays,
  imagePoints: InputArrayOfArrays,
  imageSize: Size,
  cameraMatrix: InputOutputArray,
  distCoeffs: InputOutputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  stdDeviationsIntrinsics: OutputArray,
  stdDeviationsExtrinsics: OutputArray,
  perViewErrors: OutputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCamera")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], stdDeviationsIntrinsics.asInstanceOf[js.Any], stdDeviationsExtrinsics.asInstanceOf[js.Any], perViewErrors.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCamera(
  objectPoints: InputArrayOfArrays,
  imagePoints: InputArrayOfArrays,
  imageSize: Size,
  cameraMatrix: InputOutputArray,
  distCoeffs: InputOutputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  stdDeviationsIntrinsics: OutputArray,
  stdDeviationsExtrinsics: OutputArray,
  perViewErrors: OutputArray,
  flags: Unit,
  criteria: TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCamera")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], stdDeviationsIntrinsics.asInstanceOf[js.Any], stdDeviationsExtrinsics.asInstanceOf[js.Any], perViewErrors.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCamera(
  objectPoints: InputArrayOfArrays,
  imagePoints: InputArrayOfArrays,
  imageSize: Size,
  cameraMatrix: InputOutputArray,
  distCoeffs: InputOutputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  stdDeviationsIntrinsics: OutputArray,
  stdDeviationsExtrinsics: OutputArray,
  perViewErrors: OutputArray,
  flags: int
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCamera")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], stdDeviationsIntrinsics.asInstanceOf[js.Any], stdDeviationsExtrinsics.asInstanceOf[js.Any], perViewErrors.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCamera(
  objectPoints: InputArrayOfArrays,
  imagePoints: InputArrayOfArrays,
  imageSize: Size,
  cameraMatrix: InputOutputArray,
  distCoeffs: InputOutputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  stdDeviationsIntrinsics: OutputArray,
  stdDeviationsExtrinsics: OutputArray,
  perViewErrors: OutputArray,
  flags: int,
  criteria: TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCamera")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], stdDeviationsIntrinsics.asInstanceOf[js.Any], stdDeviationsExtrinsics.asInstanceOf[js.Any], perViewErrors.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]

inline def calibrateCameraRO(
  objectPoints: InputArrayOfArrays,
  imagePoints: InputArrayOfArrays,
  imageSize: Size,
  iFixedPoint: int,
  cameraMatrix: InputOutputArray,
  distCoeffs: InputOutputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  newObjPoints: OutputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCameraRO")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], iFixedPoint.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], newObjPoints.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCameraRO(
  objectPoints: InputArrayOfArrays,
  imagePoints: InputArrayOfArrays,
  imageSize: Size,
  iFixedPoint: int,
  cameraMatrix: InputOutputArray,
  distCoeffs: InputOutputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  newObjPoints: OutputArray,
  flags: Unit,
  criteria: TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCameraRO")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], iFixedPoint.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], newObjPoints.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCameraRO(
  objectPoints: InputArrayOfArrays,
  imagePoints: InputArrayOfArrays,
  imageSize: Size,
  iFixedPoint: int,
  cameraMatrix: InputOutputArray,
  distCoeffs: InputOutputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  newObjPoints: OutputArray,
  flags: int
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCameraRO")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], iFixedPoint.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], newObjPoints.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCameraRO(
  objectPoints: InputArrayOfArrays,
  imagePoints: InputArrayOfArrays,
  imageSize: Size,
  iFixedPoint: int,
  cameraMatrix: InputOutputArray,
  distCoeffs: InputOutputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  newObjPoints: OutputArray,
  flags: int,
  criteria: TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCameraRO")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], iFixedPoint.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], newObjPoints.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCameraRO(
  objectPoints: InputArrayOfArrays,
  imagePoints: InputArrayOfArrays,
  imageSize: Size,
  iFixedPoint: int,
  cameraMatrix: InputOutputArray,
  distCoeffs: InputOutputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  newObjPoints: OutputArray,
  stdDeviationsIntrinsics: OutputArray,
  stdDeviationsExtrinsics: OutputArray,
  stdDeviationsObjPoints: OutputArray,
  perViewErrors: OutputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCameraRO")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], iFixedPoint.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], newObjPoints.asInstanceOf[js.Any], stdDeviationsIntrinsics.asInstanceOf[js.Any], stdDeviationsExtrinsics.asInstanceOf[js.Any], stdDeviationsObjPoints.asInstanceOf[js.Any], perViewErrors.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCameraRO(
  objectPoints: InputArrayOfArrays,
  imagePoints: InputArrayOfArrays,
  imageSize: Size,
  iFixedPoint: int,
  cameraMatrix: InputOutputArray,
  distCoeffs: InputOutputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  newObjPoints: OutputArray,
  stdDeviationsIntrinsics: OutputArray,
  stdDeviationsExtrinsics: OutputArray,
  stdDeviationsObjPoints: OutputArray,
  perViewErrors: OutputArray,
  flags: Unit,
  criteria: TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCameraRO")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], iFixedPoint.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], newObjPoints.asInstanceOf[js.Any], stdDeviationsIntrinsics.asInstanceOf[js.Any], stdDeviationsExtrinsics.asInstanceOf[js.Any], stdDeviationsObjPoints.asInstanceOf[js.Any], perViewErrors.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCameraRO(
  objectPoints: InputArrayOfArrays,
  imagePoints: InputArrayOfArrays,
  imageSize: Size,
  iFixedPoint: int,
  cameraMatrix: InputOutputArray,
  distCoeffs: InputOutputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  newObjPoints: OutputArray,
  stdDeviationsIntrinsics: OutputArray,
  stdDeviationsExtrinsics: OutputArray,
  stdDeviationsObjPoints: OutputArray,
  perViewErrors: OutputArray,
  flags: int
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCameraRO")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], iFixedPoint.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], newObjPoints.asInstanceOf[js.Any], stdDeviationsIntrinsics.asInstanceOf[js.Any], stdDeviationsExtrinsics.asInstanceOf[js.Any], stdDeviationsObjPoints.asInstanceOf[js.Any], perViewErrors.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCameraRO(
  objectPoints: InputArrayOfArrays,
  imagePoints: InputArrayOfArrays,
  imageSize: Size,
  iFixedPoint: int,
  cameraMatrix: InputOutputArray,
  distCoeffs: InputOutputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  newObjPoints: OutputArray,
  stdDeviationsIntrinsics: OutputArray,
  stdDeviationsExtrinsics: OutputArray,
  stdDeviationsObjPoints: OutputArray,
  perViewErrors: OutputArray,
  flags: int,
  criteria: TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCameraRO")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], iFixedPoint.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], newObjPoints.asInstanceOf[js.Any], stdDeviationsIntrinsics.asInstanceOf[js.Any], stdDeviationsExtrinsics.asInstanceOf[js.Any], stdDeviationsObjPoints.asInstanceOf[js.Any], perViewErrors.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]

inline def calibrateHandEye(
  R_gripper2base: InputArrayOfArrays,
  t_gripper2base: InputArrayOfArrays,
  R_target2cam: InputArrayOfArrays,
  t_target2cam: InputArrayOfArrays,
  R_cam2gripper: OutputArray,
  t_cam2gripper: OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateHandEye")(R_gripper2base.asInstanceOf[js.Any], t_gripper2base.asInstanceOf[js.Any], R_target2cam.asInstanceOf[js.Any], t_target2cam.asInstanceOf[js.Any], R_cam2gripper.asInstanceOf[js.Any], t_cam2gripper.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calibrateHandEye(
  R_gripper2base: InputArrayOfArrays,
  t_gripper2base: InputArrayOfArrays,
  R_target2cam: InputArrayOfArrays,
  t_target2cam: InputArrayOfArrays,
  R_cam2gripper: OutputArray,
  t_cam2gripper: OutputArray,
  method: HandEyeCalibrationMethod
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateHandEye")(R_gripper2base.asInstanceOf[js.Any], t_gripper2base.asInstanceOf[js.Any], R_target2cam.asInstanceOf[js.Any], t_target2cam.asInstanceOf[js.Any], R_cam2gripper.asInstanceOf[js.Any], t_cam2gripper.asInstanceOf[js.Any], method.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def calibrationMatrixValues(
  cameraMatrix: InputArray,
  imageSize: Size,
  apertureWidth: double,
  apertureHeight: double,
  fovx: Any,
  fovy: Any,
  focalLength: Any,
  principalPoint: Any,
  aspectRatio: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrationMatrixValues")(cameraMatrix.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], apertureWidth.asInstanceOf[js.Any], apertureHeight.asInstanceOf[js.Any], fovx.asInstanceOf[js.Any], fovy.asInstanceOf[js.Any], focalLength.asInstanceOf[js.Any], principalPoint.asInstanceOf[js.Any], aspectRatio.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def cartToPolar(x: InputArray, y: InputArray, magnitude: OutputArray, angle: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cartToPolar")(x.asInstanceOf[js.Any], y.asInstanceOf[js.Any], magnitude.asInstanceOf[js.Any], angle.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def cartToPolar(x: InputArray, y: InputArray, magnitude: OutputArray, angle: OutputArray, angleInDegrees: bool): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cartToPolar")(x.asInstanceOf[js.Any], y.asInstanceOf[js.Any], magnitude.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], angleInDegrees.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def channels: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("channels").asInstanceOf[Any]

inline def checkChessboard(img: InputArray, size: Size): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkChessboard")(img.asInstanceOf[js.Any], size.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def checkHardwareSupport(feature: int): bool = ^.asInstanceOf[js.Dynamic].applyDynamic("checkHardwareSupport")(feature.asInstanceOf[js.Any]).asInstanceOf[bool]

inline def checkRange(a: InputArray): bool = ^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any]).asInstanceOf[bool]
inline def checkRange(a: InputArray, quiet: Unit, pos: Any): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(a: InputArray, quiet: Unit, pos: Any, minVal: Unit, maxVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(a: InputArray, quiet: Unit, pos: Any, minVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(a: InputArray, quiet: Unit, pos: Any, minVal: double, maxVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(a: InputArray, quiet: Unit, pos: Unit, minVal: Unit, maxVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(a: InputArray, quiet: Unit, pos: Unit, minVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(a: InputArray, quiet: Unit, pos: Unit, minVal: double, maxVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(a: InputArray, quiet: bool): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(a: InputArray, quiet: bool, pos: Any): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(a: InputArray, quiet: bool, pos: Any, minVal: Unit, maxVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(a: InputArray, quiet: bool, pos: Any, minVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(a: InputArray, quiet: bool, pos: Any, minVal: double, maxVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(a: InputArray, quiet: bool, pos: Unit, minVal: Unit, maxVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(a: InputArray, quiet: bool, pos: Unit, minVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(a: InputArray, quiet: bool, pos: Unit, minVal: double, maxVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def circle(img: InputOutputArray, center: Point, radius: int, color: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("circle")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], radius.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def circle(
  img: InputOutputArray,
  center: Point,
  radius: int,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("circle")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], radius.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def circle(img: InputOutputArray, center: Point, radius: int, color: Any, thickness: Unit, lineType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("circle")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], radius.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def circle(
  img: InputOutputArray,
  center: Point,
  radius: int,
  color: Any,
  thickness: Unit,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("circle")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], radius.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def circle(img: InputOutputArray, center: Point, radius: int, color: Any, thickness: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("circle")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], radius.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def circle(
  img: InputOutputArray,
  center: Point,
  radius: int,
  color: Any,
  thickness: int,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("circle")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], radius.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def circle(img: InputOutputArray, center: Point, radius: int, color: Any, thickness: int, lineType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("circle")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], radius.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def circle(
  img: InputOutputArray,
  center: Point,
  radius: int,
  color: Any,
  thickness: int,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("circle")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], radius.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def clipLine(imgRect: Rect, pt1: Any, pt2: Any): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("clipLine")(imgRect.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def clipLine(imgSize: Size2l, pt1: Any, pt2: Any): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("clipLine")(imgSize.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def clipLine(imgSize: Size, pt1: Any, pt2: Any): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("clipLine")(imgSize.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def cols: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("cols").asInstanceOf[Any]

inline def compare(src1: InputArray, src2: InputArray, dst: OutputArray, cmpop: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("compare")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], cmpop.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def compareHist(H1: Any, H2: Any, method: int): double = (^.asInstanceOf[js.Dynamic].applyDynamic("compareHist")(H1.asInstanceOf[js.Any], H2.asInstanceOf[js.Any], method.asInstanceOf[js.Any])).asInstanceOf[double]
inline def compareHist(H1: InputArray, H2: InputArray, method: int): double = (^.asInstanceOf[js.Dynamic].applyDynamic("compareHist")(H1.asInstanceOf[js.Any], H2.asInstanceOf[js.Any], method.asInstanceOf[js.Any])).asInstanceOf[double]

inline def completeSymm(m: InputOutputArray): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("completeSymm")(m.asInstanceOf[js.Any]).asInstanceOf[Unit]
inline def completeSymm(m: InputOutputArray, lowerToUpper: bool): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("completeSymm")(m.asInstanceOf[js.Any], lowerToUpper.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def composeRT(
  rvec1: InputArray,
  tvec1: InputArray,
  rvec2: InputArray,
  tvec2: InputArray,
  rvec3: OutputArray,
  tvec3: OutputArray,
  dr3dr1: js.UndefOr[OutputArray],
  dr3dt1: js.UndefOr[OutputArray],
  dr3dr2: js.UndefOr[OutputArray],
  dr3dt2: js.UndefOr[OutputArray],
  dt3dr1: js.UndefOr[OutputArray],
  dt3dt1: js.UndefOr[OutputArray],
  dt3dr2: js.UndefOr[OutputArray],
  dt3dt2: js.UndefOr[OutputArray]
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("composeRT")(rvec1.asInstanceOf[js.Any], tvec1.asInstanceOf[js.Any], rvec2.asInstanceOf[js.Any], tvec2.asInstanceOf[js.Any], rvec3.asInstanceOf[js.Any], tvec3.asInstanceOf[js.Any], dr3dr1.asInstanceOf[js.Any], dr3dt1.asInstanceOf[js.Any], dr3dr2.asInstanceOf[js.Any], dr3dt2.asInstanceOf[js.Any], dt3dr1.asInstanceOf[js.Any], dt3dt1.asInstanceOf[js.Any], dt3dr2.asInstanceOf[js.Any], dt3dt2.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def computeCorrespondEpilines(points: InputArray, whichImage: int, F: InputArray, lines: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("computeCorrespondEpilines")(points.asInstanceOf[js.Any], whichImage.asInstanceOf[js.Any], F.asInstanceOf[js.Any], lines.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def computeECC(templateImage: InputArray, inputImage: InputArray): double = (^.asInstanceOf[js.Dynamic].applyDynamic("computeECC")(templateImage.asInstanceOf[js.Any], inputImage.asInstanceOf[js.Any])).asInstanceOf[double]
inline def computeECC(templateImage: InputArray, inputImage: InputArray, inputMask: InputArray): double = (^.asInstanceOf[js.Dynamic].applyDynamic("computeECC")(templateImage.asInstanceOf[js.Any], inputImage.asInstanceOf[js.Any], inputMask.asInstanceOf[js.Any])).asInstanceOf[double]

inline def connectedComponents(image: InputArray, labels: OutputArray): int = (^.asInstanceOf[js.Dynamic].applyDynamic("connectedComponents")(image.asInstanceOf[js.Any], labels.asInstanceOf[js.Any])).asInstanceOf[int]
inline def connectedComponents(image: InputArray, labels: OutputArray, connectivity: Unit, ltype: int): int = (^.asInstanceOf[js.Dynamic].applyDynamic("connectedComponents")(image.asInstanceOf[js.Any], labels.asInstanceOf[js.Any], connectivity.asInstanceOf[js.Any], ltype.asInstanceOf[js.Any])).asInstanceOf[int]
inline def connectedComponents(image: InputArray, labels: OutputArray, connectivity: int): int = (^.asInstanceOf[js.Dynamic].applyDynamic("connectedComponents")(image.asInstanceOf[js.Any], labels.asInstanceOf[js.Any], connectivity.asInstanceOf[js.Any])).asInstanceOf[int]
inline def connectedComponents(image: InputArray, labels: OutputArray, connectivity: int, ltype: int): int = (^.asInstanceOf[js.Dynamic].applyDynamic("connectedComponents")(image.asInstanceOf[js.Any], labels.asInstanceOf[js.Any], connectivity.asInstanceOf[js.Any], ltype.asInstanceOf[js.Any])).asInstanceOf[int]
inline def connectedComponents(image: InputArray, labels: OutputArray, connectivity: int, ltype: int, ccltype: int): int = (^.asInstanceOf[js.Dynamic].applyDynamic("connectedComponents")(image.asInstanceOf[js.Any], labels.asInstanceOf[js.Any], connectivity.asInstanceOf[js.Any], ltype.asInstanceOf[js.Any], ccltype.asInstanceOf[js.Any])).asInstanceOf[int]

inline def connectedComponentsWithStats(image: InputArray, labels: OutputArray, stats: OutputArray, centroids: OutputArray): int = (^.asInstanceOf[js.Dynamic].applyDynamic("connectedComponentsWithStats")(image.asInstanceOf[js.Any], labels.asInstanceOf[js.Any], stats.asInstanceOf[js.Any], centroids.asInstanceOf[js.Any])).asInstanceOf[int]
inline def connectedComponentsWithStats(
  image: InputArray,
  labels: OutputArray,
  stats: OutputArray,
  centroids: OutputArray,
  connectivity: Unit,
  ltype: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("connectedComponentsWithStats")(image.asInstanceOf[js.Any], labels.asInstanceOf[js.Any], stats.asInstanceOf[js.Any], centroids.asInstanceOf[js.Any], connectivity.asInstanceOf[js.Any], ltype.asInstanceOf[js.Any])).asInstanceOf[int]
inline def connectedComponentsWithStats(
  image: InputArray,
  labels: OutputArray,
  stats: OutputArray,
  centroids: OutputArray,
  connectivity: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("connectedComponentsWithStats")(image.asInstanceOf[js.Any], labels.asInstanceOf[js.Any], stats.asInstanceOf[js.Any], centroids.asInstanceOf[js.Any], connectivity.asInstanceOf[js.Any])).asInstanceOf[int]
inline def connectedComponentsWithStats(
  image: InputArray,
  labels: OutputArray,
  stats: OutputArray,
  centroids: OutputArray,
  connectivity: int,
  ltype: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("connectedComponentsWithStats")(image.asInstanceOf[js.Any], labels.asInstanceOf[js.Any], stats.asInstanceOf[js.Any], centroids.asInstanceOf[js.Any], connectivity.asInstanceOf[js.Any], ltype.asInstanceOf[js.Any])).asInstanceOf[int]
inline def connectedComponentsWithStats(
  image: InputArray,
  labels: OutputArray,
  stats: OutputArray,
  centroids: OutputArray,
  connectivity: int,
  ltype: int,
  ccltype: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("connectedComponentsWithStats")(image.asInstanceOf[js.Any], labels.asInstanceOf[js.Any], stats.asInstanceOf[js.Any], centroids.asInstanceOf[js.Any], connectivity.asInstanceOf[js.Any], ltype.asInstanceOf[js.Any], ccltype.asInstanceOf[js.Any])).asInstanceOf[int]

inline def contourArea(contour: InputArray): double = ^.asInstanceOf[js.Dynamic].applyDynamic("contourArea")(contour.asInstanceOf[js.Any]).asInstanceOf[double]
inline def contourArea(contour: InputArray, oriented: bool): double = (^.asInstanceOf[js.Dynamic].applyDynamic("contourArea")(contour.asInstanceOf[js.Any], oriented.asInstanceOf[js.Any])).asInstanceOf[double]

inline def convertFp16(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convertFp16")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def convertMaps(map1: InputArray, map2: InputArray, dstmap1: OutputArray, dstmap2: OutputArray, dstmap1type: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convertMaps")(map1.asInstanceOf[js.Any], map2.asInstanceOf[js.Any], dstmap1.asInstanceOf[js.Any], dstmap2.asInstanceOf[js.Any], dstmap1type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def convertMaps(
  map1: InputArray,
  map2: InputArray,
  dstmap1: OutputArray,
  dstmap2: OutputArray,
  dstmap1type: int,
  nninterpolation: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convertMaps")(map1.asInstanceOf[js.Any], map2.asInstanceOf[js.Any], dstmap1.asInstanceOf[js.Any], dstmap2.asInstanceOf[js.Any], dstmap1type.asInstanceOf[js.Any], nninterpolation.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def convertPointsFromHomogeneous(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convertPointsFromHomogeneous")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def convertPointsHomogeneous(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convertPointsHomogeneous")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def convertPointsToHomogeneous(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convertPointsToHomogeneous")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def convertScaleAbs(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convertScaleAbs")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def convertScaleAbs(src: InputArray, dst: OutputArray, alpha: Unit, beta: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convertScaleAbs")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def convertScaleAbs(src: InputArray, dst: OutputArray, alpha: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convertScaleAbs")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def convertScaleAbs(src: InputArray, dst: OutputArray, alpha: double, beta: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convertScaleAbs")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def convexHull(points: InputArray, hull: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convexHull")(points.asInstanceOf[js.Any], hull.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def convexHull(points: InputArray, hull: OutputArray, clockwise: Unit, returnPoints: bool): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convexHull")(points.asInstanceOf[js.Any], hull.asInstanceOf[js.Any], clockwise.asInstanceOf[js.Any], returnPoints.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def convexHull(points: InputArray, hull: OutputArray, clockwise: bool): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convexHull")(points.asInstanceOf[js.Any], hull.asInstanceOf[js.Any], clockwise.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def convexHull(points: InputArray, hull: OutputArray, clockwise: bool, returnPoints: bool): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convexHull")(points.asInstanceOf[js.Any], hull.asInstanceOf[js.Any], clockwise.asInstanceOf[js.Any], returnPoints.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def convexityDefects(contour: InputArray, convexhull: InputArray, convexityDefects: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convexityDefects")(contour.asInstanceOf[js.Any], convexhull.asInstanceOf[js.Any], convexityDefects.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def copyMakeBorder(src: InputArray, dst: OutputArray, top: int, bottom: int, left: int, right: int, borderType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("copyMakeBorder")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], top.asInstanceOf[js.Any], bottom.asInstanceOf[js.Any], left.asInstanceOf[js.Any], right.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def copyMakeBorder(
  src: InputArray,
  dst: OutputArray,
  top: int,
  bottom: int,
  left: int,
  right: int,
  borderType: int,
  value: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("copyMakeBorder")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], top.asInstanceOf[js.Any], bottom.asInstanceOf[js.Any], left.asInstanceOf[js.Any], right.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], value.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def copyTo(src: InputArray, dst: OutputArray, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("copyTo")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def cornerEigenValsAndVecs(src: InputArray, dst: OutputArray, blockSize: int, ksize: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cornerEigenValsAndVecs")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def cornerEigenValsAndVecs(src: InputArray, dst: OutputArray, blockSize: int, ksize: int, borderType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cornerEigenValsAndVecs")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def cornerHarris(src: InputArray, dst: OutputArray, blockSize: int, ksize: int, k: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cornerHarris")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], k.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def cornerHarris(src: InputArray, dst: OutputArray, blockSize: int, ksize: int, k: double, borderType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cornerHarris")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], k.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def cornerMinEigenVal(src: InputArray, dst: OutputArray, blockSize: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cornerMinEigenVal")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def cornerMinEigenVal(src: InputArray, dst: OutputArray, blockSize: int, ksize: Unit, borderType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cornerMinEigenVal")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def cornerMinEigenVal(src: InputArray, dst: OutputArray, blockSize: int, ksize: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cornerMinEigenVal")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def cornerMinEigenVal(src: InputArray, dst: OutputArray, blockSize: int, ksize: int, borderType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cornerMinEigenVal")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def cornerSubPix(
  image: InputArray,
  corners: InputOutputArray,
  winSize: Size,
  zeroZone: Size,
  criteria: TermCriteria
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cornerSubPix")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], zeroZone.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def correctMatches(
  F: InputArray,
  points1: InputArray,
  points2: InputArray,
  newPoints1: OutputArray,
  newPoints2: OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("correctMatches")(F.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], newPoints1.asInstanceOf[js.Any], newPoints2.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def countNonZero(src: InputArray): int = ^.asInstanceOf[js.Dynamic].applyDynamic("countNonZero")(src.asInstanceOf[js.Any]).asInstanceOf[int]

inline def createCLAHE(): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("createCLAHE")().asInstanceOf[Any]
inline def createCLAHE(clipLimit: Unit, tileGridSize: Size): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("createCLAHE")(clipLimit.asInstanceOf[js.Any], tileGridSize.asInstanceOf[js.Any])).asInstanceOf[Any]
inline def createCLAHE(clipLimit: double): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("createCLAHE")(clipLimit.asInstanceOf[js.Any]).asInstanceOf[Any]
inline def createCLAHE(clipLimit: double, tileGridSize: Size): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("createCLAHE")(clipLimit.asInstanceOf[js.Any], tileGridSize.asInstanceOf[js.Any])).asInstanceOf[Any]

inline def createFaceDetectionMaskGenerator(): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("createFaceDetectionMaskGenerator")().asInstanceOf[Any]

inline def createGeneralizedHoughBallard(): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("createGeneralizedHoughBallard")().asInstanceOf[Any]

inline def createGeneralizedHoughGuil(): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("createGeneralizedHoughGuil")().asInstanceOf[Any]

inline def createLineSegmentDetector(
  _refine: js.UndefOr[int],
  _scale: js.UndefOr[double],
  _sigma_scale: js.UndefOr[double],
  _quant: js.UndefOr[double],
  _ang_th: js.UndefOr[double],
  _log_eps: js.UndefOr[double],
  _density_th: js.UndefOr[double],
  _n_bins: js.UndefOr[int]
): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("createLineSegmentDetector")(_refine.asInstanceOf[js.Any], _scale.asInstanceOf[js.Any], _sigma_scale.asInstanceOf[js.Any], _quant.asInstanceOf[js.Any], _ang_th.asInstanceOf[js.Any], _log_eps.asInstanceOf[js.Any], _density_th.asInstanceOf[js.Any], _n_bins.asInstanceOf[js.Any])).asInstanceOf[Any]

inline def cubeRoot(`val`: float): float = ^.asInstanceOf[js.Dynamic].applyDynamic("cubeRoot")(`val`.asInstanceOf[js.Any]).asInstanceOf[float]

inline def cvAbs(arg93: Any, x: Tp): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("cv_abs")(arg93.asInstanceOf[js.Any], x.asInstanceOf[js.Any])).asInstanceOf[Any]
inline def cvAbs(x: ushort): ushort = ^.asInstanceOf[js.Dynamic].applyDynamic("cv_abs")(x.asInstanceOf[js.Any]).asInstanceOf[ushort]

inline def cvAbs_int(x: short): int = ^.asInstanceOf[js.Dynamic].applyDynamic("cv_abs")(x.asInstanceOf[js.Any]).asInstanceOf[int]

inline def cvAbs_schar(x: schar): schar = ^.asInstanceOf[js.Dynamic].applyDynamic("cv_abs")(x.asInstanceOf[js.Any]).asInstanceOf[schar]

inline def cvAbs_uchar(x: uchar): uchar = ^.asInstanceOf[js.Dynamic].applyDynamic("cv_abs")(x.asInstanceOf[js.Any]).asInstanceOf[uchar]

inline def cvCeil(value: double | float | int): int = ^.asInstanceOf[js.Dynamic].applyDynamic("cvCeil")(value.asInstanceOf[js.Any]).asInstanceOf[int]

inline def cvFloor(value: double | float | int): int = ^.asInstanceOf[js.Dynamic].applyDynamic("cvFloor")(value.asInstanceOf[js.Any]).asInstanceOf[int]

inline def cvIsInf(value: double | float): int = ^.asInstanceOf[js.Dynamic].applyDynamic("cvIsInf")(value.asInstanceOf[js.Any]).asInstanceOf[int]

inline def cvIsNaN(value: double | float): int = ^.asInstanceOf[js.Dynamic].applyDynamic("cvIsNaN")(value.asInstanceOf[js.Any]).asInstanceOf[int]

inline def cvRound(value: double | float | int): int = ^.asInstanceOf[js.Dynamic].applyDynamic("cvRound")(value.asInstanceOf[js.Any]).asInstanceOf[int]

inline def cvtColor(src: InputArray, dst: OutputArray, code: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cvtColor")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], code.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def cvtColor(src: InputArray, dst: OutputArray, code: int, dstCn: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cvtColor")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], code.asInstanceOf[js.Any], dstCn.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def cvtColorTwoPlane(src1: InputArray, src2: InputArray, dst: OutputArray, code: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cvtColorTwoPlane")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], code.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def dct(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dct")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dct(src: InputArray, dst: OutputArray, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dct")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def decomposeEssentialMat(E: InputArray, R1: OutputArray, R2: OutputArray, t: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeEssentialMat")(E.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], t.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def decomposeHomographyMat(
  H: InputArray,
  K: InputArray,
  rotations: OutputArrayOfArrays,
  translations: OutputArrayOfArrays,
  normals: OutputArrayOfArrays
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeHomographyMat")(H.asInstanceOf[js.Any], K.asInstanceOf[js.Any], rotations.asInstanceOf[js.Any], translations.asInstanceOf[js.Any], normals.asInstanceOf[js.Any])).asInstanceOf[int]

inline def decomposeProjectionMatrix(projMatrix: InputArray, cameraMatrix: OutputArray, rotMatrix: OutputArray, transVect: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: InputArray,
  cameraMatrix: OutputArray,
  rotMatrix: OutputArray,
  transVect: OutputArray,
  rotMatrixX: Unit,
  rotMatrixY: Unit,
  rotMatrixZ: Unit,
  eulerAngles: OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any], rotMatrixZ.asInstanceOf[js.Any], eulerAngles.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: InputArray,
  cameraMatrix: OutputArray,
  rotMatrix: OutputArray,
  transVect: OutputArray,
  rotMatrixX: Unit,
  rotMatrixY: Unit,
  rotMatrixZ: OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any], rotMatrixZ.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: InputArray,
  cameraMatrix: OutputArray,
  rotMatrix: OutputArray,
  transVect: OutputArray,
  rotMatrixX: Unit,
  rotMatrixY: Unit,
  rotMatrixZ: OutputArray,
  eulerAngles: OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any], rotMatrixZ.asInstanceOf[js.Any], eulerAngles.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: InputArray,
  cameraMatrix: OutputArray,
  rotMatrix: OutputArray,
  transVect: OutputArray,
  rotMatrixX: Unit,
  rotMatrixY: OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: InputArray,
  cameraMatrix: OutputArray,
  rotMatrix: OutputArray,
  transVect: OutputArray,
  rotMatrixX: Unit,
  rotMatrixY: OutputArray,
  rotMatrixZ: Unit,
  eulerAngles: OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any], rotMatrixZ.asInstanceOf[js.Any], eulerAngles.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: InputArray,
  cameraMatrix: OutputArray,
  rotMatrix: OutputArray,
  transVect: OutputArray,
  rotMatrixX: Unit,
  rotMatrixY: OutputArray,
  rotMatrixZ: OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any], rotMatrixZ.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: InputArray,
  cameraMatrix: OutputArray,
  rotMatrix: OutputArray,
  transVect: OutputArray,
  rotMatrixX: Unit,
  rotMatrixY: OutputArray,
  rotMatrixZ: OutputArray,
  eulerAngles: OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any], rotMatrixZ.asInstanceOf[js.Any], eulerAngles.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: InputArray,
  cameraMatrix: OutputArray,
  rotMatrix: OutputArray,
  transVect: OutputArray,
  rotMatrixX: OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: InputArray,
  cameraMatrix: OutputArray,
  rotMatrix: OutputArray,
  transVect: OutputArray,
  rotMatrixX: OutputArray,
  rotMatrixY: Unit,
  rotMatrixZ: Unit,
  eulerAngles: OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any], rotMatrixZ.asInstanceOf[js.Any], eulerAngles.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: InputArray,
  cameraMatrix: OutputArray,
  rotMatrix: OutputArray,
  transVect: OutputArray,
  rotMatrixX: OutputArray,
  rotMatrixY: Unit,
  rotMatrixZ: OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any], rotMatrixZ.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: InputArray,
  cameraMatrix: OutputArray,
  rotMatrix: OutputArray,
  transVect: OutputArray,
  rotMatrixX: OutputArray,
  rotMatrixY: Unit,
  rotMatrixZ: OutputArray,
  eulerAngles: OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any], rotMatrixZ.asInstanceOf[js.Any], eulerAngles.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: InputArray,
  cameraMatrix: OutputArray,
  rotMatrix: OutputArray,
  transVect: OutputArray,
  rotMatrixX: OutputArray,
  rotMatrixY: OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: InputArray,
  cameraMatrix: OutputArray,
  rotMatrix: OutputArray,
  transVect: OutputArray,
  rotMatrixX: OutputArray,
  rotMatrixY: OutputArray,
  rotMatrixZ: Unit,
  eulerAngles: OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any], rotMatrixZ.asInstanceOf[js.Any], eulerAngles.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: InputArray,
  cameraMatrix: OutputArray,
  rotMatrix: OutputArray,
  transVect: OutputArray,
  rotMatrixX: OutputArray,
  rotMatrixY: OutputArray,
  rotMatrixZ: OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any], rotMatrixZ.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: InputArray,
  cameraMatrix: OutputArray,
  rotMatrix: OutputArray,
  transVect: OutputArray,
  rotMatrixX: OutputArray,
  rotMatrixY: OutputArray,
  rotMatrixZ: OutputArray,
  eulerAngles: OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any], rotMatrixZ.asInstanceOf[js.Any], eulerAngles.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def demosaicing(src: InputArray, dst: OutputArray, code: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("demosaicing")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], code.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def demosaicing(src: InputArray, dst: OutputArray, code: int, dstCn: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("demosaicing")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], code.asInstanceOf[js.Any], dstCn.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def determinant(mtx: InputArray): double = ^.asInstanceOf[js.Dynamic].applyDynamic("determinant")(mtx.asInstanceOf[js.Any]).asInstanceOf[double]

inline def dft(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dft")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dft(src: InputArray, dst: OutputArray, flags: Unit, nonzeroRows: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dft")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], nonzeroRows.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dft(src: InputArray, dst: OutputArray, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dft")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dft(src: InputArray, dst: OutputArray, flags: int, nonzeroRows: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dft")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], nonzeroRows.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def dilate(src: InputArray, dst: OutputArray, kernel: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: InputArray,
  dst: OutputArray,
  kernel: InputArray,
  anchor: Unit,
  iterations: Unit,
  borderType: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: InputArray,
  dst: OutputArray,
  kernel: InputArray,
  anchor: Unit,
  iterations: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: InputArray,
  dst: OutputArray,
  kernel: InputArray,
  anchor: Unit,
  iterations: Unit,
  borderType: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(src: InputArray, dst: OutputArray, kernel: InputArray, anchor: Unit, iterations: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: InputArray,
  dst: OutputArray,
  kernel: InputArray,
  anchor: Unit,
  iterations: int,
  borderType: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: InputArray,
  dst: OutputArray,
  kernel: InputArray,
  anchor: Unit,
  iterations: int,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: InputArray,
  dst: OutputArray,
  kernel: InputArray,
  anchor: Unit,
  iterations: int,
  borderType: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(src: InputArray, dst: OutputArray, kernel: InputArray, anchor: Point): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: InputArray,
  dst: OutputArray,
  kernel: InputArray,
  anchor: Point,
  iterations: Unit,
  borderType: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: InputArray,
  dst: OutputArray,
  kernel: InputArray,
  anchor: Point,
  iterations: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: InputArray,
  dst: OutputArray,
  kernel: InputArray,
  anchor: Point,
  iterations: Unit,
  borderType: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(src: InputArray, dst: OutputArray, kernel: InputArray, anchor: Point, iterations: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: InputArray,
  dst: OutputArray,
  kernel: InputArray,
  anchor: Point,
  iterations: int,
  borderType: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: InputArray,
  dst: OutputArray,
  kernel: InputArray,
  anchor: Point,
  iterations: int,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: InputArray,
  dst: OutputArray,
  kernel: InputArray,
  anchor: Point,
  iterations: int,
  borderType: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def distanceTransform(src: InputArray, dst: OutputArray, distanceType: int, maskSize: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("distanceTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], distanceType.asInstanceOf[js.Any], maskSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def distanceTransform(src: InputArray, dst: OutputArray, distanceType: int, maskSize: int, dstType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("distanceTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], distanceType.asInstanceOf[js.Any], maskSize.asInstanceOf[js.Any], dstType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def distanceTransform(src: InputArray, dst: OutputArray, labels: OutputArray, distanceType: int, maskSize: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("distanceTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], labels.asInstanceOf[js.Any], distanceType.asInstanceOf[js.Any], maskSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def distanceTransform(
  src: InputArray,
  dst: OutputArray,
  labels: OutputArray,
  distanceType: int,
  maskSize: int,
  labelType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("distanceTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], labels.asInstanceOf[js.Any], distanceType.asInstanceOf[js.Any], maskSize.asInstanceOf[js.Any], labelType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def divUp(a: int, b: Any): int = (^.asInstanceOf[js.Dynamic].applyDynamic("divUp")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[int]
inline def divUp(a: sizeT, b: Any): sizeT = (^.asInstanceOf[js.Dynamic].applyDynamic("divUp")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[sizeT]

inline def divide(scale: double, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("divide")(scale.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def divide(scale: double, src2: InputArray, dst: OutputArray, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("divide")(scale.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def divide(src1: InputArray, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("divide")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def divide(src1: InputArray, src2: InputArray, dst: OutputArray, scale: Unit, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("divide")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def divide(src1: InputArray, src2: InputArray, dst: OutputArray, scale: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("divide")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def divide(src1: InputArray, src2: InputArray, dst: OutputArray, scale: double, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("divide")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def drawChessboardCorners(image: InputOutputArray, patternSize: Size, corners: InputArray, patternWasFound: bool): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawChessboardCorners")(image.asInstanceOf[js.Any], patternSize.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], patternWasFound.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def drawContours(image: InputOutputArray, contours: InputArrayOfArrays, contourIdx: int, color: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  hierarchy: Unit,
  maxLevel: Unit,
  offset: Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  hierarchy: Unit,
  maxLevel: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  hierarchy: Unit,
  maxLevel: int,
  offset: Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  hierarchy: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  hierarchy: InputArray,
  maxLevel: Unit,
  offset: Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  hierarchy: InputArray,
  maxLevel: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  hierarchy: InputArray,
  maxLevel: int,
  offset: Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: int,
  hierarchy: Unit,
  maxLevel: Unit,
  offset: Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: int,
  hierarchy: Unit,
  maxLevel: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: int,
  hierarchy: Unit,
  maxLevel: int,
  offset: Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: int,
  hierarchy: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: int,
  hierarchy: InputArray,
  maxLevel: Unit,
  offset: Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: int,
  hierarchy: InputArray,
  maxLevel: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: int,
  hierarchy: InputArray,
  maxLevel: int,
  offset: Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(image: InputOutputArray, contours: InputArrayOfArrays, contourIdx: int, color: Any, thickness: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: Unit,
  hierarchy: Unit,
  maxLevel: Unit,
  offset: Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: Unit,
  hierarchy: Unit,
  maxLevel: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: Unit,
  hierarchy: Unit,
  maxLevel: int,
  offset: Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: Unit,
  hierarchy: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: Unit,
  hierarchy: InputArray,
  maxLevel: Unit,
  offset: Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: Unit,
  hierarchy: InputArray,
  maxLevel: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: Unit,
  hierarchy: InputArray,
  maxLevel: int,
  offset: Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: int,
  hierarchy: Unit,
  maxLevel: Unit,
  offset: Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: int,
  hierarchy: Unit,
  maxLevel: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: int,
  hierarchy: Unit,
  maxLevel: int,
  offset: Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: int,
  hierarchy: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: int,
  hierarchy: InputArray,
  maxLevel: Unit,
  offset: Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: int,
  hierarchy: InputArray,
  maxLevel: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: InputOutputArray,
  contours: InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: int,
  hierarchy: InputArray,
  maxLevel: int,
  offset: Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def drawFrameAxes(
  image: InputOutputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvec: InputArray,
  tvec: InputArray,
  length: float
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawFrameAxes")(image.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], length.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawFrameAxes(
  image: InputOutputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvec: InputArray,
  tvec: InputArray,
  length: float,
  thickness: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawFrameAxes")(image.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], length.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def drawKeypoints(image: InputArray, keypoints: Any, outImage: InputOutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawKeypoints")(image.asInstanceOf[js.Any], keypoints.asInstanceOf[js.Any], outImage.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawKeypoints(image: InputArray, keypoints: Any, outImage: InputOutputArray, color: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawKeypoints")(image.asInstanceOf[js.Any], keypoints.asInstanceOf[js.Any], outImage.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawKeypoints(image: InputArray, keypoints: Any, outImage: InputOutputArray, color: Any, flags: DrawMatchesFlags): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawKeypoints")(image.asInstanceOf[js.Any], keypoints.asInstanceOf[js.Any], outImage.asInstanceOf[js.Any], color.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawKeypoints(
  image: InputArray,
  keypoints: Any,
  outImage: InputOutputArray,
  color: Unit,
  flags: DrawMatchesFlags
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawKeypoints")(image.asInstanceOf[js.Any], keypoints.asInstanceOf[js.Any], outImage.asInstanceOf[js.Any], color.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def drawMarker(img: InputOutputArray, position: Point, color: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: InputOutputArray,
  position: Point,
  color: Any,
  markerType: Unit,
  markerSize: Unit,
  thickness: Unit,
  line_type: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: InputOutputArray,
  position: Point,
  color: Any,
  markerType: Unit,
  markerSize: Unit,
  thickness: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: InputOutputArray,
  position: Point,
  color: Any,
  markerType: Unit,
  markerSize: Unit,
  thickness: int,
  line_type: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(img: InputOutputArray, position: Point, color: Any, markerType: Unit, markerSize: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: InputOutputArray,
  position: Point,
  color: Any,
  markerType: Unit,
  markerSize: int,
  thickness: Unit,
  line_type: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: InputOutputArray,
  position: Point,
  color: Any,
  markerType: Unit,
  markerSize: int,
  thickness: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: InputOutputArray,
  position: Point,
  color: Any,
  markerType: Unit,
  markerSize: int,
  thickness: int,
  line_type: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(img: InputOutputArray, position: Point, color: Any, markerType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: InputOutputArray,
  position: Point,
  color: Any,
  markerType: int,
  markerSize: Unit,
  thickness: Unit,
  line_type: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: InputOutputArray,
  position: Point,
  color: Any,
  markerType: int,
  markerSize: Unit,
  thickness: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: InputOutputArray,
  position: Point,
  color: Any,
  markerType: int,
  markerSize: Unit,
  thickness: int,
  line_type: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(img: InputOutputArray, position: Point, color: Any, markerType: int, markerSize: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: InputOutputArray,
  position: Point,
  color: Any,
  markerType: int,
  markerSize: int,
  thickness: Unit,
  line_type: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: InputOutputArray,
  position: Point,
  color: Any,
  markerType: int,
  markerSize: int,
  thickness: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: InputOutputArray,
  position: Point,
  color: Any,
  markerType: int,
  markerSize: int,
  thickness: int,
  line_type: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def drawMatches(
  img1: InputArray,
  keypoints1: Any,
  img2: InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: InputOutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: InputArray,
  keypoints1: Any,
  img2: InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: InputOutputArray,
  matchColor: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: InputArray,
  keypoints1: Any,
  img2: InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: InputOutputArray,
  matchColor: Any,
  singlePointColor: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: InputArray,
  keypoints1: Any,
  img2: InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: InputOutputArray,
  matchColor: Any,
  singlePointColor: Any,
  matchesMask: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any], matchesMask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: InputArray,
  keypoints1: Any,
  img2: InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: InputOutputArray,
  matchColor: Any,
  singlePointColor: Any,
  matchesMask: Any,
  flags: DrawMatchesFlags
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any], matchesMask.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: InputArray,
  keypoints1: Any,
  img2: InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: InputOutputArray,
  matchColor: Any,
  singlePointColor: Any,
  matchesMask: Unit,
  flags: DrawMatchesFlags
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any], matchesMask.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: InputArray,
  keypoints1: Any,
  img2: InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: InputOutputArray,
  matchColor: Any,
  singlePointColor: Unit,
  matchesMask: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any], matchesMask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: InputArray,
  keypoints1: Any,
  img2: InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: InputOutputArray,
  matchColor: Any,
  singlePointColor: Unit,
  matchesMask: Any,
  flags: DrawMatchesFlags
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any], matchesMask.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: InputArray,
  keypoints1: Any,
  img2: InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: InputOutputArray,
  matchColor: Any,
  singlePointColor: Unit,
  matchesMask: Unit,
  flags: DrawMatchesFlags
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any], matchesMask.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: InputArray,
  keypoints1: Any,
  img2: InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: InputOutputArray,
  matchColor: Unit,
  singlePointColor: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: InputArray,
  keypoints1: Any,
  img2: InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: InputOutputArray,
  matchColor: Unit,
  singlePointColor: Any,
  matchesMask: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any], matchesMask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: InputArray,
  keypoints1: Any,
  img2: InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: InputOutputArray,
  matchColor: Unit,
  singlePointColor: Any,
  matchesMask: Any,
  flags: DrawMatchesFlags
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any], matchesMask.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: InputArray,
  keypoints1: Any,
  img2: InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: InputOutputArray,
  matchColor: Unit,
  singlePointColor: Any,
  matchesMask: Unit,
  flags: DrawMatchesFlags
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any], matchesMask.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: InputArray,
  keypoints1: Any,
  img2: InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: InputOutputArray,
  matchColor: Unit,
  singlePointColor: Unit,
  matchesMask: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any], matchesMask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: InputArray,
  keypoints1: Any,
  img2: InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: InputOutputArray,
  matchColor: Unit,
  singlePointColor: Unit,
  matchesMask: Any,
  flags: DrawMatchesFlags
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any], matchesMask.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: InputArray,
  keypoints1: Any,
  img2: InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: InputOutputArray,
  matchColor: Unit,
  singlePointColor: Unit,
  matchesMask: Unit,
  flags: DrawMatchesFlags
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any], matchesMask.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def dumpInputArray(argument: InputArray): String = ^.asInstanceOf[js.Dynamic].applyDynamic("dumpInputArray")(argument.asInstanceOf[js.Any]).asInstanceOf[String]

inline def dumpInputArrayOfArrays(argument: InputArrayOfArrays): String = ^.asInstanceOf[js.Dynamic].applyDynamic("dumpInputArrayOfArrays")(argument.asInstanceOf[js.Any]).asInstanceOf[String]

inline def dumpInputOutputArray(argument: InputOutputArray): String = ^.asInstanceOf[js.Dynamic].applyDynamic("dumpInputOutputArray")(argument.asInstanceOf[js.Any]).asInstanceOf[String]

inline def dumpInputOutputArrayOfArrays(argument: InputOutputArrayOfArrays): String = ^.asInstanceOf[js.Dynamic].applyDynamic("dumpInputOutputArrayOfArrays")(argument.asInstanceOf[js.Any]).asInstanceOf[String]

inline def eigen(src: InputArray, eigenvalues: OutputArray): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("eigen")(src.asInstanceOf[js.Any], eigenvalues.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def eigen(src: InputArray, eigenvalues: OutputArray, eigenvectors: OutputArray): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("eigen")(src.asInstanceOf[js.Any], eigenvalues.asInstanceOf[js.Any], eigenvectors.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def eigenNonSymmetric(src: InputArray, eigenvalues: OutputArray, eigenvectors: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("eigenNonSymmetric")(src.asInstanceOf[js.Any], eigenvalues.asInstanceOf[js.Any], eigenvectors.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def ellipse(img: InputOutputArray, box: Any, color: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse")(img.asInstanceOf[js.Any], box.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def ellipse(img: InputOutputArray, box: Any, color: Any, thickness: Unit, lineType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse")(img.asInstanceOf[js.Any], box.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def ellipse(img: InputOutputArray, box: Any, color: Any, thickness: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse")(img.asInstanceOf[js.Any], box.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def ellipse(img: InputOutputArray, box: Any, color: Any, thickness: int, lineType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse")(img.asInstanceOf[js.Any], box.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def ellipse(
  img: InputOutputArray,
  center: Point,
  axes: Size,
  angle: double,
  startAngle: double,
  endAngle: double,
  color: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], axes.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], startAngle.asInstanceOf[js.Any], endAngle.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def ellipse(
  img: InputOutputArray,
  center: Point,
  axes: Size,
  angle: double,
  startAngle: double,
  endAngle: double,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], axes.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], startAngle.asInstanceOf[js.Any], endAngle.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def ellipse(
  img: InputOutputArray,
  center: Point,
  axes: Size,
  angle: double,
  startAngle: double,
  endAngle: double,
  color: Any,
  thickness: Unit,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], axes.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], startAngle.asInstanceOf[js.Any], endAngle.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def ellipse(
  img: InputOutputArray,
  center: Point,
  axes: Size,
  angle: double,
  startAngle: double,
  endAngle: double,
  color: Any,
  thickness: Unit,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], axes.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], startAngle.asInstanceOf[js.Any], endAngle.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def ellipse(
  img: InputOutputArray,
  center: Point,
  axes: Size,
  angle: double,
  startAngle: double,
  endAngle: double,
  color: Any,
  thickness: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], axes.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], startAngle.asInstanceOf[js.Any], endAngle.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def ellipse(
  img: InputOutputArray,
  center: Point,
  axes: Size,
  angle: double,
  startAngle: double,
  endAngle: double,
  color: Any,
  thickness: int,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], axes.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], startAngle.asInstanceOf[js.Any], endAngle.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def ellipse(
  img: InputOutputArray,
  center: Point,
  axes: Size,
  angle: double,
  startAngle: double,
  endAngle: double,
  color: Any,
  thickness: int,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], axes.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], startAngle.asInstanceOf[js.Any], endAngle.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def ellipse(
  img: InputOutputArray,
  center: Point,
  axes: Size,
  angle: double,
  startAngle: double,
  endAngle: double,
  color: Any,
  thickness: int,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], axes.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], startAngle.asInstanceOf[js.Any], endAngle.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def ellipse1(
  dst: typings.mirada.distSrcTypesOpencvMod.Mat,
  rotatedRect: typings.mirada.distSrcTypesOpencvMod.RotatedRect,
  ellipseColor: typings.mirada.distSrcTypesOpencvHacksMod.Scalar,
  arg0: Double,
  line: LineTypes
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse1")(dst.asInstanceOf[js.Any], rotatedRect.asInstanceOf[js.Any], ellipseColor.asInstanceOf[js.Any], arg0.asInstanceOf[js.Any], line.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def ellipse2Poly(center: Point2d, axes: Size2d, angle: int, arcStart: int, arcEnd: int, delta: int, pts: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse2Poly")(center.asInstanceOf[js.Any], axes.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], arcStart.asInstanceOf[js.Any], arcEnd.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], pts.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def ellipse2Poly(center: Point, axes: Size, angle: int, arcStart: int, arcEnd: int, delta: int, pts: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse2Poly")(center.asInstanceOf[js.Any], axes.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], arcStart.asInstanceOf[js.Any], arcEnd.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], pts.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def equalizeHist(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("equalizeHist")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def erode(src: InputArray, dst: OutputArray, kernel: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: InputArray,
  dst: OutputArray,
  kernel: InputArray,
  anchor: Unit,
  iterations: Unit,
  borderType: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: InputArray,
  dst: OutputArray,
  kernel: InputArray,
  anchor: Unit,
  iterations: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: InputArray,
  dst: OutputArray,
  kernel: InputArray,
  anchor: Unit,
  iterations: Unit,
  borderType: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(src: InputArray, dst: OutputArray, kernel: InputArray, anchor: Unit, iterations: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: InputArray,
  dst: OutputArray,
  kernel: InputArray,
  anchor: Unit,
  iterations: int,
  borderType: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: InputArray,
  dst: OutputArray,
  kernel: InputArray,
  anchor: Unit,
  iterations: int,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: InputArray,
  dst: OutputArray,
  kernel: InputArray,
  anchor: Unit,
  iterations: int,
  borderType: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(src: InputArray, dst: OutputArray, kernel: InputArray, anchor: Point): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: InputArray,
  dst: OutputArray,
  kernel: InputArray,
  anchor: Point,
  iterations: Unit,
  borderType: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: InputArray,
  dst: OutputArray,
  kernel: InputArray,
  anchor: Point,
  iterations: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: InputArray,
  dst: OutputArray,
  kernel: InputArray,
  anchor: Point,
  iterations: Unit,
  borderType: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(src: InputArray, dst: OutputArray, kernel: InputArray, anchor: Point, iterations: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: InputArray,
  dst: OutputArray,
  kernel: InputArray,
  anchor: Point,
  iterations: int,
  borderType: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: InputArray,
  dst: OutputArray,
  kernel: InputArray,
  anchor: Point,
  iterations: int,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: InputArray,
  dst: OutputArray,
  kernel: InputArray,
  anchor: Point,
  iterations: int,
  borderType: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def error(_code: int, _err: Any, _func: Any, _file: Any, _line: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("error")(_code.asInstanceOf[js.Any], _err.asInstanceOf[js.Any], _func.asInstanceOf[js.Any], _file.asInstanceOf[js.Any], _line.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def error(exc: Any): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("error")(exc.asInstanceOf[js.Any]).asInstanceOf[Unit]

inline def estimateAffine2D(
  from: InputArray,
  to: InputArray,
  inliers: js.UndefOr[OutputArray],
  method: js.UndefOr[int],
  ransacReprojThreshold: js.UndefOr[double],
  maxIters: js.UndefOr[sizeT],
  confidence: js.UndefOr[double],
  refineIters: js.UndefOr[sizeT]
): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("estimateAffine2D")(from.asInstanceOf[js.Any], to.asInstanceOf[js.Any], inliers.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any], refineIters.asInstanceOf[js.Any])).asInstanceOf[Any]

inline def estimateAffine3D(src: InputArray, dst: InputArray, out: OutputArray, inliers: OutputArray): int = (^.asInstanceOf[js.Dynamic].applyDynamic("estimateAffine3D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], out.asInstanceOf[js.Any], inliers.asInstanceOf[js.Any])).asInstanceOf[int]
inline def estimateAffine3D(
  src: InputArray,
  dst: InputArray,
  out: OutputArray,
  inliers: OutputArray,
  ransacThreshold: Unit,
  confidence: double
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("estimateAffine3D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], out.asInstanceOf[js.Any], inliers.asInstanceOf[js.Any], ransacThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[int]
inline def estimateAffine3D(src: InputArray, dst: InputArray, out: OutputArray, inliers: OutputArray, ransacThreshold: double): int = (^.asInstanceOf[js.Dynamic].applyDynamic("estimateAffine3D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], out.asInstanceOf[js.Any], inliers.asInstanceOf[js.Any], ransacThreshold.asInstanceOf[js.Any])).asInstanceOf[int]
inline def estimateAffine3D(
  src: InputArray,
  dst: InputArray,
  out: OutputArray,
  inliers: OutputArray,
  ransacThreshold: double,
  confidence: double
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("estimateAffine3D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], out.asInstanceOf[js.Any], inliers.asInstanceOf[js.Any], ransacThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[int]

inline def estimateAffinePartial2D(
  from: InputArray,
  to: InputArray,
  inliers: js.UndefOr[OutputArray],
  method: js.UndefOr[int],
  ransacReprojThreshold: js.UndefOr[double],
  maxIters: js.UndefOr[sizeT],
  confidence: js.UndefOr[double],
  refineIters: js.UndefOr[sizeT]
): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("estimateAffinePartial2D")(from.asInstanceOf[js.Any], to.asInstanceOf[js.Any], inliers.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any], refineIters.asInstanceOf[js.Any])).asInstanceOf[Any]

inline def estimateRigidTransform(src: InputArray, dst: InputArray, fullAffine: bool): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("estimateRigidTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], fullAffine.asInstanceOf[js.Any])).asInstanceOf[Mat]

inline def exceptionFromPtr(err: Double): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("exceptionFromPtr")(err.asInstanceOf[js.Any]).asInstanceOf[Any]

inline def exp(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("exp")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def extractChannel(src: InputArray, dst: OutputArray, coi: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("extractChannel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], coi.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def fastAtan2(y: float, x: float): float = (^.asInstanceOf[js.Dynamic].applyDynamic("fastAtan2")(y.asInstanceOf[js.Any], x.asInstanceOf[js.Any])).asInstanceOf[float]

inline def fastFree(ptr: Any): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("fastFree")(ptr.asInstanceOf[js.Any]).asInstanceOf[Unit]

inline def fastMalloc(bufSize: sizeT): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("fastMalloc")(bufSize.asInstanceOf[js.Any]).asInstanceOf[Any]

inline def fillConvexPoly(img: InputOutputArray, points: InputArray, color: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillConvexPoly")(img.asInstanceOf[js.Any], points.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillConvexPoly(img: InputOutputArray, points: InputArray, color: Any, lineType: Unit, shift: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillConvexPoly")(img.asInstanceOf[js.Any], points.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillConvexPoly(img: InputOutputArray, points: InputArray, color: Any, lineType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillConvexPoly")(img.asInstanceOf[js.Any], points.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillConvexPoly(img: InputOutputArray, points: InputArray, color: Any, lineType: int, shift: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillConvexPoly")(img.asInstanceOf[js.Any], points.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillConvexPoly(img: InputOutputArray, pts: Any, npts: int, color: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillConvexPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillConvexPoly(img: InputOutputArray, pts: Any, npts: int, color: Any, lineType: Unit, shift: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillConvexPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillConvexPoly(img: InputOutputArray, pts: Any, npts: int, color: Any, lineType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillConvexPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillConvexPoly(img: InputOutputArray, pts: Any, npts: int, color: Any, lineType: int, shift: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillConvexPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def fillPoly(img: InputOutputArray, pts: Any, npts: Any, ncontours: int, color: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(
  img: InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  color: Any,
  lineType: Unit,
  shift: Unit,
  offset: Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(img: InputOutputArray, pts: Any, npts: Any, ncontours: int, color: Any, lineType: Unit, shift: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(
  img: InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  color: Any,
  lineType: Unit,
  shift: int,
  offset: Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(img: InputOutputArray, pts: Any, npts: Any, ncontours: int, color: Any, lineType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(
  img: InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  color: Any,
  lineType: int,
  shift: Unit,
  offset: Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(img: InputOutputArray, pts: Any, npts: Any, ncontours: int, color: Any, lineType: int, shift: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(
  img: InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  color: Any,
  lineType: int,
  shift: int,
  offset: Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(img: InputOutputArray, pts: InputArrayOfArrays, color: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(
  img: InputOutputArray,
  pts: InputArrayOfArrays,
  color: Any,
  lineType: Unit,
  shift: Unit,
  offset: Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(img: InputOutputArray, pts: InputArrayOfArrays, color: Any, lineType: Unit, shift: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(
  img: InputOutputArray,
  pts: InputArrayOfArrays,
  color: Any,
  lineType: Unit,
  shift: int,
  offset: Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(img: InputOutputArray, pts: InputArrayOfArrays, color: Any, lineType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(
  img: InputOutputArray,
  pts: InputArrayOfArrays,
  color: Any,
  lineType: int,
  shift: Unit,
  offset: Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(img: InputOutputArray, pts: InputArrayOfArrays, color: Any, lineType: int, shift: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(
  img: InputOutputArray,
  pts: InputArrayOfArrays,
  color: Any,
  lineType: int,
  shift: int,
  offset: Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def filter2D(src: InputArray, dst: OutputArray, ddepth: int, kernel: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("filter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def filter2D(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  kernel: InputArray,
  anchor: Unit,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("filter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def filter2D(src: InputArray, dst: OutputArray, ddepth: int, kernel: InputArray, anchor: Unit, delta: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("filter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def filter2D(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  kernel: InputArray,
  anchor: Unit,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("filter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def filter2D(src: InputArray, dst: OutputArray, ddepth: int, kernel: InputArray, anchor: Point): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("filter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def filter2D(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  kernel: InputArray,
  anchor: Point,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("filter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def filter2D(src: InputArray, dst: OutputArray, ddepth: int, kernel: InputArray, anchor: Point, delta: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("filter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def filter2D(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  kernel: InputArray,
  anchor: Point,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("filter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def filterHomographyDecompByVisibleRefpoints(
  rotations: InputArrayOfArrays,
  normals: InputArrayOfArrays,
  beforePoints: InputArray,
  afterPoints: InputArray,
  possibleSolutions: OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("filterHomographyDecompByVisibleRefpoints")(rotations.asInstanceOf[js.Any], normals.asInstanceOf[js.Any], beforePoints.asInstanceOf[js.Any], afterPoints.asInstanceOf[js.Any], possibleSolutions.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def filterHomographyDecompByVisibleRefpoints(
  rotations: InputArrayOfArrays,
  normals: InputArrayOfArrays,
  beforePoints: InputArray,
  afterPoints: InputArray,
  possibleSolutions: OutputArray,
  pointsMask: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("filterHomographyDecompByVisibleRefpoints")(rotations.asInstanceOf[js.Any], normals.asInstanceOf[js.Any], beforePoints.asInstanceOf[js.Any], afterPoints.asInstanceOf[js.Any], possibleSolutions.asInstanceOf[js.Any], pointsMask.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def filterSpeckles(img: InputOutputArray, newVal: double, maxSpeckleSize: int, maxDiff: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("filterSpeckles")(img.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], maxSpeckleSize.asInstanceOf[js.Any], maxDiff.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def filterSpeckles(img: InputOutputArray, newVal: double, maxSpeckleSize: int, maxDiff: double, buf: InputOutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("filterSpeckles")(img.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], maxSpeckleSize.asInstanceOf[js.Any], maxDiff.asInstanceOf[js.Any], buf.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def find4QuadCornerSubpix(img: InputArray, corners: InputOutputArray, region_size: Size): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("find4QuadCornerSubpix")(img.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], region_size.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def findChessboardCorners(image: InputArray, patternSize: Size, corners: OutputArray): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("findChessboardCorners")(image.asInstanceOf[js.Any], patternSize.asInstanceOf[js.Any], corners.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def findChessboardCorners(image: InputArray, patternSize: Size, corners: OutputArray, flags: int): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("findChessboardCorners")(image.asInstanceOf[js.Any], patternSize.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def findChessboardCornersSB(image: InputArray, patternSize: Size, corners: OutputArray): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("findChessboardCornersSB")(image.asInstanceOf[js.Any], patternSize.asInstanceOf[js.Any], corners.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def findChessboardCornersSB(image: InputArray, patternSize: Size, corners: OutputArray, flags: int): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("findChessboardCornersSB")(image.asInstanceOf[js.Any], patternSize.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def findCirclesGrid(image: InputArray, patternSize: Size, centers: OutputArray): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("findCirclesGrid")(image.asInstanceOf[js.Any], patternSize.asInstanceOf[js.Any], centers.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def findCirclesGrid(image: InputArray, patternSize: Size, centers: OutputArray, flags: Unit, blobDetector: Any): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("findCirclesGrid")(image.asInstanceOf[js.Any], patternSize.asInstanceOf[js.Any], centers.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], blobDetector.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def findCirclesGrid(image: InputArray, patternSize: Size, centers: OutputArray, flags: int): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("findCirclesGrid")(image.asInstanceOf[js.Any], patternSize.asInstanceOf[js.Any], centers.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def findCirclesGrid(image: InputArray, patternSize: Size, centers: OutputArray, flags: int, blobDetector: Any): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("findCirclesGrid")(image.asInstanceOf[js.Any], patternSize.asInstanceOf[js.Any], centers.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], blobDetector.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def findCirclesGrid(
  image: InputArray,
  patternSize: Size,
  centers: OutputArray,
  flags: int,
  blobDetector: Any,
  parameters: Any
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("findCirclesGrid")(image.asInstanceOf[js.Any], patternSize.asInstanceOf[js.Any], centers.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], blobDetector.asInstanceOf[js.Any], parameters.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def findContours(image: InputArray, contours: OutputArrayOfArrays, hierarchy: OutputArray, mode: int, method: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("findContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], mode.asInstanceOf[js.Any], method.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def findContours(
  image: InputArray,
  contours: OutputArrayOfArrays,
  hierarchy: OutputArray,
  mode: int,
  method: int,
  offset: Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("findContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], mode.asInstanceOf[js.Any], method.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def findContours(image: InputArray, contours: OutputArrayOfArrays, mode: int, method: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("findContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], mode.asInstanceOf[js.Any], method.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def findContours(image: InputArray, contours: OutputArrayOfArrays, mode: int, method: int, offset: Point): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("findContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], mode.asInstanceOf[js.Any], method.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def findEssentialMat(points1: InputArray, points2: InputArray, cameraMatrix: InputArray): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findEssentialMat(
  points1: InputArray,
  points2: InputArray,
  cameraMatrix: InputArray,
  method: Unit,
  prob: Unit,
  threshold: Unit,
  mask: OutputArray
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findEssentialMat(
  points1: InputArray,
  points2: InputArray,
  cameraMatrix: InputArray,
  method: Unit,
  prob: Unit,
  threshold: double
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findEssentialMat(
  points1: InputArray,
  points2: InputArray,
  cameraMatrix: InputArray,
  method: Unit,
  prob: Unit,
  threshold: double,
  mask: OutputArray
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findEssentialMat(points1: InputArray, points2: InputArray, cameraMatrix: InputArray, method: Unit, prob: double): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findEssentialMat(
  points1: InputArray,
  points2: InputArray,
  cameraMatrix: InputArray,
  method: Unit,
  prob: double,
  threshold: Unit,
  mask: OutputArray
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findEssentialMat(
  points1: InputArray,
  points2: InputArray,
  cameraMatrix: InputArray,
  method: Unit,
  prob: double,
  threshold: double
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findEssentialMat(
  points1: InputArray,
  points2: InputArray,
  cameraMatrix: InputArray,
  method: Unit,
  prob: double,
  threshold: double,
  mask: OutputArray
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findEssentialMat(points1: InputArray, points2: InputArray, cameraMatrix: InputArray, method: int): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findEssentialMat(
  points1: InputArray,
  points2: InputArray,
  cameraMatrix: InputArray,
  method: int,
  prob: Unit,
  threshold: Unit,
  mask: OutputArray
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findEssentialMat(
  points1: InputArray,
  points2: InputArray,
  cameraMatrix: InputArray,
  method: int,
  prob: Unit,
  threshold: double
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findEssentialMat(
  points1: InputArray,
  points2: InputArray,
  cameraMatrix: InputArray,
  method: int,
  prob: Unit,
  threshold: double,
  mask: OutputArray
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findEssentialMat(points1: InputArray, points2: InputArray, cameraMatrix: InputArray, method: int, prob: double): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findEssentialMat(
  points1: InputArray,
  points2: InputArray,
  cameraMatrix: InputArray,
  method: int,
  prob: double,
  threshold: Unit,
  mask: OutputArray
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findEssentialMat(
  points1: InputArray,
  points2: InputArray,
  cameraMatrix: InputArray,
  method: int,
  prob: double,
  threshold: double
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findEssentialMat(
  points1: InputArray,
  points2: InputArray,
  cameraMatrix: InputArray,
  method: int,
  prob: double,
  threshold: double,
  mask: OutputArray
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findEssentialMat(
  points1: InputArray,
  points2: InputArray,
  focal: js.UndefOr[double],
  pp: js.UndefOr[Point2d],
  method: js.UndefOr[int],
  prob: js.UndefOr[double],
  threshold: js.UndefOr[double],
  mask: js.UndefOr[OutputArray]
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], focal.asInstanceOf[js.Any], pp.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Mat]

inline def findFundamentalMat(points1: InputArray, points2: InputArray): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findFundamentalMat(points1: InputArray, points2: InputArray, mask: OutputArray): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findFundamentalMat(
  points1: InputArray,
  points2: InputArray,
  mask: OutputArray,
  method: Unit,
  ransacReprojThreshold: Unit,
  confidence: double
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findFundamentalMat(
  points1: InputArray,
  points2: InputArray,
  mask: OutputArray,
  method: Unit,
  ransacReprojThreshold: double
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findFundamentalMat(
  points1: InputArray,
  points2: InputArray,
  mask: OutputArray,
  method: Unit,
  ransacReprojThreshold: double,
  confidence: double
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findFundamentalMat(points1: InputArray, points2: InputArray, mask: OutputArray, method: int): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], method.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findFundamentalMat(
  points1: InputArray,
  points2: InputArray,
  mask: OutputArray,
  method: int,
  ransacReprojThreshold: Unit,
  confidence: double
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findFundamentalMat(
  points1: InputArray,
  points2: InputArray,
  mask: OutputArray,
  method: int,
  ransacReprojThreshold: double
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findFundamentalMat(
  points1: InputArray,
  points2: InputArray,
  mask: OutputArray,
  method: int,
  ransacReprojThreshold: double,
  confidence: double
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findFundamentalMat(
  points1: InputArray,
  points2: InputArray,
  method: Unit,
  ransacReprojThreshold: Unit,
  confidence: Unit,
  mask: OutputArray
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findFundamentalMat(
  points1: InputArray,
  points2: InputArray,
  method: Unit,
  ransacReprojThreshold: Unit,
  confidence: double
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findFundamentalMat(
  points1: InputArray,
  points2: InputArray,
  method: Unit,
  ransacReprojThreshold: Unit,
  confidence: double,
  mask: OutputArray
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findFundamentalMat(points1: InputArray, points2: InputArray, method: Unit, ransacReprojThreshold: double): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findFundamentalMat(
  points1: InputArray,
  points2: InputArray,
  method: Unit,
  ransacReprojThreshold: double,
  confidence: Unit,
  mask: OutputArray
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findFundamentalMat(
  points1: InputArray,
  points2: InputArray,
  method: Unit,
  ransacReprojThreshold: double,
  confidence: double
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findFundamentalMat(
  points1: InputArray,
  points2: InputArray,
  method: Unit,
  ransacReprojThreshold: double,
  confidence: double,
  mask: OutputArray
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findFundamentalMat(points1: InputArray, points2: InputArray, method: int): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findFundamentalMat(
  points1: InputArray,
  points2: InputArray,
  method: int,
  ransacReprojThreshold: Unit,
  confidence: Unit,
  mask: OutputArray
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findFundamentalMat(
  points1: InputArray,
  points2: InputArray,
  method: int,
  ransacReprojThreshold: Unit,
  confidence: double
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findFundamentalMat(
  points1: InputArray,
  points2: InputArray,
  method: int,
  ransacReprojThreshold: Unit,
  confidence: double,
  mask: OutputArray
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findFundamentalMat(points1: InputArray, points2: InputArray, method: int, ransacReprojThreshold: double): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findFundamentalMat(
  points1: InputArray,
  points2: InputArray,
  method: int,
  ransacReprojThreshold: double,
  confidence: Unit,
  mask: OutputArray
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findFundamentalMat(
  points1: InputArray,
  points2: InputArray,
  method: int,
  ransacReprojThreshold: double,
  confidence: double
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findFundamentalMat(
  points1: InputArray,
  points2: InputArray,
  method: int,
  ransacReprojThreshold: double,
  confidence: double,
  mask: OutputArray
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Mat]

inline def findHomography(srcPoints: InputArray, dstPoints: InputArray): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(srcPoints: InputArray, dstPoints: InputArray, mask: OutputArray): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  mask: OutputArray,
  method: Unit,
  ransacReprojThreshold: double
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(srcPoints: InputArray, dstPoints: InputArray, mask: OutputArray, method: int): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], method.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  mask: OutputArray,
  method: int,
  ransacReprojThreshold: double
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: Unit,
  ransacReprojThreshold: Unit,
  mask: Unit,
  maxIters: Any
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: Unit,
  ransacReprojThreshold: Unit,
  mask: Unit,
  maxIters: Any,
  confidence: Any
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: Unit,
  ransacReprojThreshold: Unit,
  mask: Unit,
  maxIters: Unit,
  confidence: Any
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: Unit,
  ransacReprojThreshold: Unit,
  mask: OutputArray
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: Unit,
  ransacReprojThreshold: Unit,
  mask: OutputArray,
  maxIters: Any
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: Unit,
  ransacReprojThreshold: Unit,
  mask: OutputArray,
  maxIters: Any,
  confidence: Any
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: Unit,
  ransacReprojThreshold: Unit,
  mask: OutputArray,
  maxIters: Unit,
  confidence: Any
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(srcPoints: InputArray, dstPoints: InputArray, method: Unit, ransacReprojThreshold: double): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: Unit,
  ransacReprojThreshold: double,
  mask: Unit,
  maxIters: Any
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: Unit,
  ransacReprojThreshold: double,
  mask: Unit,
  maxIters: Any,
  confidence: Any
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: Unit,
  ransacReprojThreshold: double,
  mask: Unit,
  maxIters: Unit,
  confidence: Any
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: Unit,
  ransacReprojThreshold: double,
  mask: OutputArray
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: Unit,
  ransacReprojThreshold: double,
  mask: OutputArray,
  maxIters: Any
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: Unit,
  ransacReprojThreshold: double,
  mask: OutputArray,
  maxIters: Any,
  confidence: Any
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: Unit,
  ransacReprojThreshold: double,
  mask: OutputArray,
  maxIters: Unit,
  confidence: Any
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(srcPoints: InputArray, dstPoints: InputArray, method: int): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: int,
  ransacReprojThreshold: Unit,
  mask: Unit,
  maxIters: Any
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: int,
  ransacReprojThreshold: Unit,
  mask: Unit,
  maxIters: Any,
  confidence: Any
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: int,
  ransacReprojThreshold: Unit,
  mask: Unit,
  maxIters: Unit,
  confidence: Any
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: int,
  ransacReprojThreshold: Unit,
  mask: OutputArray
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: int,
  ransacReprojThreshold: Unit,
  mask: OutputArray,
  maxIters: Any
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: int,
  ransacReprojThreshold: Unit,
  mask: OutputArray,
  maxIters: Any,
  confidence: Any
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: int,
  ransacReprojThreshold: Unit,
  mask: OutputArray,
  maxIters: Unit,
  confidence: Any
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(srcPoints: InputArray, dstPoints: InputArray, method: int, ransacReprojThreshold: double): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: int,
  ransacReprojThreshold: double,
  mask: Unit,
  maxIters: Any
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: int,
  ransacReprojThreshold: double,
  mask: Unit,
  maxIters: Any,
  confidence: Any
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: int,
  ransacReprojThreshold: double,
  mask: Unit,
  maxIters: Unit,
  confidence: Any
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: int,
  ransacReprojThreshold: double,
  mask: OutputArray
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: int,
  ransacReprojThreshold: double,
  mask: OutputArray,
  maxIters: Any
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: int,
  ransacReprojThreshold: double,
  mask: OutputArray,
  maxIters: Any,
  confidence: Any
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def findHomography(
  srcPoints: InputArray,
  dstPoints: InputArray,
  method: int,
  ransacReprojThreshold: double,
  mask: OutputArray,
  maxIters: Unit,
  confidence: Any
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[Mat]

inline def findNonZero(src: InputArray, idx: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("findNonZero")(src.asInstanceOf[js.Any], idx.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def findTransformECC(templateImage: InputArray, inputImage: InputArray, warpMatrix: InputOutputArray): double = (^.asInstanceOf[js.Dynamic].applyDynamic("findTransformECC")(templateImage.asInstanceOf[js.Any], inputImage.asInstanceOf[js.Any], warpMatrix.asInstanceOf[js.Any])).asInstanceOf[double]
inline def findTransformECC(
  templateImage: InputArray,
  inputImage: InputArray,
  warpMatrix: InputOutputArray,
  motionType: Unit,
  criteria: Unit,
  inputMask: InputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("findTransformECC")(templateImage.asInstanceOf[js.Any], inputImage.asInstanceOf[js.Any], warpMatrix.asInstanceOf[js.Any], motionType.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], inputMask.asInstanceOf[js.Any])).asInstanceOf[double]
inline def findTransformECC(
  templateImage: InputArray,
  inputImage: InputArray,
  warpMatrix: InputOutputArray,
  motionType: Unit,
  criteria: TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("findTransformECC")(templateImage.asInstanceOf[js.Any], inputImage.asInstanceOf[js.Any], warpMatrix.asInstanceOf[js.Any], motionType.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]
inline def findTransformECC(
  templateImage: InputArray,
  inputImage: InputArray,
  warpMatrix: InputOutputArray,
  motionType: Unit,
  criteria: TermCriteria,
  inputMask: InputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("findTransformECC")(templateImage.asInstanceOf[js.Any], inputImage.asInstanceOf[js.Any], warpMatrix.asInstanceOf[js.Any], motionType.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], inputMask.asInstanceOf[js.Any])).asInstanceOf[double]
inline def findTransformECC(templateImage: InputArray, inputImage: InputArray, warpMatrix: InputOutputArray, motionType: int): double = (^.asInstanceOf[js.Dynamic].applyDynamic("findTransformECC")(templateImage.asInstanceOf[js.Any], inputImage.asInstanceOf[js.Any], warpMatrix.asInstanceOf[js.Any], motionType.asInstanceOf[js.Any])).asInstanceOf[double]
inline def findTransformECC(
  templateImage: InputArray,
  inputImage: InputArray,
  warpMatrix: InputOutputArray,
  motionType: int,
  criteria: Unit,
  inputMask: InputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("findTransformECC")(templateImage.asInstanceOf[js.Any], inputImage.asInstanceOf[js.Any], warpMatrix.asInstanceOf[js.Any], motionType.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], inputMask.asInstanceOf[js.Any])).asInstanceOf[double]
inline def findTransformECC(
  templateImage: InputArray,
  inputImage: InputArray,
  warpMatrix: InputOutputArray,
  motionType: int,
  criteria: TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("findTransformECC")(templateImage.asInstanceOf[js.Any], inputImage.asInstanceOf[js.Any], warpMatrix.asInstanceOf[js.Any], motionType.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]
inline def findTransformECC(
  templateImage: InputArray,
  inputImage: InputArray,
  warpMatrix: InputOutputArray,
  motionType: int,
  criteria: TermCriteria,
  inputMask: InputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("findTransformECC")(templateImage.asInstanceOf[js.Any], inputImage.asInstanceOf[js.Any], warpMatrix.asInstanceOf[js.Any], motionType.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], inputMask.asInstanceOf[js.Any])).asInstanceOf[double]
inline def findTransformECC(
  templateImage: InputArray,
  inputImage: InputArray,
  warpMatrix: InputOutputArray,
  motionType: int,
  criteria: TermCriteria,
  inputMask: InputArray,
  gaussFiltSize: int
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("findTransformECC")(templateImage.asInstanceOf[js.Any], inputImage.asInstanceOf[js.Any], warpMatrix.asInstanceOf[js.Any], motionType.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], inputMask.asInstanceOf[js.Any], gaussFiltSize.asInstanceOf[js.Any])).asInstanceOf[double]

inline def fitEllipse(points: InputArray): RotatedRect = ^.asInstanceOf[js.Dynamic].applyDynamic("fitEllipse")(points.asInstanceOf[js.Any]).asInstanceOf[RotatedRect]

inline def fitEllipseAMS(points: InputArray): RotatedRect = ^.asInstanceOf[js.Dynamic].applyDynamic("fitEllipseAMS")(points.asInstanceOf[js.Any]).asInstanceOf[RotatedRect]

inline def fitEllipseDirect(points: InputArray): RotatedRect = ^.asInstanceOf[js.Dynamic].applyDynamic("fitEllipseDirect")(points.asInstanceOf[js.Any]).asInstanceOf[RotatedRect]

inline def fitLine(points: InputArray, line: OutputArray, distType: int, param: double, reps: double, aeps: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fitLine")(points.asInstanceOf[js.Any], line.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], param.asInstanceOf[js.Any], reps.asInstanceOf[js.Any], aeps.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def flip(src: InputArray, dst: OutputArray, flipCode: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("flip")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flipCode.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def floodFill(image: InputOutputArray, mask: InputOutputArray, seedPoint: Point, newVal: Scalar): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(image: InputOutputArray, mask: InputOutputArray, seedPoint: Point, newVal: Scalar, rect: Any): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: InputOutputArray,
  mask: InputOutputArray,
  seedPoint: Point,
  newVal: Scalar,
  rect: Any,
  loDiff: Unit,
  upDiff: Unit,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: InputOutputArray,
  mask: InputOutputArray,
  seedPoint: Point,
  newVal: Scalar,
  rect: Any,
  loDiff: Unit,
  upDiff: Scalar
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: InputOutputArray,
  mask: InputOutputArray,
  seedPoint: Point,
  newVal: Scalar,
  rect: Any,
  loDiff: Unit,
  upDiff: Scalar,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: InputOutputArray,
  mask: InputOutputArray,
  seedPoint: Point,
  newVal: Scalar,
  rect: Any,
  loDiff: Scalar
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: InputOutputArray,
  mask: InputOutputArray,
  seedPoint: Point,
  newVal: Scalar,
  rect: Any,
  loDiff: Scalar,
  upDiff: Unit,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: InputOutputArray,
  mask: InputOutputArray,
  seedPoint: Point,
  newVal: Scalar,
  rect: Any,
  loDiff: Scalar,
  upDiff: Scalar
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: InputOutputArray,
  mask: InputOutputArray,
  seedPoint: Point,
  newVal: Scalar,
  rect: Any,
  loDiff: Scalar,
  upDiff: Scalar,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: InputOutputArray,
  mask: InputOutputArray,
  seedPoint: Point,
  newVal: Scalar,
  rect: Unit,
  loDiff: Unit,
  upDiff: Unit,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: InputOutputArray,
  mask: InputOutputArray,
  seedPoint: Point,
  newVal: Scalar,
  rect: Unit,
  loDiff: Unit,
  upDiff: Scalar
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: InputOutputArray,
  mask: InputOutputArray,
  seedPoint: Point,
  newVal: Scalar,
  rect: Unit,
  loDiff: Unit,
  upDiff: Scalar,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: InputOutputArray,
  mask: InputOutputArray,
  seedPoint: Point,
  newVal: Scalar,
  rect: Unit,
  loDiff: Scalar
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: InputOutputArray,
  mask: InputOutputArray,
  seedPoint: Point,
  newVal: Scalar,
  rect: Unit,
  loDiff: Scalar,
  upDiff: Unit,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: InputOutputArray,
  mask: InputOutputArray,
  seedPoint: Point,
  newVal: Scalar,
  rect: Unit,
  loDiff: Scalar,
  upDiff: Scalar
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: InputOutputArray,
  mask: InputOutputArray,
  seedPoint: Point,
  newVal: Scalar,
  rect: Unit,
  loDiff: Scalar,
  upDiff: Scalar,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(image: InputOutputArray, seedPoint: Point, newVal: Scalar): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(image: InputOutputArray, seedPoint: Point, newVal: Scalar, rect: Any): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: InputOutputArray,
  seedPoint: Point,
  newVal: Scalar,
  rect: Any,
  loDiff: Unit,
  upDiff: Unit,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(image: InputOutputArray, seedPoint: Point, newVal: Scalar, rect: Any, loDiff: Unit, upDiff: Scalar): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: InputOutputArray,
  seedPoint: Point,
  newVal: Scalar,
  rect: Any,
  loDiff: Unit,
  upDiff: Scalar,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(image: InputOutputArray, seedPoint: Point, newVal: Scalar, rect: Any, loDiff: Scalar): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: InputOutputArray,
  seedPoint: Point,
  newVal: Scalar,
  rect: Any,
  loDiff: Scalar,
  upDiff: Unit,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: InputOutputArray,
  seedPoint: Point,
  newVal: Scalar,
  rect: Any,
  loDiff: Scalar,
  upDiff: Scalar
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: InputOutputArray,
  seedPoint: Point,
  newVal: Scalar,
  rect: Any,
  loDiff: Scalar,
  upDiff: Scalar,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: InputOutputArray,
  seedPoint: Point,
  newVal: Scalar,
  rect: Unit,
  loDiff: Unit,
  upDiff: Unit,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: InputOutputArray,
  seedPoint: Point,
  newVal: Scalar,
  rect: Unit,
  loDiff: Unit,
  upDiff: Scalar
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: InputOutputArray,
  seedPoint: Point,
  newVal: Scalar,
  rect: Unit,
  loDiff: Unit,
  upDiff: Scalar,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(image: InputOutputArray, seedPoint: Point, newVal: Scalar, rect: Unit, loDiff: Scalar): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: InputOutputArray,
  seedPoint: Point,
  newVal: Scalar,
  rect: Unit,
  loDiff: Scalar,
  upDiff: Unit,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: InputOutputArray,
  seedPoint: Point,
  newVal: Scalar,
  rect: Unit,
  loDiff: Scalar,
  upDiff: Scalar
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: InputOutputArray,
  seedPoint: Point,
  newVal: Scalar,
  rect: Unit,
  loDiff: Scalar,
  upDiff: Scalar,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]

inline def flushPendingDeletes(a: Any*): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("flushPendingDeletes")(a.asInstanceOf[Seq[js.Any]]*).asInstanceOf[Any]

inline def forEachImpl(arg94: Any, arg95: Any, operation: Any): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("forEach_impl")(arg94.asInstanceOf[js.Any], arg95.asInstanceOf[js.Any], operation.asInstanceOf[js.Any])).asInstanceOf[Any]

inline def gemm(
  src1: InputArray,
  src2: InputArray,
  alpha: double,
  src3: InputArray,
  beta: double,
  dst: OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("gemm")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], src3.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def gemm(
  src1: InputArray,
  src2: InputArray,
  alpha: double,
  src3: InputArray,
  beta: double,
  dst: OutputArray,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("gemm")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], src3.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def getAffineTransform(src: Any, dst: Any): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getAffineTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def getAffineTransform(src: InputArray, dst: InputArray): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getAffineTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Mat]

inline def getAvailableBackends(): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("getAvailableBackends")().asInstanceOf[Any]

inline def getAvailableTargets(be: Backend): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("getAvailableTargets")(be.asInstanceOf[js.Any]).asInstanceOf[Any]

inline def getBuildInformation(): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("getBuildInformation")().asInstanceOf[Any]

inline def getCPUFeaturesLine(): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("getCPUFeaturesLine")().asInstanceOf[Any]

inline def getCPUTickCount(): int64 = ^.asInstanceOf[js.Dynamic].applyDynamic("getCPUTickCount")().asInstanceOf[int64]

inline def getDefaultNewCameraMatrix(cameraMatrix: InputArray): Mat = ^.asInstanceOf[js.Dynamic].applyDynamic("getDefaultNewCameraMatrix")(cameraMatrix.asInstanceOf[js.Any]).asInstanceOf[Mat]
inline def getDefaultNewCameraMatrix(cameraMatrix: InputArray, imgsize: Unit, centerPrincipalPoint: bool): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getDefaultNewCameraMatrix")(cameraMatrix.asInstanceOf[js.Any], imgsize.asInstanceOf[js.Any], centerPrincipalPoint.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def getDefaultNewCameraMatrix(cameraMatrix: InputArray, imgsize: Size): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getDefaultNewCameraMatrix")(cameraMatrix.asInstanceOf[js.Any], imgsize.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def getDefaultNewCameraMatrix(cameraMatrix: InputArray, imgsize: Size, centerPrincipalPoint: bool): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getDefaultNewCameraMatrix")(cameraMatrix.asInstanceOf[js.Any], imgsize.asInstanceOf[js.Any], centerPrincipalPoint.asInstanceOf[js.Any])).asInstanceOf[Mat]

inline def getDerivKernels(kx: OutputArray, ky: OutputArray, dx: int, dy: int, ksize: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("getDerivKernels")(kx.asInstanceOf[js.Any], ky.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def getDerivKernels(kx: OutputArray, ky: OutputArray, dx: int, dy: int, ksize: int, normalize: Unit, ktype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("getDerivKernels")(kx.asInstanceOf[js.Any], ky.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any], ktype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def getDerivKernels(kx: OutputArray, ky: OutputArray, dx: int, dy: int, ksize: int, normalize: bool): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("getDerivKernels")(kx.asInstanceOf[js.Any], ky.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def getDerivKernels(kx: OutputArray, ky: OutputArray, dx: int, dy: int, ksize: int, normalize: bool, ktype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("getDerivKernels")(kx.asInstanceOf[js.Any], ky.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any], ktype.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def getElemSize(`type`: int): sizeT = ^.asInstanceOf[js.Dynamic].applyDynamic("getElemSize")(`type`.asInstanceOf[js.Any]).asInstanceOf[sizeT]

inline def getFontScaleFromHeight(fontFace: Any, pixelHeight: Any): double = (^.asInstanceOf[js.Dynamic].applyDynamic("getFontScaleFromHeight")(fontFace.asInstanceOf[js.Any], pixelHeight.asInstanceOf[js.Any])).asInstanceOf[double]
inline def getFontScaleFromHeight(fontFace: Any, pixelHeight: Any, thickness: Any): double = (^.asInstanceOf[js.Dynamic].applyDynamic("getFontScaleFromHeight")(fontFace.asInstanceOf[js.Any], pixelHeight.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[double]

inline def getGaborKernel(ksize: Size, sigma: double, theta: double, lambd: double, gamma: double): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getGaborKernel")(ksize.asInstanceOf[js.Any], sigma.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], lambd.asInstanceOf[js.Any], gamma.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def getGaborKernel(ksize: Size, sigma: double, theta: double, lambd: double, gamma: double, psi: Unit, ktype: int): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getGaborKernel")(ksize.asInstanceOf[js.Any], sigma.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], lambd.asInstanceOf[js.Any], gamma.asInstanceOf[js.Any], psi.asInstanceOf[js.Any], ktype.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def getGaborKernel(ksize: Size, sigma: double, theta: double, lambd: double, gamma: double, psi: double): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getGaborKernel")(ksize.asInstanceOf[js.Any], sigma.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], lambd.asInstanceOf[js.Any], gamma.asInstanceOf[js.Any], psi.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def getGaborKernel(ksize: Size, sigma: double, theta: double, lambd: double, gamma: double, psi: double, ktype: int): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getGaborKernel")(ksize.asInstanceOf[js.Any], sigma.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], lambd.asInstanceOf[js.Any], gamma.asInstanceOf[js.Any], psi.asInstanceOf[js.Any], ktype.asInstanceOf[js.Any])).asInstanceOf[Mat]

inline def getGaussianKernel(ksize: int, sigma: double): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getGaussianKernel")(ksize.asInstanceOf[js.Any], sigma.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def getGaussianKernel(ksize: int, sigma: double, ktype: int): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getGaussianKernel")(ksize.asInstanceOf[js.Any], sigma.asInstanceOf[js.Any], ktype.asInstanceOf[js.Any])).asInstanceOf[Mat]

inline def getHardwareFeatureName(feature: int): String = ^.asInstanceOf[js.Dynamic].applyDynamic("getHardwareFeatureName")(feature.asInstanceOf[js.Any]).asInstanceOf[String]

inline def getInheritedInstanceCount(a: Any*): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("getInheritedInstanceCount")(a.asInstanceOf[Seq[js.Any]]*).asInstanceOf[Any]

inline def getLiveInheritedInstances(a: Any*): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("getLiveInheritedInstances")(a.asInstanceOf[Seq[js.Any]]*).asInstanceOf[Any]

inline def getNumThreads(): int = ^.asInstanceOf[js.Dynamic].applyDynamic("getNumThreads")().asInstanceOf[int]

inline def getNumberOfCPUs(): int = ^.asInstanceOf[js.Dynamic].applyDynamic("getNumberOfCPUs")().asInstanceOf[int]

inline def getOptimalDFTSize(vecsize: int): int = ^.asInstanceOf[js.Dynamic].applyDynamic("getOptimalDFTSize")(vecsize.asInstanceOf[js.Any]).asInstanceOf[int]

inline def getOptimalNewCameraMatrix(cameraMatrix: InputArray, distCoeffs: InputArray, imageSize: Size, alpha: double): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getOptimalNewCameraMatrix")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def getOptimalNewCameraMatrix(
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  imageSize: Size,
  alpha: double,
  newImgSize: Unit,
  validPixROI: Any
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getOptimalNewCameraMatrix")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImgSize.asInstanceOf[js.Any], validPixROI.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def getOptimalNewCameraMatrix(
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  imageSize: Size,
  alpha: double,
  newImgSize: Unit,
  validPixROI: Any,
  centerPrincipalPoint: bool
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getOptimalNewCameraMatrix")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImgSize.asInstanceOf[js.Any], validPixROI.asInstanceOf[js.Any], centerPrincipalPoint.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def getOptimalNewCameraMatrix(
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  imageSize: Size,
  alpha: double,
  newImgSize: Unit,
  validPixROI: Unit,
  centerPrincipalPoint: bool
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getOptimalNewCameraMatrix")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImgSize.asInstanceOf[js.Any], validPixROI.asInstanceOf[js.Any], centerPrincipalPoint.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def getOptimalNewCameraMatrix(cameraMatrix: InputArray, distCoeffs: InputArray, imageSize: Size, alpha: double, newImgSize: Size): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getOptimalNewCameraMatrix")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImgSize.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def getOptimalNewCameraMatrix(
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  imageSize: Size,
  alpha: double,
  newImgSize: Size,
  validPixROI: Any
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getOptimalNewCameraMatrix")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImgSize.asInstanceOf[js.Any], validPixROI.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def getOptimalNewCameraMatrix(
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  imageSize: Size,
  alpha: double,
  newImgSize: Size,
  validPixROI: Any,
  centerPrincipalPoint: bool
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getOptimalNewCameraMatrix")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImgSize.asInstanceOf[js.Any], validPixROI.asInstanceOf[js.Any], centerPrincipalPoint.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def getOptimalNewCameraMatrix(
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  imageSize: Size,
  alpha: double,
  newImgSize: Size,
  validPixROI: Unit,
  centerPrincipalPoint: bool
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getOptimalNewCameraMatrix")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImgSize.asInstanceOf[js.Any], validPixROI.asInstanceOf[js.Any], centerPrincipalPoint.asInstanceOf[js.Any])).asInstanceOf[Mat]

inline def getPerspectiveTransform(src: Any, dst: Any): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getPerspectiveTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def getPerspectiveTransform(src: Any, dst: Any, solveMethod: int): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getPerspectiveTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], solveMethod.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def getPerspectiveTransform(src: InputArray, dst: InputArray): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getPerspectiveTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def getPerspectiveTransform(src: InputArray, dst: InputArray, solveMethod: int): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getPerspectiveTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], solveMethod.asInstanceOf[js.Any])).asInstanceOf[Mat]

inline def getRectSubPix(image: InputArray, patchSize: Size, center: Point2f, patch: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("getRectSubPix")(image.asInstanceOf[js.Any], patchSize.asInstanceOf[js.Any], center.asInstanceOf[js.Any], patch.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def getRectSubPix(image: InputArray, patchSize: Size, center: Point2f, patch: OutputArray, patchType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("getRectSubPix")(image.asInstanceOf[js.Any], patchSize.asInstanceOf[js.Any], center.asInstanceOf[js.Any], patch.asInstanceOf[js.Any], patchType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def getRotationMatrix2D(center: Point2f, angle: double, scale: double): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getRotationMatrix2D")(center.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Mat]

inline def getStructuringElement(shape: int, ksize: Size): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getStructuringElement")(shape.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def getStructuringElement(shape: int, ksize: Size, anchor: Point): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getStructuringElement")(shape.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any])).asInstanceOf[Mat]

inline def getTextSize(text: Any, fontFace: int, fontScale: double, thickness: int, baseLine: Any): Size = (^.asInstanceOf[js.Dynamic].applyDynamic("getTextSize")(text.asInstanceOf[js.Any], fontFace.asInstanceOf[js.Any], fontScale.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], baseLine.asInstanceOf[js.Any])).asInstanceOf[Size]

inline def getThreadNum(): int = ^.asInstanceOf[js.Dynamic].applyDynamic("getThreadNum")().asInstanceOf[int]

inline def getTickCount(): int64 = ^.asInstanceOf[js.Dynamic].applyDynamic("getTickCount")().asInstanceOf[int64]

inline def getTickFrequency(): double = ^.asInstanceOf[js.Dynamic].applyDynamic("getTickFrequency")().asInstanceOf[double]

inline def getValidDisparityROI(roi1: Rect, roi2: Rect, minDisparity: int, numberOfDisparities: int, SADWindowSize: int): Rect = (^.asInstanceOf[js.Dynamic].applyDynamic("getValidDisparityROI")(roi1.asInstanceOf[js.Any], roi2.asInstanceOf[js.Any], minDisparity.asInstanceOf[js.Any], numberOfDisparities.asInstanceOf[js.Any], SADWindowSize.asInstanceOf[js.Any])).asInstanceOf[Rect]

inline def getVersionMajor(): int = ^.asInstanceOf[js.Dynamic].applyDynamic("getVersionMajor")().asInstanceOf[int]

inline def getVersionMinor(): int = ^.asInstanceOf[js.Dynamic].applyDynamic("getVersionMinor")().asInstanceOf[int]

inline def getVersionRevision(): int = ^.asInstanceOf[js.Dynamic].applyDynamic("getVersionRevision")().asInstanceOf[int]

inline def getVersionString(): String = ^.asInstanceOf[js.Dynamic].applyDynamic("getVersionString")().asInstanceOf[String]

inline def glob(pattern: String, result: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("glob")(pattern.asInstanceOf[js.Any], result.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def glob(pattern: String, result: Any, recursive: bool): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("glob")(pattern.asInstanceOf[js.Any], result.asInstanceOf[js.Any], recursive.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def goodFeaturesToTrack(
  image: InputArray,
  corners: OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: InputArray,
  corners: OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: Unit,
  blockSize: Unit,
  useHarrisDetector: Unit,
  k: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any], k.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: InputArray,
  corners: OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: Unit,
  blockSize: Unit,
  useHarrisDetector: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: InputArray,
  corners: OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: Unit,
  blockSize: Unit,
  useHarrisDetector: bool,
  k: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any], k.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: InputArray,
  corners: OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: Unit,
  blockSize: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: InputArray,
  corners: OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: Unit,
  blockSize: int,
  useHarrisDetector: Unit,
  k: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any], k.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: InputArray,
  corners: OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: Unit,
  blockSize: int,
  useHarrisDetector: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: InputArray,
  corners: OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: Unit,
  blockSize: int,
  useHarrisDetector: bool,
  k: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any], k.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: InputArray,
  corners: OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: InputArray,
  corners: OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: InputArray,
  blockSize: Unit,
  useHarrisDetector: Unit,
  k: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any], k.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: InputArray,
  corners: OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: InputArray,
  blockSize: Unit,
  useHarrisDetector: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: InputArray,
  corners: OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: InputArray,
  blockSize: Unit,
  useHarrisDetector: bool,
  k: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any], k.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: InputArray,
  corners: OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: InputArray,
  blockSize: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: InputArray,
  corners: OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: InputArray,
  blockSize: int,
  gradientSize: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], gradientSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: InputArray,
  corners: OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: InputArray,
  blockSize: int,
  gradientSize: int,
  useHarrisDetector: Unit,
  k: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], gradientSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any], k.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: InputArray,
  corners: OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: InputArray,
  blockSize: int,
  gradientSize: int,
  useHarrisDetector: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], gradientSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: InputArray,
  corners: OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: InputArray,
  blockSize: int,
  gradientSize: int,
  useHarrisDetector: bool,
  k: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], gradientSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any], k.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: InputArray,
  corners: OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: InputArray,
  blockSize: int,
  useHarrisDetector: Unit,
  k: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any], k.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: InputArray,
  corners: OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: InputArray,
  blockSize: int,
  useHarrisDetector: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: InputArray,
  corners: OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: InputArray,
  blockSize: int,
  useHarrisDetector: bool,
  k: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any], k.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def grabCut(
  img: InputArray,
  mask: InputOutputArray,
  rect: Rect,
  bgdModel: InputOutputArray,
  fgdModel: InputOutputArray,
  iterCount: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("grabCut")(img.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], bgdModel.asInstanceOf[js.Any], fgdModel.asInstanceOf[js.Any], iterCount.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def grabCut(
  img: InputArray,
  mask: InputOutputArray,
  rect: Rect,
  bgdModel: InputOutputArray,
  fgdModel: InputOutputArray,
  iterCount: int,
  mode: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("grabCut")(img.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], bgdModel.asInstanceOf[js.Any], fgdModel.asInstanceOf[js.Any], iterCount.asInstanceOf[js.Any], mode.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def groupRectangles(rectList: Any, groupThreshold: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("groupRectangles")(rectList.asInstanceOf[js.Any], groupThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def groupRectangles(rectList: Any, groupThreshold: int, eps: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("groupRectangles")(rectList.asInstanceOf[js.Any], groupThreshold.asInstanceOf[js.Any], eps.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def groupRectangles(rectList: Any, groupThreshold: int, eps: double, weights: Any, levelWeights: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("groupRectangles")(rectList.asInstanceOf[js.Any], groupThreshold.asInstanceOf[js.Any], eps.asInstanceOf[js.Any], weights.asInstanceOf[js.Any], levelWeights.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def groupRectangles(rectList: Any, rejectLevels: Any, levelWeights: Any, groupThreshold: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("groupRectangles")(rectList.asInstanceOf[js.Any], rejectLevels.asInstanceOf[js.Any], levelWeights.asInstanceOf[js.Any], groupThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def groupRectangles(rectList: Any, rejectLevels: Any, levelWeights: Any, groupThreshold: int, eps: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("groupRectangles")(rectList.asInstanceOf[js.Any], rejectLevels.asInstanceOf[js.Any], levelWeights.asInstanceOf[js.Any], groupThreshold.asInstanceOf[js.Any], eps.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def groupRectangles(rectList: Any, weights: Any, groupThreshold: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("groupRectangles")(rectList.asInstanceOf[js.Any], weights.asInstanceOf[js.Any], groupThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def groupRectangles(rectList: Any, weights: Any, groupThreshold: int, eps: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("groupRectangles")(rectList.asInstanceOf[js.Any], weights.asInstanceOf[js.Any], groupThreshold.asInstanceOf[js.Any], eps.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def groupRectanglesMeanshift(rectList: Any, foundWeights: Any, foundScales: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("groupRectangles_meanshift")(rectList.asInstanceOf[js.Any], foundWeights.asInstanceOf[js.Any], foundScales.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def groupRectanglesMeanshift(rectList: Any, foundWeights: Any, foundScales: Any, detectThreshold: Unit, winDetSize: Size): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("groupRectangles_meanshift")(rectList.asInstanceOf[js.Any], foundWeights.asInstanceOf[js.Any], foundScales.asInstanceOf[js.Any], detectThreshold.asInstanceOf[js.Any], winDetSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def groupRectanglesMeanshift(rectList: Any, foundWeights: Any, foundScales: Any, detectThreshold: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("groupRectangles_meanshift")(rectList.asInstanceOf[js.Any], foundWeights.asInstanceOf[js.Any], foundScales.asInstanceOf[js.Any], detectThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def groupRectanglesMeanshift(rectList: Any, foundWeights: Any, foundScales: Any, detectThreshold: double, winDetSize: Size): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("groupRectangles_meanshift")(rectList.asInstanceOf[js.Any], foundWeights.asInstanceOf[js.Any], foundScales.asInstanceOf[js.Any], detectThreshold.asInstanceOf[js.Any], winDetSize.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def halNiDct2D(context: cvhalDFT, src_data: uchar, src_step: sizeT, dst_data: uchar, dst_step: sizeT): cvhalDFT = (^.asInstanceOf[js.Dynamic].applyDynamic("hal_ni_dct2D")(context.asInstanceOf[js.Any], src_data.asInstanceOf[js.Any], src_step.asInstanceOf[js.Any], dst_data.asInstanceOf[js.Any], dst_step.asInstanceOf[js.Any])).asInstanceOf[cvhalDFT]

inline def halNiDctFree2D(context: cvhalDFT): cvhalDFT = ^.asInstanceOf[js.Dynamic].applyDynamic("hal_ni_dctFree2D")(context.asInstanceOf[js.Any]).asInstanceOf[cvhalDFT]

inline def halNiDctInit2D(context: cvhalDFT, width: int, height: int, depth: int, flags: int): cvhalDFT = (^.asInstanceOf[js.Dynamic].applyDynamic("hal_ni_dctInit2D")(context.asInstanceOf[js.Any], width.asInstanceOf[js.Any], height.asInstanceOf[js.Any], depth.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[cvhalDFT]

inline def halNiDft1D(context: cvhalDFT, src: uchar, dst: uchar): cvhalDFT = (^.asInstanceOf[js.Dynamic].applyDynamic("hal_ni_dft1D")(context.asInstanceOf[js.Any], src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[cvhalDFT]

inline def halNiDft2D(context: cvhalDFT, src_data: uchar, src_step: sizeT, dst_data: uchar, dst_step: sizeT): cvhalDFT = (^.asInstanceOf[js.Dynamic].applyDynamic("hal_ni_dft2D")(context.asInstanceOf[js.Any], src_data.asInstanceOf[js.Any], src_step.asInstanceOf[js.Any], dst_data.asInstanceOf[js.Any], dst_step.asInstanceOf[js.Any])).asInstanceOf[cvhalDFT]

inline def halNiDftFree1D(context: cvhalDFT): cvhalDFT = ^.asInstanceOf[js.Dynamic].applyDynamic("hal_ni_dftFree1D")(context.asInstanceOf[js.Any]).asInstanceOf[cvhalDFT]

inline def halNiDftFree2D(context: cvhalDFT): cvhalDFT = ^.asInstanceOf[js.Dynamic].applyDynamic("hal_ni_dftFree2D")(context.asInstanceOf[js.Any]).asInstanceOf[cvhalDFT]

inline def halNiDftInit1D(context: cvhalDFT, len: int, count: int, depth: int, flags: int, needBuffer: Any): cvhalDFT = (^.asInstanceOf[js.Dynamic].applyDynamic("hal_ni_dftInit1D")(context.asInstanceOf[js.Any], len.asInstanceOf[js.Any], count.asInstanceOf[js.Any], depth.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], needBuffer.asInstanceOf[js.Any])).asInstanceOf[cvhalDFT]

inline def halNiDftInit2D(
  context: cvhalDFT,
  width: int,
  height: int,
  depth: int,
  src_channels: int,
  dst_channels: int,
  flags: int,
  nonzero_rows: int
): cvhalDFT = (^.asInstanceOf[js.Dynamic].applyDynamic("hal_ni_dftInit2D")(context.asInstanceOf[js.Any], width.asInstanceOf[js.Any], height.asInstanceOf[js.Any], depth.asInstanceOf[js.Any], src_channels.asInstanceOf[js.Any], dst_channels.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], nonzero_rows.asInstanceOf[js.Any])).asInstanceOf[cvhalDFT]

inline def halNiMinMaxIdx(
  src_data: uchar,
  src_step: sizeT,
  width: int,
  height: int,
  depth: int,
  minVal: Any,
  maxVal: Any,
  minIdx: Any,
  maxIdx: Any,
  mask: uchar
): uchar = (^.asInstanceOf[js.Dynamic].applyDynamic("hal_ni_minMaxIdx")(src_data.asInstanceOf[js.Any], src_step.asInstanceOf[js.Any], width.asInstanceOf[js.Any], height.asInstanceOf[js.Any], depth.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[uchar]

inline def hconcat(src1: InputArray, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("hconcat")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def hconcat(src: Any, nsrc: sizeT, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("hconcat")(src.asInstanceOf[js.Any], nsrc.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def hconcat(src: InputArrayOfArrays, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("hconcat")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def idct(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("idct")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def idct(src: InputArray, dst: OutputArray, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("idct")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def idft(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("idft")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def idft(src: InputArray, dst: OutputArray, flags: Unit, nonzeroRows: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("idft")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], nonzeroRows.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def idft(src: InputArray, dst: OutputArray, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("idft")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def idft(src: InputArray, dst: OutputArray, flags: int, nonzeroRows: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("idft")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], nonzeroRows.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def imagesFromBlob(blob_ : Any, images_ : OutputArrayOfArrays): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("imagesFromBlob")(blob_.asInstanceOf[js.Any], images_.asInstanceOf[js.Any])).asInstanceOf[Any]

inline def imread(canvasOrImageHtmlElement: String): typings.mirada.distSrcTypesOpencvMod.Mat = ^.asInstanceOf[js.Dynamic].applyDynamic("imread")(canvasOrImageHtmlElement.asInstanceOf[js.Any]).asInstanceOf[typings.mirada.distSrcTypesOpencvMod.Mat]
inline def imread(canvasOrImageHtmlElement: HTMLElement): typings.mirada.distSrcTypesOpencvMod.Mat = ^.asInstanceOf[js.Dynamic].applyDynamic("imread")(canvasOrImageHtmlElement.asInstanceOf[js.Any]).asInstanceOf[typings.mirada.distSrcTypesOpencvMod.Mat]

inline def imshow(canvasSource: String, mat: typings.mirada.distSrcTypesOpencvMod.Mat): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("imshow")(canvasSource.asInstanceOf[js.Any], mat.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def imshow(canvasSource: HTMLElement, mat: typings.mirada.distSrcTypesOpencvMod.Mat): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("imshow")(canvasSource.asInstanceOf[js.Any], mat.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def inRange(src: InputArray, lowerb: InputArray, upperb: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("inRange")(src.asInstanceOf[js.Any], lowerb.asInstanceOf[js.Any], upperb.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def initCameraMatrix2D(objectPoints: InputArrayOfArrays, imagePoints: InputArrayOfArrays, imageSize: Size): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("initCameraMatrix2D")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def initCameraMatrix2D(
  objectPoints: InputArrayOfArrays,
  imagePoints: InputArrayOfArrays,
  imageSize: Size,
  aspectRatio: double
): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("initCameraMatrix2D")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], aspectRatio.asInstanceOf[js.Any])).asInstanceOf[Mat]

inline def initUndistortRectifyMap(
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  R: InputArray,
  newCameraMatrix: InputArray,
  size: Size,
  m1type: int,
  map1: OutputArray,
  map2: OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("initUndistortRectifyMap")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], R.asInstanceOf[js.Any], newCameraMatrix.asInstanceOf[js.Any], size.asInstanceOf[js.Any], m1type.asInstanceOf[js.Any], map1.asInstanceOf[js.Any], map2.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def initWideAngleProjMap(
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  imageSize: Size,
  destImageWidth: int,
  m1type: int,
  map1: OutputArray,
  map2: OutputArray
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("initWideAngleProjMap")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], destImageWidth.asInstanceOf[js.Any], m1type.asInstanceOf[js.Any], map1.asInstanceOf[js.Any], map2.asInstanceOf[js.Any])).asInstanceOf[float]
inline def initWideAngleProjMap(
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  imageSize: Size,
  destImageWidth: int,
  m1type: int,
  map1: OutputArray,
  map2: OutputArray,
  projType: Any
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("initWideAngleProjMap")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], destImageWidth.asInstanceOf[js.Any], m1type.asInstanceOf[js.Any], map1.asInstanceOf[js.Any], map2.asInstanceOf[js.Any], projType.asInstanceOf[js.Any])).asInstanceOf[float]
inline def initWideAngleProjMap(
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  imageSize: Size,
  destImageWidth: int,
  m1type: int,
  map1: OutputArray,
  map2: OutputArray,
  projType: Any,
  alpha: double
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("initWideAngleProjMap")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], destImageWidth.asInstanceOf[js.Any], m1type.asInstanceOf[js.Any], map1.asInstanceOf[js.Any], map2.asInstanceOf[js.Any], projType.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any])).asInstanceOf[float]
inline def initWideAngleProjMap(
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  imageSize: Size,
  destImageWidth: int,
  m1type: int,
  map1: OutputArray,
  map2: OutputArray,
  projType: Unit,
  alpha: double
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("initWideAngleProjMap")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], destImageWidth.asInstanceOf[js.Any], m1type.asInstanceOf[js.Any], map1.asInstanceOf[js.Any], map2.asInstanceOf[js.Any], projType.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any])).asInstanceOf[float]
inline def initWideAngleProjMap(
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  imageSize: Size,
  destImageWidth: int,
  m1type: int,
  map1: OutputArray,
  map2: OutputArray,
  projType: int
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("initWideAngleProjMap")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], destImageWidth.asInstanceOf[js.Any], m1type.asInstanceOf[js.Any], map1.asInstanceOf[js.Any], map2.asInstanceOf[js.Any], projType.asInstanceOf[js.Any])).asInstanceOf[float]
inline def initWideAngleProjMap(
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  imageSize: Size,
  destImageWidth: int,
  m1type: int,
  map1: OutputArray,
  map2: OutputArray,
  projType: int,
  alpha: double
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("initWideAngleProjMap")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], destImageWidth.asInstanceOf[js.Any], m1type.asInstanceOf[js.Any], map1.asInstanceOf[js.Any], map2.asInstanceOf[js.Any], projType.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any])).asInstanceOf[float]

inline def inpaint(src: InputArray, inpaintMask: InputArray, dst: OutputArray, inpaintRadius: double, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("inpaint")(src.asInstanceOf[js.Any], inpaintMask.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], inpaintRadius.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def insertChannel(src: InputArray, dst: InputOutputArray, coi: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("insertChannel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], coi.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def integral(src: InputArray, sum: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def integral(src: InputArray, sum: OutputArray, sdepth: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sdepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def integral(src: InputArray, sum: OutputArray, sqsum: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sqsum.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def integral(src: InputArray, sum: OutputArray, sqsum: OutputArray, sdepth: Unit, sqdepth: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sqsum.asInstanceOf[js.Any], sdepth.asInstanceOf[js.Any], sqdepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def integral(src: InputArray, sum: OutputArray, sqsum: OutputArray, sdepth: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sqsum.asInstanceOf[js.Any], sdepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def integral(src: InputArray, sum: OutputArray, sqsum: OutputArray, sdepth: int, sqdepth: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sqsum.asInstanceOf[js.Any], sdepth.asInstanceOf[js.Any], sqdepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def integral(src: InputArray, sum: OutputArray, sqsum: OutputArray, tilted: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sqsum.asInstanceOf[js.Any], tilted.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def integral(
  src: InputArray,
  sum: OutputArray,
  sqsum: OutputArray,
  tilted: OutputArray,
  sdepth: Unit,
  sqdepth: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sqsum.asInstanceOf[js.Any], tilted.asInstanceOf[js.Any], sdepth.asInstanceOf[js.Any], sqdepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def integral(src: InputArray, sum: OutputArray, sqsum: OutputArray, tilted: OutputArray, sdepth: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sqsum.asInstanceOf[js.Any], tilted.asInstanceOf[js.Any], sdepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def integral(
  src: InputArray,
  sum: OutputArray,
  sqsum: OutputArray,
  tilted: OutputArray,
  sdepth: int,
  sqdepth: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sqsum.asInstanceOf[js.Any], tilted.asInstanceOf[js.Any], sdepth.asInstanceOf[js.Any], sqdepth.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def intersectConvexConvex(_p1: InputArray, _p2: InputArray, _p12: OutputArray): float = (^.asInstanceOf[js.Dynamic].applyDynamic("intersectConvexConvex")(_p1.asInstanceOf[js.Any], _p2.asInstanceOf[js.Any], _p12.asInstanceOf[js.Any])).asInstanceOf[float]
inline def intersectConvexConvex(_p1: InputArray, _p2: InputArray, _p12: OutputArray, handleNested: bool): float = (^.asInstanceOf[js.Dynamic].applyDynamic("intersectConvexConvex")(_p1.asInstanceOf[js.Any], _p2.asInstanceOf[js.Any], _p12.asInstanceOf[js.Any], handleNested.asInstanceOf[js.Any])).asInstanceOf[float]

inline def invert(src: InputArray, dst: OutputArray): double = (^.asInstanceOf[js.Dynamic].applyDynamic("invert")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[double]
inline def invert(src: InputArray, dst: OutputArray, flags: int): double = (^.asInstanceOf[js.Dynamic].applyDynamic("invert")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[double]

inline def invertAffineTransform(M: InputArray, iM: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("invertAffineTransform")(M.asInstanceOf[js.Any], iM.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def isContourConvex(contour: InputArray): bool = ^.asInstanceOf[js.Dynamic].applyDynamic("isContourConvex")(contour.asInstanceOf[js.Any]).asInstanceOf[bool]

inline def kArray: SpeedLevel = ^.asInstanceOf[js.Dynamic].selectDynamic("kArray").asInstanceOf[SpeedLevel]

inline def kBitsetHash: SpeedLevel = ^.asInstanceOf[js.Dynamic].selectDynamic("kBitsetHash").asInstanceOf[SpeedLevel]

inline def kHash: SpeedLevel = ^.asInstanceOf[js.Dynamic].selectDynamic("kHash").asInstanceOf[SpeedLevel]

inline def kmeans(
  data: InputArray,
  K: int,
  bestLabels: InputOutputArray,
  criteria: TermCriteria,
  attempts: int,
  flags: int
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("kmeans")(data.asInstanceOf[js.Any], K.asInstanceOf[js.Any], bestLabels.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], attempts.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[double]
inline def kmeans(
  data: InputArray,
  K: int,
  bestLabels: InputOutputArray,
  criteria: TermCriteria,
  attempts: int,
  flags: int,
  centers: OutputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("kmeans")(data.asInstanceOf[js.Any], K.asInstanceOf[js.Any], bestLabels.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], attempts.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], centers.asInstanceOf[js.Any])).asInstanceOf[double]

inline def line(img: InputOutputArray, pt1: Point, pt2: Point, color: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("line")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def line(
  img: InputOutputArray,
  pt1: Point,
  pt2: Point,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("line")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def line(img: InputOutputArray, pt1: Point, pt2: Point, color: Any, thickness: Unit, lineType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("line")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def line(
  img: InputOutputArray,
  pt1: Point,
  pt2: Point,
  color: Any,
  thickness: Unit,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("line")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def line(img: InputOutputArray, pt1: Point, pt2: Point, color: Any, thickness: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("line")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def line(
  img: InputOutputArray,
  pt1: Point,
  pt2: Point,
  color: Any,
  thickness: int,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("line")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def line(img: InputOutputArray, pt1: Point, pt2: Point, color: Any, thickness: int, lineType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("line")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def line(
  img: InputOutputArray,
  pt1: Point,
  pt2: Point,
  color: Any,
  thickness: int,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("line")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def linearPolar(src: InputArray, dst: OutputArray, center: Point2f, maxRadius: double, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("linearPolar")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], center.asInstanceOf[js.Any], maxRadius.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def log(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("log")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def logPolar(src: InputArray, dst: OutputArray, center: Point2f, M: double, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("logPolar")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], center.asInstanceOf[js.Any], M.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def magnitude(x: InputArray, y: InputArray, magnitude: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("magnitude")(x.asInstanceOf[js.Any], y.asInstanceOf[js.Any], magnitude.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def matFromArray(rows: Double, cols: Double, `type`: Any, array: js.Array[Double]): typings.mirada.distSrcTypesOpencvMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("matFromArray")(rows.asInstanceOf[js.Any], cols.asInstanceOf[js.Any], `type`.asInstanceOf[js.Any], array.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvMod.Mat]
inline def matFromArray(rows: Double, cols: Double, `type`: Any, array: js.typedarray.ArrayBufferView): typings.mirada.distSrcTypesOpencvMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("matFromArray")(rows.asInstanceOf[js.Any], cols.asInstanceOf[js.Any], `type`.asInstanceOf[js.Any], array.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvMod.Mat]
inline def matFromArray(rows: Double, cols: Double, `type`: Any, array: Any): typings.mirada.distSrcTypesOpencvMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("matFromArray")(rows.asInstanceOf[js.Any], cols.asInstanceOf[js.Any], `type`.asInstanceOf[js.Any], array.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvMod.Mat]

inline def matFromImageData(imageData: typings.mirada.distSrcTypesOpencvHacksMod.ImageData): typings.mirada.distSrcTypesOpencvMod.Mat = ^.asInstanceOf[js.Dynamic].applyDynamic("matFromImageData")(imageData.asInstanceOf[js.Any]).asInstanceOf[typings.mirada.distSrcTypesOpencvMod.Mat]

inline def matMulDeriv(A: InputArray, B: InputArray, dABdA: OutputArray, dABdB: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("matMulDeriv")(A.asInstanceOf[js.Any], B.asInstanceOf[js.Any], dABdA.asInstanceOf[js.Any], dABdB.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def matchShapes(contour1: InputArray, contour2: InputArray, method: int, parameter: double): double = (^.asInstanceOf[js.Dynamic].applyDynamic("matchShapes")(contour1.asInstanceOf[js.Any], contour2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], parameter.asInstanceOf[js.Any])).asInstanceOf[double]

inline def matchTemplate(image: InputArray, templ: InputArray, result: OutputArray, method: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("matchTemplate")(image.asInstanceOf[js.Any], templ.asInstanceOf[js.Any], result.asInstanceOf[js.Any], method.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def matchTemplate(image: InputArray, templ: InputArray, result: OutputArray, method: int, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("matchTemplate")(image.asInstanceOf[js.Any], templ.asInstanceOf[js.Any], result.asInstanceOf[js.Any], method.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def max(src1: Any, src2: Any, dst: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("max")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def max(src1: InputArray, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("max")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def mean(src: InputArray): Scalar = ^.asInstanceOf[js.Dynamic].applyDynamic("mean")(src.asInstanceOf[js.Any]).asInstanceOf[Scalar]
inline def mean(src: InputArray, mask: InputArray): Scalar = (^.asInstanceOf[js.Dynamic].applyDynamic("mean")(src.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Scalar]

inline def meanShift(probImage: InputArray, window: Any, criteria: TermCriteria): int = (^.asInstanceOf[js.Dynamic].applyDynamic("meanShift")(probImage.asInstanceOf[js.Any], window.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[int]

inline def meanStdDev(src: InputArray, mean: OutputArray, stddev: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("meanStdDev")(src.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], stddev.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def meanStdDev(src: InputArray, mean: OutputArray, stddev: OutputArray, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("meanStdDev")(src.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], stddev.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def medianBlur(src: InputArray, dst: OutputArray, ksize: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("medianBlur")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def merge(mv: Any, count: sizeT, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("merge")(mv.asInstanceOf[js.Any], count.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def merge(mv: InputArrayOfArrays, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("merge")(mv.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def min(src1: Any, src2: Any, dst: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("min")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def min(src1: InputArray, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("min")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def minAreaRect(points: InputArray): RotatedRect = ^.asInstanceOf[js.Dynamic].applyDynamic("minAreaRect")(points.asInstanceOf[js.Any]).asInstanceOf[RotatedRect]

inline def minEnclosingCircle(points: InputArray, center: Any, radius: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minEnclosingCircle")(points.asInstanceOf[js.Any], center.asInstanceOf[js.Any], radius.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def minEnclosingTriangle(points: InputArray, triangle: OutputArray): double = (^.asInstanceOf[js.Dynamic].applyDynamic("minEnclosingTriangle")(points.asInstanceOf[js.Any], triangle.asInstanceOf[js.Any])).asInstanceOf[double]

inline def minMaxIdx(src: InputArray, minVal: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Any, minIdx: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Any, minIdx: Any, maxIdx: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Any, minIdx: Any, maxIdx: Any, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Any, minIdx: Any, maxIdx: Unit, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Any, minIdx: Unit, maxIdx: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Any, minIdx: Unit, maxIdx: Any, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Any, minIdx: Unit, maxIdx: Unit, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Unit, minIdx: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Unit, minIdx: Any, maxIdx: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Unit, minIdx: Any, maxIdx: Any, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Unit, minIdx: Any, maxIdx: Unit, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Unit, minIdx: Unit, maxIdx: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Unit, minIdx: Unit, maxIdx: Any, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Unit, minIdx: Unit, maxIdx: Unit, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def minMaxLoc(a: Any, minVal: Any, maxVal: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(a.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(a: Any, minVal: Any, maxVal: Any, minIdx: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(a.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(a: Any, minVal: Any, maxVal: Any, minIdx: Any, maxIdx: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(a.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(a: Any, minVal: Any, maxVal: Any, minIdx: Unit, maxIdx: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(a.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(src: InputArray, minVal: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Any, minLoc: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Any, minLoc: Any, maxLoc: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Any, minLoc: Any, maxLoc: Any, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Any, minLoc: Any, maxLoc: Unit, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Any, minLoc: Unit, maxLoc: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Any, minLoc: Unit, maxLoc: Any, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Any, minLoc: Unit, maxLoc: Unit, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Unit, minLoc: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Unit, minLoc: Any, maxLoc: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Unit, minLoc: Any, maxLoc: Any, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Unit, minLoc: Any, maxLoc: Unit, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Unit, minLoc: Unit, maxLoc: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Unit, minLoc: Unit, maxLoc: Any, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Unit, minLoc: Unit, maxLoc: Unit, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def mixChannels(src: Any, nsrcs: sizeT, dst: Any, ndsts: sizeT, fromTo: Any, npairs: sizeT): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mixChannels")(src.asInstanceOf[js.Any], nsrcs.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ndsts.asInstanceOf[js.Any], fromTo.asInstanceOf[js.Any], npairs.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def mixChannels(src: InputArrayOfArrays, dst: InputOutputArrayOfArrays, fromTo: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mixChannels")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], fromTo.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def mixChannels(src: InputArrayOfArrays, dst: InputOutputArrayOfArrays, fromTo: Any, npairs: sizeT): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mixChannels")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], fromTo.asInstanceOf[js.Any], npairs.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def moments(array: InputArray): Moments = ^.asInstanceOf[js.Dynamic].applyDynamic("moments")(array.asInstanceOf[js.Any]).asInstanceOf[Moments]
inline def moments(array: InputArray, binaryImage: bool): Moments = (^.asInstanceOf[js.Dynamic].applyDynamic("moments")(array.asInstanceOf[js.Any], binaryImage.asInstanceOf[js.Any])).asInstanceOf[Moments]

inline def morphologyDefaultBorderValue(): Scalar = ^.asInstanceOf[js.Dynamic].applyDynamic("morphologyDefaultBorderValue")().asInstanceOf[Scalar]

inline def morphologyEx(src: InputArray, dst: OutputArray, op: int, kernel: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: InputArray,
  dst: OutputArray,
  op: int,
  kernel: InputArray,
  anchor: Unit,
  iterations: Unit,
  borderType: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: InputArray,
  dst: OutputArray,
  op: int,
  kernel: InputArray,
  anchor: Unit,
  iterations: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: InputArray,
  dst: OutputArray,
  op: int,
  kernel: InputArray,
  anchor: Unit,
  iterations: Unit,
  borderType: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(src: InputArray, dst: OutputArray, op: int, kernel: InputArray, anchor: Unit, iterations: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: InputArray,
  dst: OutputArray,
  op: int,
  kernel: InputArray,
  anchor: Unit,
  iterations: int,
  borderType: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: InputArray,
  dst: OutputArray,
  op: int,
  kernel: InputArray,
  anchor: Unit,
  iterations: int,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: InputArray,
  dst: OutputArray,
  op: int,
  kernel: InputArray,
  anchor: Unit,
  iterations: int,
  borderType: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(src: InputArray, dst: OutputArray, op: int, kernel: InputArray, anchor: Point): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: InputArray,
  dst: OutputArray,
  op: int,
  kernel: InputArray,
  anchor: Point,
  iterations: Unit,
  borderType: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: InputArray,
  dst: OutputArray,
  op: int,
  kernel: InputArray,
  anchor: Point,
  iterations: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: InputArray,
  dst: OutputArray,
  op: int,
  kernel: InputArray,
  anchor: Point,
  iterations: Unit,
  borderType: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(src: InputArray, dst: OutputArray, op: int, kernel: InputArray, anchor: Point, iterations: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: InputArray,
  dst: OutputArray,
  op: int,
  kernel: InputArray,
  anchor: Point,
  iterations: int,
  borderType: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: InputArray,
  dst: OutputArray,
  op: int,
  kernel: InputArray,
  anchor: Point,
  iterations: int,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: InputArray,
  dst: OutputArray,
  op: int,
  kernel: InputArray,
  anchor: Point,
  iterations: int,
  borderType: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def mulSpectrums(a: InputArray, b: InputArray, c: OutputArray, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulSpectrums")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any], c.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def mulSpectrums(a: InputArray, b: InputArray, c: OutputArray, flags: int, conjB: bool): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulSpectrums")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any], c.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], conjB.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def mulTransposed(src: InputArray, dst: OutputArray, aTa: bool): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulTransposed")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], aTa.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def mulTransposed(src: InputArray, dst: OutputArray, aTa: bool, delta: Unit, scale: Unit, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulTransposed")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], aTa.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def mulTransposed(src: InputArray, dst: OutputArray, aTa: bool, delta: Unit, scale: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulTransposed")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], aTa.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def mulTransposed(src: InputArray, dst: OutputArray, aTa: bool, delta: Unit, scale: double, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulTransposed")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], aTa.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def mulTransposed(src: InputArray, dst: OutputArray, aTa: bool, delta: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulTransposed")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], aTa.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def mulTransposed(src: InputArray, dst: OutputArray, aTa: bool, delta: InputArray, scale: Unit, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulTransposed")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], aTa.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def mulTransposed(src: InputArray, dst: OutputArray, aTa: bool, delta: InputArray, scale: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulTransposed")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], aTa.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def mulTransposed(src: InputArray, dst: OutputArray, aTa: bool, delta: InputArray, scale: double, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulTransposed")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], aTa.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def multiply(src1: InputArray, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("multiply")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def multiply(src1: InputArray, src2: InputArray, dst: OutputArray, scale: Unit, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("multiply")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def multiply(src1: InputArray, src2: InputArray, dst: OutputArray, scale: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("multiply")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def multiply(src1: InputArray, src2: InputArray, dst: OutputArray, scale: double, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("multiply")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def norm(src1: InputArray): double = ^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src1.asInstanceOf[js.Any]).asInstanceOf[double]
inline def norm(src1: InputArray, normType: Unit, mask: InputArray): double = (^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src1.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[double]
inline def norm(src1: InputArray, normType: int): double = (^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src1.asInstanceOf[js.Any], normType.asInstanceOf[js.Any])).asInstanceOf[double]
inline def norm(src1: InputArray, normType: int, mask: InputArray): double = (^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src1.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[double]
inline def norm(src1: InputArray, src2: InputArray): double = (^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any])).asInstanceOf[double]
inline def norm(src1: InputArray, src2: InputArray, normType: Unit, mask: InputArray): double = (^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[double]
inline def norm(src1: InputArray, src2: InputArray, normType: int): double = (^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], normType.asInstanceOf[js.Any])).asInstanceOf[double]
inline def norm(src1: InputArray, src2: InputArray, normType: int, mask: InputArray): double = (^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[double]
inline def norm(src: Any, normType: int): double = (^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src.asInstanceOf[js.Any], normType.asInstanceOf[js.Any])).asInstanceOf[double]

inline def norm1(
  a: typings.mirada.distSrcTypesOpencvMod.Mat,
  b: typings.mirada.distSrcTypesOpencvMod.Mat,
  `type`: NormTypes
): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("norm1")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any], `type`.asInstanceOf[js.Any])).asInstanceOf[Double]

inline def normInf(arg96: Any, arg97: Any, a: Any, n: int): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("normInf")(arg96.asInstanceOf[js.Any], arg97.asInstanceOf[js.Any], a.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[Any]
inline def normInf(arg98: Any, arg99: Any, a: Any, b: Any, n: int): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("normInf")(arg98.asInstanceOf[js.Any], arg99.asInstanceOf[js.Any], a.asInstanceOf[js.Any], b.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[Any]

inline def normL1(arg100: Any, arg101: Any, a: Any, n: int): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("normL1")(arg100.asInstanceOf[js.Any], arg101.asInstanceOf[js.Any], a.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[Any]
inline def normL1(arg102: Any, arg103: Any, a: Any, b: Any, n: int): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("normL1")(arg102.asInstanceOf[js.Any], arg103.asInstanceOf[js.Any], a.asInstanceOf[js.Any], b.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[Any]
inline def normL1(a: Any, b: Any, n: int): float = (^.asInstanceOf[js.Dynamic].applyDynamic("normL1")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[float]

inline def normL1_uchar(a: uchar, b: uchar, n: int): uchar = (^.asInstanceOf[js.Dynamic].applyDynamic("normL1")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[uchar]

inline def normL2Sqr(arg104: Any, arg105: Any, a: Any, n: int): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("normL2Sqr")(arg104.asInstanceOf[js.Any], arg105.asInstanceOf[js.Any], a.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[Any]
inline def normL2Sqr(arg106: Any, arg107: Any, a: Any, b: Any, n: int): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("normL2Sqr")(arg106.asInstanceOf[js.Any], arg107.asInstanceOf[js.Any], a.asInstanceOf[js.Any], b.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[Any]
inline def normL2Sqr(a: Any, b: Any, n: int): float = (^.asInstanceOf[js.Dynamic].applyDynamic("normL2Sqr")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[float]

inline def normalize(src: Any, dst: Any, alpha: double, normType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], normType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(src: InputArray, dst: InputOutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: InputArray,
  dst: InputOutputArray,
  alpha: Unit,
  beta: Unit,
  norm_type: Unit,
  dtype: Unit,
  mask: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(src: InputArray, dst: InputOutputArray, alpha: Unit, beta: Unit, norm_type: Unit, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: InputArray,
  dst: InputOutputArray,
  alpha: Unit,
  beta: Unit,
  norm_type: Unit,
  dtype: int,
  mask: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(src: InputArray, dst: InputOutputArray, alpha: Unit, beta: Unit, norm_type: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: InputArray,
  dst: InputOutputArray,
  alpha: Unit,
  beta: Unit,
  norm_type: int,
  dtype: Unit,
  mask: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(src: InputArray, dst: InputOutputArray, alpha: Unit, beta: Unit, norm_type: int, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: InputArray,
  dst: InputOutputArray,
  alpha: Unit,
  beta: Unit,
  norm_type: int,
  dtype: int,
  mask: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(src: InputArray, dst: InputOutputArray, alpha: Unit, beta: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: InputArray,
  dst: InputOutputArray,
  alpha: Unit,
  beta: double,
  norm_type: Unit,
  dtype: Unit,
  mask: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(src: InputArray, dst: InputOutputArray, alpha: Unit, beta: double, norm_type: Unit, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: InputArray,
  dst: InputOutputArray,
  alpha: Unit,
  beta: double,
  norm_type: Unit,
  dtype: int,
  mask: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(src: InputArray, dst: InputOutputArray, alpha: Unit, beta: double, norm_type: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: InputArray,
  dst: InputOutputArray,
  alpha: Unit,
  beta: double,
  norm_type: int,
  dtype: Unit,
  mask: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(src: InputArray, dst: InputOutputArray, alpha: Unit, beta: double, norm_type: int, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: InputArray,
  dst: InputOutputArray,
  alpha: Unit,
  beta: double,
  norm_type: int,
  dtype: int,
  mask: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(src: InputArray, dst: InputOutputArray, alpha: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: InputArray,
  dst: InputOutputArray,
  alpha: double,
  beta: Unit,
  norm_type: Unit,
  dtype: Unit,
  mask: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(src: InputArray, dst: InputOutputArray, alpha: double, beta: Unit, norm_type: Unit, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: InputArray,
  dst: InputOutputArray,
  alpha: double,
  beta: Unit,
  norm_type: Unit,
  dtype: int,
  mask: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(src: InputArray, dst: InputOutputArray, alpha: double, beta: Unit, norm_type: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: InputArray,
  dst: InputOutputArray,
  alpha: double,
  beta: Unit,
  norm_type: int,
  dtype: Unit,
  mask: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(src: InputArray, dst: InputOutputArray, alpha: double, beta: Unit, norm_type: int, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: InputArray,
  dst: InputOutputArray,
  alpha: double,
  beta: Unit,
  norm_type: int,
  dtype: int,
  mask: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(src: InputArray, dst: InputOutputArray, alpha: double, beta: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: InputArray,
  dst: InputOutputArray,
  alpha: double,
  beta: double,
  norm_type: Unit,
  dtype: Unit,
  mask: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(src: InputArray, dst: InputOutputArray, alpha: double, beta: double, norm_type: Unit, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: InputArray,
  dst: InputOutputArray,
  alpha: double,
  beta: double,
  norm_type: Unit,
  dtype: int,
  mask: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(src: InputArray, dst: InputOutputArray, alpha: double, beta: double, norm_type: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: InputArray,
  dst: InputOutputArray,
  alpha: double,
  beta: double,
  norm_type: int,
  dtype: Unit,
  mask: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(src: InputArray, dst: InputOutputArray, alpha: double, beta: double, norm_type: int, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: InputArray,
  dst: InputOutputArray,
  alpha: double,
  beta: double,
  norm_type: int,
  dtype: int,
  mask: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def onRuntimeInitialized(): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("onRuntimeInitialized")().asInstanceOf[Any]

inline def parallelFor(range: Any, body: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("parallel_for_")(range.asInstanceOf[js.Any], body.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def parallelFor(range: Any, body: Any, nstripes: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("parallel_for_")(range.asInstanceOf[js.Any], body.asInstanceOf[js.Any], nstripes.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def partition(arg119: Any, arg120: Any, _vec: Any, labels: Any): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("partition")(arg119.asInstanceOf[js.Any], arg120.asInstanceOf[js.Any], _vec.asInstanceOf[js.Any], labels.asInstanceOf[js.Any])).asInstanceOf[Any]
inline def partition(arg119: Any, arg120: Any, _vec: Any, labels: Any, predicate: EqPredicate): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("partition")(arg119.asInstanceOf[js.Any], arg120.asInstanceOf[js.Any], _vec.asInstanceOf[js.Any], labels.asInstanceOf[js.Any], predicate.asInstanceOf[js.Any])).asInstanceOf[Any]

inline def patchNaNs(a: InputOutputArray): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("patchNaNs")(a.asInstanceOf[js.Any]).asInstanceOf[Unit]
inline def patchNaNs(a: InputOutputArray, `val`: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("patchNaNs")(a.asInstanceOf[js.Any], `val`.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def perspectiveTransform(src: InputArray, dst: OutputArray, m: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("perspectiveTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], m.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def phase(x: InputArray, y: InputArray, angle: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("phase")(x.asInstanceOf[js.Any], y.asInstanceOf[js.Any], angle.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def phase(x: InputArray, y: InputArray, angle: OutputArray, angleInDegrees: bool): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("phase")(x.asInstanceOf[js.Any], y.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], angleInDegrees.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def pointPolygonTest(contour: InputArray, pt: Point2f, measureDist: bool): double = (^.asInstanceOf[js.Dynamic].applyDynamic("pointPolygonTest")(contour.asInstanceOf[js.Any], pt.asInstanceOf[js.Any], measureDist.asInstanceOf[js.Any])).asInstanceOf[double]

inline def polarToCart(magnitude: InputArray, angle: InputArray, x: OutputArray, y: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polarToCart")(magnitude.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], x.asInstanceOf[js.Any], y.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polarToCart(magnitude: InputArray, angle: InputArray, x: OutputArray, y: OutputArray, angleInDegrees: bool): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polarToCart")(magnitude.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], x.asInstanceOf[js.Any], y.asInstanceOf[js.Any], angleInDegrees.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def polylines(img: InputOutputArray, pts: Any, npts: Any, ncontours: int, isClosed: bool, color: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  isClosed: bool,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  isClosed: bool,
  color: Any,
  thickness: Unit,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  isClosed: bool,
  color: Any,
  thickness: Unit,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  isClosed: bool,
  color: Any,
  thickness: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  isClosed: bool,
  color: Any,
  thickness: int,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  isClosed: bool,
  color: Any,
  thickness: int,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  isClosed: bool,
  color: Any,
  thickness: int,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(img: InputOutputArray, pts: InputArrayOfArrays, isClosed: bool, color: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: InputOutputArray,
  pts: InputArrayOfArrays,
  isClosed: bool,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: InputOutputArray,
  pts: InputArrayOfArrays,
  isClosed: bool,
  color: Any,
  thickness: Unit,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: InputOutputArray,
  pts: InputArrayOfArrays,
  isClosed: bool,
  color: Any,
  thickness: Unit,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(img: InputOutputArray, pts: InputArrayOfArrays, isClosed: bool, color: Any, thickness: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: InputOutputArray,
  pts: InputArrayOfArrays,
  isClosed: bool,
  color: Any,
  thickness: int,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: InputOutputArray,
  pts: InputArrayOfArrays,
  isClosed: bool,
  color: Any,
  thickness: int,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: InputOutputArray,
  pts: InputArrayOfArrays,
  isClosed: bool,
  color: Any,
  thickness: int,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def pow(src: InputArray, power: double, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pow")(src.asInstanceOf[js.Any], power.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def preCornerDetect(src: InputArray, dst: OutputArray, ksize: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("preCornerDetect")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def preCornerDetect(src: InputArray, dst: OutputArray, ksize: int, borderType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("preCornerDetect")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def projectPoints(
  objectPoints: InputArray,
  rvec: InputArray,
  tvec: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  imagePoints: OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("projectPoints")(objectPoints.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def projectPoints(
  objectPoints: InputArray,
  rvec: InputArray,
  tvec: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  imagePoints: OutputArray,
  jacobian: Unit,
  aspectRatio: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("projectPoints")(objectPoints.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], jacobian.asInstanceOf[js.Any], aspectRatio.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def projectPoints(
  objectPoints: InputArray,
  rvec: InputArray,
  tvec: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  imagePoints: OutputArray,
  jacobian: OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("projectPoints")(objectPoints.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], jacobian.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def projectPoints(
  objectPoints: InputArray,
  rvec: InputArray,
  tvec: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  imagePoints: OutputArray,
  jacobian: OutputArray,
  aspectRatio: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("projectPoints")(objectPoints.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], jacobian.asInstanceOf[js.Any], aspectRatio.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def putText(img: InputOutputArray, text: Any, org_ : Point, fontFace: int, fontScale: double, color: Scalar): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("putText")(img.asInstanceOf[js.Any], text.asInstanceOf[js.Any], org_.asInstanceOf[js.Any], fontFace.asInstanceOf[js.Any], fontScale.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def putText(
  img: InputOutputArray,
  text: Any,
  org_ : Point,
  fontFace: int,
  fontScale: double,
  color: Scalar,
  thickness: Unit,
  lineType: Unit,
  bottomLeftOrigin: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("putText")(img.asInstanceOf[js.Any], text.asInstanceOf[js.Any], org_.asInstanceOf[js.Any], fontFace.asInstanceOf[js.Any], fontScale.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], bottomLeftOrigin.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def putText(
  img: InputOutputArray,
  text: Any,
  org_ : Point,
  fontFace: int,
  fontScale: double,
  color: Scalar,
  thickness: Unit,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("putText")(img.asInstanceOf[js.Any], text.asInstanceOf[js.Any], org_.asInstanceOf[js.Any], fontFace.asInstanceOf[js.Any], fontScale.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def putText(
  img: InputOutputArray,
  text: Any,
  org_ : Point,
  fontFace: int,
  fontScale: double,
  color: Scalar,
  thickness: Unit,
  lineType: int,
  bottomLeftOrigin: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("putText")(img.asInstanceOf[js.Any], text.asInstanceOf[js.Any], org_.asInstanceOf[js.Any], fontFace.asInstanceOf[js.Any], fontScale.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], bottomLeftOrigin.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def putText(
  img: InputOutputArray,
  text: Any,
  org_ : Point,
  fontFace: int,
  fontScale: double,
  color: Scalar,
  thickness: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("putText")(img.asInstanceOf[js.Any], text.asInstanceOf[js.Any], org_.asInstanceOf[js.Any], fontFace.asInstanceOf[js.Any], fontScale.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def putText(
  img: InputOutputArray,
  text: Any,
  org_ : Point,
  fontFace: int,
  fontScale: double,
  color: Scalar,
  thickness: int,
  lineType: Unit,
  bottomLeftOrigin: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("putText")(img.asInstanceOf[js.Any], text.asInstanceOf[js.Any], org_.asInstanceOf[js.Any], fontFace.asInstanceOf[js.Any], fontScale.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], bottomLeftOrigin.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def putText(
  img: InputOutputArray,
  text: Any,
  org_ : Point,
  fontFace: int,
  fontScale: double,
  color: Scalar,
  thickness: int,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("putText")(img.asInstanceOf[js.Any], text.asInstanceOf[js.Any], org_.asInstanceOf[js.Any], fontFace.asInstanceOf[js.Any], fontScale.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def putText(
  img: InputOutputArray,
  text: Any,
  org_ : Point,
  fontFace: int,
  fontScale: double,
  color: Scalar,
  thickness: int,
  lineType: int,
  bottomLeftOrigin: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("putText")(img.asInstanceOf[js.Any], text.asInstanceOf[js.Any], org_.asInstanceOf[js.Any], fontFace.asInstanceOf[js.Any], fontScale.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], bottomLeftOrigin.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def pyrDown(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pyrDown")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def pyrDown(src: InputArray, dst: OutputArray, dstsize: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pyrDown")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dstsize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def pyrDown(src: InputArray, dst: OutputArray, dstsize: Any, borderType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pyrDown")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dstsize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def pyrDown(src: InputArray, dst: OutputArray, dstsize: Unit, borderType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pyrDown")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dstsize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def pyrMeanShiftFiltering(src: InputArray, dst: OutputArray, sp: double, sr: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pyrMeanShiftFiltering")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], sp.asInstanceOf[js.Any], sr.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def pyrMeanShiftFiltering(src: InputArray, dst: OutputArray, sp: double, sr: double, maxLevel: Unit, termcrit: TermCriteria): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pyrMeanShiftFiltering")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], sp.asInstanceOf[js.Any], sr.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], termcrit.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def pyrMeanShiftFiltering(src: InputArray, dst: OutputArray, sp: double, sr: double, maxLevel: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pyrMeanShiftFiltering")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], sp.asInstanceOf[js.Any], sr.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def pyrMeanShiftFiltering(src: InputArray, dst: OutputArray, sp: double, sr: double, maxLevel: int, termcrit: TermCriteria): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pyrMeanShiftFiltering")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], sp.asInstanceOf[js.Any], sr.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], termcrit.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def pyrUp(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pyrUp")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def pyrUp(src: InputArray, dst: OutputArray, dstsize: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pyrUp")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dstsize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def pyrUp(src: InputArray, dst: OutputArray, dstsize: Any, borderType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pyrUp")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dstsize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def pyrUp(src: InputArray, dst: OutputArray, dstsize: Unit, borderType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pyrUp")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dstsize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def randShuffle(dst: InputOutputArray): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("randShuffle")(dst.asInstanceOf[js.Any]).asInstanceOf[Unit]
inline def randShuffle(dst: InputOutputArray, iterFactor: Unit, rng: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("randShuffle")(dst.asInstanceOf[js.Any], iterFactor.asInstanceOf[js.Any], rng.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def randShuffle(dst: InputOutputArray, iterFactor: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("randShuffle")(dst.asInstanceOf[js.Any], iterFactor.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def randShuffle(dst: InputOutputArray, iterFactor: double, rng: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("randShuffle")(dst.asInstanceOf[js.Any], iterFactor.asInstanceOf[js.Any], rng.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def randn(dst: InputOutputArray, mean: InputArray, stddev: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("randn")(dst.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], stddev.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def randu(dst: InputOutputArray, low: InputArray, high: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("randu")(dst.asInstanceOf[js.Any], low.asInstanceOf[js.Any], high.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def readNet(model: Any): Net = ^.asInstanceOf[js.Dynamic].applyDynamic("readNet")(model.asInstanceOf[js.Any]).asInstanceOf[Net]
inline def readNet(model: Any, config: Any): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNet")(model.asInstanceOf[js.Any], config.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNet(model: Any, config: Any, framework: Any): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNet")(model.asInstanceOf[js.Any], config.asInstanceOf[js.Any], framework.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNet(model: Any, config: Unit, framework: Any): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNet")(model.asInstanceOf[js.Any], config.asInstanceOf[js.Any], framework.asInstanceOf[js.Any])).asInstanceOf[Net]

inline def readNetFromCaffe(bufferProto: Any, lenProto: sizeT, bufferModel: Any): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromCaffe")(bufferProto.asInstanceOf[js.Any], lenProto.asInstanceOf[js.Any], bufferModel.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNetFromCaffe(bufferProto: Any, lenProto: sizeT, bufferModel: Any, lenModel: sizeT): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromCaffe")(bufferProto.asInstanceOf[js.Any], lenProto.asInstanceOf[js.Any], bufferModel.asInstanceOf[js.Any], lenModel.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNetFromCaffe(bufferProto: Any, lenProto: sizeT, bufferModel: Unit, lenModel: sizeT): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromCaffe")(bufferProto.asInstanceOf[js.Any], lenProto.asInstanceOf[js.Any], bufferModel.asInstanceOf[js.Any], lenModel.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNetFromCaffe(prototxt: Any): Net = ^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromCaffe")(prototxt.asInstanceOf[js.Any]).asInstanceOf[Net]
inline def readNetFromCaffe(prototxt: Any, caffeModel: Any | sizeT): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromCaffe")(prototxt.asInstanceOf[js.Any], caffeModel.asInstanceOf[js.Any])).asInstanceOf[Net]

inline def readNetFromCaffe_uchar(bufferProto: uchar): uchar = ^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromCaffe")(bufferProto.asInstanceOf[js.Any]).asInstanceOf[uchar]
inline def readNetFromCaffe_uchar(bufferProto: uchar, bufferModel: uchar): uchar = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromCaffe")(bufferProto.asInstanceOf[js.Any], bufferModel.asInstanceOf[js.Any])).asInstanceOf[uchar]

inline def readNetFromDarknet(bufferCfg: Any, lenCfg: sizeT, bufferModel: Any): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromDarknet")(bufferCfg.asInstanceOf[js.Any], lenCfg.asInstanceOf[js.Any], bufferModel.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNetFromDarknet(bufferCfg: Any, lenCfg: sizeT, bufferModel: Any, lenModel: sizeT): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromDarknet")(bufferCfg.asInstanceOf[js.Any], lenCfg.asInstanceOf[js.Any], bufferModel.asInstanceOf[js.Any], lenModel.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNetFromDarknet(bufferCfg: Any, lenCfg: sizeT, bufferModel: Unit, lenModel: sizeT): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromDarknet")(bufferCfg.asInstanceOf[js.Any], lenCfg.asInstanceOf[js.Any], bufferModel.asInstanceOf[js.Any], lenModel.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNetFromDarknet(cfgFile: Any): Net = ^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromDarknet")(cfgFile.asInstanceOf[js.Any]).asInstanceOf[Net]
inline def readNetFromDarknet(cfgFile: Any, darknetModel: Any | sizeT): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromDarknet")(cfgFile.asInstanceOf[js.Any], darknetModel.asInstanceOf[js.Any])).asInstanceOf[Net]

inline def readNetFromDarknet_uchar(bufferCfg: uchar): uchar = ^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromDarknet")(bufferCfg.asInstanceOf[js.Any]).asInstanceOf[uchar]
inline def readNetFromDarknet_uchar(bufferCfg: uchar, bufferModel: uchar): uchar = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromDarknet")(bufferCfg.asInstanceOf[js.Any], bufferModel.asInstanceOf[js.Any])).asInstanceOf[uchar]

inline def readNetFromModelOptimizer(xml: Any, bin: Any): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromModelOptimizer")(xml.asInstanceOf[js.Any], bin.asInstanceOf[js.Any])).asInstanceOf[Net]

inline def readNetFromONNX(buffer: Any, sizeBuffer: sizeT): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromONNX")(buffer.asInstanceOf[js.Any], sizeBuffer.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNetFromONNX(onnxFile: Any): Net = ^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromONNX")(onnxFile.asInstanceOf[js.Any]).asInstanceOf[Net]

inline def readNetFromONNX_uchar(buffer: uchar): uchar = ^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromONNX")(buffer.asInstanceOf[js.Any]).asInstanceOf[uchar]

inline def readNetFromTensorflow(bufferModel: Any, lenModel: sizeT, bufferConfig: Any): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromTensorflow")(bufferModel.asInstanceOf[js.Any], lenModel.asInstanceOf[js.Any], bufferConfig.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNetFromTensorflow(bufferModel: Any, lenModel: sizeT, bufferConfig: Any, lenConfig: sizeT): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromTensorflow")(bufferModel.asInstanceOf[js.Any], lenModel.asInstanceOf[js.Any], bufferConfig.asInstanceOf[js.Any], lenConfig.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNetFromTensorflow(bufferModel: Any, lenModel: sizeT, bufferConfig: Unit, lenConfig: sizeT): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromTensorflow")(bufferModel.asInstanceOf[js.Any], lenModel.asInstanceOf[js.Any], bufferConfig.asInstanceOf[js.Any], lenConfig.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNetFromTensorflow(model: Any): Net = ^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromTensorflow")(model.asInstanceOf[js.Any]).asInstanceOf[Net]
inline def readNetFromTensorflow(model: Any, config: Any | sizeT): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromTensorflow")(model.asInstanceOf[js.Any], config.asInstanceOf[js.Any])).asInstanceOf[Net]

inline def readNetFromTensorflow_uchar(bufferModel: uchar): uchar = ^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromTensorflow")(bufferModel.asInstanceOf[js.Any]).asInstanceOf[uchar]
inline def readNetFromTensorflow_uchar(bufferModel: uchar, bufferConfig: uchar): uchar = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromTensorflow")(bufferModel.asInstanceOf[js.Any], bufferConfig.asInstanceOf[js.Any])).asInstanceOf[uchar]

inline def readNetFromTorch(model: Any): Net = ^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromTorch")(model.asInstanceOf[js.Any]).asInstanceOf[Net]
inline def readNetFromTorch(model: Any, isBinary: Unit, evaluate: bool): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromTorch")(model.asInstanceOf[js.Any], isBinary.asInstanceOf[js.Any], evaluate.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNetFromTorch(model: Any, isBinary: bool): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromTorch")(model.asInstanceOf[js.Any], isBinary.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNetFromTorch(model: Any, isBinary: bool, evaluate: bool): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromTorch")(model.asInstanceOf[js.Any], isBinary.asInstanceOf[js.Any], evaluate.asInstanceOf[js.Any])).asInstanceOf[Net]

inline def readNet_uchar(framework: Any, bufferModel: uchar): uchar = (^.asInstanceOf[js.Dynamic].applyDynamic("readNet")(framework.asInstanceOf[js.Any], bufferModel.asInstanceOf[js.Any])).asInstanceOf[uchar]
inline def readNet_uchar(framework: Any, bufferModel: uchar, bufferConfig: uchar): uchar = (^.asInstanceOf[js.Dynamic].applyDynamic("readNet")(framework.asInstanceOf[js.Any], bufferModel.asInstanceOf[js.Any], bufferConfig.asInstanceOf[js.Any])).asInstanceOf[uchar]

inline def readOpticalFlow(path: Any): Mat = ^.asInstanceOf[js.Dynamic].applyDynamic("readOpticalFlow")(path.asInstanceOf[js.Any]).asInstanceOf[Mat]

inline def readTensorFromONNX(path: Any): Mat = ^.asInstanceOf[js.Dynamic].applyDynamic("readTensorFromONNX")(path.asInstanceOf[js.Any]).asInstanceOf[Mat]

inline def readTorchBlob(filename: Any): Mat = ^.asInstanceOf[js.Dynamic].applyDynamic("readTorchBlob")(filename.asInstanceOf[js.Any]).asInstanceOf[Mat]
inline def readTorchBlob(filename: Any, isBinary: bool): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("readTorchBlob")(filename.asInstanceOf[js.Any], isBinary.asInstanceOf[js.Any])).asInstanceOf[Mat]

inline def recoverPose(E: InputArray, points1: InputArray, points2: InputArray, R: OutputArray, t: OutputArray): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any])).asInstanceOf[int]
inline def recoverPose(
  E: InputArray,
  points1: InputArray,
  points2: InputArray,
  R: OutputArray,
  t: OutputArray,
  focal: Unit,
  pp: Unit,
  mask: InputOutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any], focal.asInstanceOf[js.Any], pp.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[int]
inline def recoverPose(
  E: InputArray,
  points1: InputArray,
  points2: InputArray,
  R: OutputArray,
  t: OutputArray,
  focal: Unit,
  pp: Point2d
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any], focal.asInstanceOf[js.Any], pp.asInstanceOf[js.Any])).asInstanceOf[int]
inline def recoverPose(
  E: InputArray,
  points1: InputArray,
  points2: InputArray,
  R: OutputArray,
  t: OutputArray,
  focal: Unit,
  pp: Point2d,
  mask: InputOutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any], focal.asInstanceOf[js.Any], pp.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[int]
inline def recoverPose(
  E: InputArray,
  points1: InputArray,
  points2: InputArray,
  R: OutputArray,
  t: OutputArray,
  focal: double
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any], focal.asInstanceOf[js.Any])).asInstanceOf[int]
inline def recoverPose(
  E: InputArray,
  points1: InputArray,
  points2: InputArray,
  R: OutputArray,
  t: OutputArray,
  focal: double,
  pp: Unit,
  mask: InputOutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any], focal.asInstanceOf[js.Any], pp.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[int]
inline def recoverPose(
  E: InputArray,
  points1: InputArray,
  points2: InputArray,
  R: OutputArray,
  t: OutputArray,
  focal: double,
  pp: Point2d
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any], focal.asInstanceOf[js.Any], pp.asInstanceOf[js.Any])).asInstanceOf[int]
inline def recoverPose(
  E: InputArray,
  points1: InputArray,
  points2: InputArray,
  R: OutputArray,
  t: OutputArray,
  focal: double,
  pp: Point2d,
  mask: InputOutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any], focal.asInstanceOf[js.Any], pp.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[int]
inline def recoverPose(
  E: InputArray,
  points1: InputArray,
  points2: InputArray,
  cameraMatrix: InputArray,
  R: OutputArray,
  t: OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any])).asInstanceOf[int]
inline def recoverPose(
  E: InputArray,
  points1: InputArray,
  points2: InputArray,
  cameraMatrix: InputArray,
  R: OutputArray,
  t: OutputArray,
  distanceThresh: double
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any], distanceThresh.asInstanceOf[js.Any])).asInstanceOf[int]
inline def recoverPose(
  E: InputArray,
  points1: InputArray,
  points2: InputArray,
  cameraMatrix: InputArray,
  R: OutputArray,
  t: OutputArray,
  distanceThresh: double,
  mask: Unit,
  triangulatedPoints: OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any], distanceThresh.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], triangulatedPoints.asInstanceOf[js.Any])).asInstanceOf[int]
inline def recoverPose(
  E: InputArray,
  points1: InputArray,
  points2: InputArray,
  cameraMatrix: InputArray,
  R: OutputArray,
  t: OutputArray,
  distanceThresh: double,
  mask: InputOutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any], distanceThresh.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[int]
inline def recoverPose(
  E: InputArray,
  points1: InputArray,
  points2: InputArray,
  cameraMatrix: InputArray,
  R: OutputArray,
  t: OutputArray,
  distanceThresh: double,
  mask: InputOutputArray,
  triangulatedPoints: OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any], distanceThresh.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], triangulatedPoints.asInstanceOf[js.Any])).asInstanceOf[int]
inline def recoverPose(
  E: InputArray,
  points1: InputArray,
  points2: InputArray,
  cameraMatrix: InputArray,
  R: OutputArray,
  t: OutputArray,
  mask: InputOutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[int]

inline def rectangle(img: InputOutputArray, pt1: Point, pt2: Point, color: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(
  img: InputOutputArray,
  pt1: Point,
  pt2: Point,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(img: InputOutputArray, pt1: Point, pt2: Point, color: Any, thickness: Unit, lineType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(
  img: InputOutputArray,
  pt1: Point,
  pt2: Point,
  color: Any,
  thickness: Unit,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(img: InputOutputArray, pt1: Point, pt2: Point, color: Any, thickness: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(
  img: InputOutputArray,
  pt1: Point,
  pt2: Point,
  color: Any,
  thickness: int,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(img: InputOutputArray, pt1: Point, pt2: Point, color: Any, thickness: int, lineType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(
  img: InputOutputArray,
  pt1: Point,
  pt2: Point,
  color: Any,
  thickness: int,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(img: InputOutputArray, rec: Rect, color: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], rec.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(img: InputOutputArray, rec: Rect, color: Any, thickness: Unit, lineType: Unit, shift: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], rec.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(img: InputOutputArray, rec: Rect, color: Any, thickness: Unit, lineType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], rec.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(img: InputOutputArray, rec: Rect, color: Any, thickness: Unit, lineType: int, shift: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], rec.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(img: InputOutputArray, rec: Rect, color: Any, thickness: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], rec.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(img: InputOutputArray, rec: Rect, color: Any, thickness: int, lineType: Unit, shift: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], rec.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(img: InputOutputArray, rec: Rect, color: Any, thickness: int, lineType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], rec.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(img: InputOutputArray, rec: Rect, color: Any, thickness: int, lineType: int, shift: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], rec.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def rectify3Collinear(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  cameraMatrix3: InputArray,
  distCoeffs3: InputArray,
  imgpt1: InputArrayOfArrays,
  imgpt3: InputArrayOfArrays,
  imageSize: Size,
  R12: InputArray,
  T12: InputArray,
  R13: InputArray,
  T13: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  R3: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  P3: OutputArray,
  Q: OutputArray,
  alpha: double,
  newImgSize: Size,
  roi1: Any,
  roi2: Any,
  flags: int
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("rectify3Collinear")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], cameraMatrix3.asInstanceOf[js.Any], distCoeffs3.asInstanceOf[js.Any], imgpt1.asInstanceOf[js.Any], imgpt3.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R12.asInstanceOf[js.Any], T12.asInstanceOf[js.Any], R13.asInstanceOf[js.Any], T13.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], R3.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], P3.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImgSize.asInstanceOf[js.Any], roi1.asInstanceOf[js.Any], roi2.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[float]

inline def redirectError(errCallback: ErrorCallback): ErrorCallback = ^.asInstanceOf[js.Dynamic].applyDynamic("redirectError")(errCallback.asInstanceOf[js.Any]).asInstanceOf[ErrorCallback]
inline def redirectError(errCallback: ErrorCallback, userdata: Any): ErrorCallback = (^.asInstanceOf[js.Dynamic].applyDynamic("redirectError")(errCallback.asInstanceOf[js.Any], userdata.asInstanceOf[js.Any])).asInstanceOf[ErrorCallback]
inline def redirectError(errCallback: ErrorCallback, userdata: Any, prevUserdata: Any): ErrorCallback = (^.asInstanceOf[js.Dynamic].applyDynamic("redirectError")(errCallback.asInstanceOf[js.Any], userdata.asInstanceOf[js.Any], prevUserdata.asInstanceOf[js.Any])).asInstanceOf[ErrorCallback]
inline def redirectError(errCallback: ErrorCallback, userdata: Unit, prevUserdata: Any): ErrorCallback = (^.asInstanceOf[js.Dynamic].applyDynamic("redirectError")(errCallback.asInstanceOf[js.Any], userdata.asInstanceOf[js.Any], prevUserdata.asInstanceOf[js.Any])).asInstanceOf[ErrorCallback]

inline def reduce(src: InputArray, dst: OutputArray, dim: int, rtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("reduce")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dim.asInstanceOf[js.Any], rtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def reduce(src: InputArray, dst: OutputArray, dim: int, rtype: int, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("reduce")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dim.asInstanceOf[js.Any], rtype.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def remap(src: InputArray, dst: OutputArray, map1: InputArray, map2: InputArray, interpolation: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("remap")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], map1.asInstanceOf[js.Any], map2.asInstanceOf[js.Any], interpolation.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def remap(
  src: InputArray,
  dst: OutputArray,
  map1: InputArray,
  map2: InputArray,
  interpolation: int,
  borderMode: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("remap")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], map1.asInstanceOf[js.Any], map2.asInstanceOf[js.Any], interpolation.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def remap(
  src: InputArray,
  dst: OutputArray,
  map1: InputArray,
  map2: InputArray,
  interpolation: int,
  borderMode: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("remap")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], map1.asInstanceOf[js.Any], map2.asInstanceOf[js.Any], interpolation.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def remap(
  src: InputArray,
  dst: OutputArray,
  map1: InputArray,
  map2: InputArray,
  interpolation: int,
  borderMode: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("remap")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], map1.asInstanceOf[js.Any], map2.asInstanceOf[js.Any], interpolation.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def repeat(src: Any, ny: int, nx: int): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("repeat")(src.asInstanceOf[js.Any], ny.asInstanceOf[js.Any], nx.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def repeat(src: InputArray, ny: int, nx: int, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("repeat")(src.asInstanceOf[js.Any], ny.asInstanceOf[js.Any], nx.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def reprojectImageTo3D(disparity: InputArray, _3dImage: OutputArray, Q: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("reprojectImageTo3D")(disparity.asInstanceOf[js.Any], _3dImage.asInstanceOf[js.Any], Q.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def reprojectImageTo3D(
  disparity: InputArray,
  _3dImage: OutputArray,
  Q: InputArray,
  handleMissingValues: Unit,
  ddepth: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("reprojectImageTo3D")(disparity.asInstanceOf[js.Any], _3dImage.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], handleMissingValues.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def reprojectImageTo3D(disparity: InputArray, _3dImage: OutputArray, Q: InputArray, handleMissingValues: bool): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("reprojectImageTo3D")(disparity.asInstanceOf[js.Any], _3dImage.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], handleMissingValues.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def reprojectImageTo3D(
  disparity: InputArray,
  _3dImage: OutputArray,
  Q: InputArray,
  handleMissingValues: bool,
  ddepth: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("reprojectImageTo3D")(disparity.asInstanceOf[js.Any], _3dImage.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], handleMissingValues.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def resize(src: InputArray, dst: OutputArray, dsize: Size): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("resize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def resize(src: InputArray, dst: OutputArray, dsize: Size, fx: Unit, fy: Unit, interpolation: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("resize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], fx.asInstanceOf[js.Any], fy.asInstanceOf[js.Any], interpolation.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def resize(src: InputArray, dst: OutputArray, dsize: Size, fx: Unit, fy: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("resize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], fx.asInstanceOf[js.Any], fy.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def resize(src: InputArray, dst: OutputArray, dsize: Size, fx: Unit, fy: double, interpolation: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("resize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], fx.asInstanceOf[js.Any], fy.asInstanceOf[js.Any], interpolation.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def resize(src: InputArray, dst: OutputArray, dsize: Size, fx: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("resize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], fx.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def resize(src: InputArray, dst: OutputArray, dsize: Size, fx: double, fy: Unit, interpolation: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("resize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], fx.asInstanceOf[js.Any], fy.asInstanceOf[js.Any], interpolation.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def resize(src: InputArray, dst: OutputArray, dsize: Size, fx: double, fy: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("resize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], fx.asInstanceOf[js.Any], fy.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def resize(src: InputArray, dst: OutputArray, dsize: Size, fx: double, fy: double, interpolation: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("resize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], fx.asInstanceOf[js.Any], fy.asInstanceOf[js.Any], interpolation.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def rotate(src: InputArray, dst: OutputArray, rotateCode: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rotate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], rotateCode.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def rotatedRectangleIntersection(rect1: Any, rect2: Any, intersectingRegion: OutputArray): int = (^.asInstanceOf[js.Dynamic].applyDynamic("rotatedRectangleIntersection")(rect1.asInstanceOf[js.Any], rect2.asInstanceOf[js.Any], intersectingRegion.asInstanceOf[js.Any])).asInstanceOf[int]

inline def roundUp(a: int, b: Any): int = (^.asInstanceOf[js.Dynamic].applyDynamic("roundUp")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[int]
inline def roundUp(a: sizeT, b: Any): sizeT = (^.asInstanceOf[js.Dynamic].applyDynamic("roundUp")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[sizeT]

inline def rows: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("rows").asInstanceOf[Any]

inline def sampsonDistance(pt1: InputArray, pt2: InputArray, F: InputArray): double = (^.asInstanceOf[js.Dynamic].applyDynamic("sampsonDistance")(pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], F.asInstanceOf[js.Any])).asInstanceOf[double]

inline def saturateCast(arg113: Any, v: double | float | int): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("saturate_cast")(arg113.asInstanceOf[js.Any], v.asInstanceOf[js.Any])).asInstanceOf[Any]
inline def saturateCast(arg116: Any, v: int64): int64 = (^.asInstanceOf[js.Dynamic].applyDynamic("saturate_cast")(arg116.asInstanceOf[js.Any], v.asInstanceOf[js.Any])).asInstanceOf[int64]

inline def saturateCast_Any(arg111: Any, v: float16T | short | unsigned): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("saturate_cast")(arg111.asInstanceOf[js.Any], v.asInstanceOf[js.Any])).asInstanceOf[Any]

inline def saturateCast_schar(arg109: Any, v: schar): schar = (^.asInstanceOf[js.Dynamic].applyDynamic("saturate_cast")(arg109.asInstanceOf[js.Any], v.asInstanceOf[js.Any])).asInstanceOf[schar]

inline def saturateCast_uchar(arg108: Any, v: uchar): uchar = (^.asInstanceOf[js.Dynamic].applyDynamic("saturate_cast")(arg108.asInstanceOf[js.Any], v.asInstanceOf[js.Any])).asInstanceOf[uchar]

inline def saturateCast_uint64(arg117: Any, v: uint64): uint64 = (^.asInstanceOf[js.Dynamic].applyDynamic("saturate_cast")(arg117.asInstanceOf[js.Any], v.asInstanceOf[js.Any])).asInstanceOf[uint64]

inline def saturateCast_ushort(arg110: Any, v: ushort): ushort = (^.asInstanceOf[js.Dynamic].applyDynamic("saturate_cast")(arg110.asInstanceOf[js.Any], v.asInstanceOf[js.Any])).asInstanceOf[ushort]

inline def scaleAdd(src1: InputArray, alpha: double, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleAdd")(src1.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def sepFilter2D(src: InputArray, dst: OutputArray, ddepth: int, kernelX: InputArray, kernelY: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sepFilter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernelX.asInstanceOf[js.Any], kernelY.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sepFilter2D(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  kernelX: InputArray,
  kernelY: InputArray,
  anchor: Unit,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sepFilter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernelX.asInstanceOf[js.Any], kernelY.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sepFilter2D(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  kernelX: InputArray,
  kernelY: InputArray,
  anchor: Unit,
  delta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sepFilter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernelX.asInstanceOf[js.Any], kernelY.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sepFilter2D(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  kernelX: InputArray,
  kernelY: InputArray,
  anchor: Unit,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sepFilter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernelX.asInstanceOf[js.Any], kernelY.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sepFilter2D(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  kernelX: InputArray,
  kernelY: InputArray,
  anchor: Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sepFilter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernelX.asInstanceOf[js.Any], kernelY.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sepFilter2D(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  kernelX: InputArray,
  kernelY: InputArray,
  anchor: Point,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sepFilter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernelX.asInstanceOf[js.Any], kernelY.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sepFilter2D(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  kernelX: InputArray,
  kernelY: InputArray,
  anchor: Point,
  delta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sepFilter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernelX.asInstanceOf[js.Any], kernelY.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sepFilter2D(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  kernelX: InputArray,
  kernelY: InputArray,
  anchor: Point,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sepFilter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernelX.asInstanceOf[js.Any], kernelY.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def setBreakOnError(flag: bool): bool = ^.asInstanceOf[js.Dynamic].applyDynamic("setBreakOnError")(flag.asInstanceOf[js.Any]).asInstanceOf[bool]

inline def setDelayFunction(a: Any*): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("setDelayFunction")(a.asInstanceOf[Seq[js.Any]]*).asInstanceOf[Any]

inline def setIdentity(mtx: InputOutputArray): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("setIdentity")(mtx.asInstanceOf[js.Any]).asInstanceOf[Unit]
inline def setIdentity(mtx: InputOutputArray, s: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("setIdentity")(mtx.asInstanceOf[js.Any], s.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def setNumThreads(nthreads: int): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("setNumThreads")(nthreads.asInstanceOf[js.Any]).asInstanceOf[Unit]

inline def setRNGSeed(seed: int): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("setRNGSeed")(seed.asInstanceOf[js.Any]).asInstanceOf[Unit]

inline def setUseOptimized(onoff: bool): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("setUseOptimized")(onoff.asInstanceOf[js.Any]).asInstanceOf[Unit]

inline def shortdim: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("shortdim").asInstanceOf[Any]

inline def shrinkCaffeModel(src: Any, dst: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("shrinkCaffeModel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def shrinkCaffeModel(src: Any, dst: Any, layersTypes: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("shrinkCaffeModel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], layersTypes.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def solve(src1: InputArray, src2: InputArray, dst: OutputArray): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("solve")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def solve(src1: InputArray, src2: InputArray, dst: OutputArray, flags: int): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("solve")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def solveCubic(coeffs: InputArray, roots: OutputArray): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solveCubic")(coeffs.asInstanceOf[js.Any], roots.asInstanceOf[js.Any])).asInstanceOf[int]

inline def solveP3P(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solveP3P")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]

inline def solvePnP(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvec: OutputArray,
  tvec: OutputArray
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnP")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def solvePnP(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvec: OutputArray,
  tvec: OutputArray,
  useExtrinsicGuess: Unit,
  flags: int
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnP")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def solvePnP(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvec: OutputArray,
  tvec: OutputArray,
  useExtrinsicGuess: bool
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnP")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def solvePnP(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvec: OutputArray,
  tvec: OutputArray,
  useExtrinsicGuess: bool,
  flags: int
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnP")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: Unit,
  rvec: Unit,
  tvec: Unit,
  reprojectionError: OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: Unit,
  rvec: Unit,
  tvec: InputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: Unit,
  rvec: Unit,
  tvec: InputArray,
  reprojectionError: OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: Unit,
  rvec: InputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: Unit,
  rvec: InputArray,
  tvec: Unit,
  reprojectionError: OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: Unit,
  rvec: InputArray,
  tvec: InputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: Unit,
  rvec: InputArray,
  tvec: InputArray,
  reprojectionError: OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: SolvePnPMethod
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: SolvePnPMethod,
  rvec: Unit,
  tvec: Unit,
  reprojectionError: OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: SolvePnPMethod,
  rvec: Unit,
  tvec: InputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: SolvePnPMethod,
  rvec: Unit,
  tvec: InputArray,
  reprojectionError: OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: SolvePnPMethod,
  rvec: InputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: SolvePnPMethod,
  rvec: InputArray,
  tvec: Unit,
  reprojectionError: OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: SolvePnPMethod,
  rvec: InputArray,
  tvec: InputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: SolvePnPMethod,
  rvec: InputArray,
  tvec: InputArray,
  reprojectionError: OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: bool
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: Unit,
  rvec: Unit,
  tvec: Unit,
  reprojectionError: OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: Unit,
  rvec: Unit,
  tvec: InputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: Unit,
  rvec: Unit,
  tvec: InputArray,
  reprojectionError: OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: Unit,
  rvec: InputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: Unit,
  rvec: InputArray,
  tvec: Unit,
  reprojectionError: OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: Unit,
  rvec: InputArray,
  tvec: InputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: Unit,
  rvec: InputArray,
  tvec: InputArray,
  reprojectionError: OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: SolvePnPMethod
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: SolvePnPMethod,
  rvec: Unit,
  tvec: Unit,
  reprojectionError: OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: SolvePnPMethod,
  rvec: Unit,
  tvec: InputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: SolvePnPMethod,
  rvec: Unit,
  tvec: InputArray,
  reprojectionError: OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: SolvePnPMethod,
  rvec: InputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: SolvePnPMethod,
  rvec: InputArray,
  tvec: Unit,
  reprojectionError: OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: SolvePnPMethod,
  rvec: InputArray,
  tvec: InputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvecs: OutputArrayOfArrays,
  tvecs: OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: SolvePnPMethod,
  rvec: InputArray,
  tvec: InputArray,
  reprojectionError: OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]

inline def solvePnPRansac(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvec: OutputArray,
  tvec: OutputArray,
  useExtrinsicGuess: js.UndefOr[bool],
  iterationsCount: js.UndefOr[int],
  reprojectionError: js.UndefOr[float],
  confidence: js.UndefOr[double],
  inliers: js.UndefOr[OutputArray],
  flags: js.UndefOr[int]
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPRansac")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], iterationsCount.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any], inliers.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def solvePnPRefineLM(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvec: InputOutputArray,
  tvec: InputOutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPRefineLM")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def solvePnPRefineLM(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvec: InputOutputArray,
  tvec: InputOutputArray,
  criteria: TermCriteria
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPRefineLM")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def solvePnPRefineVVS(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvec: InputOutputArray,
  tvec: InputOutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPRefineVVS")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def solvePnPRefineVVS(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvec: InputOutputArray,
  tvec: InputOutputArray,
  criteria: Unit,
  VVSlambda: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPRefineVVS")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], VVSlambda.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def solvePnPRefineVVS(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvec: InputOutputArray,
  tvec: InputOutputArray,
  criteria: TermCriteria
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPRefineVVS")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def solvePnPRefineVVS(
  objectPoints: InputArray,
  imagePoints: InputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  rvec: InputOutputArray,
  tvec: InputOutputArray,
  criteria: TermCriteria,
  VVSlambda: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPRefineVVS")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], VVSlambda.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def solvePoly(coeffs: InputArray, roots: OutputArray): double = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePoly")(coeffs.asInstanceOf[js.Any], roots.asInstanceOf[js.Any])).asInstanceOf[double]
inline def solvePoly(coeffs: InputArray, roots: OutputArray, maxIters: int): double = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePoly")(coeffs.asInstanceOf[js.Any], roots.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any])).asInstanceOf[double]

inline def sort(src: InputArray, dst: OutputArray, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sort")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def sortIdx(src: InputArray, dst: OutputArray, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sortIdx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def spatialGradient(src: InputArray, dx: OutputArray, dy: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("spatialGradient")(src.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def spatialGradient(src: InputArray, dx: OutputArray, dy: OutputArray, ksize: Unit, borderType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("spatialGradient")(src.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def spatialGradient(src: InputArray, dx: OutputArray, dy: OutputArray, ksize: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("spatialGradient")(src.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def spatialGradient(src: InputArray, dx: OutputArray, dy: OutputArray, ksize: int, borderType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("spatialGradient")(src.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def split(m: InputArray, mv: OutputArrayOfArrays): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("split")(m.asInstanceOf[js.Any], mv.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def split(src: Any, mvbegin: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("split")(src.asInstanceOf[js.Any], mvbegin.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def sqrBoxFilter(src: InputArray, dst: OutputArray, ddepth: int, ksize: Size): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sqrBoxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sqrBoxFilter(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  ksize: Size,
  anchor: Unit,
  normalize: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sqrBoxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sqrBoxFilter(src: InputArray, dst: OutputArray, ddepth: int, ksize: Size, anchor: Unit, normalize: bool): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sqrBoxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sqrBoxFilter(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  ksize: Size,
  anchor: Unit,
  normalize: bool,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sqrBoxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sqrBoxFilter(src: InputArray, dst: OutputArray, ddepth: int, ksize: Size, anchor: Point): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sqrBoxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sqrBoxFilter(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  ksize: Size,
  anchor: Point,
  normalize: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sqrBoxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sqrBoxFilter(src: InputArray, dst: OutputArray, ddepth: int, ksize: Size, anchor: Point, normalize: bool): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sqrBoxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sqrBoxFilter(
  src: InputArray,
  dst: OutputArray,
  ddepth: int,
  ksize: Size,
  anchor: Point,
  normalize: bool,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sqrBoxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def sqrt(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sqrt")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def stereoCalibrate(
  objectPoints: InputArrayOfArrays,
  imagePoints1: InputArrayOfArrays,
  imagePoints2: InputArrayOfArrays,
  cameraMatrix1: InputOutputArray,
  distCoeffs1: InputOutputArray,
  cameraMatrix2: InputOutputArray,
  distCoeffs2: InputOutputArray,
  imageSize: Size,
  R: InputOutputArray,
  T: InputOutputArray,
  E: OutputArray,
  F: OutputArray,
  perViewErrors: OutputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoCalibrate")(objectPoints.asInstanceOf[js.Any], imagePoints1.asInstanceOf[js.Any], imagePoints2.asInstanceOf[js.Any], cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], E.asInstanceOf[js.Any], F.asInstanceOf[js.Any], perViewErrors.asInstanceOf[js.Any])).asInstanceOf[double]
inline def stereoCalibrate(
  objectPoints: InputArrayOfArrays,
  imagePoints1: InputArrayOfArrays,
  imagePoints2: InputArrayOfArrays,
  cameraMatrix1: InputOutputArray,
  distCoeffs1: InputOutputArray,
  cameraMatrix2: InputOutputArray,
  distCoeffs2: InputOutputArray,
  imageSize: Size,
  R: InputOutputArray,
  T: InputOutputArray,
  E: OutputArray,
  F: OutputArray,
  perViewErrors: OutputArray,
  flags: Unit,
  criteria: TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoCalibrate")(objectPoints.asInstanceOf[js.Any], imagePoints1.asInstanceOf[js.Any], imagePoints2.asInstanceOf[js.Any], cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], E.asInstanceOf[js.Any], F.asInstanceOf[js.Any], perViewErrors.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]
inline def stereoCalibrate(
  objectPoints: InputArrayOfArrays,
  imagePoints1: InputArrayOfArrays,
  imagePoints2: InputArrayOfArrays,
  cameraMatrix1: InputOutputArray,
  distCoeffs1: InputOutputArray,
  cameraMatrix2: InputOutputArray,
  distCoeffs2: InputOutputArray,
  imageSize: Size,
  R: InputOutputArray,
  T: InputOutputArray,
  E: OutputArray,
  F: OutputArray,
  perViewErrors: OutputArray,
  flags: int
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoCalibrate")(objectPoints.asInstanceOf[js.Any], imagePoints1.asInstanceOf[js.Any], imagePoints2.asInstanceOf[js.Any], cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], E.asInstanceOf[js.Any], F.asInstanceOf[js.Any], perViewErrors.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[double]
inline def stereoCalibrate(
  objectPoints: InputArrayOfArrays,
  imagePoints1: InputArrayOfArrays,
  imagePoints2: InputArrayOfArrays,
  cameraMatrix1: InputOutputArray,
  distCoeffs1: InputOutputArray,
  cameraMatrix2: InputOutputArray,
  distCoeffs2: InputOutputArray,
  imageSize: Size,
  R: InputOutputArray,
  T: InputOutputArray,
  E: OutputArray,
  F: OutputArray,
  perViewErrors: OutputArray,
  flags: int,
  criteria: TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoCalibrate")(objectPoints.asInstanceOf[js.Any], imagePoints1.asInstanceOf[js.Any], imagePoints2.asInstanceOf[js.Any], cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], E.asInstanceOf[js.Any], F.asInstanceOf[js.Any], perViewErrors.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]
inline def stereoCalibrate(
  objectPoints: InputArrayOfArrays,
  imagePoints1: InputArrayOfArrays,
  imagePoints2: InputArrayOfArrays,
  cameraMatrix1: InputOutputArray,
  distCoeffs1: InputOutputArray,
  cameraMatrix2: InputOutputArray,
  distCoeffs2: InputOutputArray,
  imageSize: Size,
  R: OutputArray,
  T: OutputArray,
  E: OutputArray,
  F: OutputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoCalibrate")(objectPoints.asInstanceOf[js.Any], imagePoints1.asInstanceOf[js.Any], imagePoints2.asInstanceOf[js.Any], cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], E.asInstanceOf[js.Any], F.asInstanceOf[js.Any])).asInstanceOf[double]
inline def stereoCalibrate(
  objectPoints: InputArrayOfArrays,
  imagePoints1: InputArrayOfArrays,
  imagePoints2: InputArrayOfArrays,
  cameraMatrix1: InputOutputArray,
  distCoeffs1: InputOutputArray,
  cameraMatrix2: InputOutputArray,
  distCoeffs2: InputOutputArray,
  imageSize: Size,
  R: OutputArray,
  T: OutputArray,
  E: OutputArray,
  F: OutputArray,
  flags: Unit,
  criteria: TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoCalibrate")(objectPoints.asInstanceOf[js.Any], imagePoints1.asInstanceOf[js.Any], imagePoints2.asInstanceOf[js.Any], cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], E.asInstanceOf[js.Any], F.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]
inline def stereoCalibrate(
  objectPoints: InputArrayOfArrays,
  imagePoints1: InputArrayOfArrays,
  imagePoints2: InputArrayOfArrays,
  cameraMatrix1: InputOutputArray,
  distCoeffs1: InputOutputArray,
  cameraMatrix2: InputOutputArray,
  distCoeffs2: InputOutputArray,
  imageSize: Size,
  R: OutputArray,
  T: OutputArray,
  E: OutputArray,
  F: OutputArray,
  flags: int
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoCalibrate")(objectPoints.asInstanceOf[js.Any], imagePoints1.asInstanceOf[js.Any], imagePoints2.asInstanceOf[js.Any], cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], E.asInstanceOf[js.Any], F.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[double]
inline def stereoCalibrate(
  objectPoints: InputArrayOfArrays,
  imagePoints1: InputArrayOfArrays,
  imagePoints2: InputArrayOfArrays,
  cameraMatrix1: InputOutputArray,
  distCoeffs1: InputOutputArray,
  cameraMatrix2: InputOutputArray,
  distCoeffs2: InputOutputArray,
  imageSize: Size,
  R: OutputArray,
  T: OutputArray,
  E: OutputArray,
  F: OutputArray,
  flags: int,
  criteria: TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoCalibrate")(objectPoints.asInstanceOf[js.Any], imagePoints1.asInstanceOf[js.Any], imagePoints2.asInstanceOf[js.Any], cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], E.asInstanceOf[js.Any], F.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]

inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: Unit,
  alpha: Unit,
  newImageSize: Unit,
  validPixROI1: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: Unit,
  alpha: Unit,
  newImageSize: Unit,
  validPixROI1: Any,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: Unit,
  alpha: Unit,
  newImageSize: Unit,
  validPixROI1: Unit,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: Unit,
  alpha: Unit,
  newImageSize: Size
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: Unit,
  alpha: Unit,
  newImageSize: Size,
  validPixROI1: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: Unit,
  alpha: Unit,
  newImageSize: Size,
  validPixROI1: Any,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: Unit,
  alpha: Unit,
  newImageSize: Size,
  validPixROI1: Unit,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: Unit,
  alpha: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: Unit,
  alpha: double,
  newImageSize: Unit,
  validPixROI1: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: Unit,
  alpha: double,
  newImageSize: Unit,
  validPixROI1: Any,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: Unit,
  alpha: double,
  newImageSize: Unit,
  validPixROI1: Unit,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: Unit,
  alpha: double,
  newImageSize: Size
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: Unit,
  alpha: double,
  newImageSize: Size,
  validPixROI1: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: Unit,
  alpha: double,
  newImageSize: Size,
  validPixROI1: Any,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: Unit,
  alpha: double,
  newImageSize: Size,
  validPixROI1: Unit,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: int,
  alpha: Unit,
  newImageSize: Unit,
  validPixROI1: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: int,
  alpha: Unit,
  newImageSize: Unit,
  validPixROI1: Any,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: int,
  alpha: Unit,
  newImageSize: Unit,
  validPixROI1: Unit,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: int,
  alpha: Unit,
  newImageSize: Size
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: int,
  alpha: Unit,
  newImageSize: Size,
  validPixROI1: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: int,
  alpha: Unit,
  newImageSize: Size,
  validPixROI1: Any,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: int,
  alpha: Unit,
  newImageSize: Size,
  validPixROI1: Unit,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: int,
  alpha: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: int,
  alpha: double,
  newImageSize: Unit,
  validPixROI1: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: int,
  alpha: double,
  newImageSize: Unit,
  validPixROI1: Any,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: int,
  alpha: double,
  newImageSize: Unit,
  validPixROI1: Unit,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: int,
  alpha: double,
  newImageSize: Size
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: int,
  alpha: double,
  newImageSize: Size,
  validPixROI1: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: int,
  alpha: double,
  newImageSize: Size,
  validPixROI1: Any,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: InputArray,
  distCoeffs1: InputArray,
  cameraMatrix2: InputArray,
  distCoeffs2: InputArray,
  imageSize: Size,
  R: InputArray,
  T: InputArray,
  R1: OutputArray,
  R2: OutputArray,
  P1: OutputArray,
  P2: OutputArray,
  Q: OutputArray,
  flags: int,
  alpha: double,
  newImageSize: Size,
  validPixROI1: Unit,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def stereoRectifyUncalibrated(
  points1: InputArray,
  points2: InputArray,
  F: InputArray,
  imgSize: Size,
  H1: OutputArray,
  H2: OutputArray
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectifyUncalibrated")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], F.asInstanceOf[js.Any], imgSize.asInstanceOf[js.Any], H1.asInstanceOf[js.Any], H2.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def stereoRectifyUncalibrated(
  points1: InputArray,
  points2: InputArray,
  F: InputArray,
  imgSize: Size,
  H1: OutputArray,
  H2: OutputArray,
  threshold: double
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectifyUncalibrated")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], F.asInstanceOf[js.Any], imgSize.asInstanceOf[js.Any], H1.asInstanceOf[js.Any], H2.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def subtract(src1: InputArray, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("subtract")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def subtract(src1: InputArray, src2: InputArray, dst: OutputArray, mask: Unit, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("subtract")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def subtract(src1: InputArray, src2: InputArray, dst: OutputArray, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("subtract")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def subtract(src1: InputArray, src2: InputArray, dst: OutputArray, mask: InputArray, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("subtract")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def sum(src: InputArray): Scalar = ^.asInstanceOf[js.Dynamic].applyDynamic("sum")(src.asInstanceOf[js.Any]).asInstanceOf[Scalar]

inline def tempfile(): String = ^.asInstanceOf[js.Dynamic].applyDynamic("tempfile")().asInstanceOf[String]
inline def tempfile(suffix: Any): String = ^.asInstanceOf[js.Dynamic].applyDynamic("tempfile")(suffix.asInstanceOf[js.Any]).asInstanceOf[String]

inline def testAsyncArray(argument: InputArray): AsyncArray = ^.asInstanceOf[js.Dynamic].applyDynamic("testAsyncArray")(argument.asInstanceOf[js.Any]).asInstanceOf[AsyncArray]

inline def testAsyncException(): AsyncArray = ^.asInstanceOf[js.Dynamic].applyDynamic("testAsyncException")().asInstanceOf[AsyncArray]

inline def theRNG(): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("theRNG")().asInstanceOf[Any]

inline def threshold(src: InputArray, dst: OutputArray, thresh: double, maxval: double, `type`: int): double = (^.asInstanceOf[js.Dynamic].applyDynamic("threshold")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], thresh.asInstanceOf[js.Any], maxval.asInstanceOf[js.Any], `type`.asInstanceOf[js.Any])).asInstanceOf[double]

inline def trace(mtx: InputArray): Scalar = ^.asInstanceOf[js.Dynamic].applyDynamic("trace")(mtx.asInstanceOf[js.Any]).asInstanceOf[Scalar]

inline def transform(src: InputArray, dst: OutputArray, m: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("transform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], m.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def transpose(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("transpose")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def triangulatePoints(
  projMatr1: InputArray,
  projMatr2: InputArray,
  projPoints1: InputArray,
  projPoints2: InputArray,
  points4D: OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("triangulatePoints")(projMatr1.asInstanceOf[js.Any], projMatr2.asInstanceOf[js.Any], projPoints1.asInstanceOf[js.Any], projPoints2.asInstanceOf[js.Any], points4D.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def undistort(src: InputArray, dst: OutputArray, cameraMatrix: InputArray, distCoeffs: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("undistort")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def undistort(
  src: InputArray,
  dst: OutputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  newCameraMatrix: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("undistort")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], newCameraMatrix.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def undistortPoints(src: InputArray, dst: OutputArray, cameraMatrix: InputArray, distCoeffs: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("undistortPoints")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def undistortPoints(
  src: InputArray,
  dst: OutputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  R: Unit,
  P: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("undistortPoints")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], R.asInstanceOf[js.Any], P.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def undistortPoints(src: InputArray, dst: OutputArray, cameraMatrix: InputArray, distCoeffs: InputArray, R: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("undistortPoints")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], R.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def undistortPoints(
  src: InputArray,
  dst: OutputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  R: InputArray,
  P: InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("undistortPoints")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], R.asInstanceOf[js.Any], P.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def undistortPoints(
  src: InputArray,
  dst: OutputArray,
  cameraMatrix: InputArray,
  distCoeffs: InputArray,
  R: InputArray,
  P: InputArray,
  criteria: TermCriteria
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("undistortPoints")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], R.asInstanceOf[js.Any], P.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def useOptimized(): bool = ^.asInstanceOf[js.Dynamic].applyDynamic("useOptimized")().asInstanceOf[bool]

inline def validateDisparity(disparity: InputOutputArray, cost: InputArray, minDisparity: int, numberOfDisparities: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("validateDisparity")(disparity.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], minDisparity.asInstanceOf[js.Any], numberOfDisparities.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def validateDisparity(
  disparity: InputOutputArray,
  cost: InputArray,
  minDisparity: int,
  numberOfDisparities: int,
  disp12MaxDisp: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("validateDisparity")(disparity.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], minDisparity.asInstanceOf[js.Any], numberOfDisparities.asInstanceOf[js.Any], disp12MaxDisp.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def vconcat(src1: InputArray, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("vconcat")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def vconcat(src: Any, nsrc: sizeT, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("vconcat")(src.asInstanceOf[js.Any], nsrc.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def vconcat(src: InputArrayOfArrays, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("vconcat")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def warpAffine(src: InputArray, dst: OutputArray, M: InputArray, dsize: Size): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpAffine")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpAffine(
  src: InputArray,
  dst: OutputArray,
  M: InputArray,
  dsize: Size,
  flags: Unit,
  borderMode: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpAffine")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpAffine(src: InputArray, dst: OutputArray, M: InputArray, dsize: Size, flags: Unit, borderMode: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpAffine")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpAffine(
  src: InputArray,
  dst: OutputArray,
  M: InputArray,
  dsize: Size,
  flags: Unit,
  borderMode: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpAffine")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpAffine(src: InputArray, dst: OutputArray, M: InputArray, dsize: Size, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpAffine")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpAffine(
  src: InputArray,
  dst: OutputArray,
  M: InputArray,
  dsize: Size,
  flags: int,
  borderMode: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpAffine")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpAffine(src: InputArray, dst: OutputArray, M: InputArray, dsize: Size, flags: int, borderMode: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpAffine")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpAffine(
  src: InputArray,
  dst: OutputArray,
  M: InputArray,
  dsize: Size,
  flags: int,
  borderMode: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpAffine")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def warpPerspective(src: InputArray, dst: OutputArray, M: InputArray, dsize: Size): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpPerspective")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpPerspective(
  src: InputArray,
  dst: OutputArray,
  M: InputArray,
  dsize: Size,
  flags: Unit,
  borderMode: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpPerspective")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpPerspective(src: InputArray, dst: OutputArray, M: InputArray, dsize: Size, flags: Unit, borderMode: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpPerspective")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpPerspective(
  src: InputArray,
  dst: OutputArray,
  M: InputArray,
  dsize: Size,
  flags: Unit,
  borderMode: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpPerspective")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpPerspective(src: InputArray, dst: OutputArray, M: InputArray, dsize: Size, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpPerspective")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpPerspective(
  src: InputArray,
  dst: OutputArray,
  M: InputArray,
  dsize: Size,
  flags: int,
  borderMode: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpPerspective")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpPerspective(src: InputArray, dst: OutputArray, M: InputArray, dsize: Size, flags: int, borderMode: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpPerspective")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpPerspective(
  src: InputArray,
  dst: OutputArray,
  M: InputArray,
  dsize: Size,
  flags: int,
  borderMode: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpPerspective")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def warpPolar(src: InputArray, dst: OutputArray, dsize: Size, center: Point2f, maxRadius: double, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpPolar")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], center.asInstanceOf[js.Any], maxRadius.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def watershed(image: InputArray, markers: InputOutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("watershed")(image.asInstanceOf[js.Any], markers.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def wrapperEMD(signature1: InputArray, signature2: InputArray, distType: int): float = (^.asInstanceOf[js.Dynamic].applyDynamic("wrapperEMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any])).asInstanceOf[float]
inline def wrapperEMD(signature1: InputArray, signature2: InputArray, distType: int, cost: Unit, lowerBound: Any): float = (^.asInstanceOf[js.Dynamic].applyDynamic("wrapperEMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], lowerBound.asInstanceOf[js.Any])).asInstanceOf[float]
inline def wrapperEMD(
  signature1: InputArray,
  signature2: InputArray,
  distType: int,
  cost: Unit,
  lowerBound: Any,
  flow: OutputArray
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("wrapperEMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], lowerBound.asInstanceOf[js.Any], flow.asInstanceOf[js.Any])).asInstanceOf[float]
inline def wrapperEMD(
  signature1: InputArray,
  signature2: InputArray,
  distType: int,
  cost: Unit,
  lowerBound: Unit,
  flow: OutputArray
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("wrapperEMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], lowerBound.asInstanceOf[js.Any], flow.asInstanceOf[js.Any])).asInstanceOf[float]
inline def wrapperEMD(signature1: InputArray, signature2: InputArray, distType: int, cost: InputArray): float = (^.asInstanceOf[js.Dynamic].applyDynamic("wrapperEMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any])).asInstanceOf[float]
inline def wrapperEMD(signature1: InputArray, signature2: InputArray, distType: int, cost: InputArray, lowerBound: Any): float = (^.asInstanceOf[js.Dynamic].applyDynamic("wrapperEMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], lowerBound.asInstanceOf[js.Any])).asInstanceOf[float]
inline def wrapperEMD(
  signature1: InputArray,
  signature2: InputArray,
  distType: int,
  cost: InputArray,
  lowerBound: Any,
  flow: OutputArray
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("wrapperEMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], lowerBound.asInstanceOf[js.Any], flow.asInstanceOf[js.Any])).asInstanceOf[float]
inline def wrapperEMD(
  signature1: InputArray,
  signature2: InputArray,
  distType: int,
  cost: InputArray,
  lowerBound: Unit,
  flow: OutputArray
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("wrapperEMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], lowerBound.asInstanceOf[js.Any], flow.asInstanceOf[js.Any])).asInstanceOf[float]

inline def writeOpticalFlow(path: Any, flow: InputArray): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("writeOpticalFlow")(path.asInstanceOf[js.Any], flow.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def writeTextGraph(model: Any, output: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("writeTextGraph")(model.asInstanceOf[js.Any], output.asInstanceOf[js.Any])).asInstanceOf[Unit]
