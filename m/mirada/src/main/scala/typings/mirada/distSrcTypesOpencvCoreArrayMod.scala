package typings.mirada

import typings.mirada.distSrcTypesOpencvHacksMod.bool
import typings.mirada.distSrcTypesOpencvHacksMod.double
import typings.mirada.distSrcTypesOpencvHacksMod.int
import typings.mirada.distSrcTypesOpencvHacksMod.sizeT
import typings.mirada.distSrcTypesOpencvTypesMod.InputArray
import typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays
import typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray
import typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArrayOfArrays
import typings.mirada.distSrcTypesOpencvTypesMod.Mat
import typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
import typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays
import typings.mirada.distSrcTypesOpencvTypesMod.Scalar
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object distSrcTypesOpencvCoreArrayMod {
  
  @JSImport("mirada/dist/src/types/opencv/core_array", JSImport.Namespace)
  @js.native
  val ^ : js.Any = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "BORDER_CONSTANT")
  @js.native
  val BORDER_CONSTANT: BorderTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "BORDER_DEFAULT")
  @js.native
  val BORDER_DEFAULT: BorderTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "BORDER_ISOLATED")
  @js.native
  val BORDER_ISOLATED: BorderTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "BORDER_REFLECT")
  @js.native
  val BORDER_REFLECT: BorderTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "BORDER_REFLECT101")
  @js.native
  val BORDER_REFLECT101: BorderTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "BORDER_REFLECT_101")
  @js.native
  val BORDER_REFLECT_101: BorderTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "BORDER_REPLICATE")
  @js.native
  val BORDER_REPLICATE: BorderTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "BORDER_TRANSPARENT")
  @js.native
  val BORDER_TRANSPARENT: BorderTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "BORDER_WRAP")
  @js.native
  val BORDER_WRAP: BorderTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "CMP_EQ")
  @js.native
  val CMP_EQ: CmpTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "CMP_GE")
  @js.native
  val CMP_GE: CmpTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "CMP_GT")
  @js.native
  val CMP_GT: CmpTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "CMP_LE")
  @js.native
  val CMP_LE: CmpTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "CMP_LT")
  @js.native
  val CMP_LT: CmpTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "CMP_NE")
  @js.native
  val CMP_NE: CmpTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "DCT_INVERSE")
  @js.native
  val DCT_INVERSE: DftFlags = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "DCT_ROWS")
  @js.native
  val DCT_ROWS: DftFlags = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "DECOMP_CHOLESKY")
  @js.native
  val DECOMP_CHOLESKY: DecompTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "DECOMP_EIG")
  @js.native
  val DECOMP_EIG: DecompTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "DECOMP_LU")
  @js.native
  val DECOMP_LU: DecompTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "DECOMP_NORMAL")
  @js.native
  val DECOMP_NORMAL: DecompTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "DECOMP_QR")
  @js.native
  val DECOMP_QR: DecompTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "DECOMP_SVD")
  @js.native
  val DECOMP_SVD: DecompTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "DFT_COMPLEX_INPUT")
  @js.native
  val DFT_COMPLEX_INPUT: DftFlags = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "DFT_COMPLEX_OUTPUT")
  @js.native
  val DFT_COMPLEX_OUTPUT: DftFlags = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "DFT_INVERSE")
  @js.native
  val DFT_INVERSE: DftFlags = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "DFT_REAL_OUTPUT")
  @js.native
  val DFT_REAL_OUTPUT: DftFlags = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "DFT_ROWS")
  @js.native
  val DFT_ROWS: DftFlags = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "DFT_SCALE")
  @js.native
  val DFT_SCALE: DftFlags = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "GEMM_1_T")
  @js.native
  val GEMM_1_T: GemmFlags = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "GEMM_2_T")
  @js.native
  val GEMM_2_T: GemmFlags = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "GEMM_3_T")
  @js.native
  val GEMM_3_T: GemmFlags = js.native
  
  inline def LUT(src: InputArray, lut: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("LUT")(src.asInstanceOf[js.Any], lut.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def Mahalanobis(v1: InputArray, v2: InputArray, icovar: InputArray): double = (^.asInstanceOf[js.Dynamic].applyDynamic("Mahalanobis")(v1.asInstanceOf[js.Any], v2.asInstanceOf[js.Any], icovar.asInstanceOf[js.Any])).asInstanceOf[double]
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "NORM_HAMMING")
  @js.native
  val NORM_HAMMING: NormTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "NORM_HAMMING2")
  @js.native
  val NORM_HAMMING2: NormTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "NORM_INF")
  @js.native
  val NORM_INF: NormTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "NORM_L1")
  @js.native
  val NORM_L1: NormTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "NORM_L2")
  @js.native
  val NORM_L2: NormTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "NORM_L2SQR")
  @js.native
  val NORM_L2SQR: NormTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "NORM_MINMAX")
  @js.native
  val NORM_MINMAX: NormTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "NORM_RELATIVE")
  @js.native
  val NORM_RELATIVE: NormTypes = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "NORM_TYPE_MASK")
  @js.native
  val NORM_TYPE_MASK: NormTypes = js.native
  
  inline def PCABackProject(data: InputArray, mean: InputArray, eigenvectors: InputArray, result: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("PCABackProject")(data.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], eigenvectors.asInstanceOf[js.Any], result.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def PCACompute(data: InputArray, mean: InputOutputArray, eigenvectors: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("PCACompute")(data.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], eigenvectors.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def PCACompute(data: InputArray, mean: InputOutputArray, eigenvectors: OutputArray, eigenvalues: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("PCACompute")(data.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], eigenvectors.asInstanceOf[js.Any], eigenvalues.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def PCACompute(
    data: InputArray,
    mean: InputOutputArray,
    eigenvectors: OutputArray,
    eigenvalues: OutputArray,
    maxComponents: double | int
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("PCACompute")(data.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], eigenvectors.asInstanceOf[js.Any], eigenvalues.asInstanceOf[js.Any], maxComponents.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def PCACompute(data: InputArray, mean: InputOutputArray, eigenvectors: OutputArray, maxComponents: double | int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("PCACompute")(data.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], eigenvectors.asInstanceOf[js.Any], maxComponents.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def PCAProject(data: InputArray, mean: InputArray, eigenvectors: InputArray, result: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("PCAProject")(data.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], eigenvectors.asInstanceOf[js.Any], result.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def PSNR(src1: InputArray, src2: InputArray): double = (^.asInstanceOf[js.Dynamic].applyDynamic("PSNR")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any])).asInstanceOf[double]
  inline def PSNR(src1: InputArray, src2: InputArray, R: double): double = (^.asInstanceOf[js.Dynamic].applyDynamic("PSNR")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], R.asInstanceOf[js.Any])).asInstanceOf[double]
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "ROTATE_180")
  @js.native
  val ROTATE_180: RotateFlags = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "ROTATE_90_CLOCKWISE")
  @js.native
  val ROTATE_90_CLOCKWISE: RotateFlags = js.native
  
  @JSImport("mirada/dist/src/types/opencv/core_array", "ROTATE_90_COUNTERCLOCKWISE")
  @js.native
  val ROTATE_90_COUNTERCLOCKWISE: RotateFlags = js.native
  
  inline def SVBackSubst(w: InputArray, u: InputArray, vt: InputArray, rhs: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("SVBackSubst")(w.asInstanceOf[js.Any], u.asInstanceOf[js.Any], vt.asInstanceOf[js.Any], rhs.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def SVDecomp(src: InputArray, w: OutputArray, u: OutputArray, vt: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("SVDecomp")(src.asInstanceOf[js.Any], w.asInstanceOf[js.Any], u.asInstanceOf[js.Any], vt.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def SVDecomp(src: InputArray, w: OutputArray, u: OutputArray, vt: OutputArray, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("SVDecomp")(src.asInstanceOf[js.Any], w.asInstanceOf[js.Any], u.asInstanceOf[js.Any], vt.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def absdiff(src1: InputArray, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("absdiff")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def add(src1: InputArray, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("add")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def add(src1: InputArray, src2: InputArray, dst: OutputArray, mask: Unit, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("add")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def add(src1: InputArray, src2: InputArray, dst: OutputArray, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("add")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def add(src1: InputArray, src2: InputArray, dst: OutputArray, mask: InputArray, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("add")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def addWeighted(src1: InputArray, alpha: double, src2: InputArray, beta: double, gamma: double, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("addWeighted")(src1.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], gamma.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def addWeighted(
    src1: InputArray,
    alpha: double,
    src2: InputArray,
    beta: double,
    gamma: double,
    dst: OutputArray,
    dtype: int
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("addWeighted")(src1.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], gamma.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def batchDistance(src1: InputArray, src2: InputArray, dist: OutputArray, dtype: int, nidx: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: Unit,
    K: Unit,
    mask: Unit,
    update: Unit,
    crosscheck: bool
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: Unit,
    K: Unit,
    mask: Unit,
    update: int
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: Unit,
    K: Unit,
    mask: Unit,
    update: int,
    crosscheck: bool
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: Unit,
    K: Unit,
    mask: InputArray
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: Unit,
    K: Unit,
    mask: InputArray,
    update: Unit,
    crosscheck: bool
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: Unit,
    K: Unit,
    mask: InputArray,
    update: int
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: Unit,
    K: Unit,
    mask: InputArray,
    update: int,
    crosscheck: bool
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: Unit,
    K: int
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: Unit,
    K: int,
    mask: Unit,
    update: Unit,
    crosscheck: bool
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: Unit,
    K: int,
    mask: Unit,
    update: int
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: Unit,
    K: int,
    mask: Unit,
    update: int,
    crosscheck: bool
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: Unit,
    K: int,
    mask: InputArray
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: Unit,
    K: int,
    mask: InputArray,
    update: Unit,
    crosscheck: bool
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: Unit,
    K: int,
    mask: InputArray,
    update: int
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: Unit,
    K: int,
    mask: InputArray,
    update: int,
    crosscheck: bool
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: int
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: int,
    K: Unit,
    mask: Unit,
    update: Unit,
    crosscheck: bool
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: int,
    K: Unit,
    mask: Unit,
    update: int
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: int,
    K: Unit,
    mask: Unit,
    update: int,
    crosscheck: bool
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: int,
    K: Unit,
    mask: InputArray
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: int,
    K: Unit,
    mask: InputArray,
    update: Unit,
    crosscheck: bool
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: int,
    K: Unit,
    mask: InputArray,
    update: int
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: int,
    K: Unit,
    mask: InputArray,
    update: int,
    crosscheck: bool
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: int,
    K: int
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: int,
    K: int,
    mask: Unit,
    update: Unit,
    crosscheck: bool
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: int,
    K: int,
    mask: Unit,
    update: int
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: int,
    K: int,
    mask: Unit,
    update: int,
    crosscheck: bool
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: int,
    K: int,
    mask: InputArray
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: int,
    K: int,
    mask: InputArray,
    update: Unit,
    crosscheck: bool
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: int,
    K: int,
    mask: InputArray,
    update: int
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def batchDistance(
    src1: InputArray,
    src2: InputArray,
    dist: OutputArray,
    dtype: int,
    nidx: OutputArray,
    normType: int,
    K: int,
    mask: InputArray,
    update: int,
    crosscheck: bool
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def bitwiseAnd(src1: InputArray, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bitwise_and")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def bitwiseAnd(src1: InputArray, src2: InputArray, dst: OutputArray, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bitwise_and")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def bitwiseNot(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bitwise_not")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def bitwiseNot(src: InputArray, dst: OutputArray, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bitwise_not")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def bitwiseOr(src1: InputArray, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bitwise_or")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def bitwiseOr(src1: InputArray, src2: InputArray, dst: OutputArray, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bitwise_or")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def bitwiseXor(src1: InputArray, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bitwise_xor")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def bitwiseXor(src1: InputArray, src2: InputArray, dst: OutputArray, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bitwise_xor")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def borderInterpolate(p: int, len: int, borderType: int): int = (^.asInstanceOf[js.Dynamic].applyDynamic("borderInterpolate")(p.asInstanceOf[js.Any], len.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[int]
  
  inline def calcCovarMatrix(samples: Any, nsamples: int, covar: Any, mean: Any, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcCovarMatrix")(samples.asInstanceOf[js.Any], nsamples.asInstanceOf[js.Any], covar.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def calcCovarMatrix(samples: Any, nsamples: int, covar: Any, mean: Any, flags: int, ctype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcCovarMatrix")(samples.asInstanceOf[js.Any], nsamples.asInstanceOf[js.Any], covar.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], ctype.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def calcCovarMatrix(samples: InputArray, covar: OutputArray, mean: InputOutputArray, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcCovarMatrix")(samples.asInstanceOf[js.Any], covar.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def calcCovarMatrix(samples: InputArray, covar: OutputArray, mean: InputOutputArray, flags: int, ctype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcCovarMatrix")(samples.asInstanceOf[js.Any], covar.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], ctype.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def cartToPolar(x: InputArray, y: InputArray, magnitude: OutputArray, angle: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cartToPolar")(x.asInstanceOf[js.Any], y.asInstanceOf[js.Any], magnitude.asInstanceOf[js.Any], angle.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def cartToPolar(x: InputArray, y: InputArray, magnitude: OutputArray, angle: OutputArray, angleInDegrees: bool): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cartToPolar")(x.asInstanceOf[js.Any], y.asInstanceOf[js.Any], magnitude.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], angleInDegrees.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def checkRange(a: InputArray): bool = ^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any]).asInstanceOf[bool]
  inline def checkRange(a: InputArray, quiet: Unit, pos: Any): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any])).asInstanceOf[bool]
  inline def checkRange(a: InputArray, quiet: Unit, pos: Any, minVal: Unit, maxVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[bool]
  inline def checkRange(a: InputArray, quiet: Unit, pos: Any, minVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any])).asInstanceOf[bool]
  inline def checkRange(a: InputArray, quiet: Unit, pos: Any, minVal: double, maxVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[bool]
  inline def checkRange(a: InputArray, quiet: Unit, pos: Unit, minVal: Unit, maxVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[bool]
  inline def checkRange(a: InputArray, quiet: Unit, pos: Unit, minVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any])).asInstanceOf[bool]
  inline def checkRange(a: InputArray, quiet: Unit, pos: Unit, minVal: double, maxVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[bool]
  inline def checkRange(a: InputArray, quiet: bool): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any])).asInstanceOf[bool]
  inline def checkRange(a: InputArray, quiet: bool, pos: Any): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any])).asInstanceOf[bool]
  inline def checkRange(a: InputArray, quiet: bool, pos: Any, minVal: Unit, maxVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[bool]
  inline def checkRange(a: InputArray, quiet: bool, pos: Any, minVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any])).asInstanceOf[bool]
  inline def checkRange(a: InputArray, quiet: bool, pos: Any, minVal: double, maxVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[bool]
  inline def checkRange(a: InputArray, quiet: bool, pos: Unit, minVal: Unit, maxVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[bool]
  inline def checkRange(a: InputArray, quiet: bool, pos: Unit, minVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any])).asInstanceOf[bool]
  inline def checkRange(a: InputArray, quiet: bool, pos: Unit, minVal: double, maxVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[bool]
  
  inline def compare(src1: InputArray, src2: InputArray, dst: OutputArray, cmpop: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("compare")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], cmpop.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def completeSymm(m: InputOutputArray): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("completeSymm")(m.asInstanceOf[js.Any]).asInstanceOf[Unit]
  inline def completeSymm(m: InputOutputArray, lowerToUpper: bool): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("completeSymm")(m.asInstanceOf[js.Any], lowerToUpper.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def convertFp16(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convertFp16")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def convertScaleAbs(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convertScaleAbs")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def convertScaleAbs(src: InputArray, dst: OutputArray, alpha: Unit, beta: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convertScaleAbs")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def convertScaleAbs(src: InputArray, dst: OutputArray, alpha: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convertScaleAbs")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def convertScaleAbs(src: InputArray, dst: OutputArray, alpha: double, beta: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convertScaleAbs")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def copyMakeBorder(src: InputArray, dst: OutputArray, top: int, bottom: int, left: int, right: int, borderType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("copyMakeBorder")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], top.asInstanceOf[js.Any], bottom.asInstanceOf[js.Any], left.asInstanceOf[js.Any], right.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def copyMakeBorder(
    src: InputArray,
    dst: OutputArray,
    top: int,
    bottom: int,
    left: int,
    right: int,
    borderType: int,
    value: Any
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("copyMakeBorder")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], top.asInstanceOf[js.Any], bottom.asInstanceOf[js.Any], left.asInstanceOf[js.Any], right.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], value.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def copyTo(src: InputArray, dst: OutputArray, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("copyTo")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def countNonZero(src: InputArray): int = ^.asInstanceOf[js.Dynamic].applyDynamic("countNonZero")(src.asInstanceOf[js.Any]).asInstanceOf[int]
  
  inline def dct(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dct")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def dct(src: InputArray, dst: OutputArray, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dct")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def determinant(mtx: InputArray): double = ^.asInstanceOf[js.Dynamic].applyDynamic("determinant")(mtx.asInstanceOf[js.Any]).asInstanceOf[double]
  
  inline def dft(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dft")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def dft(src: InputArray, dst: OutputArray, flags: Unit, nonzeroRows: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dft")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], nonzeroRows.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def dft(src: InputArray, dst: OutputArray, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dft")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def dft(src: InputArray, dst: OutputArray, flags: int, nonzeroRows: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dft")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], nonzeroRows.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def divide(scale: double, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("divide")(scale.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def divide(scale: double, src2: InputArray, dst: OutputArray, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("divide")(scale.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def divide(src1: InputArray, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("divide")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def divide(src1: InputArray, src2: InputArray, dst: OutputArray, scale: Unit, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("divide")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def divide(src1: InputArray, src2: InputArray, dst: OutputArray, scale: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("divide")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def divide(src1: InputArray, src2: InputArray, dst: OutputArray, scale: double, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("divide")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def eigen(src: InputArray, eigenvalues: OutputArray): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("eigen")(src.asInstanceOf[js.Any], eigenvalues.asInstanceOf[js.Any])).asInstanceOf[bool]
  inline def eigen(src: InputArray, eigenvalues: OutputArray, eigenvectors: OutputArray): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("eigen")(src.asInstanceOf[js.Any], eigenvalues.asInstanceOf[js.Any], eigenvectors.asInstanceOf[js.Any])).asInstanceOf[bool]
  
  inline def eigenNonSymmetric(src: InputArray, eigenvalues: OutputArray, eigenvectors: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("eigenNonSymmetric")(src.asInstanceOf[js.Any], eigenvalues.asInstanceOf[js.Any], eigenvectors.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def exp(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("exp")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def extractChannel(src: InputArray, dst: OutputArray, coi: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("extractChannel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], coi.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def findNonZero(src: InputArray, idx: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("findNonZero")(src.asInstanceOf[js.Any], idx.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def flip(src: InputArray, dst: OutputArray, flipCode: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("flip")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flipCode.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def gemm(
    src1: InputArray,
    src2: InputArray,
    alpha: double,
    src3: InputArray,
    beta: double,
    dst: OutputArray
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("gemm")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], src3.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def gemm(
    src1: InputArray,
    src2: InputArray,
    alpha: double,
    src3: InputArray,
    beta: double,
    dst: OutputArray,
    flags: int
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("gemm")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], src3.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def getOptimalDFTSize(vecsize: int): int = ^.asInstanceOf[js.Dynamic].applyDynamic("getOptimalDFTSize")(vecsize.asInstanceOf[js.Any]).asInstanceOf[int]
  
  inline def hconcat(src1: InputArray, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("hconcat")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def hconcat(src: Any, nsrc: sizeT, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("hconcat")(src.asInstanceOf[js.Any], nsrc.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def hconcat(src: InputArrayOfArrays, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("hconcat")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def idct(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("idct")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def idct(src: InputArray, dst: OutputArray, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("idct")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def idft(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("idft")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def idft(src: InputArray, dst: OutputArray, flags: Unit, nonzeroRows: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("idft")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], nonzeroRows.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def idft(src: InputArray, dst: OutputArray, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("idft")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def idft(src: InputArray, dst: OutputArray, flags: int, nonzeroRows: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("idft")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], nonzeroRows.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def inRange(src: InputArray, lowerb: InputArray, upperb: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("inRange")(src.asInstanceOf[js.Any], lowerb.asInstanceOf[js.Any], upperb.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def insertChannel(src: InputArray, dst: InputOutputArray, coi: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("insertChannel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], coi.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def invert(src: InputArray, dst: OutputArray): double = (^.asInstanceOf[js.Dynamic].applyDynamic("invert")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[double]
  inline def invert(src: InputArray, dst: OutputArray, flags: int): double = (^.asInstanceOf[js.Dynamic].applyDynamic("invert")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[double]
  
  inline def log(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("log")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def magnitude(x: InputArray, y: InputArray, magnitude: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("magnitude")(x.asInstanceOf[js.Any], y.asInstanceOf[js.Any], magnitude.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def max(src1: Any, src2: Any, dst: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("max")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def max(src1: InputArray, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("max")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def mean(src: InputArray): Scalar = ^.asInstanceOf[js.Dynamic].applyDynamic("mean")(src.asInstanceOf[js.Any]).asInstanceOf[Scalar]
  inline def mean(src: InputArray, mask: InputArray): Scalar = (^.asInstanceOf[js.Dynamic].applyDynamic("mean")(src.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Scalar]
  
  inline def meanStdDev(src: InputArray, mean: OutputArray, stddev: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("meanStdDev")(src.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], stddev.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def meanStdDev(src: InputArray, mean: OutputArray, stddev: OutputArray, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("meanStdDev")(src.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], stddev.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def merge(mv: Any, count: sizeT, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("merge")(mv.asInstanceOf[js.Any], count.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def merge(mv: InputArrayOfArrays, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("merge")(mv.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def min(src1: Any, src2: Any, dst: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("min")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def min(src1: InputArray, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("min")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def minMaxIdx(src: InputArray, minVal: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Any, minIdx: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Any, minIdx: Any, maxIdx: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Any, minIdx: Any, maxIdx: Any, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Any, minIdx: Any, maxIdx: Unit, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Any, minIdx: Unit, maxIdx: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Any, minIdx: Unit, maxIdx: Any, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Any, minIdx: Unit, maxIdx: Unit, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Unit, minIdx: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Unit, minIdx: Any, maxIdx: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Unit, minIdx: Any, maxIdx: Any, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Unit, minIdx: Any, maxIdx: Unit, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Unit, minIdx: Unit, maxIdx: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Unit, minIdx: Unit, maxIdx: Any, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxIdx(src: InputArray, minVal: Any, maxVal: Unit, minIdx: Unit, maxIdx: Unit, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def minMaxLoc(a: Any, minVal: Any, maxVal: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(a.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxLoc(a: Any, minVal: Any, maxVal: Any, minIdx: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(a.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxLoc(a: Any, minVal: Any, maxVal: Any, minIdx: Any, maxIdx: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(a.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxLoc(a: Any, minVal: Any, maxVal: Any, minIdx: Unit, maxIdx: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(a.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxLoc(src: InputArray, minVal: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Any, minLoc: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Any, minLoc: Any, maxLoc: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Any, minLoc: Any, maxLoc: Any, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Any, minLoc: Any, maxLoc: Unit, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Any, minLoc: Unit, maxLoc: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Any, minLoc: Unit, maxLoc: Any, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Any, minLoc: Unit, maxLoc: Unit, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Unit, minLoc: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Unit, minLoc: Any, maxLoc: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Unit, minLoc: Any, maxLoc: Any, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Unit, minLoc: Any, maxLoc: Unit, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Unit, minLoc: Unit, maxLoc: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Unit, minLoc: Unit, maxLoc: Any, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def minMaxLoc(src: InputArray, minVal: Any, maxVal: Unit, minLoc: Unit, maxLoc: Unit, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def mixChannels(src: Any, nsrcs: sizeT, dst: Any, ndsts: sizeT, fromTo: Any, npairs: sizeT): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mixChannels")(src.asInstanceOf[js.Any], nsrcs.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ndsts.asInstanceOf[js.Any], fromTo.asInstanceOf[js.Any], npairs.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def mixChannels(src: InputArrayOfArrays, dst: InputOutputArrayOfArrays, fromTo: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mixChannels")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], fromTo.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def mixChannels(src: InputArrayOfArrays, dst: InputOutputArrayOfArrays, fromTo: Any, npairs: sizeT): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mixChannels")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], fromTo.asInstanceOf[js.Any], npairs.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def mulSpectrums(a: InputArray, b: InputArray, c: OutputArray, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulSpectrums")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any], c.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def mulSpectrums(a: InputArray, b: InputArray, c: OutputArray, flags: int, conjB: bool): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulSpectrums")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any], c.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], conjB.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def mulTransposed(src: InputArray, dst: OutputArray, aTa: bool): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulTransposed")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], aTa.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def mulTransposed(src: InputArray, dst: OutputArray, aTa: bool, delta: Unit, scale: Unit, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulTransposed")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], aTa.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def mulTransposed(src: InputArray, dst: OutputArray, aTa: bool, delta: Unit, scale: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulTransposed")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], aTa.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def mulTransposed(src: InputArray, dst: OutputArray, aTa: bool, delta: Unit, scale: double, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulTransposed")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], aTa.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def mulTransposed(src: InputArray, dst: OutputArray, aTa: bool, delta: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulTransposed")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], aTa.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def mulTransposed(src: InputArray, dst: OutputArray, aTa: bool, delta: InputArray, scale: Unit, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulTransposed")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], aTa.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def mulTransposed(src: InputArray, dst: OutputArray, aTa: bool, delta: InputArray, scale: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulTransposed")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], aTa.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def mulTransposed(src: InputArray, dst: OutputArray, aTa: bool, delta: InputArray, scale: double, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulTransposed")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], aTa.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def multiply(src1: InputArray, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("multiply")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def multiply(src1: InputArray, src2: InputArray, dst: OutputArray, scale: Unit, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("multiply")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def multiply(src1: InputArray, src2: InputArray, dst: OutputArray, scale: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("multiply")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def multiply(src1: InputArray, src2: InputArray, dst: OutputArray, scale: double, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("multiply")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def norm(src1: InputArray): double = ^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src1.asInstanceOf[js.Any]).asInstanceOf[double]
  inline def norm(src1: InputArray, normType: Unit, mask: InputArray): double = (^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src1.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[double]
  inline def norm(src1: InputArray, normType: int): double = (^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src1.asInstanceOf[js.Any], normType.asInstanceOf[js.Any])).asInstanceOf[double]
  inline def norm(src1: InputArray, normType: int, mask: InputArray): double = (^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src1.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[double]
  inline def norm(src1: InputArray, src2: InputArray): double = (^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any])).asInstanceOf[double]
  inline def norm(src1: InputArray, src2: InputArray, normType: Unit, mask: InputArray): double = (^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[double]
  inline def norm(src1: InputArray, src2: InputArray, normType: int): double = (^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], normType.asInstanceOf[js.Any])).asInstanceOf[double]
  inline def norm(src1: InputArray, src2: InputArray, normType: int, mask: InputArray): double = (^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[double]
  inline def norm(src: Any, normType: int): double = (^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src.asInstanceOf[js.Any], normType.asInstanceOf[js.Any])).asInstanceOf[double]
  
  inline def normalize(src: Any, dst: Any, alpha: double, normType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], normType.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(src: InputArray, dst: InputOutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(
    src: InputArray,
    dst: InputOutputArray,
    alpha: Unit,
    beta: Unit,
    norm_type: Unit,
    dtype: Unit,
    mask: InputArray
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(src: InputArray, dst: InputOutputArray, alpha: Unit, beta: Unit, norm_type: Unit, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(
    src: InputArray,
    dst: InputOutputArray,
    alpha: Unit,
    beta: Unit,
    norm_type: Unit,
    dtype: int,
    mask: InputArray
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(src: InputArray, dst: InputOutputArray, alpha: Unit, beta: Unit, norm_type: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(
    src: InputArray,
    dst: InputOutputArray,
    alpha: Unit,
    beta: Unit,
    norm_type: int,
    dtype: Unit,
    mask: InputArray
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(src: InputArray, dst: InputOutputArray, alpha: Unit, beta: Unit, norm_type: int, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(
    src: InputArray,
    dst: InputOutputArray,
    alpha: Unit,
    beta: Unit,
    norm_type: int,
    dtype: int,
    mask: InputArray
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(src: InputArray, dst: InputOutputArray, alpha: Unit, beta: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(
    src: InputArray,
    dst: InputOutputArray,
    alpha: Unit,
    beta: double,
    norm_type: Unit,
    dtype: Unit,
    mask: InputArray
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(src: InputArray, dst: InputOutputArray, alpha: Unit, beta: double, norm_type: Unit, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(
    src: InputArray,
    dst: InputOutputArray,
    alpha: Unit,
    beta: double,
    norm_type: Unit,
    dtype: int,
    mask: InputArray
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(src: InputArray, dst: InputOutputArray, alpha: Unit, beta: double, norm_type: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(
    src: InputArray,
    dst: InputOutputArray,
    alpha: Unit,
    beta: double,
    norm_type: int,
    dtype: Unit,
    mask: InputArray
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(src: InputArray, dst: InputOutputArray, alpha: Unit, beta: double, norm_type: int, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(
    src: InputArray,
    dst: InputOutputArray,
    alpha: Unit,
    beta: double,
    norm_type: int,
    dtype: int,
    mask: InputArray
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(src: InputArray, dst: InputOutputArray, alpha: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(
    src: InputArray,
    dst: InputOutputArray,
    alpha: double,
    beta: Unit,
    norm_type: Unit,
    dtype: Unit,
    mask: InputArray
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(src: InputArray, dst: InputOutputArray, alpha: double, beta: Unit, norm_type: Unit, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(
    src: InputArray,
    dst: InputOutputArray,
    alpha: double,
    beta: Unit,
    norm_type: Unit,
    dtype: int,
    mask: InputArray
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(src: InputArray, dst: InputOutputArray, alpha: double, beta: Unit, norm_type: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(
    src: InputArray,
    dst: InputOutputArray,
    alpha: double,
    beta: Unit,
    norm_type: int,
    dtype: Unit,
    mask: InputArray
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(src: InputArray, dst: InputOutputArray, alpha: double, beta: Unit, norm_type: int, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(
    src: InputArray,
    dst: InputOutputArray,
    alpha: double,
    beta: Unit,
    norm_type: int,
    dtype: int,
    mask: InputArray
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(src: InputArray, dst: InputOutputArray, alpha: double, beta: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(
    src: InputArray,
    dst: InputOutputArray,
    alpha: double,
    beta: double,
    norm_type: Unit,
    dtype: Unit,
    mask: InputArray
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(src: InputArray, dst: InputOutputArray, alpha: double, beta: double, norm_type: Unit, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(
    src: InputArray,
    dst: InputOutputArray,
    alpha: double,
    beta: double,
    norm_type: Unit,
    dtype: int,
    mask: InputArray
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(src: InputArray, dst: InputOutputArray, alpha: double, beta: double, norm_type: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(
    src: InputArray,
    dst: InputOutputArray,
    alpha: double,
    beta: double,
    norm_type: int,
    dtype: Unit,
    mask: InputArray
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(src: InputArray, dst: InputOutputArray, alpha: double, beta: double, norm_type: int, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def normalize(
    src: InputArray,
    dst: InputOutputArray,
    alpha: double,
    beta: double,
    norm_type: int,
    dtype: int,
    mask: InputArray
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def patchNaNs(a: InputOutputArray): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("patchNaNs")(a.asInstanceOf[js.Any]).asInstanceOf[Unit]
  inline def patchNaNs(a: InputOutputArray, `val`: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("patchNaNs")(a.asInstanceOf[js.Any], `val`.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def perspectiveTransform(src: InputArray, dst: OutputArray, m: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("perspectiveTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], m.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def phase(x: InputArray, y: InputArray, angle: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("phase")(x.asInstanceOf[js.Any], y.asInstanceOf[js.Any], angle.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def phase(x: InputArray, y: InputArray, angle: OutputArray, angleInDegrees: bool): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("phase")(x.asInstanceOf[js.Any], y.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], angleInDegrees.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def polarToCart(magnitude: InputArray, angle: InputArray, x: OutputArray, y: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polarToCart")(magnitude.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], x.asInstanceOf[js.Any], y.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def polarToCart(magnitude: InputArray, angle: InputArray, x: OutputArray, y: OutputArray, angleInDegrees: bool): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polarToCart")(magnitude.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], x.asInstanceOf[js.Any], y.asInstanceOf[js.Any], angleInDegrees.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def pow(src: InputArray, power: double, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pow")(src.asInstanceOf[js.Any], power.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def randShuffle(dst: InputOutputArray): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("randShuffle")(dst.asInstanceOf[js.Any]).asInstanceOf[Unit]
  inline def randShuffle(dst: InputOutputArray, iterFactor: Unit, rng: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("randShuffle")(dst.asInstanceOf[js.Any], iterFactor.asInstanceOf[js.Any], rng.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def randShuffle(dst: InputOutputArray, iterFactor: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("randShuffle")(dst.asInstanceOf[js.Any], iterFactor.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def randShuffle(dst: InputOutputArray, iterFactor: double, rng: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("randShuffle")(dst.asInstanceOf[js.Any], iterFactor.asInstanceOf[js.Any], rng.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def randn(dst: InputOutputArray, mean: InputArray, stddev: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("randn")(dst.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], stddev.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def randu(dst: InputOutputArray, low: InputArray, high: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("randu")(dst.asInstanceOf[js.Any], low.asInstanceOf[js.Any], high.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def reduce(src: InputArray, dst: OutputArray, dim: int, rtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("reduce")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dim.asInstanceOf[js.Any], rtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def reduce(src: InputArray, dst: OutputArray, dim: int, rtype: int, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("reduce")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dim.asInstanceOf[js.Any], rtype.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def repeat(src: Any, ny: int, nx: int): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("repeat")(src.asInstanceOf[js.Any], ny.asInstanceOf[js.Any], nx.asInstanceOf[js.Any])).asInstanceOf[Mat]
  inline def repeat(src: InputArray, ny: int, nx: int, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("repeat")(src.asInstanceOf[js.Any], ny.asInstanceOf[js.Any], nx.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def rotate(src: InputArray, dst: OutputArray, rotateCode: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rotate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], rotateCode.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def scaleAdd(src1: InputArray, alpha: double, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleAdd")(src1.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def setIdentity(mtx: InputOutputArray): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("setIdentity")(mtx.asInstanceOf[js.Any]).asInstanceOf[Unit]
  inline def setIdentity(mtx: InputOutputArray, s: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("setIdentity")(mtx.asInstanceOf[js.Any], s.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def setRNGSeed(seed: int): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("setRNGSeed")(seed.asInstanceOf[js.Any]).asInstanceOf[Unit]
  
  inline def solve(src1: InputArray, src2: InputArray, dst: OutputArray): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("solve")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[bool]
  inline def solve(src1: InputArray, src2: InputArray, dst: OutputArray, flags: int): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("solve")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[bool]
  
  inline def solveCubic(coeffs: InputArray, roots: OutputArray): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solveCubic")(coeffs.asInstanceOf[js.Any], roots.asInstanceOf[js.Any])).asInstanceOf[int]
  
  inline def solvePoly(coeffs: InputArray, roots: OutputArray): double = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePoly")(coeffs.asInstanceOf[js.Any], roots.asInstanceOf[js.Any])).asInstanceOf[double]
  inline def solvePoly(coeffs: InputArray, roots: OutputArray, maxIters: int): double = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePoly")(coeffs.asInstanceOf[js.Any], roots.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any])).asInstanceOf[double]
  
  inline def sort(src: InputArray, dst: OutputArray, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sort")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def sortIdx(src: InputArray, dst: OutputArray, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sortIdx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def split(m: InputArray, mv: OutputArrayOfArrays): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("split")(m.asInstanceOf[js.Any], mv.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def split(src: Any, mvbegin: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("split")(src.asInstanceOf[js.Any], mvbegin.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def sqrt(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sqrt")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def subtract(src1: InputArray, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("subtract")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def subtract(src1: InputArray, src2: InputArray, dst: OutputArray, mask: Unit, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("subtract")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def subtract(src1: InputArray, src2: InputArray, dst: OutputArray, mask: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("subtract")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def subtract(src1: InputArray, src2: InputArray, dst: OutputArray, mask: InputArray, dtype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("subtract")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def sum(src: InputArray): Scalar = ^.asInstanceOf[js.Dynamic].applyDynamic("sum")(src.asInstanceOf[js.Any]).asInstanceOf[Scalar]
  
  inline def theRNG(): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("theRNG")().asInstanceOf[Any]
  
  inline def trace(mtx: InputArray): Scalar = ^.asInstanceOf[js.Dynamic].applyDynamic("trace")(mtx.asInstanceOf[js.Any]).asInstanceOf[Scalar]
  
  inline def transform(src: InputArray, dst: OutputArray, m: InputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("transform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], m.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def transpose(src: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("transpose")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def vconcat(src1: InputArray, src2: InputArray, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("vconcat")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def vconcat(src: Any, nsrc: sizeT, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("vconcat")(src.asInstanceOf[js.Any], nsrc.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def vconcat(src: InputArrayOfArrays, dst: OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("vconcat")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  type BorderTypes = Any
  
  type CmpTypes = Any
  
  type DecompTypes = Any
  
  type DftFlags = Any
  
  type GemmFlags = Any
  
  type NormTypes = Any
  
  type RotateFlags = Any
}
