package typings.mirada.distSrcTypesOpencvMod

import typings.mirada.distSrcTypesOpencvCalib3dMod.HandEyeCalibrationMethod
import typings.mirada.distSrcTypesOpencvCalib3dMod.SolvePnPMethod
import typings.mirada.distSrcTypesOpencvCalib3dMod.UndistortTypes
import typings.mirada.distSrcTypesOpencvCoreArrayMod.BorderTypes
import typings.mirada.distSrcTypesOpencvCoreArrayMod.CmpTypes
import typings.mirada.distSrcTypesOpencvCoreArrayMod.DecompTypes
import typings.mirada.distSrcTypesOpencvCoreArrayMod.DftFlags
import typings.mirada.distSrcTypesOpencvCoreArrayMod.GemmFlags
import typings.mirada.distSrcTypesOpencvCoreArrayMod.NormTypes
import typings.mirada.distSrcTypesOpencvCoreArrayMod.RotateFlags
import typings.mirada.distSrcTypesOpencvCoreUtilsMod.CpuFeatures
import typings.mirada.distSrcTypesOpencvCoreUtilsMod.SortFlags
import typings.mirada.distSrcTypesOpencvDescriptorMatcherMod.MatcherType
import typings.mirada.distSrcTypesOpencvDnnMod.Backend
import typings.mirada.distSrcTypesOpencvDnnMod.Target
import typings.mirada.distSrcTypesOpencvFeatures2dDrawMod.DrawMatchesFlags
import typings.mirada.distSrcTypesOpencvHacksMod.AsyncArray
import typings.mirada.distSrcTypesOpencvHacksMod.CVDataType
import typings.mirada.distSrcTypesOpencvHacksMod.EqPredicate
import typings.mirada.distSrcTypesOpencvHacksMod.ErrorCallback
import typings.mirada.distSrcTypesOpencvHacksMod.Moments
import typings.mirada.distSrcTypesOpencvHacksMod.Net
import typings.mirada.distSrcTypesOpencvHacksMod.Tp
import typings.mirada.distSrcTypesOpencvHacksMod.bool
import typings.mirada.distSrcTypesOpencvHacksMod.cvhalDFT
import typings.mirada.distSrcTypesOpencvHacksMod.double
import typings.mirada.distSrcTypesOpencvHacksMod.float
import typings.mirada.distSrcTypesOpencvHacksMod.float16T
import typings.mirada.distSrcTypesOpencvHacksMod.int
import typings.mirada.distSrcTypesOpencvHacksMod.int64
import typings.mirada.distSrcTypesOpencvHacksMod.schar
import typings.mirada.distSrcTypesOpencvHacksMod.short
import typings.mirada.distSrcTypesOpencvHacksMod.sizeT
import typings.mirada.distSrcTypesOpencvHacksMod.uchar
import typings.mirada.distSrcTypesOpencvHacksMod.uint64
import typings.mirada.distSrcTypesOpencvHacksMod.unsigned
import typings.mirada.distSrcTypesOpencvHacksMod.ushort
import typings.mirada.distSrcTypesOpencvHogdescriptorMod.DescriptorStorageFormat
import typings.mirada.distSrcTypesOpencvHogdescriptorMod.HistogramNormType
import typings.mirada.distSrcTypesOpencvImgprocColorConversionsMod.ColorConversionCodes
import typings.mirada.distSrcTypesOpencvImgprocDrawMod.HersheyFonts
import typings.mirada.distSrcTypesOpencvImgprocDrawMod.LineTypes
import typings.mirada.distSrcTypesOpencvImgprocDrawMod.MarkerTypes
import typings.mirada.distSrcTypesOpencvImgprocFeatureMod.HoughModes
import typings.mirada.distSrcTypesOpencvImgprocFeatureMod.LineSegmentDetectorModes
import typings.mirada.distSrcTypesOpencvImgprocFilterMod.MorphShapes
import typings.mirada.distSrcTypesOpencvImgprocFilterMod.MorphTypes
import typings.mirada.distSrcTypesOpencvImgprocFilterMod.SpecialFilter
import typings.mirada.distSrcTypesOpencvImgprocHistMod.HistCompMethods
import typings.mirada.distSrcTypesOpencvImgprocMiscMod.AdaptiveThresholdTypes
import typings.mirada.distSrcTypesOpencvImgprocMiscMod.DistanceTransformLabelTypes
import typings.mirada.distSrcTypesOpencvImgprocMiscMod.DistanceTransformMasks
import typings.mirada.distSrcTypesOpencvImgprocMiscMod.DistanceTypes
import typings.mirada.distSrcTypesOpencvImgprocMiscMod.FloodFillFlags
import typings.mirada.distSrcTypesOpencvImgprocMiscMod.GrabCutClasses
import typings.mirada.distSrcTypesOpencvImgprocMiscMod.GrabCutModes
import typings.mirada.distSrcTypesOpencvImgprocMiscMod.ThresholdTypes
import typings.mirada.distSrcTypesOpencvImgprocObjectMod.TemplateMatchModes
import typings.mirada.distSrcTypesOpencvImgprocShapeMod.ConnectedComponentsAlgorithmsTypes
import typings.mirada.distSrcTypesOpencvImgprocShapeMod.ConnectedComponentsTypes
import typings.mirada.distSrcTypesOpencvImgprocShapeMod.ContourApproximationModes
import typings.mirada.distSrcTypesOpencvImgprocShapeMod.RectanglesIntersectTypes
import typings.mirada.distSrcTypesOpencvImgprocShapeMod.RetrievalModes
import typings.mirada.distSrcTypesOpencvImgprocShapeMod.ShapeMatchModes
import typings.mirada.distSrcTypesOpencvImgprocTransformMod.InterpolationFlags
import typings.mirada.distSrcTypesOpencvImgprocTransformMod.InterpolationMasks
import typings.mirada.distSrcTypesOpencvImgprocTransformMod.WarpPolarMode
import typings.mirada.distSrcTypesOpencvLshTableMod.SpeedLevel
import typings.mirada.distSrcTypesOpencvMod.^
import typings.mirada.distSrcTypesOpencvPcaMod.Flags
import typings.std.HTMLElement
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}


inline def ADAPTIVE_THRESH_GAUSSIAN_C: AdaptiveThresholdTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("ADAPTIVE_THRESH_GAUSSIAN_C").asInstanceOf[AdaptiveThresholdTypes]

inline def ADAPTIVE_THRESH_MEAN_C: AdaptiveThresholdTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("ADAPTIVE_THRESH_MEAN_C").asInstanceOf[AdaptiveThresholdTypes]

inline def AUTO_STEP: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("AUTO_STEP").asInstanceOf[Any]

inline def BORDER_CONSTANT: BorderTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("BORDER_CONSTANT").asInstanceOf[BorderTypes]

inline def BORDER_DEFAULT: BorderTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("BORDER_DEFAULT").asInstanceOf[BorderTypes]

inline def BORDER_ISOLATED: BorderTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("BORDER_ISOLATED").asInstanceOf[BorderTypes]

inline def BORDER_REFLECT: BorderTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("BORDER_REFLECT").asInstanceOf[BorderTypes]

inline def BORDER_REFLECT101: BorderTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("BORDER_REFLECT101").asInstanceOf[BorderTypes]

inline def BORDER_REFLECT_101: BorderTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("BORDER_REFLECT_101").asInstanceOf[BorderTypes]

inline def BORDER_REPLICATE: BorderTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("BORDER_REPLICATE").asInstanceOf[BorderTypes]

inline def BORDER_TRANSPARENT: BorderTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("BORDER_TRANSPARENT").asInstanceOf[BorderTypes]

inline def BORDER_WRAP: BorderTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("BORDER_WRAP").asInstanceOf[BorderTypes]

inline def BRUTEFORCE: MatcherType = ^.asInstanceOf[js.Dynamic].selectDynamic("BRUTEFORCE").asInstanceOf[MatcherType]

inline def BRUTEFORCE_HAMMING: MatcherType = ^.asInstanceOf[js.Dynamic].selectDynamic("BRUTEFORCE_HAMMING").asInstanceOf[MatcherType]

inline def BRUTEFORCE_HAMMINGLUT: MatcherType = ^.asInstanceOf[js.Dynamic].selectDynamic("BRUTEFORCE_HAMMINGLUT").asInstanceOf[MatcherType]

inline def BRUTEFORCE_L1: MatcherType = ^.asInstanceOf[js.Dynamic].selectDynamic("BRUTEFORCE_L1").asInstanceOf[MatcherType]

inline def BRUTEFORCE_SL2: MatcherType = ^.asInstanceOf[js.Dynamic].selectDynamic("BRUTEFORCE_SL2").asInstanceOf[MatcherType]

inline def CALIB_CB_ACCURACY: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_CB_ACCURACY").asInstanceOf[Any]

inline def CALIB_CB_ADAPTIVE_THRESH: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_CB_ADAPTIVE_THRESH").asInstanceOf[Any]

inline def CALIB_CB_ASYMMETRIC_GRID: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_CB_ASYMMETRIC_GRID").asInstanceOf[Any]

inline def CALIB_CB_CLUSTERING: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_CB_CLUSTERING").asInstanceOf[Any]

inline def CALIB_CB_EXHAUSTIVE: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_CB_EXHAUSTIVE").asInstanceOf[Any]

inline def CALIB_CB_FAST_CHECK: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_CB_FAST_CHECK").asInstanceOf[Any]

inline def CALIB_CB_FILTER_QUADS: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_CB_FILTER_QUADS").asInstanceOf[Any]

inline def CALIB_CB_NORMALIZE_IMAGE: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_CB_NORMALIZE_IMAGE").asInstanceOf[Any]

inline def CALIB_CB_SYMMETRIC_GRID: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_CB_SYMMETRIC_GRID").asInstanceOf[Any]

inline def CALIB_FIX_ASPECT_RATIO: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_FIX_ASPECT_RATIO").asInstanceOf[Any]

inline def CALIB_FIX_FOCAL_LENGTH: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_FIX_FOCAL_LENGTH").asInstanceOf[Any]

inline def CALIB_FIX_INTRINSIC: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_FIX_INTRINSIC").asInstanceOf[Any]

inline def CALIB_FIX_K1: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_FIX_K1").asInstanceOf[Any]

inline def CALIB_FIX_K2: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_FIX_K2").asInstanceOf[Any]

inline def CALIB_FIX_K3: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_FIX_K3").asInstanceOf[Any]

inline def CALIB_FIX_K4: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_FIX_K4").asInstanceOf[Any]

inline def CALIB_FIX_K5: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_FIX_K5").asInstanceOf[Any]

inline def CALIB_FIX_K6: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_FIX_K6").asInstanceOf[Any]

inline def CALIB_FIX_PRINCIPAL_POINT: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_FIX_PRINCIPAL_POINT").asInstanceOf[Any]

inline def CALIB_FIX_S1_S2_S3_S4: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_FIX_S1_S2_S3_S4").asInstanceOf[Any]

inline def CALIB_FIX_TANGENT_DIST: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_FIX_TANGENT_DIST").asInstanceOf[Any]

inline def CALIB_FIX_TAUX_TAUY: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_FIX_TAUX_TAUY").asInstanceOf[Any]

inline def CALIB_HAND_EYE_ANDREFF: HandEyeCalibrationMethod = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_HAND_EYE_ANDREFF").asInstanceOf[HandEyeCalibrationMethod]

inline def CALIB_HAND_EYE_DANIILIDIS: HandEyeCalibrationMethod = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_HAND_EYE_DANIILIDIS").asInstanceOf[HandEyeCalibrationMethod]

inline def CALIB_HAND_EYE_HORAUD: HandEyeCalibrationMethod = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_HAND_EYE_HORAUD").asInstanceOf[HandEyeCalibrationMethod]

inline def CALIB_HAND_EYE_PARK: HandEyeCalibrationMethod = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_HAND_EYE_PARK").asInstanceOf[HandEyeCalibrationMethod]

inline def CALIB_HAND_EYE_TSAI: HandEyeCalibrationMethod = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_HAND_EYE_TSAI").asInstanceOf[HandEyeCalibrationMethod]

inline def CALIB_NINTRINSIC: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_NINTRINSIC").asInstanceOf[Any]

inline def CALIB_RATIONAL_MODEL: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_RATIONAL_MODEL").asInstanceOf[Any]

inline def CALIB_SAME_FOCAL_LENGTH: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_SAME_FOCAL_LENGTH").asInstanceOf[Any]

inline def CALIB_THIN_PRISM_MODEL: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_THIN_PRISM_MODEL").asInstanceOf[Any]

inline def CALIB_TILTED_MODEL: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_TILTED_MODEL").asInstanceOf[Any]

inline def CALIB_USE_EXTRINSIC_GUESS: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_USE_EXTRINSIC_GUESS").asInstanceOf[Any]

inline def CALIB_USE_INTRINSIC_GUESS: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_USE_INTRINSIC_GUESS").asInstanceOf[Any]

inline def CALIB_USE_LU: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_USE_LU").asInstanceOf[Any]

inline def CALIB_USE_QR: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_USE_QR").asInstanceOf[Any]

inline def CALIB_ZERO_DISPARITY: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_ZERO_DISPARITY").asInstanceOf[Any]

inline def CALIB_ZERO_TANGENT_DIST: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CALIB_ZERO_TANGENT_DIST").asInstanceOf[Any]

inline def CASCADE_DO_CANNY_PRUNING: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CASCADE_DO_CANNY_PRUNING").asInstanceOf[Any]

inline def CASCADE_DO_ROUGH_SEARCH: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CASCADE_DO_ROUGH_SEARCH").asInstanceOf[Any]

inline def CASCADE_FIND_BIGGEST_OBJECT: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CASCADE_FIND_BIGGEST_OBJECT").asInstanceOf[Any]

inline def CASCADE_SCALE_IMAGE: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CASCADE_SCALE_IMAGE").asInstanceOf[Any]

inline def CCL_DEFAULT: ConnectedComponentsAlgorithmsTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CCL_DEFAULT").asInstanceOf[ConnectedComponentsAlgorithmsTypes]

inline def CCL_GRANA: ConnectedComponentsAlgorithmsTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CCL_GRANA").asInstanceOf[ConnectedComponentsAlgorithmsTypes]

inline def CCL_WU: ConnectedComponentsAlgorithmsTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CCL_WU").asInstanceOf[ConnectedComponentsAlgorithmsTypes]

inline def CC_STAT_AREA: ConnectedComponentsTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CC_STAT_AREA").asInstanceOf[ConnectedComponentsTypes]

inline def CC_STAT_HEIGHT: ConnectedComponentsTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CC_STAT_HEIGHT").asInstanceOf[ConnectedComponentsTypes]

inline def CC_STAT_LEFT: ConnectedComponentsTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CC_STAT_LEFT").asInstanceOf[ConnectedComponentsTypes]

inline def CC_STAT_MAX: ConnectedComponentsTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CC_STAT_MAX").asInstanceOf[ConnectedComponentsTypes]

inline def CC_STAT_TOP: ConnectedComponentsTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CC_STAT_TOP").asInstanceOf[ConnectedComponentsTypes]

inline def CC_STAT_WIDTH: ConnectedComponentsTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CC_STAT_WIDTH").asInstanceOf[ConnectedComponentsTypes]

inline def CHAIN_APPROX_NONE: ContourApproximationModes = ^.asInstanceOf[js.Dynamic].selectDynamic("CHAIN_APPROX_NONE").asInstanceOf[ContourApproximationModes]

inline def CHAIN_APPROX_SIMPLE: ContourApproximationModes = ^.asInstanceOf[js.Dynamic].selectDynamic("CHAIN_APPROX_SIMPLE").asInstanceOf[ContourApproximationModes]

inline def CHAIN_APPROX_TC89_KCOS: ContourApproximationModes = ^.asInstanceOf[js.Dynamic].selectDynamic("CHAIN_APPROX_TC89_KCOS").asInstanceOf[ContourApproximationModes]

inline def CHAIN_APPROX_TC89_L1: ContourApproximationModes = ^.asInstanceOf[js.Dynamic].selectDynamic("CHAIN_APPROX_TC89_L1").asInstanceOf[ContourApproximationModes]

inline def CMP_EQ: CmpTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CMP_EQ").asInstanceOf[CmpTypes]

inline def CMP_GE: CmpTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CMP_GE").asInstanceOf[CmpTypes]

inline def CMP_GT: CmpTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CMP_GT").asInstanceOf[CmpTypes]

inline def CMP_LE: CmpTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CMP_LE").asInstanceOf[CmpTypes]

inline def CMP_LT: CmpTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CMP_LT").asInstanceOf[CmpTypes]

inline def CMP_NE: CmpTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("CMP_NE").asInstanceOf[CmpTypes]

inline def COLORBGR2Lab: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2Lab").asInstanceOf[ColorConversionCodes]

inline def COLORBGR2Luv: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2Luv").asInstanceOf[ColorConversionCodes]

inline def COLORBGR2YCrCb: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2YCrCb").asInstanceOf[ColorConversionCodes]

inline def COLORBayerBG2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerBG2BGR").asInstanceOf[ColorConversionCodes]

inline def COLORBayerBG2BGRA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerBG2BGRA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerBG2BGREA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerBG2BGR_EA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerBG2BGRVNG: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerBG2BGR_VNG").asInstanceOf[ColorConversionCodes]

inline def COLORBayerBG2GRAY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerBG2GRAY").asInstanceOf[ColorConversionCodes]

inline def COLORBayerBG2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerBG2RGB").asInstanceOf[ColorConversionCodes]

inline def COLORBayerBG2RGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerBG2RGBA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerBG2RGBEA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerBG2RGB_EA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerBG2RGBVNG: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerBG2RGB_VNG").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGB2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGB2BGR").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGB2BGRA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGB2BGRA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGB2BGREA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGB2BGR_EA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGB2BGRVNG: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGB2BGR_VNG").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGB2GRAY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGB2GRAY").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGB2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGB2RGB").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGB2RGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGB2RGBA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGB2RGBEA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGB2RGB_EA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGB2RGBVNG: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGB2RGB_VNG").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGR2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGR2BGR").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGR2BGRA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGR2BGRA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGR2BGREA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGR2BGR_EA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGR2BGRVNG: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGR2BGR_VNG").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGR2GRAY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGR2GRAY").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGR2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGR2RGB").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGR2RGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGR2RGBA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGR2RGBEA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGR2RGB_EA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerGR2RGBVNG: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerGR2RGB_VNG").asInstanceOf[ColorConversionCodes]

inline def COLORBayerRG2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerRG2BGR").asInstanceOf[ColorConversionCodes]

inline def COLORBayerRG2BGRA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerRG2BGRA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerRG2BGREA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerRG2BGR_EA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerRG2BGRVNG: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerRG2BGR_VNG").asInstanceOf[ColorConversionCodes]

inline def COLORBayerRG2GRAY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerRG2GRAY").asInstanceOf[ColorConversionCodes]

inline def COLORBayerRG2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerRG2RGB").asInstanceOf[ColorConversionCodes]

inline def COLORBayerRG2RGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerRG2RGBA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerRG2RGBEA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerRG2RGB_EA").asInstanceOf[ColorConversionCodes]

inline def COLORBayerRG2RGBVNG: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BayerRG2RGB_VNG").asInstanceOf[ColorConversionCodes]

inline def COLORLBGR2Lab: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_LBGR2Lab").asInstanceOf[ColorConversionCodes]

inline def COLORLBGR2Luv: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_LBGR2Luv").asInstanceOf[ColorConversionCodes]

inline def COLORLRGB2Lab: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_LRGB2Lab").asInstanceOf[ColorConversionCodes]

inline def COLORLRGB2Luv: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_LRGB2Luv").asInstanceOf[ColorConversionCodes]

inline def COLORLab2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_Lab2BGR").asInstanceOf[ColorConversionCodes]

inline def COLORLab2LBGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_Lab2LBGR").asInstanceOf[ColorConversionCodes]

inline def COLORLab2LRGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_Lab2LRGB").asInstanceOf[ColorConversionCodes]

inline def COLORLab2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_Lab2RGB").asInstanceOf[ColorConversionCodes]

inline def COLORLuv2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_Luv2BGR").asInstanceOf[ColorConversionCodes]

inline def COLORLuv2LBGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_Luv2LBGR").asInstanceOf[ColorConversionCodes]

inline def COLORLuv2LRGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_Luv2LRGB").asInstanceOf[ColorConversionCodes]

inline def COLORLuv2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_Luv2RGB").asInstanceOf[ColorConversionCodes]

inline def COLORMRGBA2RGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_mRGBA2RGBA").asInstanceOf[ColorConversionCodes]

inline def COLORRGB2Lab: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2Lab").asInstanceOf[ColorConversionCodes]

inline def COLORRGB2Luv: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2Luv").asInstanceOf[ColorConversionCodes]

inline def COLORRGB2YCrCb: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2YCrCb").asInstanceOf[ColorConversionCodes]

inline def COLORRGBA2mRGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGBA2mRGBA").asInstanceOf[ColorConversionCodes]

inline def COLORYCrCb2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YCrCb2BGR").asInstanceOf[ColorConversionCodes]

inline def COLORYCrCb2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YCrCb2RGB").asInstanceOf[ColorConversionCodes]

inline def COLORYUV420p2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV420p2BGR").asInstanceOf[ColorConversionCodes]

inline def COLORYUV420p2BGRA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV420p2BGRA").asInstanceOf[ColorConversionCodes]

inline def COLORYUV420p2GRAY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV420p2GRAY").asInstanceOf[ColorConversionCodes]

inline def COLORYUV420p2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV420p2RGB").asInstanceOf[ColorConversionCodes]

inline def COLORYUV420p2RGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV420p2RGBA").asInstanceOf[ColorConversionCodes]

inline def COLORYUV420sp2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV420sp2BGR").asInstanceOf[ColorConversionCodes]

inline def COLORYUV420sp2BGRA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV420sp2BGRA").asInstanceOf[ColorConversionCodes]

inline def COLORYUV420sp2GRAY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV420sp2GRAY").asInstanceOf[ColorConversionCodes]

inline def COLORYUV420sp2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV420sp2RGB").asInstanceOf[ColorConversionCodes]

inline def COLORYUV420sp2RGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV420sp2RGBA").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2BGR555: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2BGR555").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2BGR565: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2BGR565").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2BGRA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2BGRA").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2GRAY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2GRAY").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2HLS: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2HLS").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2HLS_FULL: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2HLS_FULL").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2HSV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2HSV").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2HSV_FULL: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2HSV_FULL").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2RGB").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2RGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2RGBA").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2XYZ: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2XYZ").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2YUV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2YUV").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2YUV_I420: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2YUV_I420").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2YUV_IYUV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2YUV_IYUV").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR2YUV_YV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR2YUV_YV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR5552BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR5552BGR").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR5552BGRA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR5552BGRA").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR5552GRAY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR5552GRAY").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR5552RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR5552RGB").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR5552RGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR5552RGBA").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR5652BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR5652BGR").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR5652BGRA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR5652BGRA").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR5652GRAY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR5652GRAY").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR5652RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR5652RGB").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGR5652RGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGR5652RGBA").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGRA2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGRA2BGR").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGRA2BGR555: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGRA2BGR555").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGRA2BGR565: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGRA2BGR565").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGRA2GRAY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGRA2GRAY").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGRA2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGRA2RGB").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGRA2RGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGRA2RGBA").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGRA2YUV_I420: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGRA2YUV_I420").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGRA2YUV_IYUV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGRA2YUV_IYUV").asInstanceOf[ColorConversionCodes]

inline def COLOR_BGRA2YUV_YV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_BGRA2YUV_YV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_COLORCVT_MAX: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_COLORCVT_MAX").asInstanceOf[ColorConversionCodes]

inline def COLOR_GRAY2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_GRAY2BGR").asInstanceOf[ColorConversionCodes]

inline def COLOR_GRAY2BGR555: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_GRAY2BGR555").asInstanceOf[ColorConversionCodes]

inline def COLOR_GRAY2BGR565: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_GRAY2BGR565").asInstanceOf[ColorConversionCodes]

inline def COLOR_GRAY2BGRA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_GRAY2BGRA").asInstanceOf[ColorConversionCodes]

inline def COLOR_GRAY2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_GRAY2RGB").asInstanceOf[ColorConversionCodes]

inline def COLOR_GRAY2RGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_GRAY2RGBA").asInstanceOf[ColorConversionCodes]

inline def COLOR_HLS2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_HLS2BGR").asInstanceOf[ColorConversionCodes]

inline def COLOR_HLS2BGR_FULL: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_HLS2BGR_FULL").asInstanceOf[ColorConversionCodes]

inline def COLOR_HLS2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_HLS2RGB").asInstanceOf[ColorConversionCodes]

inline def COLOR_HLS2RGB_FULL: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_HLS2RGB_FULL").asInstanceOf[ColorConversionCodes]

inline def COLOR_HSV2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_HSV2BGR").asInstanceOf[ColorConversionCodes]

inline def COLOR_HSV2BGR_FULL: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_HSV2BGR_FULL").asInstanceOf[ColorConversionCodes]

inline def COLOR_HSV2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_HSV2RGB").asInstanceOf[ColorConversionCodes]

inline def COLOR_HSV2RGB_FULL: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_HSV2RGB_FULL").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2BGR").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2BGR555: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2BGR555").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2BGR565: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2BGR565").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2BGRA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2BGRA").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2GRAY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2GRAY").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2HLS: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2HLS").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2HLS_FULL: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2HLS_FULL").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2HSV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2HSV").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2HSV_FULL: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2HSV_FULL").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2RGBA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2RGBA").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2XYZ: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2XYZ").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2YUV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2YUV").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2YUV_I420: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2YUV_I420").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2YUV_IYUV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2YUV_IYUV").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGB2YUV_YV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGB2YUV_YV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGBA2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGBA2BGR").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGBA2BGR555: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGBA2BGR555").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGBA2BGR565: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGBA2BGR565").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGBA2BGRA: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGBA2BGRA").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGBA2GRAY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGBA2GRAY").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGBA2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGBA2RGB").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGBA2YUV_I420: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGBA2YUV_I420").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGBA2YUV_IYUV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGBA2YUV_IYUV").asInstanceOf[ColorConversionCodes]

inline def COLOR_RGBA2YUV_YV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_RGBA2YUV_YV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_XYZ2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_XYZ2BGR").asInstanceOf[ColorConversionCodes]

inline def COLOR_XYZ2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_XYZ2RGB").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGR: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGR").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGRA_I420: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGRA_I420").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGRA_IYUV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGRA_IYUV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGRA_NV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGRA_NV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGRA_NV21: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGRA_NV21").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGRA_UYNV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGRA_UYNV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGRA_UYVY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGRA_UYVY").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGRA_Y422: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGRA_Y422").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGRA_YUNV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGRA_YUNV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGRA_YUY2: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGRA_YUY2").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGRA_YUYV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGRA_YUYV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGRA_YV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGRA_YV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGRA_YVYU: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGRA_YVYU").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGR_I420: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGR_I420").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGR_IYUV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGR_IYUV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGR_NV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGR_NV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGR_NV21: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGR_NV21").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGR_UYNV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGR_UYNV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGR_UYVY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGR_UYVY").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGR_Y422: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGR_Y422").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGR_YUNV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGR_YUNV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGR_YUY2: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGR_YUY2").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGR_YUYV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGR_YUYV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGR_YV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGR_YV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2BGR_YVYU: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2BGR_YVYU").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2GRAY_420: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2GRAY_420").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2GRAY_I420: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2GRAY_I420").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2GRAY_IYUV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2GRAY_IYUV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2GRAY_NV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2GRAY_NV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2GRAY_NV21: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2GRAY_NV21").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2GRAY_UYNV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2GRAY_UYNV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2GRAY_UYVY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2GRAY_UYVY").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2GRAY_Y422: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2GRAY_Y422").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2GRAY_YUNV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2GRAY_YUNV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2GRAY_YUY2: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2GRAY_YUY2").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2GRAY_YUYV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2GRAY_YUYV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2GRAY_YV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2GRAY_YV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2GRAY_YVYU: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2GRAY_YVYU").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGB: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGB").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGBA_I420: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGBA_I420").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGBA_IYUV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGBA_IYUV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGBA_NV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGBA_NV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGBA_NV21: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGBA_NV21").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGBA_UYNV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGBA_UYNV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGBA_UYVY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGBA_UYVY").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGBA_Y422: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGBA_Y422").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGBA_YUNV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGBA_YUNV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGBA_YUY2: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGBA_YUY2").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGBA_YUYV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGBA_YUYV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGBA_YV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGBA_YV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGBA_YVYU: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGBA_YVYU").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGB_I420: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGB_I420").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGB_IYUV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGB_IYUV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGB_NV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGB_NV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGB_NV21: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGB_NV21").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGB_UYNV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGB_UYNV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGB_UYVY: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGB_UYVY").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGB_Y422: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGB_Y422").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGB_YUNV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGB_YUNV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGB_YUY2: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGB_YUY2").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGB_YUYV: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGB_YUYV").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGB_YV12: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGB_YV12").asInstanceOf[ColorConversionCodes]

inline def COLOR_YUV2RGB_YVYU: ColorConversionCodes = ^.asInstanceOf[js.Dynamic].selectDynamic("COLOR_YUV2RGB_YVYU").asInstanceOf[ColorConversionCodes]

inline def CONTINUOUS_FLAG: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("CONTINUOUS_FLAG").asInstanceOf[Any]

inline def CONTOURS_MATCH_I1: ShapeMatchModes = ^.asInstanceOf[js.Dynamic].selectDynamic("CONTOURS_MATCH_I1").asInstanceOf[ShapeMatchModes]

inline def CONTOURS_MATCH_I2: ShapeMatchModes = ^.asInstanceOf[js.Dynamic].selectDynamic("CONTOURS_MATCH_I2").asInstanceOf[ShapeMatchModes]

inline def CONTOURS_MATCH_I3: ShapeMatchModes = ^.asInstanceOf[js.Dynamic].selectDynamic("CONTOURS_MATCH_I3").asInstanceOf[ShapeMatchModes]

inline def CPU_AVX: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX").asInstanceOf[CpuFeatures]

inline def CPU_AVX2: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX2").asInstanceOf[CpuFeatures]

inline def CPU_AVX512_CEL: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX512_CEL").asInstanceOf[CpuFeatures]

inline def CPU_AVX512_CNL: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX512_CNL").asInstanceOf[CpuFeatures]

inline def CPU_AVX512_COMMON: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX512_COMMON").asInstanceOf[CpuFeatures]

inline def CPU_AVX512_ICL: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX512_ICL").asInstanceOf[CpuFeatures]

inline def CPU_AVX512_KNL: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX512_KNL").asInstanceOf[CpuFeatures]

inline def CPU_AVX512_KNM: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX512_KNM").asInstanceOf[CpuFeatures]

inline def CPU_AVX512_SKX: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX512_SKX").asInstanceOf[CpuFeatures]

inline def CPU_AVX_5124FMAPS: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_5124FMAPS").asInstanceOf[CpuFeatures]

inline def CPU_AVX_5124VNNIW: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_5124VNNIW").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512BITALG: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512BITALG").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512BW: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512BW").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512CD: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512CD").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512DQ: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512DQ").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512ER: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512ER").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512F: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512F").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512IFMA: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512IFMA").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512IFMA512: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512IFMA512").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512PF: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512PF").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512VBMI: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512VBMI").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512VBMI2: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512VBMI2").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512VL: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512VL").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512VNNI: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512VNNI").asInstanceOf[CpuFeatures]

inline def CPU_AVX_512VPOPCNTDQ: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_AVX_512VPOPCNTDQ").asInstanceOf[CpuFeatures]

inline def CPU_FMA3: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_FMA3").asInstanceOf[CpuFeatures]

inline def CPU_FP16: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_FP16").asInstanceOf[CpuFeatures]

inline def CPU_MAX_FEATURE: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_MAX_FEATURE").asInstanceOf[CpuFeatures]

inline def CPU_MMX: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_MMX").asInstanceOf[CpuFeatures]

inline def CPU_NEON: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_NEON").asInstanceOf[CpuFeatures]

inline def CPU_POPCNT: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_POPCNT").asInstanceOf[CpuFeatures]

inline def CPU_SSE: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_SSE").asInstanceOf[CpuFeatures]

inline def CPU_SSE2: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_SSE2").asInstanceOf[CpuFeatures]

inline def CPU_SSE3: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_SSE3").asInstanceOf[CpuFeatures]

inline def CPU_SSE4_1: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_SSE4_1").asInstanceOf[CpuFeatures]

inline def CPU_SSE4_2: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_SSE4_2").asInstanceOf[CpuFeatures]

inline def CPU_SSSE3: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_SSSE3").asInstanceOf[CpuFeatures]

inline def CPU_VSX: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_VSX").asInstanceOf[CpuFeatures]

inline def CPU_VSX3: CpuFeatures = ^.asInstanceOf[js.Dynamic].selectDynamic("CPU_VSX3").asInstanceOf[CpuFeatures]

inline def CV_16S: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_16S").asInstanceOf[CVDataType]

inline def CV_16SC1: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_16SC1").asInstanceOf[CVDataType]

inline def CV_16SC2: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_16SC2").asInstanceOf[CVDataType]

inline def CV_16SC3: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_16SC3").asInstanceOf[CVDataType]

inline def CV_16SC4: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_16SC4").asInstanceOf[CVDataType]

inline def CV_16U: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_16U").asInstanceOf[CVDataType]

inline def CV_16UC1: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_16UC1").asInstanceOf[CVDataType]

inline def CV_16UC2: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_16UC2").asInstanceOf[CVDataType]

inline def CV_16UC3: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_16UC3").asInstanceOf[CVDataType]

inline def CV_16UC4: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_16UC4").asInstanceOf[CVDataType]

inline def CV_32F: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_32F").asInstanceOf[CVDataType]

inline def CV_32FC1: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_32FC1").asInstanceOf[CVDataType]

inline def CV_32FC2: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_32FC2").asInstanceOf[CVDataType]

inline def CV_32FC3: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_32FC3").asInstanceOf[CVDataType]

inline def CV_32FC4: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_32FC4").asInstanceOf[CVDataType]

inline def CV_32S: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_32S").asInstanceOf[CVDataType]

inline def CV_32SC1: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_32SC1").asInstanceOf[CVDataType]

inline def CV_32SC2: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_32SC2").asInstanceOf[CVDataType]

inline def CV_32SC3: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_32SC3").asInstanceOf[CVDataType]

inline def CV_32SC4: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_32SC4").asInstanceOf[CVDataType]

inline def CV_64F: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_64F").asInstanceOf[CVDataType]

inline def CV_64FC1: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_64FC1").asInstanceOf[CVDataType]

inline def CV_64FC2: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_64FC2").asInstanceOf[CVDataType]

inline def CV_64FC3: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_64FC3").asInstanceOf[CVDataType]

inline def CV_64FC4: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_64FC4").asInstanceOf[CVDataType]

inline def CV_8S: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_8S").asInstanceOf[CVDataType]

inline def CV_8SC1: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_8SC1").asInstanceOf[CVDataType]

inline def CV_8SC2: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_8SC2").asInstanceOf[CVDataType]

inline def CV_8SC3: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_8SC3").asInstanceOf[CVDataType]

inline def CV_8SC4: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_8SC4").asInstanceOf[CVDataType]

inline def CV_8U: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_8U").asInstanceOf[CVDataType]

inline def CV_8UC1: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_8UC1").asInstanceOf[CVDataType]

inline def CV_8UC2: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_8UC2").asInstanceOf[CVDataType]

inline def CV_8UC3: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_8UC3").asInstanceOf[CVDataType]

inline def CV_8UC4: CVDataType = ^.asInstanceOf[js.Dynamic].selectDynamic("CV_8UC4").asInstanceOf[CVDataType]

inline def CV_XADD(addr: Any, delta: int): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("CV_XADD")(addr.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Any]

inline def CamShift(
  probImage: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  window: Any,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria
): typings.mirada.distSrcTypesOpencvTypesMod.RotatedRect = (^.asInstanceOf[js.Dynamic].applyDynamic("CamShift")(probImage.asInstanceOf[js.Any], window.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.RotatedRect]

inline def Canny(
  dx: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dy: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  edges: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  threshold1: double,
  threshold2: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Canny")(dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], edges.asInstanceOf[js.Any], threshold1.asInstanceOf[js.Any], threshold2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Canny(
  dx: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dy: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  edges: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  threshold1: double,
  threshold2: double,
  L2gradient: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Canny")(dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], edges.asInstanceOf[js.Any], threshold1.asInstanceOf[js.Any], threshold2.asInstanceOf[js.Any], L2gradient.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Canny(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  edges: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  threshold1: double,
  threshold2: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Canny")(image.asInstanceOf[js.Any], edges.asInstanceOf[js.Any], threshold1.asInstanceOf[js.Any], threshold2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Canny(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  edges: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  threshold1: double,
  threshold2: double,
  apertureSize: Unit,
  L2gradient: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Canny")(image.asInstanceOf[js.Any], edges.asInstanceOf[js.Any], threshold1.asInstanceOf[js.Any], threshold2.asInstanceOf[js.Any], apertureSize.asInstanceOf[js.Any], L2gradient.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Canny(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  edges: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  threshold1: double,
  threshold2: double,
  apertureSize: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Canny")(image.asInstanceOf[js.Any], edges.asInstanceOf[js.Any], threshold1.asInstanceOf[js.Any], threshold2.asInstanceOf[js.Any], apertureSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Canny(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  edges: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  threshold1: double,
  threshold2: double,
  apertureSize: int,
  L2gradient: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Canny")(image.asInstanceOf[js.Any], edges.asInstanceOf[js.Any], threshold1.asInstanceOf[js.Any], threshold2.asInstanceOf[js.Any], apertureSize.asInstanceOf[js.Any], L2gradient.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def Cholesky(A: Any, astep: sizeT, m: int, b: Any, bstep: sizeT, n: int): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("Cholesky")(A.asInstanceOf[js.Any], astep.asInstanceOf[js.Any], m.asInstanceOf[js.Any], b.asInstanceOf[js.Any], bstep.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def DATA_AS_COL: Flags = ^.asInstanceOf[js.Dynamic].selectDynamic("DATA_AS_COL").asInstanceOf[Flags]

inline def DATA_AS_ROW: Flags = ^.asInstanceOf[js.Dynamic].selectDynamic("DATA_AS_ROW").asInstanceOf[Flags]

inline def DCT_INVERSE: DftFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("DCT_INVERSE").asInstanceOf[DftFlags]

inline def DCT_ROWS: DftFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("DCT_ROWS").asInstanceOf[DftFlags]

inline def DECOMP_CHOLESKY: DecompTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DECOMP_CHOLESKY").asInstanceOf[DecompTypes]

inline def DECOMP_EIG: DecompTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DECOMP_EIG").asInstanceOf[DecompTypes]

inline def DECOMP_LU: DecompTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DECOMP_LU").asInstanceOf[DecompTypes]

inline def DECOMP_NORMAL: DecompTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DECOMP_NORMAL").asInstanceOf[DecompTypes]

inline def DECOMP_QR: DecompTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DECOMP_QR").asInstanceOf[DecompTypes]

inline def DECOMP_SVD: DecompTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DECOMP_SVD").asInstanceOf[DecompTypes]

inline def DEFAULT: DrawMatchesFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("DEFAULT").asInstanceOf[DrawMatchesFlags]

inline def DEFAULT_NLEVELS: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("DEFAULT_NLEVELS").asInstanceOf[Any]

inline def DEPTH_MASK: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("DEPTH_MASK").asInstanceOf[Any]

inline def DESCR_FORMAT_COL_BY_COL: DescriptorStorageFormat = ^.asInstanceOf[js.Dynamic].selectDynamic("DESCR_FORMAT_COL_BY_COL").asInstanceOf[DescriptorStorageFormat]

inline def DESCR_FORMAT_ROW_BY_ROW: DescriptorStorageFormat = ^.asInstanceOf[js.Dynamic].selectDynamic("DESCR_FORMAT_ROW_BY_ROW").asInstanceOf[DescriptorStorageFormat]

inline def DFT_COMPLEX_INPUT: DftFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("DFT_COMPLEX_INPUT").asInstanceOf[DftFlags]

inline def DFT_COMPLEX_OUTPUT: DftFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("DFT_COMPLEX_OUTPUT").asInstanceOf[DftFlags]

inline def DFT_INVERSE: DftFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("DFT_INVERSE").asInstanceOf[DftFlags]

inline def DFT_REAL_OUTPUT: DftFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("DFT_REAL_OUTPUT").asInstanceOf[DftFlags]

inline def DFT_ROWS: DftFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("DFT_ROWS").asInstanceOf[DftFlags]

inline def DFT_SCALE: DftFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("DFT_SCALE").asInstanceOf[DftFlags]

inline def DIST_C: DistanceTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DIST_C").asInstanceOf[DistanceTypes]

inline def DIST_FAIR: DistanceTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DIST_FAIR").asInstanceOf[DistanceTypes]

inline def DIST_HUBER: DistanceTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DIST_HUBER").asInstanceOf[DistanceTypes]

inline def DIST_L1: DistanceTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DIST_L1").asInstanceOf[DistanceTypes]

inline def DIST_L12: DistanceTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DIST_L12").asInstanceOf[DistanceTypes]

inline def DIST_L2: DistanceTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DIST_L2").asInstanceOf[DistanceTypes]

inline def DIST_LABEL_CCOMP: DistanceTransformLabelTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DIST_LABEL_CCOMP").asInstanceOf[DistanceTransformLabelTypes]

inline def DIST_LABEL_PIXEL: DistanceTransformLabelTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DIST_LABEL_PIXEL").asInstanceOf[DistanceTransformLabelTypes]

inline def DIST_MASK_3: DistanceTransformMasks = ^.asInstanceOf[js.Dynamic].selectDynamic("DIST_MASK_3").asInstanceOf[DistanceTransformMasks]

inline def DIST_MASK_5: DistanceTransformMasks = ^.asInstanceOf[js.Dynamic].selectDynamic("DIST_MASK_5").asInstanceOf[DistanceTransformMasks]

inline def DIST_MASK_PRECISE: DistanceTransformMasks = ^.asInstanceOf[js.Dynamic].selectDynamic("DIST_MASK_PRECISE").asInstanceOf[DistanceTransformMasks]

inline def DIST_USER: DistanceTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DIST_USER").asInstanceOf[DistanceTypes]

inline def DIST_WELSCH: DistanceTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("DIST_WELSCH").asInstanceOf[DistanceTypes]

inline def DNN_BACKEND_DEFAULT: Backend = ^.asInstanceOf[js.Dynamic].selectDynamic("DNN_BACKEND_DEFAULT").asInstanceOf[Backend]

inline def DNN_BACKEND_HALIDE: Backend = ^.asInstanceOf[js.Dynamic].selectDynamic("DNN_BACKEND_HALIDE").asInstanceOf[Backend]

inline def DNN_BACKEND_INFERENCE_ENGINE: Backend = ^.asInstanceOf[js.Dynamic].selectDynamic("DNN_BACKEND_INFERENCE_ENGINE").asInstanceOf[Backend]

inline def DNN_BACKEND_OPENCV: Backend = ^.asInstanceOf[js.Dynamic].selectDynamic("DNN_BACKEND_OPENCV").asInstanceOf[Backend]

inline def DNN_BACKEND_VKCOM: Backend = ^.asInstanceOf[js.Dynamic].selectDynamic("DNN_BACKEND_VKCOM").asInstanceOf[Backend]

inline def DNN_TARGET_CPU: Target = ^.asInstanceOf[js.Dynamic].selectDynamic("DNN_TARGET_CPU").asInstanceOf[Target]

inline def DNN_TARGET_FPGA: Target = ^.asInstanceOf[js.Dynamic].selectDynamic("DNN_TARGET_FPGA").asInstanceOf[Target]

inline def DNN_TARGET_MYRIAD: Target = ^.asInstanceOf[js.Dynamic].selectDynamic("DNN_TARGET_MYRIAD").asInstanceOf[Target]

inline def DNN_TARGET_OPENCL: Target = ^.asInstanceOf[js.Dynamic].selectDynamic("DNN_TARGET_OPENCL").asInstanceOf[Target]

inline def DNN_TARGET_OPENCL_FP16: Target = ^.asInstanceOf[js.Dynamic].selectDynamic("DNN_TARGET_OPENCL_FP16").asInstanceOf[Target]

inline def DNN_TARGET_VULKAN: Target = ^.asInstanceOf[js.Dynamic].selectDynamic("DNN_TARGET_VULKAN").asInstanceOf[Target]

inline def DRAW_OVER_OUTIMG: DrawMatchesFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("DRAW_OVER_OUTIMG").asInstanceOf[DrawMatchesFlags]

inline def DRAW_RICH_KEYPOINTS: DrawMatchesFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("DRAW_RICH_KEYPOINTS").asInstanceOf[DrawMatchesFlags]

inline def EMD(
  signature1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  signature2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distType: int
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("EMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any])).asInstanceOf[float]
inline def EMD(
  signature1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  signature2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distType: int,
  cost: Unit,
  lowerBound: Any
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("EMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], lowerBound.asInstanceOf[js.Any])).asInstanceOf[float]
inline def EMD(
  signature1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  signature2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distType: int,
  cost: Unit,
  lowerBound: Any,
  flow: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("EMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], lowerBound.asInstanceOf[js.Any], flow.asInstanceOf[js.Any])).asInstanceOf[float]
inline def EMD(
  signature1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  signature2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distType: int,
  cost: Unit,
  lowerBound: Unit,
  flow: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("EMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], lowerBound.asInstanceOf[js.Any], flow.asInstanceOf[js.Any])).asInstanceOf[float]
inline def EMD(
  signature1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  signature2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distType: int,
  cost: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("EMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any])).asInstanceOf[float]
inline def EMD(
  signature1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  signature2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distType: int,
  cost: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lowerBound: Any
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("EMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], lowerBound.asInstanceOf[js.Any])).asInstanceOf[float]
inline def EMD(
  signature1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  signature2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distType: int,
  cost: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lowerBound: Any,
  flow: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("EMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], lowerBound.asInstanceOf[js.Any], flow.asInstanceOf[js.Any])).asInstanceOf[float]
inline def EMD(
  signature1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  signature2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distType: int,
  cost: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lowerBound: Unit,
  flow: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("EMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], lowerBound.asInstanceOf[js.Any], flow.asInstanceOf[js.Any])).asInstanceOf[float]

inline def FILLED: LineTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("FILLED").asInstanceOf[LineTypes]

inline def FILTER_SCHARR: SpecialFilter = ^.asInstanceOf[js.Dynamic].selectDynamic("FILTER_SCHARR").asInstanceOf[SpecialFilter]

inline def FLANNBASED: MatcherType = ^.asInstanceOf[js.Dynamic].selectDynamic("FLANNBASED").asInstanceOf[MatcherType]

inline def FLOODFILL_FIXED_RANGE: FloodFillFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("FLOODFILL_FIXED_RANGE").asInstanceOf[FloodFillFlags]

inline def FLOODFILL_MASK_ONLY: FloodFillFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("FLOODFILL_MASK_ONLY").asInstanceOf[FloodFillFlags]

inline def FM_7POINT: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("FM_7POINT").asInstanceOf[Any]

inline def FM_8POINT: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("FM_8POINT").asInstanceOf[Any]

inline def FM_LMEDS: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("FM_LMEDS").asInstanceOf[Any]

inline def FM_RANSAC: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("FM_RANSAC").asInstanceOf[Any]

inline def FONT_HERSHEY_COMPLEX: HersheyFonts = ^.asInstanceOf[js.Dynamic].selectDynamic("FONT_HERSHEY_COMPLEX").asInstanceOf[HersheyFonts]

inline def FONT_HERSHEY_COMPLEX_SMALL: HersheyFonts = ^.asInstanceOf[js.Dynamic].selectDynamic("FONT_HERSHEY_COMPLEX_SMALL").asInstanceOf[HersheyFonts]

inline def FONT_HERSHEY_DUPLEX: HersheyFonts = ^.asInstanceOf[js.Dynamic].selectDynamic("FONT_HERSHEY_DUPLEX").asInstanceOf[HersheyFonts]

inline def FONT_HERSHEY_PLAIN: HersheyFonts = ^.asInstanceOf[js.Dynamic].selectDynamic("FONT_HERSHEY_PLAIN").asInstanceOf[HersheyFonts]

inline def FONT_HERSHEY_SCRIPT_COMPLEX: HersheyFonts = ^.asInstanceOf[js.Dynamic].selectDynamic("FONT_HERSHEY_SCRIPT_COMPLEX").asInstanceOf[HersheyFonts]

inline def FONT_HERSHEY_SCRIPT_SIMPLEX: HersheyFonts = ^.asInstanceOf[js.Dynamic].selectDynamic("FONT_HERSHEY_SCRIPT_SIMPLEX").asInstanceOf[HersheyFonts]

inline def FONT_HERSHEY_SIMPLEX: HersheyFonts = ^.asInstanceOf[js.Dynamic].selectDynamic("FONT_HERSHEY_SIMPLEX").asInstanceOf[HersheyFonts]

inline def FONT_HERSHEY_TRIPLEX: HersheyFonts = ^.asInstanceOf[js.Dynamic].selectDynamic("FONT_HERSHEY_TRIPLEX").asInstanceOf[HersheyFonts]

inline def FONT_ITALIC: HersheyFonts = ^.asInstanceOf[js.Dynamic].selectDynamic("FONT_ITALIC").asInstanceOf[HersheyFonts]

inline def FSCreateDataFile(
  arg0: String,
  path: String,
  data: js.typedarray.Uint8Array,
  arg3: Boolean,
  arg4: Boolean,
  arg5: Boolean
): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("FS_createDataFile")(arg0.asInstanceOf[js.Any], path.asInstanceOf[js.Any], data.asInstanceOf[js.Any], arg3.asInstanceOf[js.Any], arg4.asInstanceOf[js.Any], arg5.asInstanceOf[js.Any])).asInstanceOf[Any]

inline def GC_BGD: GrabCutClasses = ^.asInstanceOf[js.Dynamic].selectDynamic("GC_BGD").asInstanceOf[GrabCutClasses]

inline def GC_EVAL: GrabCutModes = ^.asInstanceOf[js.Dynamic].selectDynamic("GC_EVAL").asInstanceOf[GrabCutModes]

inline def GC_EVAL_FREEZE_MODEL: GrabCutModes = ^.asInstanceOf[js.Dynamic].selectDynamic("GC_EVAL_FREEZE_MODEL").asInstanceOf[GrabCutModes]

inline def GC_FGD: GrabCutClasses = ^.asInstanceOf[js.Dynamic].selectDynamic("GC_FGD").asInstanceOf[GrabCutClasses]

inline def GC_INIT_WITH_MASK: GrabCutModes = ^.asInstanceOf[js.Dynamic].selectDynamic("GC_INIT_WITH_MASK").asInstanceOf[GrabCutModes]

inline def GC_INIT_WITH_RECT: GrabCutModes = ^.asInstanceOf[js.Dynamic].selectDynamic("GC_INIT_WITH_RECT").asInstanceOf[GrabCutModes]

inline def GC_PR_BGD: GrabCutClasses = ^.asInstanceOf[js.Dynamic].selectDynamic("GC_PR_BGD").asInstanceOf[GrabCutClasses]

inline def GC_PR_FGD: GrabCutClasses = ^.asInstanceOf[js.Dynamic].selectDynamic("GC_PR_FGD").asInstanceOf[GrabCutClasses]

inline def GEMM_1_T: GemmFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("GEMM_1_T").asInstanceOf[GemmFlags]

inline def GEMM_2_T: GemmFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("GEMM_2_T").asInstanceOf[GemmFlags]

inline def GEMM_3_T: GemmFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("GEMM_3_T").asInstanceOf[GemmFlags]

inline def GaussianBlur(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  sigmaX: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("GaussianBlur")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], sigmaX.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def GaussianBlur(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  sigmaX: double,
  sigmaY: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("GaussianBlur")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], sigmaX.asInstanceOf[js.Any], sigmaY.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def GaussianBlur(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  sigmaX: double,
  sigmaY: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("GaussianBlur")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], sigmaX.asInstanceOf[js.Any], sigmaY.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def GaussianBlur(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  sigmaX: double,
  sigmaY: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("GaussianBlur")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], sigmaX.asInstanceOf[js.Any], sigmaY.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def HISTCMP_BHATTACHARYYA: HistCompMethods = ^.asInstanceOf[js.Dynamic].selectDynamic("HISTCMP_BHATTACHARYYA").asInstanceOf[HistCompMethods]

inline def HISTCMP_CHISQR: HistCompMethods = ^.asInstanceOf[js.Dynamic].selectDynamic("HISTCMP_CHISQR").asInstanceOf[HistCompMethods]

inline def HISTCMP_CHISQR_ALT: HistCompMethods = ^.asInstanceOf[js.Dynamic].selectDynamic("HISTCMP_CHISQR_ALT").asInstanceOf[HistCompMethods]

inline def HISTCMP_CORREL: HistCompMethods = ^.asInstanceOf[js.Dynamic].selectDynamic("HISTCMP_CORREL").asInstanceOf[HistCompMethods]

inline def HISTCMP_HELLINGER: HistCompMethods = ^.asInstanceOf[js.Dynamic].selectDynamic("HISTCMP_HELLINGER").asInstanceOf[HistCompMethods]

inline def HISTCMP_INTERSECT: HistCompMethods = ^.asInstanceOf[js.Dynamic].selectDynamic("HISTCMP_INTERSECT").asInstanceOf[HistCompMethods]

inline def HISTCMP_KL_DIV: HistCompMethods = ^.asInstanceOf[js.Dynamic].selectDynamic("HISTCMP_KL_DIV").asInstanceOf[HistCompMethods]

inline def HOUGH_GRADIENT: HoughModes = ^.asInstanceOf[js.Dynamic].selectDynamic("HOUGH_GRADIENT").asInstanceOf[HoughModes]

inline def HOUGH_MULTI_SCALE: HoughModes = ^.asInstanceOf[js.Dynamic].selectDynamic("HOUGH_MULTI_SCALE").asInstanceOf[HoughModes]

inline def HOUGH_PROBABILISTIC: HoughModes = ^.asInstanceOf[js.Dynamic].selectDynamic("HOUGH_PROBABILISTIC").asInstanceOf[HoughModes]

inline def HOUGH_STANDARD: HoughModes = ^.asInstanceOf[js.Dynamic].selectDynamic("HOUGH_STANDARD").asInstanceOf[HoughModes]

inline def HoughCircles(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  circles: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: int,
  dp: double,
  minDist: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  circles: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: Unit,
  param2: Unit,
  minRadius: Unit,
  maxRadius: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any], minRadius.asInstanceOf[js.Any], maxRadius.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  circles: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: Unit,
  param2: Unit,
  minRadius: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any], minRadius.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  circles: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: Unit,
  param2: Unit,
  minRadius: int,
  maxRadius: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any], minRadius.asInstanceOf[js.Any], maxRadius.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  circles: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: Unit,
  param2: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  circles: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: Unit,
  param2: double,
  minRadius: Unit,
  maxRadius: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any], minRadius.asInstanceOf[js.Any], maxRadius.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  circles: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: Unit,
  param2: double,
  minRadius: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any], minRadius.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  circles: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: Unit,
  param2: double,
  minRadius: int,
  maxRadius: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any], minRadius.asInstanceOf[js.Any], maxRadius.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  circles: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  circles: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: double,
  param2: Unit,
  minRadius: Unit,
  maxRadius: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any], minRadius.asInstanceOf[js.Any], maxRadius.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  circles: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: double,
  param2: Unit,
  minRadius: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any], minRadius.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  circles: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: double,
  param2: Unit,
  minRadius: int,
  maxRadius: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any], minRadius.asInstanceOf[js.Any], maxRadius.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  circles: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: double,
  param2: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  circles: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: double,
  param2: double,
  minRadius: Unit,
  maxRadius: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any], minRadius.asInstanceOf[js.Any], maxRadius.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  circles: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: double,
  param2: double,
  minRadius: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any], minRadius.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughCircles(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  circles: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: int,
  dp: double,
  minDist: double,
  param1: double,
  param2: double,
  minRadius: int,
  maxRadius: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughCircles")(image.asInstanceOf[js.Any], circles.asInstanceOf[js.Any], method.asInstanceOf[js.Any], dp.asInstanceOf[js.Any], minDist.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], param2.asInstanceOf[js.Any], minRadius.asInstanceOf[js.Any], maxRadius.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def HoughLines(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lines: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rho: double,
  theta: double,
  threshold: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lines: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: Unit,
  stn: Unit,
  min_theta: Unit,
  max_theta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any], min_theta.asInstanceOf[js.Any], max_theta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lines: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: Unit,
  stn: Unit,
  min_theta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any], min_theta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lines: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: Unit,
  stn: Unit,
  min_theta: double,
  max_theta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any], min_theta.asInstanceOf[js.Any], max_theta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lines: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: Unit,
  stn: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lines: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: Unit,
  stn: double,
  min_theta: Unit,
  max_theta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any], min_theta.asInstanceOf[js.Any], max_theta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lines: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: Unit,
  stn: double,
  min_theta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any], min_theta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lines: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: Unit,
  stn: double,
  min_theta: double,
  max_theta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any], min_theta.asInstanceOf[js.Any], max_theta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lines: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lines: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: double,
  stn: Unit,
  min_theta: Unit,
  max_theta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any], min_theta.asInstanceOf[js.Any], max_theta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lines: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: double,
  stn: Unit,
  min_theta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any], min_theta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lines: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: double,
  stn: Unit,
  min_theta: double,
  max_theta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any], min_theta.asInstanceOf[js.Any], max_theta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lines: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: double,
  stn: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lines: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: double,
  stn: double,
  min_theta: Unit,
  max_theta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any], min_theta.asInstanceOf[js.Any], max_theta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lines: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: double,
  stn: double,
  min_theta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any], min_theta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLines(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lines: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  srn: double,
  stn: double,
  min_theta: double,
  max_theta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLines")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], srn.asInstanceOf[js.Any], stn.asInstanceOf[js.Any], min_theta.asInstanceOf[js.Any], max_theta.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def HoughLinesP(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lines: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rho: double,
  theta: double,
  threshold: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLinesP")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLinesP(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lines: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  minLineLength: Unit,
  maxLineGap: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLinesP")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], minLineLength.asInstanceOf[js.Any], maxLineGap.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLinesP(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lines: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  minLineLength: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLinesP")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], minLineLength.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HoughLinesP(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lines: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rho: double,
  theta: double,
  threshold: int,
  minLineLength: double,
  maxLineGap: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLinesP")(image.asInstanceOf[js.Any], lines.asInstanceOf[js.Any], rho.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], minLineLength.asInstanceOf[js.Any], maxLineGap.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def HoughLinesPointSet(
  _point: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  _lines: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  lines_max: int,
  threshold: int,
  min_rho: double,
  max_rho: double,
  rho_step: double,
  min_theta: double,
  max_theta: double,
  theta_step: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HoughLinesPointSet")(_point.asInstanceOf[js.Any], _lines.asInstanceOf[js.Any], lines_max.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], min_rho.asInstanceOf[js.Any], max_rho.asInstanceOf[js.Any], rho_step.asInstanceOf[js.Any], min_theta.asInstanceOf[js.Any], max_theta.asInstanceOf[js.Any], theta_step.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def HuMoments(moments: Any, hu: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HuMoments")(moments.asInstanceOf[js.Any], hu.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def HuMoments(m: Any, hu: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("HuMoments")(m.asInstanceOf[js.Any], hu.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def INPAINT_NS: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("INPAINT_NS").asInstanceOf[Any]

inline def INPAINT_TELEA: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("INPAINT_TELEA").asInstanceOf[Any]

inline def INTERSECT_FULL: RectanglesIntersectTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("INTERSECT_FULL").asInstanceOf[RectanglesIntersectTypes]

inline def INTERSECT_NONE: RectanglesIntersectTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("INTERSECT_NONE").asInstanceOf[RectanglesIntersectTypes]

inline def INTERSECT_PARTIAL: RectanglesIntersectTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("INTERSECT_PARTIAL").asInstanceOf[RectanglesIntersectTypes]

inline def INTER_AREA: InterpolationFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("INTER_AREA").asInstanceOf[InterpolationFlags]

inline def INTER_BITS: InterpolationMasks = ^.asInstanceOf[js.Dynamic].selectDynamic("INTER_BITS").asInstanceOf[InterpolationMasks]

inline def INTER_BITS2: InterpolationMasks = ^.asInstanceOf[js.Dynamic].selectDynamic("INTER_BITS2").asInstanceOf[InterpolationMasks]

inline def INTER_CUBIC: InterpolationFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("INTER_CUBIC").asInstanceOf[InterpolationFlags]

inline def INTER_LANCZOS4: InterpolationFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("INTER_LANCZOS4").asInstanceOf[InterpolationFlags]

inline def INTER_LINEAR: InterpolationFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("INTER_LINEAR").asInstanceOf[InterpolationFlags]

inline def INTER_LINEAR_EXACT: InterpolationFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("INTER_LINEAR_EXACT").asInstanceOf[InterpolationFlags]

inline def INTER_MAX: InterpolationFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("INTER_MAX").asInstanceOf[InterpolationFlags]

inline def INTER_NEAREST: InterpolationFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("INTER_NEAREST").asInstanceOf[InterpolationFlags]

inline def INTER_TAB_SIZE: InterpolationMasks = ^.asInstanceOf[js.Dynamic].selectDynamic("INTER_TAB_SIZE").asInstanceOf[InterpolationMasks]

inline def INTER_TAB_SIZE2: InterpolationMasks = ^.asInstanceOf[js.Dynamic].selectDynamic("INTER_TAB_SIZE2").asInstanceOf[InterpolationMasks]

inline def L2Hys: HistogramNormType = ^.asInstanceOf[js.Dynamic].selectDynamic("L2Hys").asInstanceOf[HistogramNormType]

inline def LINE_4: LineTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("LINE_4").asInstanceOf[LineTypes]

inline def LINE_8: LineTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("LINE_8").asInstanceOf[LineTypes]

inline def LINE_AA: LineTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("LINE_AA").asInstanceOf[LineTypes]

inline def LMEDS: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("LMEDS").asInstanceOf[Any]

inline def LSD_REFINE_ADV: LineSegmentDetectorModes = ^.asInstanceOf[js.Dynamic].selectDynamic("LSD_REFINE_ADV").asInstanceOf[LineSegmentDetectorModes]

inline def LSD_REFINE_NONE: LineSegmentDetectorModes = ^.asInstanceOf[js.Dynamic].selectDynamic("LSD_REFINE_NONE").asInstanceOf[LineSegmentDetectorModes]

inline def LSD_REFINE_STD: LineSegmentDetectorModes = ^.asInstanceOf[js.Dynamic].selectDynamic("LSD_REFINE_STD").asInstanceOf[LineSegmentDetectorModes]

inline def LU(A: Any, astep: sizeT, m: int, b: Any, bstep: sizeT, n: int): int = (^.asInstanceOf[js.Dynamic].applyDynamic("LU")(A.asInstanceOf[js.Any], astep.asInstanceOf[js.Any], m.asInstanceOf[js.Any], b.asInstanceOf[js.Any], bstep.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[int]

inline def LUT(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lut: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("LUT")(src.asInstanceOf[js.Any], lut.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def Laplacian(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: Unit,
  scale: Unit,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: Unit,
  scale: Unit,
  delta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: Unit,
  scale: Unit,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: Unit,
  scale: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: Unit,
  scale: double,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: Unit,
  scale: double,
  delta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: Unit,
  scale: double,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: int,
  scale: Unit,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: int,
  scale: Unit,
  delta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: int,
  scale: Unit,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: int,
  scale: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: int,
  scale: double,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: int,
  scale: double,
  delta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Laplacian(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: int,
  scale: double,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Laplacian")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def MAGIC_MASK: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("MAGIC_MASK").asInstanceOf[Any]

inline def MAGIC_VAL: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("MAGIC_VAL").asInstanceOf[Any]

inline def MARKER_CROSS: MarkerTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MARKER_CROSS").asInstanceOf[MarkerTypes]

inline def MARKER_DIAMOND: MarkerTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MARKER_DIAMOND").asInstanceOf[MarkerTypes]

inline def MARKER_SQUARE: MarkerTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MARKER_SQUARE").asInstanceOf[MarkerTypes]

inline def MARKER_STAR: MarkerTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MARKER_STAR").asInstanceOf[MarkerTypes]

inline def MARKER_TILTED_CROSS: MarkerTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MARKER_TILTED_CROSS").asInstanceOf[MarkerTypes]

inline def MARKER_TRIANGLE_DOWN: MarkerTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MARKER_TRIANGLE_DOWN").asInstanceOf[MarkerTypes]

inline def MARKER_TRIANGLE_UP: MarkerTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MARKER_TRIANGLE_UP").asInstanceOf[MarkerTypes]

inline def MORPH_BLACKHAT: MorphTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MORPH_BLACKHAT").asInstanceOf[MorphTypes]

inline def MORPH_CLOSE: MorphTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MORPH_CLOSE").asInstanceOf[MorphTypes]

inline def MORPH_CROSS: MorphShapes = ^.asInstanceOf[js.Dynamic].selectDynamic("MORPH_CROSS").asInstanceOf[MorphShapes]

inline def MORPH_DILATE: MorphTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MORPH_DILATE").asInstanceOf[MorphTypes]

inline def MORPH_ELLIPSE: MorphShapes = ^.asInstanceOf[js.Dynamic].selectDynamic("MORPH_ELLIPSE").asInstanceOf[MorphShapes]

inline def MORPH_ERODE: MorphTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MORPH_ERODE").asInstanceOf[MorphTypes]

inline def MORPH_GRADIENT: MorphTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MORPH_GRADIENT").asInstanceOf[MorphTypes]

inline def MORPH_HITMISS: MorphTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MORPH_HITMISS").asInstanceOf[MorphTypes]

inline def MORPH_OPEN: MorphTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MORPH_OPEN").asInstanceOf[MorphTypes]

inline def MORPH_RECT: MorphShapes = ^.asInstanceOf[js.Dynamic].selectDynamic("MORPH_RECT").asInstanceOf[MorphShapes]

inline def MORPH_TOPHAT: MorphTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("MORPH_TOPHAT").asInstanceOf[MorphTypes]

inline def MOTION_AFFINE: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("MOTION_AFFINE").asInstanceOf[Any]

inline def MOTION_EUCLIDEAN: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("MOTION_EUCLIDEAN").asInstanceOf[Any]

inline def MOTION_HOMOGRAPHY: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("MOTION_HOMOGRAPHY").asInstanceOf[Any]

inline def MOTION_TRANSLATION: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("MOTION_TRANSLATION").asInstanceOf[Any]

inline def Mahalanobis(
  v1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  v2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  icovar: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("Mahalanobis")(v1.asInstanceOf[js.Any], v2.asInstanceOf[js.Any], icovar.asInstanceOf[js.Any])).asInstanceOf[double]

inline def NMSBoxes(bboxes: Any, scores: Any, score_threshold: Any, nms_threshold: Any, indices: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("NMSBoxes")(bboxes.asInstanceOf[js.Any], scores.asInstanceOf[js.Any], score_threshold.asInstanceOf[js.Any], nms_threshold.asInstanceOf[js.Any], indices.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def NMSBoxes(bboxes: Any, scores: Any, score_threshold: Any, nms_threshold: Any, indices: Any, eta: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("NMSBoxes")(bboxes.asInstanceOf[js.Any], scores.asInstanceOf[js.Any], score_threshold.asInstanceOf[js.Any], nms_threshold.asInstanceOf[js.Any], indices.asInstanceOf[js.Any], eta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def NMSBoxes(
  bboxes: Any,
  scores: Any,
  score_threshold: Any,
  nms_threshold: Any,
  indices: Any,
  eta: Any,
  top_k: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("NMSBoxes")(bboxes.asInstanceOf[js.Any], scores.asInstanceOf[js.Any], score_threshold.asInstanceOf[js.Any], nms_threshold.asInstanceOf[js.Any], indices.asInstanceOf[js.Any], eta.asInstanceOf[js.Any], top_k.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def NMSBoxes(
  bboxes: Any,
  scores: Any,
  score_threshold: Any,
  nms_threshold: Any,
  indices: Any,
  eta: Unit,
  top_k: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("NMSBoxes")(bboxes.asInstanceOf[js.Any], scores.asInstanceOf[js.Any], score_threshold.asInstanceOf[js.Any], nms_threshold.asInstanceOf[js.Any], indices.asInstanceOf[js.Any], eta.asInstanceOf[js.Any], top_k.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def NORM_HAMMING: NormTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("NORM_HAMMING").asInstanceOf[NormTypes]

inline def NORM_HAMMING2: NormTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("NORM_HAMMING2").asInstanceOf[NormTypes]

inline def NORM_INF: NormTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("NORM_INF").asInstanceOf[NormTypes]

inline def NORM_L1: NormTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("NORM_L1").asInstanceOf[NormTypes]

inline def NORM_L2: NormTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("NORM_L2").asInstanceOf[NormTypes]

inline def NORM_L2SQR: NormTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("NORM_L2SQR").asInstanceOf[NormTypes]

inline def NORM_MINMAX: NormTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("NORM_MINMAX").asInstanceOf[NormTypes]

inline def NORM_RELATIVE: NormTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("NORM_RELATIVE").asInstanceOf[NormTypes]

inline def NORM_TYPE_MASK: NormTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("NORM_TYPE_MASK").asInstanceOf[NormTypes]

inline def NOT_DRAW_SINGLE_POINTS: DrawMatchesFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("NOT_DRAW_SINGLE_POINTS").asInstanceOf[DrawMatchesFlags]

inline def OPTFLOW_FARNEBACK_GAUSSIAN: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("OPTFLOW_FARNEBACK_GAUSSIAN").asInstanceOf[Any]

inline def OPTFLOW_LK_GET_MIN_EIGENVALS: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("OPTFLOW_LK_GET_MIN_EIGENVALS").asInstanceOf[Any]

inline def OPTFLOW_USE_INITIAL_FLOW: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("OPTFLOW_USE_INITIAL_FLOW").asInstanceOf[Any]

inline def PCABackProject(
  data: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mean: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  eigenvectors: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  result: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("PCABackProject")(data.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], eigenvectors.asInstanceOf[js.Any], result.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def PCACompute(
  data: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mean: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  eigenvectors: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("PCACompute")(data.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], eigenvectors.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def PCACompute(
  data: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mean: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  eigenvectors: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  eigenvalues: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("PCACompute")(data.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], eigenvectors.asInstanceOf[js.Any], eigenvalues.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def PCACompute(
  data: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mean: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  eigenvectors: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  eigenvalues: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxComponents: double | int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("PCACompute")(data.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], eigenvectors.asInstanceOf[js.Any], eigenvalues.asInstanceOf[js.Any], maxComponents.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def PCACompute(
  data: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mean: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  eigenvectors: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxComponents: double | int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("PCACompute")(data.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], eigenvectors.asInstanceOf[js.Any], maxComponents.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def PCAProject(
  data: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mean: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  eigenvectors: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  result: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("PCAProject")(data.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], eigenvectors.asInstanceOf[js.Any], result.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def PROJ_SPHERICAL_EQRECT: UndistortTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("PROJ_SPHERICAL_EQRECT").asInstanceOf[UndistortTypes]

inline def PROJ_SPHERICAL_ORTHO: UndistortTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("PROJ_SPHERICAL_ORTHO").asInstanceOf[UndistortTypes]

inline def PSNR(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("PSNR")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any])).asInstanceOf[double]
inline def PSNR(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R: double
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("PSNR")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], R.asInstanceOf[js.Any])).asInstanceOf[double]

inline def RANSAC: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("RANSAC").asInstanceOf[Any]

inline def RETR_CCOMP: RetrievalModes = ^.asInstanceOf[js.Dynamic].selectDynamic("RETR_CCOMP").asInstanceOf[RetrievalModes]

inline def RETR_EXTERNAL: RetrievalModes = ^.asInstanceOf[js.Dynamic].selectDynamic("RETR_EXTERNAL").asInstanceOf[RetrievalModes]

inline def RETR_FLOODFILL: RetrievalModes = ^.asInstanceOf[js.Dynamic].selectDynamic("RETR_FLOODFILL").asInstanceOf[RetrievalModes]

inline def RETR_LIST: RetrievalModes = ^.asInstanceOf[js.Dynamic].selectDynamic("RETR_LIST").asInstanceOf[RetrievalModes]

inline def RETR_TREE: RetrievalModes = ^.asInstanceOf[js.Dynamic].selectDynamic("RETR_TREE").asInstanceOf[RetrievalModes]

inline def RHO: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("RHO").asInstanceOf[Any]

inline def ROTATE_180: RotateFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("ROTATE_180").asInstanceOf[RotateFlags]

inline def ROTATE_90_CLOCKWISE: RotateFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("ROTATE_90_CLOCKWISE").asInstanceOf[RotateFlags]

inline def ROTATE_90_COUNTERCLOCKWISE: RotateFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("ROTATE_90_COUNTERCLOCKWISE").asInstanceOf[RotateFlags]

inline def RQDecomp3x3(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mtxR: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  mtxQ: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Vec3d = (^.asInstanceOf[js.Dynamic].applyDynamic("RQDecomp3x3")(src.asInstanceOf[js.Any], mtxR.asInstanceOf[js.Any], mtxQ.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Vec3d]
inline def RQDecomp3x3(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mtxR: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  mtxQ: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Qx: Unit,
  Qy: Unit,
  Qz: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Vec3d = (^.asInstanceOf[js.Dynamic].applyDynamic("RQDecomp3x3")(src.asInstanceOf[js.Any], mtxR.asInstanceOf[js.Any], mtxQ.asInstanceOf[js.Any], Qx.asInstanceOf[js.Any], Qy.asInstanceOf[js.Any], Qz.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Vec3d]
inline def RQDecomp3x3(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mtxR: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  mtxQ: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Qx: Unit,
  Qy: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Vec3d = (^.asInstanceOf[js.Dynamic].applyDynamic("RQDecomp3x3")(src.asInstanceOf[js.Any], mtxR.asInstanceOf[js.Any], mtxQ.asInstanceOf[js.Any], Qx.asInstanceOf[js.Any], Qy.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Vec3d]
inline def RQDecomp3x3(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mtxR: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  mtxQ: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Qx: Unit,
  Qy: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Qz: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Vec3d = (^.asInstanceOf[js.Dynamic].applyDynamic("RQDecomp3x3")(src.asInstanceOf[js.Any], mtxR.asInstanceOf[js.Any], mtxQ.asInstanceOf[js.Any], Qx.asInstanceOf[js.Any], Qy.asInstanceOf[js.Any], Qz.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Vec3d]
inline def RQDecomp3x3(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mtxR: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  mtxQ: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Qx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Vec3d = (^.asInstanceOf[js.Dynamic].applyDynamic("RQDecomp3x3")(src.asInstanceOf[js.Any], mtxR.asInstanceOf[js.Any], mtxQ.asInstanceOf[js.Any], Qx.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Vec3d]
inline def RQDecomp3x3(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mtxR: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  mtxQ: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Qx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Qy: Unit,
  Qz: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Vec3d = (^.asInstanceOf[js.Dynamic].applyDynamic("RQDecomp3x3")(src.asInstanceOf[js.Any], mtxR.asInstanceOf[js.Any], mtxQ.asInstanceOf[js.Any], Qx.asInstanceOf[js.Any], Qy.asInstanceOf[js.Any], Qz.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Vec3d]
inline def RQDecomp3x3(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mtxR: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  mtxQ: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Qx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Qy: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Vec3d = (^.asInstanceOf[js.Dynamic].applyDynamic("RQDecomp3x3")(src.asInstanceOf[js.Any], mtxR.asInstanceOf[js.Any], mtxQ.asInstanceOf[js.Any], Qx.asInstanceOf[js.Any], Qy.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Vec3d]
inline def RQDecomp3x3(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mtxR: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  mtxQ: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Qx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Qy: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Qz: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Vec3d = (^.asInstanceOf[js.Dynamic].applyDynamic("RQDecomp3x3")(src.asInstanceOf[js.Any], mtxR.asInstanceOf[js.Any], mtxQ.asInstanceOf[js.Any], Qx.asInstanceOf[js.Any], Qy.asInstanceOf[js.Any], Qz.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Vec3d]

inline def Rodrigues(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Rodrigues")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Rodrigues(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  jacobian: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Rodrigues")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], jacobian.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def SOLVEPNP_AP3P: SolvePnPMethod = ^.asInstanceOf[js.Dynamic].selectDynamic("SOLVEPNP_AP3P").asInstanceOf[SolvePnPMethod]

inline def SOLVEPNP_DLS: SolvePnPMethod = ^.asInstanceOf[js.Dynamic].selectDynamic("SOLVEPNP_DLS").asInstanceOf[SolvePnPMethod]

inline def SOLVEPNP_EPNP: SolvePnPMethod = ^.asInstanceOf[js.Dynamic].selectDynamic("SOLVEPNP_EPNP").asInstanceOf[SolvePnPMethod]

inline def SOLVEPNP_IPPE: SolvePnPMethod = ^.asInstanceOf[js.Dynamic].selectDynamic("SOLVEPNP_IPPE").asInstanceOf[SolvePnPMethod]

inline def SOLVEPNP_IPPE_SQUARE: SolvePnPMethod = ^.asInstanceOf[js.Dynamic].selectDynamic("SOLVEPNP_IPPE_SQUARE").asInstanceOf[SolvePnPMethod]

inline def SOLVEPNP_ITERATIVE: SolvePnPMethod = ^.asInstanceOf[js.Dynamic].selectDynamic("SOLVEPNP_ITERATIVE").asInstanceOf[SolvePnPMethod]

inline def SOLVEPNP_P3P: SolvePnPMethod = ^.asInstanceOf[js.Dynamic].selectDynamic("SOLVEPNP_P3P").asInstanceOf[SolvePnPMethod]

inline def SOLVEPNP_UPNP: SolvePnPMethod = ^.asInstanceOf[js.Dynamic].selectDynamic("SOLVEPNP_UPNP").asInstanceOf[SolvePnPMethod]

inline def SORT_ASCENDING: SortFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("SORT_ASCENDING").asInstanceOf[SortFlags]

inline def SORT_DESCENDING: SortFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("SORT_DESCENDING").asInstanceOf[SortFlags]

inline def SORT_EVERY_COLUMN: SortFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("SORT_EVERY_COLUMN").asInstanceOf[SortFlags]

inline def SORT_EVERY_ROW: SortFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("SORT_EVERY_ROW").asInstanceOf[SortFlags]

inline def SUBMATRIX_FLAG: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("SUBMATRIX_FLAG").asInstanceOf[Any]

inline def SVBackSubst(
  w: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  u: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  vt: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rhs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("SVBackSubst")(w.asInstanceOf[js.Any], u.asInstanceOf[js.Any], vt.asInstanceOf[js.Any], rhs.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def SVDecomp(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  w: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  u: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  vt: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("SVDecomp")(src.asInstanceOf[js.Any], w.asInstanceOf[js.Any], u.asInstanceOf[js.Any], vt.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def SVDecomp(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  w: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  u: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  vt: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("SVDecomp")(src.asInstanceOf[js.Any], w.asInstanceOf[js.Any], u.asInstanceOf[js.Any], vt.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def Scharr(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  dx: int,
  dy: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Scharr")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Scharr(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  scale: Unit,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Scharr")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Scharr(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  scale: Unit,
  delta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Scharr")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Scharr(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  scale: Unit,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Scharr")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Scharr(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  scale: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Scharr")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Scharr(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  scale: double,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Scharr")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Scharr(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  scale: double,
  delta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Scharr")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Scharr(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  scale: double,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Scharr")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def Sobel(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  dx: int,
  dy: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: Unit,
  scale: Unit,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: Unit,
  scale: Unit,
  delta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: Unit,
  scale: Unit,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: Unit,
  scale: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: Unit,
  scale: double,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: Unit,
  scale: double,
  delta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: Unit,
  scale: double,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: int,
  scale: Unit,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: int,
  scale: Unit,
  delta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: int,
  scale: Unit,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: int,
  scale: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: int,
  scale: double,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: int,
  scale: double,
  delta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def Sobel(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  dx: int,
  dy: int,
  ksize: int,
  scale: double,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Sobel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def THRESH_BINARY: ThresholdTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("THRESH_BINARY").asInstanceOf[ThresholdTypes]

inline def THRESH_BINARY_INV: ThresholdTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("THRESH_BINARY_INV").asInstanceOf[ThresholdTypes]

inline def THRESH_MASK: ThresholdTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("THRESH_MASK").asInstanceOf[ThresholdTypes]

inline def THRESH_OTSU: ThresholdTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("THRESH_OTSU").asInstanceOf[ThresholdTypes]

inline def THRESH_TOZERO: ThresholdTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("THRESH_TOZERO").asInstanceOf[ThresholdTypes]

inline def THRESH_TOZERO_INV: ThresholdTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("THRESH_TOZERO_INV").asInstanceOf[ThresholdTypes]

inline def THRESH_TRIANGLE: ThresholdTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("THRESH_TRIANGLE").asInstanceOf[ThresholdTypes]

inline def THRESH_TRUNC: ThresholdTypes = ^.asInstanceOf[js.Dynamic].selectDynamic("THRESH_TRUNC").asInstanceOf[ThresholdTypes]

inline def TM_CCOEFF: TemplateMatchModes = ^.asInstanceOf[js.Dynamic].selectDynamic("TM_CCOEFF").asInstanceOf[TemplateMatchModes]

inline def TM_CCOEFF_NORMED: TemplateMatchModes = ^.asInstanceOf[js.Dynamic].selectDynamic("TM_CCOEFF_NORMED").asInstanceOf[TemplateMatchModes]

inline def TM_CCORR: TemplateMatchModes = ^.asInstanceOf[js.Dynamic].selectDynamic("TM_CCORR").asInstanceOf[TemplateMatchModes]

inline def TM_CCORR_NORMED: TemplateMatchModes = ^.asInstanceOf[js.Dynamic].selectDynamic("TM_CCORR_NORMED").asInstanceOf[TemplateMatchModes]

inline def TM_SQDIFF: TemplateMatchModes = ^.asInstanceOf[js.Dynamic].selectDynamic("TM_SQDIFF").asInstanceOf[TemplateMatchModes]

inline def TM_SQDIFF_NORMED: TemplateMatchModes = ^.asInstanceOf[js.Dynamic].selectDynamic("TM_SQDIFF_NORMED").asInstanceOf[TemplateMatchModes]

inline def TYPE_MASK: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("TYPE_MASK").asInstanceOf[Any]

inline def TermCriteriaCOUNT: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("TermCriteria_COUNT").asInstanceOf[Any]

inline def TermCriteriaEPS: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("TermCriteria_EPS").asInstanceOf[Any]

inline def TermCriteriaMAXITER: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("TermCriteria_MAX_ITER").asInstanceOf[Any]

inline def USE_AVG: Flags = ^.asInstanceOf[js.Dynamic].selectDynamic("USE_AVG").asInstanceOf[Flags]

inline def WARP_FILL_OUTLIERS: InterpolationFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("WARP_FILL_OUTLIERS").asInstanceOf[InterpolationFlags]

inline def WARP_INVERSE_MAP: InterpolationFlags = ^.asInstanceOf[js.Dynamic].selectDynamic("WARP_INVERSE_MAP").asInstanceOf[InterpolationFlags]

inline def WARP_POLAR_LINEAR: WarpPolarMode = ^.asInstanceOf[js.Dynamic].selectDynamic("WARP_POLAR_LINEAR").asInstanceOf[WarpPolarMode]

inline def WARP_POLAR_LOG: WarpPolarMode = ^.asInstanceOf[js.Dynamic].selectDynamic("WARP_POLAR_LOG").asInstanceOf[WarpPolarMode]

inline def absdiff(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("absdiff")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def adaptiveThreshold(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxValue: double,
  adaptiveMethod: int,
  thresholdType: int,
  blockSize: int,
  C: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("adaptiveThreshold")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], maxValue.asInstanceOf[js.Any], adaptiveMethod.asInstanceOf[js.Any], thresholdType.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], C.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def add(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("add")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def add(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  mask: Unit,
  dtype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("add")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def add(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("add")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def add(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dtype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("add")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def addWeighted(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  alpha: double,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  beta: double,
  gamma: double,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("addWeighted")(src1.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], gamma.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def addWeighted(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  alpha: double,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  beta: double,
  gamma: double,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("addWeighted")(src1.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], gamma.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def alignPtr(arg92: Any, ptr: Any): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("alignPtr")(arg92.asInstanceOf[js.Any], ptr.asInstanceOf[js.Any])).asInstanceOf[Any]
inline def alignPtr(arg92: Any, ptr: Any, n: int): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("alignPtr")(arg92.asInstanceOf[js.Any], ptr.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[Any]

inline def alignSize(sz: sizeT, n: int): sizeT = (^.asInstanceOf[js.Dynamic].applyDynamic("alignSize")(sz.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[sizeT]

inline def approxPolyDP(
  curve: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  approxCurve: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  epsilon: double,
  closed: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("approxPolyDP")(curve.asInstanceOf[js.Any], approxCurve.asInstanceOf[js.Any], epsilon.asInstanceOf[js.Any], closed.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def arcLength(curve: typings.mirada.distSrcTypesOpencvTypesMod.InputArray, closed: bool): double = (^.asInstanceOf[js.Dynamic].applyDynamic("arcLength")(curve.asInstanceOf[js.Any], closed.asInstanceOf[js.Any])).asInstanceOf[double]

inline def arrowedLine(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: Unit,
  line_type: Unit,
  shift: Unit,
  tipLength: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], tipLength.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: Unit,
  line_type: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: Unit,
  line_type: Unit,
  shift: int,
  tipLength: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], tipLength.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: Unit,
  line_type: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: Unit,
  line_type: int,
  shift: Unit,
  tipLength: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], tipLength.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: Unit,
  line_type: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: Unit,
  line_type: int,
  shift: int,
  tipLength: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], tipLength.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: int,
  line_type: Unit,
  shift: Unit,
  tipLength: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], tipLength.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: int,
  line_type: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: int,
  line_type: Unit,
  shift: int,
  tipLength: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], tipLength.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: int,
  line_type: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: int,
  line_type: int,
  shift: Unit,
  tipLength: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], tipLength.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: int,
  line_type: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def arrowedLine(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: int,
  line_type: int,
  shift: int,
  tipLength: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("arrowedLine")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], tipLength.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: Unit,
  K: Unit,
  mask: Unit,
  update: Unit,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: Unit,
  K: Unit,
  mask: Unit,
  update: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: Unit,
  K: Unit,
  mask: Unit,
  update: int,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: Unit,
  K: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: Unit,
  K: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  update: Unit,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: Unit,
  K: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  update: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: Unit,
  K: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  update: int,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: Unit,
  K: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: Unit,
  K: int,
  mask: Unit,
  update: Unit,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: Unit,
  K: int,
  mask: Unit,
  update: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: Unit,
  K: int,
  mask: Unit,
  update: int,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: Unit,
  K: int,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: Unit,
  K: int,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  update: Unit,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: Unit,
  K: int,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  update: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: Unit,
  K: int,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  update: int,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: int,
  K: Unit,
  mask: Unit,
  update: Unit,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: int,
  K: Unit,
  mask: Unit,
  update: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: int,
  K: Unit,
  mask: Unit,
  update: int,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: int,
  K: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: int,
  K: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  update: Unit,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: int,
  K: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  update: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: int,
  K: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  update: int,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: int,
  K: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: int,
  K: int,
  mask: Unit,
  update: Unit,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: int,
  K: int,
  mask: Unit,
  update: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: int,
  K: int,
  mask: Unit,
  update: int,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: int,
  K: int,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: int,
  K: int,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  update: Unit,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: int,
  K: int,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  update: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def batchDistance(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int,
  nidx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  normType: int,
  K: int,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  update: int,
  crosscheck: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("batchDistance")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dist.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], nidx.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], K.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], update.asInstanceOf[js.Any], crosscheck.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def bilateralFilter(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  d: int,
  sigmaColor: double,
  sigmaSpace: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bilateralFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], d.asInstanceOf[js.Any], sigmaColor.asInstanceOf[js.Any], sigmaSpace.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def bilateralFilter(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  d: int,
  sigmaColor: double,
  sigmaSpace: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bilateralFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], d.asInstanceOf[js.Any], sigmaColor.asInstanceOf[js.Any], sigmaSpace.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def bitwiseAnd(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bitwise_and")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def bitwiseAnd(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bitwise_and")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def bitwiseNot(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bitwise_not")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def bitwiseNot(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bitwise_not")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def bitwiseOr(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bitwise_or")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def bitwiseOr(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bitwise_or")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def bitwiseXor(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bitwise_xor")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def bitwiseXor(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bitwise_xor")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def blendLinear(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  weights1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  weights2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("blendLinear")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], weights1.asInstanceOf[js.Any], weights2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def blobFromImage(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  blob: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  scalefactor: js.UndefOr[double],
  size: js.UndefOr[Any],
  mean: js.UndefOr[Any],
  swapRB: js.UndefOr[bool],
  crop: js.UndefOr[bool],
  ddepth: js.UndefOr[int]
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("blobFromImage")(image.asInstanceOf[js.Any], blob.asInstanceOf[js.Any], scalefactor.asInstanceOf[js.Any], size.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], swapRB.asInstanceOf[js.Any], crop.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def blobFromImage(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  scalefactor: js.UndefOr[double],
  size: js.UndefOr[Any],
  mean: js.UndefOr[Any],
  swapRB: js.UndefOr[bool],
  crop: js.UndefOr[bool],
  ddepth: js.UndefOr[int]
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("blobFromImage")(image.asInstanceOf[js.Any], scalefactor.asInstanceOf[js.Any], size.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], swapRB.asInstanceOf[js.Any], crop.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]

inline def blobFromImages(
  images: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  blob: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  scalefactor: js.UndefOr[double],
  size: js.UndefOr[typings.mirada.distSrcTypesOpencvTypesMod.Size],
  mean: js.UndefOr[Any],
  swapRB: js.UndefOr[bool],
  crop: js.UndefOr[bool],
  ddepth: js.UndefOr[int]
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("blobFromImages")(images.asInstanceOf[js.Any], blob.asInstanceOf[js.Any], scalefactor.asInstanceOf[js.Any], size.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], swapRB.asInstanceOf[js.Any], crop.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def blobFromImages(
  images: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  scalefactor: js.UndefOr[double],
  size: js.UndefOr[typings.mirada.distSrcTypesOpencvTypesMod.Size],
  mean: js.UndefOr[Any],
  swapRB: js.UndefOr[bool],
  crop: js.UndefOr[bool],
  ddepth: js.UndefOr[int]
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("blobFromImages")(images.asInstanceOf[js.Any], scalefactor.asInstanceOf[js.Any], size.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], swapRB.asInstanceOf[js.Any], crop.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]

inline def blur(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("blur")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def blur(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  anchor: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("blur")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def blur(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("blur")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def blur(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("blur")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def borderInterpolate(p: int, len: int, borderType: int): int = (^.asInstanceOf[js.Dynamic].applyDynamic("borderInterpolate")(p.asInstanceOf[js.Any], len.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[int]

inline def boundingRect(array: typings.mirada.distSrcTypesOpencvTypesMod.InputArray): typings.mirada.distSrcTypesOpencvTypesMod.Rect = ^.asInstanceOf[js.Dynamic].applyDynamic("boundingRect")(array.asInstanceOf[js.Any]).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Rect]

inline def boxFilter(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("boxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def boxFilter(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  anchor: Unit,
  normalize: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("boxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def boxFilter(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  anchor: Unit,
  normalize: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("boxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def boxFilter(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  anchor: Unit,
  normalize: bool,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("boxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def boxFilter(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("boxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def boxFilter(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  normalize: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("boxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def boxFilter(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  normalize: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("boxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def boxFilter(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  normalize: bool,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("boxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def boxPoints(
  box: typings.mirada.distSrcTypesOpencvTypesMod.RotatedRect,
  points: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("boxPoints")(box.asInstanceOf[js.Any], points.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def buildOpticalFlowPyramid(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  pyramid: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  pyramid: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: int,
  withDerivatives: Unit,
  pyrBorder: Unit,
  derivBorder: Unit,
  tryReuseInputImage: bool
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any], derivBorder.asInstanceOf[js.Any], tryReuseInputImage.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  pyramid: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: int,
  withDerivatives: Unit,
  pyrBorder: Unit,
  derivBorder: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any], derivBorder.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  pyramid: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: int,
  withDerivatives: Unit,
  pyrBorder: Unit,
  derivBorder: int,
  tryReuseInputImage: bool
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any], derivBorder.asInstanceOf[js.Any], tryReuseInputImage.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  pyramid: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: int,
  withDerivatives: Unit,
  pyrBorder: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  pyramid: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: int,
  withDerivatives: Unit,
  pyrBorder: int,
  derivBorder: Unit,
  tryReuseInputImage: bool
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any], derivBorder.asInstanceOf[js.Any], tryReuseInputImage.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  pyramid: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: int,
  withDerivatives: Unit,
  pyrBorder: int,
  derivBorder: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any], derivBorder.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  pyramid: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: int,
  withDerivatives: Unit,
  pyrBorder: int,
  derivBorder: int,
  tryReuseInputImage: bool
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any], derivBorder.asInstanceOf[js.Any], tryReuseInputImage.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  pyramid: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: int,
  withDerivatives: bool
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  pyramid: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: int,
  withDerivatives: bool,
  pyrBorder: Unit,
  derivBorder: Unit,
  tryReuseInputImage: bool
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any], derivBorder.asInstanceOf[js.Any], tryReuseInputImage.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  pyramid: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: int,
  withDerivatives: bool,
  pyrBorder: Unit,
  derivBorder: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any], derivBorder.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  pyramid: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: int,
  withDerivatives: bool,
  pyrBorder: Unit,
  derivBorder: int,
  tryReuseInputImage: bool
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any], derivBorder.asInstanceOf[js.Any], tryReuseInputImage.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  pyramid: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: int,
  withDerivatives: bool,
  pyrBorder: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  pyramid: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: int,
  withDerivatives: bool,
  pyrBorder: int,
  derivBorder: Unit,
  tryReuseInputImage: bool
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any], derivBorder.asInstanceOf[js.Any], tryReuseInputImage.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  pyramid: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: int,
  withDerivatives: bool,
  pyrBorder: int,
  derivBorder: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any], derivBorder.asInstanceOf[js.Any])).asInstanceOf[int]
inline def buildOpticalFlowPyramid(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  pyramid: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: int,
  withDerivatives: bool,
  pyrBorder: int,
  derivBorder: int,
  tryReuseInputImage: bool
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("buildOpticalFlowPyramid")(img.asInstanceOf[js.Any], pyramid.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], withDerivatives.asInstanceOf[js.Any], pyrBorder.asInstanceOf[js.Any], derivBorder.asInstanceOf[js.Any], tryReuseInputImage.asInstanceOf[js.Any])).asInstanceOf[int]

inline def buildPyramid(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  maxlevel: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("buildPyramid")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], maxlevel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def buildPyramid(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  maxlevel: int,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("buildPyramid")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], maxlevel.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def calcBackProject(
  images: Any,
  nimages: int,
  channels: Any,
  hist: Any,
  backProject: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ranges: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcBackProject")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], backProject.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcBackProject(
  images: Any,
  nimages: int,
  channels: Any,
  hist: Any,
  backProject: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ranges: Any,
  scale: Unit,
  uniform: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcBackProject")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], backProject.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], uniform.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcBackProject(
  images: Any,
  nimages: int,
  channels: Any,
  hist: Any,
  backProject: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ranges: Any,
  scale: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcBackProject")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], backProject.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcBackProject(
  images: Any,
  nimages: int,
  channels: Any,
  hist: Any,
  backProject: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ranges: Any,
  scale: double,
  uniform: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcBackProject")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], backProject.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], uniform.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcBackProject(
  images: Any,
  nimages: int,
  channels: Any,
  hist: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  backProject: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ranges: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcBackProject")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], backProject.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcBackProject(
  images: Any,
  nimages: int,
  channels: Any,
  hist: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  backProject: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ranges: Any,
  scale: Unit,
  uniform: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcBackProject")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], backProject.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], uniform.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcBackProject(
  images: Any,
  nimages: int,
  channels: Any,
  hist: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  backProject: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ranges: Any,
  scale: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcBackProject")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], backProject.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcBackProject(
  images: Any,
  nimages: int,
  channels: Any,
  hist: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  backProject: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ranges: Any,
  scale: double,
  uniform: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcBackProject")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], backProject.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], uniform.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcBackProject(
  images: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  channels: Any,
  hist: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ranges: Any,
  scale: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcBackProject")(images.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def calcCovarMatrix(samples: Any, nsamples: int, covar: Any, mean: Any, flags: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcCovarMatrix")(samples.asInstanceOf[js.Any], nsamples.asInstanceOf[js.Any], covar.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcCovarMatrix(samples: Any, nsamples: int, covar: Any, mean: Any, flags: int, ctype: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcCovarMatrix")(samples.asInstanceOf[js.Any], nsamples.asInstanceOf[js.Any], covar.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], ctype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcCovarMatrix(
  samples: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  covar: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  mean: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcCovarMatrix")(samples.asInstanceOf[js.Any], covar.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcCovarMatrix(
  samples: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  covar: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  mean: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  flags: int,
  ctype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcCovarMatrix")(samples.asInstanceOf[js.Any], covar.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], ctype.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def calcHist(
  images: Any,
  nimages: int,
  channels: Any,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  hist: Any,
  dims: int,
  histSize: Any,
  ranges: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcHist")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], dims.asInstanceOf[js.Any], histSize.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcHist(
  images: Any,
  nimages: int,
  channels: Any,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  hist: Any,
  dims: int,
  histSize: Any,
  ranges: Any,
  uniform: Unit,
  accumulate: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcHist")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], dims.asInstanceOf[js.Any], histSize.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], uniform.asInstanceOf[js.Any], accumulate.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcHist(
  images: Any,
  nimages: int,
  channels: Any,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  hist: Any,
  dims: int,
  histSize: Any,
  ranges: Any,
  uniform: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcHist")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], dims.asInstanceOf[js.Any], histSize.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], uniform.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcHist(
  images: Any,
  nimages: int,
  channels: Any,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  hist: Any,
  dims: int,
  histSize: Any,
  ranges: Any,
  uniform: bool,
  accumulate: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcHist")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], dims.asInstanceOf[js.Any], histSize.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], uniform.asInstanceOf[js.Any], accumulate.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcHist(
  images: Any,
  nimages: int,
  channels: Any,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  hist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dims: int,
  histSize: Any,
  ranges: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcHist")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], dims.asInstanceOf[js.Any], histSize.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcHist(
  images: Any,
  nimages: int,
  channels: Any,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  hist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dims: int,
  histSize: Any,
  ranges: Any,
  uniform: Unit,
  accumulate: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcHist")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], dims.asInstanceOf[js.Any], histSize.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], uniform.asInstanceOf[js.Any], accumulate.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcHist(
  images: Any,
  nimages: int,
  channels: Any,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  hist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dims: int,
  histSize: Any,
  ranges: Any,
  uniform: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcHist")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], dims.asInstanceOf[js.Any], histSize.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], uniform.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcHist(
  images: Any,
  nimages: int,
  channels: Any,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  hist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dims: int,
  histSize: Any,
  ranges: Any,
  uniform: bool,
  accumulate: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcHist")(images.asInstanceOf[js.Any], nimages.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], dims.asInstanceOf[js.Any], histSize.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], uniform.asInstanceOf[js.Any], accumulate.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcHist(
  images: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  channels: Any,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  hist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  histSize: Any,
  ranges: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcHist")(images.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], histSize.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcHist(
  images: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  channels: Any,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  hist: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  histSize: Any,
  ranges: Any,
  accumulate: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcHist")(images.asInstanceOf[js.Any], channels.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], hist.asInstanceOf[js.Any], histSize.asInstanceOf[js.Any], ranges.asInstanceOf[js.Any], accumulate.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def calcOpticalFlowFarneback(
  prev: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  next: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  flow: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pyr_scale: double,
  levels: int,
  winsize: int,
  iterations: int,
  poly_n: int,
  poly_sigma: double,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowFarneback")(prev.asInstanceOf[js.Any], next.asInstanceOf[js.Any], flow.asInstanceOf[js.Any], pyr_scale.asInstanceOf[js.Any], levels.asInstanceOf[js.Any], winsize.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], poly_n.asInstanceOf[js.Any], poly_sigma.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: Unit,
  maxLevel: Unit,
  criteria: Unit,
  flags: Unit,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: Unit,
  maxLevel: Unit,
  criteria: Unit,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: Unit,
  maxLevel: Unit,
  criteria: Unit,
  flags: int,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: Unit,
  maxLevel: Unit,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: Unit,
  maxLevel: Unit,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria,
  flags: Unit,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: Unit,
  maxLevel: Unit,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: Unit,
  maxLevel: Unit,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria,
  flags: int,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: Unit,
  maxLevel: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: Unit,
  maxLevel: int,
  criteria: Unit,
  flags: Unit,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: Unit,
  maxLevel: int,
  criteria: Unit,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: Unit,
  maxLevel: int,
  criteria: Unit,
  flags: int,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: Unit,
  maxLevel: int,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: Unit,
  maxLevel: int,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria,
  flags: Unit,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: Unit,
  maxLevel: int,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: Unit,
  maxLevel: int,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria,
  flags: int,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: Unit,
  criteria: Unit,
  flags: Unit,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: Unit,
  criteria: Unit,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: Unit,
  criteria: Unit,
  flags: int,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: Unit,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: Unit,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria,
  flags: Unit,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: Unit,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: Unit,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria,
  flags: int,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: int,
  criteria: Unit,
  flags: Unit,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: int,
  criteria: Unit,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: int,
  criteria: Unit,
  flags: int,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: int,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: int,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria,
  flags: Unit,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: int,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calcOpticalFlowPyrLK(
  prevImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextImg: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  prevPts: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  nextPts: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  status: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  err: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  maxLevel: int,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria,
  flags: int,
  minEigThreshold: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calcOpticalFlowPyrLK")(prevImg.asInstanceOf[js.Any], nextImg.asInstanceOf[js.Any], prevPts.asInstanceOf[js.Any], nextPts.asInstanceOf[js.Any], status.asInstanceOf[js.Any], err.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], minEigThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def calibrateCamera(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCamera")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCamera(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  flags: Unit,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCamera")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCamera(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  flags: int
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCamera")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCamera(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  flags: int,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCamera")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCamera(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  stdDeviationsIntrinsics: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  stdDeviationsExtrinsics: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  perViewErrors: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCamera")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], stdDeviationsIntrinsics.asInstanceOf[js.Any], stdDeviationsExtrinsics.asInstanceOf[js.Any], perViewErrors.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCamera(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  stdDeviationsIntrinsics: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  stdDeviationsExtrinsics: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  perViewErrors: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: Unit,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCamera")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], stdDeviationsIntrinsics.asInstanceOf[js.Any], stdDeviationsExtrinsics.asInstanceOf[js.Any], perViewErrors.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCamera(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  stdDeviationsIntrinsics: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  stdDeviationsExtrinsics: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  perViewErrors: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCamera")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], stdDeviationsIntrinsics.asInstanceOf[js.Any], stdDeviationsExtrinsics.asInstanceOf[js.Any], perViewErrors.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCamera(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  stdDeviationsIntrinsics: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  stdDeviationsExtrinsics: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  perViewErrors: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCamera")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], stdDeviationsIntrinsics.asInstanceOf[js.Any], stdDeviationsExtrinsics.asInstanceOf[js.Any], perViewErrors.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]

inline def calibrateCameraRO(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  iFixedPoint: int,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  newObjPoints: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCameraRO")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], iFixedPoint.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], newObjPoints.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCameraRO(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  iFixedPoint: int,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  newObjPoints: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: Unit,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCameraRO")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], iFixedPoint.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], newObjPoints.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCameraRO(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  iFixedPoint: int,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  newObjPoints: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCameraRO")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], iFixedPoint.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], newObjPoints.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCameraRO(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  iFixedPoint: int,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  newObjPoints: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCameraRO")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], iFixedPoint.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], newObjPoints.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCameraRO(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  iFixedPoint: int,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  newObjPoints: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  stdDeviationsIntrinsics: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  stdDeviationsExtrinsics: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  stdDeviationsObjPoints: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  perViewErrors: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCameraRO")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], iFixedPoint.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], newObjPoints.asInstanceOf[js.Any], stdDeviationsIntrinsics.asInstanceOf[js.Any], stdDeviationsExtrinsics.asInstanceOf[js.Any], stdDeviationsObjPoints.asInstanceOf[js.Any], perViewErrors.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCameraRO(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  iFixedPoint: int,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  newObjPoints: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  stdDeviationsIntrinsics: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  stdDeviationsExtrinsics: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  stdDeviationsObjPoints: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  perViewErrors: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: Unit,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCameraRO")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], iFixedPoint.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], newObjPoints.asInstanceOf[js.Any], stdDeviationsIntrinsics.asInstanceOf[js.Any], stdDeviationsExtrinsics.asInstanceOf[js.Any], stdDeviationsObjPoints.asInstanceOf[js.Any], perViewErrors.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCameraRO(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  iFixedPoint: int,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  newObjPoints: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  stdDeviationsIntrinsics: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  stdDeviationsExtrinsics: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  stdDeviationsObjPoints: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  perViewErrors: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCameraRO")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], iFixedPoint.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], newObjPoints.asInstanceOf[js.Any], stdDeviationsIntrinsics.asInstanceOf[js.Any], stdDeviationsExtrinsics.asInstanceOf[js.Any], stdDeviationsObjPoints.asInstanceOf[js.Any], perViewErrors.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[double]
inline def calibrateCameraRO(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  iFixedPoint: int,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  newObjPoints: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  stdDeviationsIntrinsics: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  stdDeviationsExtrinsics: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  stdDeviationsObjPoints: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  perViewErrors: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateCameraRO")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], iFixedPoint.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], newObjPoints.asInstanceOf[js.Any], stdDeviationsIntrinsics.asInstanceOf[js.Any], stdDeviationsExtrinsics.asInstanceOf[js.Any], stdDeviationsObjPoints.asInstanceOf[js.Any], perViewErrors.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]

inline def calibrateHandEye(
  R_gripper2base: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  t_gripper2base: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  R_target2cam: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  t_target2cam: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  R_cam2gripper: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  t_cam2gripper: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateHandEye")(R_gripper2base.asInstanceOf[js.Any], t_gripper2base.asInstanceOf[js.Any], R_target2cam.asInstanceOf[js.Any], t_target2cam.asInstanceOf[js.Any], R_cam2gripper.asInstanceOf[js.Any], t_cam2gripper.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def calibrateHandEye(
  R_gripper2base: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  t_gripper2base: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  R_target2cam: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  t_target2cam: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  R_cam2gripper: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  t_cam2gripper: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: HandEyeCalibrationMethod
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrateHandEye")(R_gripper2base.asInstanceOf[js.Any], t_gripper2base.asInstanceOf[js.Any], R_target2cam.asInstanceOf[js.Any], t_target2cam.asInstanceOf[js.Any], R_cam2gripper.asInstanceOf[js.Any], t_cam2gripper.asInstanceOf[js.Any], method.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def calibrationMatrixValues(
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  apertureWidth: double,
  apertureHeight: double,
  fovx: Any,
  fovy: Any,
  focalLength: Any,
  principalPoint: Any,
  aspectRatio: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("calibrationMatrixValues")(cameraMatrix.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], apertureWidth.asInstanceOf[js.Any], apertureHeight.asInstanceOf[js.Any], fovx.asInstanceOf[js.Any], fovy.asInstanceOf[js.Any], focalLength.asInstanceOf[js.Any], principalPoint.asInstanceOf[js.Any], aspectRatio.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def cartToPolar(
  x: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  y: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  magnitude: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  angle: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cartToPolar")(x.asInstanceOf[js.Any], y.asInstanceOf[js.Any], magnitude.asInstanceOf[js.Any], angle.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def cartToPolar(
  x: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  y: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  magnitude: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  angle: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  angleInDegrees: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cartToPolar")(x.asInstanceOf[js.Any], y.asInstanceOf[js.Any], magnitude.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], angleInDegrees.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def channels: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("channels").asInstanceOf[Any]

inline def checkChessboard(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  size: typings.mirada.distSrcTypesOpencvTypesMod.Size
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkChessboard")(img.asInstanceOf[js.Any], size.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def checkHardwareSupport(feature: int): bool = ^.asInstanceOf[js.Dynamic].applyDynamic("checkHardwareSupport")(feature.asInstanceOf[js.Any]).asInstanceOf[bool]

inline def checkRange(a: typings.mirada.distSrcTypesOpencvTypesMod.InputArray): bool = ^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any]).asInstanceOf[bool]
inline def checkRange(a: typings.mirada.distSrcTypesOpencvTypesMod.InputArray, quiet: Unit, pos: Any): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(
  a: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  quiet: Unit,
  pos: Any,
  minVal: Unit,
  maxVal: double
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(a: typings.mirada.distSrcTypesOpencvTypesMod.InputArray, quiet: Unit, pos: Any, minVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(
  a: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  quiet: Unit,
  pos: Any,
  minVal: double,
  maxVal: double
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(
  a: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  quiet: Unit,
  pos: Unit,
  minVal: Unit,
  maxVal: double
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(a: typings.mirada.distSrcTypesOpencvTypesMod.InputArray, quiet: Unit, pos: Unit, minVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(
  a: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  quiet: Unit,
  pos: Unit,
  minVal: double,
  maxVal: double
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(a: typings.mirada.distSrcTypesOpencvTypesMod.InputArray, quiet: bool): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(a: typings.mirada.distSrcTypesOpencvTypesMod.InputArray, quiet: bool, pos: Any): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(
  a: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  quiet: bool,
  pos: Any,
  minVal: Unit,
  maxVal: double
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(a: typings.mirada.distSrcTypesOpencvTypesMod.InputArray, quiet: bool, pos: Any, minVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(
  a: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  quiet: bool,
  pos: Any,
  minVal: double,
  maxVal: double
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(
  a: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  quiet: bool,
  pos: Unit,
  minVal: Unit,
  maxVal: double
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(a: typings.mirada.distSrcTypesOpencvTypesMod.InputArray, quiet: bool, pos: Unit, minVal: double): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def checkRange(
  a: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  quiet: bool,
  pos: Unit,
  minVal: double,
  maxVal: double
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("checkRange")(a.asInstanceOf[js.Any], quiet.asInstanceOf[js.Any], pos.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def circle(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  center: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  radius: int,
  color: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("circle")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], radius.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def circle(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  center: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  radius: int,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("circle")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], radius.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def circle(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  center: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  radius: int,
  color: Any,
  thickness: Unit,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("circle")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], radius.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def circle(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  center: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  radius: int,
  color: Any,
  thickness: Unit,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("circle")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], radius.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def circle(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  center: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  radius: int,
  color: Any,
  thickness: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("circle")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], radius.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def circle(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  center: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  radius: int,
  color: Any,
  thickness: int,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("circle")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], radius.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def circle(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  center: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  radius: int,
  color: Any,
  thickness: int,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("circle")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], radius.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def circle(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  center: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  radius: int,
  color: Any,
  thickness: int,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("circle")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], radius.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def clipLine(imgRect: typings.mirada.distSrcTypesOpencvTypesMod.Rect, pt1: Any, pt2: Any): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("clipLine")(imgRect.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def clipLine(imgSize: typings.mirada.distSrcTypesOpencvTypesMod.Size2l, pt1: Any, pt2: Any): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("clipLine")(imgSize.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def clipLine(imgSize: typings.mirada.distSrcTypesOpencvTypesMod.Size, pt1: Any, pt2: Any): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("clipLine")(imgSize.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def cols: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("cols").asInstanceOf[Any]

inline def compare(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  cmpop: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("compare")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], cmpop.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def compareHist(H1: Any, H2: Any, method: int): double = (^.asInstanceOf[js.Dynamic].applyDynamic("compareHist")(H1.asInstanceOf[js.Any], H2.asInstanceOf[js.Any], method.asInstanceOf[js.Any])).asInstanceOf[double]
inline def compareHist(
  H1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  H2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("compareHist")(H1.asInstanceOf[js.Any], H2.asInstanceOf[js.Any], method.asInstanceOf[js.Any])).asInstanceOf[double]

inline def completeSymm(m: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("completeSymm")(m.asInstanceOf[js.Any]).asInstanceOf[Unit]
inline def completeSymm(m: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray, lowerToUpper: bool): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("completeSymm")(m.asInstanceOf[js.Any], lowerToUpper.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def composeRT(
  rvec1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  tvec1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvec2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  tvec2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvec3: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  tvec3: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dr3dr1: js.UndefOr[typings.mirada.distSrcTypesOpencvTypesMod.OutputArray],
  dr3dt1: js.UndefOr[typings.mirada.distSrcTypesOpencvTypesMod.OutputArray],
  dr3dr2: js.UndefOr[typings.mirada.distSrcTypesOpencvTypesMod.OutputArray],
  dr3dt2: js.UndefOr[typings.mirada.distSrcTypesOpencvTypesMod.OutputArray],
  dt3dr1: js.UndefOr[typings.mirada.distSrcTypesOpencvTypesMod.OutputArray],
  dt3dt1: js.UndefOr[typings.mirada.distSrcTypesOpencvTypesMod.OutputArray],
  dt3dr2: js.UndefOr[typings.mirada.distSrcTypesOpencvTypesMod.OutputArray],
  dt3dt2: js.UndefOr[typings.mirada.distSrcTypesOpencvTypesMod.OutputArray]
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("composeRT")(rvec1.asInstanceOf[js.Any], tvec1.asInstanceOf[js.Any], rvec2.asInstanceOf[js.Any], tvec2.asInstanceOf[js.Any], rvec3.asInstanceOf[js.Any], tvec3.asInstanceOf[js.Any], dr3dr1.asInstanceOf[js.Any], dr3dt1.asInstanceOf[js.Any], dr3dr2.asInstanceOf[js.Any], dr3dt2.asInstanceOf[js.Any], dt3dr1.asInstanceOf[js.Any], dt3dt1.asInstanceOf[js.Any], dt3dr2.asInstanceOf[js.Any], dt3dt2.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def computeCorrespondEpilines(
  points: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  whichImage: int,
  F: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lines: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("computeCorrespondEpilines")(points.asInstanceOf[js.Any], whichImage.asInstanceOf[js.Any], F.asInstanceOf[js.Any], lines.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def computeECC(
  templateImage: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  inputImage: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("computeECC")(templateImage.asInstanceOf[js.Any], inputImage.asInstanceOf[js.Any])).asInstanceOf[double]
inline def computeECC(
  templateImage: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  inputImage: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  inputMask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("computeECC")(templateImage.asInstanceOf[js.Any], inputImage.asInstanceOf[js.Any], inputMask.asInstanceOf[js.Any])).asInstanceOf[double]

inline def connectedComponents(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  labels: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("connectedComponents")(image.asInstanceOf[js.Any], labels.asInstanceOf[js.Any])).asInstanceOf[int]
inline def connectedComponents(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  labels: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  connectivity: Unit,
  ltype: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("connectedComponents")(image.asInstanceOf[js.Any], labels.asInstanceOf[js.Any], connectivity.asInstanceOf[js.Any], ltype.asInstanceOf[js.Any])).asInstanceOf[int]
inline def connectedComponents(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  labels: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  connectivity: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("connectedComponents")(image.asInstanceOf[js.Any], labels.asInstanceOf[js.Any], connectivity.asInstanceOf[js.Any])).asInstanceOf[int]
inline def connectedComponents(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  labels: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  connectivity: int,
  ltype: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("connectedComponents")(image.asInstanceOf[js.Any], labels.asInstanceOf[js.Any], connectivity.asInstanceOf[js.Any], ltype.asInstanceOf[js.Any])).asInstanceOf[int]
inline def connectedComponents(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  labels: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  connectivity: int,
  ltype: int,
  ccltype: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("connectedComponents")(image.asInstanceOf[js.Any], labels.asInstanceOf[js.Any], connectivity.asInstanceOf[js.Any], ltype.asInstanceOf[js.Any], ccltype.asInstanceOf[js.Any])).asInstanceOf[int]

inline def connectedComponentsWithStats(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  labels: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  stats: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  centroids: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("connectedComponentsWithStats")(image.asInstanceOf[js.Any], labels.asInstanceOf[js.Any], stats.asInstanceOf[js.Any], centroids.asInstanceOf[js.Any])).asInstanceOf[int]
inline def connectedComponentsWithStats(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  labels: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  stats: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  centroids: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  connectivity: Unit,
  ltype: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("connectedComponentsWithStats")(image.asInstanceOf[js.Any], labels.asInstanceOf[js.Any], stats.asInstanceOf[js.Any], centroids.asInstanceOf[js.Any], connectivity.asInstanceOf[js.Any], ltype.asInstanceOf[js.Any])).asInstanceOf[int]
inline def connectedComponentsWithStats(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  labels: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  stats: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  centroids: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  connectivity: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("connectedComponentsWithStats")(image.asInstanceOf[js.Any], labels.asInstanceOf[js.Any], stats.asInstanceOf[js.Any], centroids.asInstanceOf[js.Any], connectivity.asInstanceOf[js.Any])).asInstanceOf[int]
inline def connectedComponentsWithStats(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  labels: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  stats: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  centroids: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  connectivity: int,
  ltype: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("connectedComponentsWithStats")(image.asInstanceOf[js.Any], labels.asInstanceOf[js.Any], stats.asInstanceOf[js.Any], centroids.asInstanceOf[js.Any], connectivity.asInstanceOf[js.Any], ltype.asInstanceOf[js.Any])).asInstanceOf[int]
inline def connectedComponentsWithStats(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  labels: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  stats: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  centroids: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  connectivity: int,
  ltype: int,
  ccltype: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("connectedComponentsWithStats")(image.asInstanceOf[js.Any], labels.asInstanceOf[js.Any], stats.asInstanceOf[js.Any], centroids.asInstanceOf[js.Any], connectivity.asInstanceOf[js.Any], ltype.asInstanceOf[js.Any], ccltype.asInstanceOf[js.Any])).asInstanceOf[int]

inline def contourArea(contour: typings.mirada.distSrcTypesOpencvTypesMod.InputArray): double = ^.asInstanceOf[js.Dynamic].applyDynamic("contourArea")(contour.asInstanceOf[js.Any]).asInstanceOf[double]
inline def contourArea(contour: typings.mirada.distSrcTypesOpencvTypesMod.InputArray, oriented: bool): double = (^.asInstanceOf[js.Dynamic].applyDynamic("contourArea")(contour.asInstanceOf[js.Any], oriented.asInstanceOf[js.Any])).asInstanceOf[double]

inline def convertFp16(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convertFp16")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def convertMaps(
  map1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  map2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstmap1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dstmap2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dstmap1type: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convertMaps")(map1.asInstanceOf[js.Any], map2.asInstanceOf[js.Any], dstmap1.asInstanceOf[js.Any], dstmap2.asInstanceOf[js.Any], dstmap1type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def convertMaps(
  map1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  map2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstmap1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dstmap2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dstmap1type: int,
  nninterpolation: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convertMaps")(map1.asInstanceOf[js.Any], map2.asInstanceOf[js.Any], dstmap1.asInstanceOf[js.Any], dstmap2.asInstanceOf[js.Any], dstmap1type.asInstanceOf[js.Any], nninterpolation.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def convertPointsFromHomogeneous(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convertPointsFromHomogeneous")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def convertPointsHomogeneous(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convertPointsHomogeneous")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def convertPointsToHomogeneous(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convertPointsToHomogeneous")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def convertScaleAbs(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convertScaleAbs")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def convertScaleAbs(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  alpha: Unit,
  beta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convertScaleAbs")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def convertScaleAbs(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  alpha: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convertScaleAbs")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def convertScaleAbs(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  alpha: double,
  beta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convertScaleAbs")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def convexHull(
  points: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  hull: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convexHull")(points.asInstanceOf[js.Any], hull.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def convexHull(
  points: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  hull: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  clockwise: Unit,
  returnPoints: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convexHull")(points.asInstanceOf[js.Any], hull.asInstanceOf[js.Any], clockwise.asInstanceOf[js.Any], returnPoints.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def convexHull(
  points: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  hull: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  clockwise: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convexHull")(points.asInstanceOf[js.Any], hull.asInstanceOf[js.Any], clockwise.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def convexHull(
  points: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  hull: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  clockwise: bool,
  returnPoints: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convexHull")(points.asInstanceOf[js.Any], hull.asInstanceOf[js.Any], clockwise.asInstanceOf[js.Any], returnPoints.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def convexityDefects(
  contour: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  convexhull: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  convexityDefects: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("convexityDefects")(contour.asInstanceOf[js.Any], convexhull.asInstanceOf[js.Any], convexityDefects.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def copyMakeBorder(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  top: int,
  bottom: int,
  left: int,
  right: int,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("copyMakeBorder")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], top.asInstanceOf[js.Any], bottom.asInstanceOf[js.Any], left.asInstanceOf[js.Any], right.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def copyMakeBorder(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  top: int,
  bottom: int,
  left: int,
  right: int,
  borderType: int,
  value: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("copyMakeBorder")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], top.asInstanceOf[js.Any], bottom.asInstanceOf[js.Any], left.asInstanceOf[js.Any], right.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], value.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def copyTo(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("copyTo")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def cornerEigenValsAndVecs(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  blockSize: int,
  ksize: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cornerEigenValsAndVecs")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def cornerEigenValsAndVecs(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  blockSize: int,
  ksize: int,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cornerEigenValsAndVecs")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def cornerHarris(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  blockSize: int,
  ksize: int,
  k: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cornerHarris")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], k.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def cornerHarris(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  blockSize: int,
  ksize: int,
  k: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cornerHarris")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], k.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def cornerMinEigenVal(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  blockSize: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cornerMinEigenVal")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def cornerMinEigenVal(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  blockSize: int,
  ksize: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cornerMinEigenVal")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def cornerMinEigenVal(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  blockSize: int,
  ksize: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cornerMinEigenVal")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def cornerMinEigenVal(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  blockSize: int,
  ksize: int,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cornerMinEigenVal")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def cornerSubPix(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  winSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  zeroZone: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cornerSubPix")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], winSize.asInstanceOf[js.Any], zeroZone.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def correctMatches(
  F: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  newPoints1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  newPoints2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("correctMatches")(F.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], newPoints1.asInstanceOf[js.Any], newPoints2.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def countNonZero(src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray): int = ^.asInstanceOf[js.Dynamic].applyDynamic("countNonZero")(src.asInstanceOf[js.Any]).asInstanceOf[int]

inline def createCLAHE(): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("createCLAHE")().asInstanceOf[Any]
inline def createCLAHE(clipLimit: Unit, tileGridSize: typings.mirada.distSrcTypesOpencvTypesMod.Size): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("createCLAHE")(clipLimit.asInstanceOf[js.Any], tileGridSize.asInstanceOf[js.Any])).asInstanceOf[Any]
inline def createCLAHE(clipLimit: double): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("createCLAHE")(clipLimit.asInstanceOf[js.Any]).asInstanceOf[Any]
inline def createCLAHE(clipLimit: double, tileGridSize: typings.mirada.distSrcTypesOpencvTypesMod.Size): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("createCLAHE")(clipLimit.asInstanceOf[js.Any], tileGridSize.asInstanceOf[js.Any])).asInstanceOf[Any]

inline def createFaceDetectionMaskGenerator(): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("createFaceDetectionMaskGenerator")().asInstanceOf[Any]

inline def createGeneralizedHoughBallard(): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("createGeneralizedHoughBallard")().asInstanceOf[Any]

inline def createGeneralizedHoughGuil(): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("createGeneralizedHoughGuil")().asInstanceOf[Any]

inline def createLineSegmentDetector(
  _refine: js.UndefOr[int],
  _scale: js.UndefOr[double],
  _sigma_scale: js.UndefOr[double],
  _quant: js.UndefOr[double],
  _ang_th: js.UndefOr[double],
  _log_eps: js.UndefOr[double],
  _density_th: js.UndefOr[double],
  _n_bins: js.UndefOr[int]
): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("createLineSegmentDetector")(_refine.asInstanceOf[js.Any], _scale.asInstanceOf[js.Any], _sigma_scale.asInstanceOf[js.Any], _quant.asInstanceOf[js.Any], _ang_th.asInstanceOf[js.Any], _log_eps.asInstanceOf[js.Any], _density_th.asInstanceOf[js.Any], _n_bins.asInstanceOf[js.Any])).asInstanceOf[Any]

inline def cubeRoot(`val`: float): float = ^.asInstanceOf[js.Dynamic].applyDynamic("cubeRoot")(`val`.asInstanceOf[js.Any]).asInstanceOf[float]

inline def cvAbs(arg93: Any, x: Tp): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("cv_abs")(arg93.asInstanceOf[js.Any], x.asInstanceOf[js.Any])).asInstanceOf[Any]
inline def cvAbs(x: ushort): ushort = ^.asInstanceOf[js.Dynamic].applyDynamic("cv_abs")(x.asInstanceOf[js.Any]).asInstanceOf[ushort]

inline def cvAbs_int(x: short): int = ^.asInstanceOf[js.Dynamic].applyDynamic("cv_abs")(x.asInstanceOf[js.Any]).asInstanceOf[int]

inline def cvAbs_schar(x: schar): schar = ^.asInstanceOf[js.Dynamic].applyDynamic("cv_abs")(x.asInstanceOf[js.Any]).asInstanceOf[schar]

inline def cvAbs_uchar(x: uchar): uchar = ^.asInstanceOf[js.Dynamic].applyDynamic("cv_abs")(x.asInstanceOf[js.Any]).asInstanceOf[uchar]

inline def cvCeil(value: double | float | int): int = ^.asInstanceOf[js.Dynamic].applyDynamic("cvCeil")(value.asInstanceOf[js.Any]).asInstanceOf[int]

inline def cvFloor(value: double | float | int): int = ^.asInstanceOf[js.Dynamic].applyDynamic("cvFloor")(value.asInstanceOf[js.Any]).asInstanceOf[int]

inline def cvIsInf(value: double | float): int = ^.asInstanceOf[js.Dynamic].applyDynamic("cvIsInf")(value.asInstanceOf[js.Any]).asInstanceOf[int]

inline def cvIsNaN(value: double | float): int = ^.asInstanceOf[js.Dynamic].applyDynamic("cvIsNaN")(value.asInstanceOf[js.Any]).asInstanceOf[int]

inline def cvRound(value: double | float | int): int = ^.asInstanceOf[js.Dynamic].applyDynamic("cvRound")(value.asInstanceOf[js.Any]).asInstanceOf[int]

inline def cvtColor(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  code: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cvtColor")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], code.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def cvtColor(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  code: int,
  dstCn: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cvtColor")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], code.asInstanceOf[js.Any], dstCn.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def cvtColorTwoPlane(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  code: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("cvtColorTwoPlane")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], code.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def dct(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dct")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dct(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dct")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def decomposeEssentialMat(
  E: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  t: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeEssentialMat")(E.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], t.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def decomposeHomographyMat(
  H: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  K: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rotations: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  translations: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  normals: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeHomographyMat")(H.asInstanceOf[js.Any], K.asInstanceOf[js.Any], rotations.asInstanceOf[js.Any], translations.asInstanceOf[js.Any], normals.asInstanceOf[js.Any])).asInstanceOf[int]

inline def decomposeProjectionMatrix(
  projMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  transVect: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  transVect: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixX: Unit,
  rotMatrixY: Unit,
  rotMatrixZ: Unit,
  eulerAngles: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any], rotMatrixZ.asInstanceOf[js.Any], eulerAngles.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  transVect: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixX: Unit,
  rotMatrixY: Unit,
  rotMatrixZ: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any], rotMatrixZ.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  transVect: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixX: Unit,
  rotMatrixY: Unit,
  rotMatrixZ: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  eulerAngles: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any], rotMatrixZ.asInstanceOf[js.Any], eulerAngles.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  transVect: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixX: Unit,
  rotMatrixY: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  transVect: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixX: Unit,
  rotMatrixY: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixZ: Unit,
  eulerAngles: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any], rotMatrixZ.asInstanceOf[js.Any], eulerAngles.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  transVect: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixX: Unit,
  rotMatrixY: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixZ: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any], rotMatrixZ.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  transVect: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixX: Unit,
  rotMatrixY: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixZ: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  eulerAngles: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any], rotMatrixZ.asInstanceOf[js.Any], eulerAngles.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  transVect: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixX: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  transVect: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixX: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixY: Unit,
  rotMatrixZ: Unit,
  eulerAngles: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any], rotMatrixZ.asInstanceOf[js.Any], eulerAngles.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  transVect: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixX: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixY: Unit,
  rotMatrixZ: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any], rotMatrixZ.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  transVect: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixX: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixY: Unit,
  rotMatrixZ: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  eulerAngles: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any], rotMatrixZ.asInstanceOf[js.Any], eulerAngles.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  transVect: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixX: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixY: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  transVect: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixX: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixY: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixZ: Unit,
  eulerAngles: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any], rotMatrixZ.asInstanceOf[js.Any], eulerAngles.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  transVect: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixX: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixY: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixZ: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any], rotMatrixZ.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def decomposeProjectionMatrix(
  projMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrix: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  transVect: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixX: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixY: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotMatrixZ: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  eulerAngles: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("decomposeProjectionMatrix")(projMatrix.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], rotMatrix.asInstanceOf[js.Any], transVect.asInstanceOf[js.Any], rotMatrixX.asInstanceOf[js.Any], rotMatrixY.asInstanceOf[js.Any], rotMatrixZ.asInstanceOf[js.Any], eulerAngles.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def demosaicing(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  code: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("demosaicing")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], code.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def demosaicing(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  code: int,
  dstCn: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("demosaicing")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], code.asInstanceOf[js.Any], dstCn.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def determinant(mtx: typings.mirada.distSrcTypesOpencvTypesMod.InputArray): double = ^.asInstanceOf[js.Dynamic].applyDynamic("determinant")(mtx.asInstanceOf[js.Any]).asInstanceOf[double]

inline def dft(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dft")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dft(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: Unit,
  nonzeroRows: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dft")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], nonzeroRows.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dft(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dft")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dft(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int,
  nonzeroRows: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dft")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], nonzeroRows.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def dilate(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  iterations: Unit,
  borderType: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  iterations: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  iterations: Unit,
  borderType: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  iterations: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  iterations: int,
  borderType: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  iterations: int,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  iterations: int,
  borderType: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  iterations: Unit,
  borderType: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  iterations: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  iterations: Unit,
  borderType: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  iterations: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  iterations: int,
  borderType: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  iterations: int,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def dilate(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  iterations: int,
  borderType: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dilate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def distanceTransform(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  distanceType: int,
  maskSize: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("distanceTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], distanceType.asInstanceOf[js.Any], maskSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def distanceTransform(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  distanceType: int,
  maskSize: int,
  dstType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("distanceTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], distanceType.asInstanceOf[js.Any], maskSize.asInstanceOf[js.Any], dstType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def distanceTransform(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  labels: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  distanceType: int,
  maskSize: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("distanceTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], labels.asInstanceOf[js.Any], distanceType.asInstanceOf[js.Any], maskSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def distanceTransform(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  labels: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  distanceType: int,
  maskSize: int,
  labelType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("distanceTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], labels.asInstanceOf[js.Any], distanceType.asInstanceOf[js.Any], maskSize.asInstanceOf[js.Any], labelType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def divUp(a: int, b: Any): int = (^.asInstanceOf[js.Dynamic].applyDynamic("divUp")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[int]
inline def divUp(a: sizeT, b: Any): sizeT = (^.asInstanceOf[js.Dynamic].applyDynamic("divUp")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[sizeT]

inline def divide(
  scale: double,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("divide")(scale.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def divide(
  scale: double,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dtype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("divide")(scale.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def divide(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("divide")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def divide(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  scale: Unit,
  dtype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("divide")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def divide(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  scale: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("divide")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def divide(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  scale: double,
  dtype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("divide")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def drawChessboardCorners(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  patternSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  patternWasFound: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawChessboardCorners")(image.asInstanceOf[js.Any], patternSize.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], patternWasFound.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  hierarchy: Unit,
  maxLevel: Unit,
  offset: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  hierarchy: Unit,
  maxLevel: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  hierarchy: Unit,
  maxLevel: int,
  offset: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  hierarchy: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  hierarchy: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  maxLevel: Unit,
  offset: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  hierarchy: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  maxLevel: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  hierarchy: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  maxLevel: int,
  offset: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: int,
  hierarchy: Unit,
  maxLevel: Unit,
  offset: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: int,
  hierarchy: Unit,
  maxLevel: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: int,
  hierarchy: Unit,
  maxLevel: int,
  offset: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: int,
  hierarchy: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: int,
  hierarchy: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  maxLevel: Unit,
  offset: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: int,
  hierarchy: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  maxLevel: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: Unit,
  lineType: int,
  hierarchy: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  maxLevel: int,
  offset: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: Unit,
  hierarchy: Unit,
  maxLevel: Unit,
  offset: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: Unit,
  hierarchy: Unit,
  maxLevel: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: Unit,
  hierarchy: Unit,
  maxLevel: int,
  offset: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: Unit,
  hierarchy: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: Unit,
  hierarchy: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  maxLevel: Unit,
  offset: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: Unit,
  hierarchy: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  maxLevel: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: Unit,
  hierarchy: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  maxLevel: int,
  offset: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: int,
  hierarchy: Unit,
  maxLevel: Unit,
  offset: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: int,
  hierarchy: Unit,
  maxLevel: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: int,
  hierarchy: Unit,
  maxLevel: int,
  offset: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: int,
  hierarchy: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: int,
  hierarchy: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  maxLevel: Unit,
  offset: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: int,
  hierarchy: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  maxLevel: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  contourIdx: int,
  color: Any,
  thickness: int,
  lineType: int,
  hierarchy: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  maxLevel: int,
  offset: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], contourIdx.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def drawFrameAxes(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  length: float
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawFrameAxes")(image.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], length.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawFrameAxes(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  length: float,
  thickness: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawFrameAxes")(image.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], length.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def drawKeypoints(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints: Any,
  outImage: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawKeypoints")(image.asInstanceOf[js.Any], keypoints.asInstanceOf[js.Any], outImage.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawKeypoints(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints: Any,
  outImage: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  color: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawKeypoints")(image.asInstanceOf[js.Any], keypoints.asInstanceOf[js.Any], outImage.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawKeypoints(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints: Any,
  outImage: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  color: Any,
  flags: DrawMatchesFlags
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawKeypoints")(image.asInstanceOf[js.Any], keypoints.asInstanceOf[js.Any], outImage.asInstanceOf[js.Any], color.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawKeypoints(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints: Any,
  outImage: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  color: Unit,
  flags: DrawMatchesFlags
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawKeypoints")(image.asInstanceOf[js.Any], keypoints.asInstanceOf[js.Any], outImage.asInstanceOf[js.Any], color.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def drawMarker(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  position: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  position: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  markerType: Unit,
  markerSize: Unit,
  thickness: Unit,
  line_type: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  position: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  markerType: Unit,
  markerSize: Unit,
  thickness: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  position: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  markerType: Unit,
  markerSize: Unit,
  thickness: int,
  line_type: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  position: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  markerType: Unit,
  markerSize: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  position: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  markerType: Unit,
  markerSize: int,
  thickness: Unit,
  line_type: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  position: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  markerType: Unit,
  markerSize: int,
  thickness: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  position: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  markerType: Unit,
  markerSize: int,
  thickness: int,
  line_type: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  position: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  markerType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  position: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  markerType: int,
  markerSize: Unit,
  thickness: Unit,
  line_type: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  position: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  markerType: int,
  markerSize: Unit,
  thickness: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  position: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  markerType: int,
  markerSize: Unit,
  thickness: int,
  line_type: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  position: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  markerType: int,
  markerSize: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  position: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  markerType: int,
  markerSize: int,
  thickness: Unit,
  line_type: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  position: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  markerType: int,
  markerSize: int,
  thickness: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMarker(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  position: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  markerType: int,
  markerSize: int,
  thickness: int,
  line_type: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMarker")(img.asInstanceOf[js.Any], position.asInstanceOf[js.Any], color.asInstanceOf[js.Any], markerType.asInstanceOf[js.Any], markerSize.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], line_type.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def drawMatches(
  img1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints1: Any,
  img2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints1: Any,
  img2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  matchColor: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints1: Any,
  img2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  matchColor: Any,
  singlePointColor: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints1: Any,
  img2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  matchColor: Any,
  singlePointColor: Any,
  matchesMask: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any], matchesMask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints1: Any,
  img2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  matchColor: Any,
  singlePointColor: Any,
  matchesMask: Any,
  flags: DrawMatchesFlags
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any], matchesMask.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints1: Any,
  img2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  matchColor: Any,
  singlePointColor: Any,
  matchesMask: Unit,
  flags: DrawMatchesFlags
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any], matchesMask.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints1: Any,
  img2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  matchColor: Any,
  singlePointColor: Unit,
  matchesMask: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any], matchesMask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints1: Any,
  img2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  matchColor: Any,
  singlePointColor: Unit,
  matchesMask: Any,
  flags: DrawMatchesFlags
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any], matchesMask.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints1: Any,
  img2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  matchColor: Any,
  singlePointColor: Unit,
  matchesMask: Unit,
  flags: DrawMatchesFlags
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any], matchesMask.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints1: Any,
  img2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  matchColor: Unit,
  singlePointColor: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints1: Any,
  img2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  matchColor: Unit,
  singlePointColor: Any,
  matchesMask: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any], matchesMask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints1: Any,
  img2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  matchColor: Unit,
  singlePointColor: Any,
  matchesMask: Any,
  flags: DrawMatchesFlags
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any], matchesMask.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints1: Any,
  img2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  matchColor: Unit,
  singlePointColor: Any,
  matchesMask: Unit,
  flags: DrawMatchesFlags
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any], matchesMask.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints1: Any,
  img2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  matchColor: Unit,
  singlePointColor: Unit,
  matchesMask: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any], matchesMask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints1: Any,
  img2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  matchColor: Unit,
  singlePointColor: Unit,
  matchesMask: Any,
  flags: DrawMatchesFlags
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any], matchesMask.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def drawMatches(
  img1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints1: Any,
  img2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  keypoints2: Any,
  matches1to2: Any,
  outImg: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  matchColor: Unit,
  singlePointColor: Unit,
  matchesMask: Unit,
  flags: DrawMatchesFlags
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("drawMatches")(img1.asInstanceOf[js.Any], keypoints1.asInstanceOf[js.Any], img2.asInstanceOf[js.Any], keypoints2.asInstanceOf[js.Any], matches1to2.asInstanceOf[js.Any], outImg.asInstanceOf[js.Any], matchColor.asInstanceOf[js.Any], singlePointColor.asInstanceOf[js.Any], matchesMask.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def dumpInputArray(argument: typings.mirada.distSrcTypesOpencvTypesMod.InputArray): String = ^.asInstanceOf[js.Dynamic].applyDynamic("dumpInputArray")(argument.asInstanceOf[js.Any]).asInstanceOf[String]

inline def dumpInputArrayOfArrays(argument: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays): String = ^.asInstanceOf[js.Dynamic].applyDynamic("dumpInputArrayOfArrays")(argument.asInstanceOf[js.Any]).asInstanceOf[String]

inline def dumpInputOutputArray(argument: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray): String = ^.asInstanceOf[js.Dynamic].applyDynamic("dumpInputOutputArray")(argument.asInstanceOf[js.Any]).asInstanceOf[String]

inline def dumpInputOutputArrayOfArrays(argument: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArrayOfArrays): String = ^.asInstanceOf[js.Dynamic].applyDynamic("dumpInputOutputArrayOfArrays")(argument.asInstanceOf[js.Any]).asInstanceOf[String]

inline def eigen(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  eigenvalues: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("eigen")(src.asInstanceOf[js.Any], eigenvalues.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def eigen(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  eigenvalues: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  eigenvectors: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("eigen")(src.asInstanceOf[js.Any], eigenvalues.asInstanceOf[js.Any], eigenvectors.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def eigenNonSymmetric(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  eigenvalues: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  eigenvectors: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("eigenNonSymmetric")(src.asInstanceOf[js.Any], eigenvalues.asInstanceOf[js.Any], eigenvectors.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def ellipse(img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray, box: Any, color: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse")(img.asInstanceOf[js.Any], box.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def ellipse(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  box: Any,
  color: Any,
  thickness: Unit,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse")(img.asInstanceOf[js.Any], box.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def ellipse(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  box: Any,
  color: Any,
  thickness: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse")(img.asInstanceOf[js.Any], box.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def ellipse(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  box: Any,
  color: Any,
  thickness: int,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse")(img.asInstanceOf[js.Any], box.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def ellipse(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  center: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  axes: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  angle: double,
  startAngle: double,
  endAngle: double,
  color: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], axes.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], startAngle.asInstanceOf[js.Any], endAngle.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def ellipse(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  center: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  axes: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  angle: double,
  startAngle: double,
  endAngle: double,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], axes.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], startAngle.asInstanceOf[js.Any], endAngle.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def ellipse(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  center: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  axes: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  angle: double,
  startAngle: double,
  endAngle: double,
  color: Any,
  thickness: Unit,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], axes.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], startAngle.asInstanceOf[js.Any], endAngle.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def ellipse(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  center: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  axes: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  angle: double,
  startAngle: double,
  endAngle: double,
  color: Any,
  thickness: Unit,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], axes.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], startAngle.asInstanceOf[js.Any], endAngle.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def ellipse(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  center: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  axes: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  angle: double,
  startAngle: double,
  endAngle: double,
  color: Any,
  thickness: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], axes.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], startAngle.asInstanceOf[js.Any], endAngle.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def ellipse(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  center: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  axes: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  angle: double,
  startAngle: double,
  endAngle: double,
  color: Any,
  thickness: int,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], axes.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], startAngle.asInstanceOf[js.Any], endAngle.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def ellipse(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  center: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  axes: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  angle: double,
  startAngle: double,
  endAngle: double,
  color: Any,
  thickness: int,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], axes.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], startAngle.asInstanceOf[js.Any], endAngle.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def ellipse(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  center: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  axes: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  angle: double,
  startAngle: double,
  endAngle: double,
  color: Any,
  thickness: int,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse")(img.asInstanceOf[js.Any], center.asInstanceOf[js.Any], axes.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], startAngle.asInstanceOf[js.Any], endAngle.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def ellipse1(
  dst: Mat,
  rotatedRect: RotatedRect,
  ellipseColor: typings.mirada.distSrcTypesOpencvHacksMod.Scalar,
  arg0: Double,
  line: LineTypes
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse1")(dst.asInstanceOf[js.Any], rotatedRect.asInstanceOf[js.Any], ellipseColor.asInstanceOf[js.Any], arg0.asInstanceOf[js.Any], line.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def ellipse2Poly(
  center: typings.mirada.distSrcTypesOpencvTypesMod.Point2d,
  axes: typings.mirada.distSrcTypesOpencvTypesMod.Size2d,
  angle: int,
  arcStart: int,
  arcEnd: int,
  delta: int,
  pts: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse2Poly")(center.asInstanceOf[js.Any], axes.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], arcStart.asInstanceOf[js.Any], arcEnd.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], pts.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def ellipse2Poly(
  center: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  axes: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  angle: int,
  arcStart: int,
  arcEnd: int,
  delta: int,
  pts: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ellipse2Poly")(center.asInstanceOf[js.Any], axes.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], arcStart.asInstanceOf[js.Any], arcEnd.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], pts.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def equalizeHist(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("equalizeHist")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def erode(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  iterations: Unit,
  borderType: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  iterations: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  iterations: Unit,
  borderType: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  iterations: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  iterations: int,
  borderType: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  iterations: int,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  iterations: int,
  borderType: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  iterations: Unit,
  borderType: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  iterations: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  iterations: Unit,
  borderType: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  iterations: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  iterations: int,
  borderType: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  iterations: int,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def erode(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  iterations: int,
  borderType: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("erode")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def error(_code: int, _err: Any, _func: Any, _file: Any, _line: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("error")(_code.asInstanceOf[js.Any], _err.asInstanceOf[js.Any], _func.asInstanceOf[js.Any], _file.asInstanceOf[js.Any], _line.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def error(exc: Any): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("error")(exc.asInstanceOf[js.Any]).asInstanceOf[Unit]

inline def estimateAffine2D(
  from: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  to: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  inliers: js.UndefOr[typings.mirada.distSrcTypesOpencvTypesMod.OutputArray],
  method: js.UndefOr[int],
  ransacReprojThreshold: js.UndefOr[double],
  maxIters: js.UndefOr[sizeT],
  confidence: js.UndefOr[double],
  refineIters: js.UndefOr[sizeT]
): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("estimateAffine2D")(from.asInstanceOf[js.Any], to.asInstanceOf[js.Any], inliers.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any], refineIters.asInstanceOf[js.Any])).asInstanceOf[Any]

inline def estimateAffine3D(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  out: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  inliers: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("estimateAffine3D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], out.asInstanceOf[js.Any], inliers.asInstanceOf[js.Any])).asInstanceOf[int]
inline def estimateAffine3D(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  out: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  inliers: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ransacThreshold: Unit,
  confidence: double
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("estimateAffine3D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], out.asInstanceOf[js.Any], inliers.asInstanceOf[js.Any], ransacThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[int]
inline def estimateAffine3D(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  out: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  inliers: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ransacThreshold: double
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("estimateAffine3D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], out.asInstanceOf[js.Any], inliers.asInstanceOf[js.Any], ransacThreshold.asInstanceOf[js.Any])).asInstanceOf[int]
inline def estimateAffine3D(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  out: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  inliers: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ransacThreshold: double,
  confidence: double
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("estimateAffine3D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], out.asInstanceOf[js.Any], inliers.asInstanceOf[js.Any], ransacThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[int]

inline def estimateAffinePartial2D(
  from: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  to: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  inliers: js.UndefOr[typings.mirada.distSrcTypesOpencvTypesMod.OutputArray],
  method: js.UndefOr[int],
  ransacReprojThreshold: js.UndefOr[double],
  maxIters: js.UndefOr[sizeT],
  confidence: js.UndefOr[double],
  refineIters: js.UndefOr[sizeT]
): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("estimateAffinePartial2D")(from.asInstanceOf[js.Any], to.asInstanceOf[js.Any], inliers.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any], refineIters.asInstanceOf[js.Any])).asInstanceOf[Any]

inline def estimateRigidTransform(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  fullAffine: bool
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("estimateRigidTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], fullAffine.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]

inline def exceptionFromPtr(err: Double): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("exceptionFromPtr")(err.asInstanceOf[js.Any]).asInstanceOf[Any]

inline def exp(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("exp")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def extractChannel(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  coi: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("extractChannel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], coi.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def fastAtan2(y: float, x: float): float = (^.asInstanceOf[js.Dynamic].applyDynamic("fastAtan2")(y.asInstanceOf[js.Any], x.asInstanceOf[js.Any])).asInstanceOf[float]

inline def fastFree(ptr: Any): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("fastFree")(ptr.asInstanceOf[js.Any]).asInstanceOf[Unit]

inline def fastMalloc(bufSize: sizeT): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("fastMalloc")(bufSize.asInstanceOf[js.Any]).asInstanceOf[Any]

inline def fillConvexPoly(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  points: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  color: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillConvexPoly")(img.asInstanceOf[js.Any], points.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillConvexPoly(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  points: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  color: Any,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillConvexPoly")(img.asInstanceOf[js.Any], points.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillConvexPoly(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  points: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  color: Any,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillConvexPoly")(img.asInstanceOf[js.Any], points.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillConvexPoly(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  points: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  color: Any,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillConvexPoly")(img.asInstanceOf[js.Any], points.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillConvexPoly(img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray, pts: Any, npts: int, color: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillConvexPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillConvexPoly(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: Any,
  npts: int,
  color: Any,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillConvexPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillConvexPoly(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: Any,
  npts: int,
  color: Any,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillConvexPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillConvexPoly(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: Any,
  npts: int,
  color: Any,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillConvexPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def fillPoly(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  color: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  color: Any,
  lineType: Unit,
  shift: Unit,
  offset: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  color: Any,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  color: Any,
  lineType: Unit,
  shift: int,
  offset: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  color: Any,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  color: Any,
  lineType: int,
  shift: Unit,
  offset: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  color: Any,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  color: Any,
  lineType: int,
  shift: int,
  offset: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  color: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  color: Any,
  lineType: Unit,
  shift: Unit,
  offset: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  color: Any,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  color: Any,
  lineType: Unit,
  shift: int,
  offset: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  color: Any,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  color: Any,
  lineType: int,
  shift: Unit,
  offset: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  color: Any,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def fillPoly(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  color: Any,
  lineType: int,
  shift: int,
  offset: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fillPoly")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], color.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def filter2D(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("filter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def filter2D(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("filter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def filter2D(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  delta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("filter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def filter2D(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("filter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def filter2D(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("filter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def filter2D(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("filter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def filter2D(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  delta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("filter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def filter2D(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("filter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def filterHomographyDecompByVisibleRefpoints(
  rotations: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  normals: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  beforePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  afterPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  possibleSolutions: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("filterHomographyDecompByVisibleRefpoints")(rotations.asInstanceOf[js.Any], normals.asInstanceOf[js.Any], beforePoints.asInstanceOf[js.Any], afterPoints.asInstanceOf[js.Any], possibleSolutions.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def filterHomographyDecompByVisibleRefpoints(
  rotations: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  normals: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  beforePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  afterPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  possibleSolutions: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  pointsMask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("filterHomographyDecompByVisibleRefpoints")(rotations.asInstanceOf[js.Any], normals.asInstanceOf[js.Any], beforePoints.asInstanceOf[js.Any], afterPoints.asInstanceOf[js.Any], possibleSolutions.asInstanceOf[js.Any], pointsMask.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def filterSpeckles(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  newVal: double,
  maxSpeckleSize: int,
  maxDiff: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("filterSpeckles")(img.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], maxSpeckleSize.asInstanceOf[js.Any], maxDiff.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def filterSpeckles(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  newVal: double,
  maxSpeckleSize: int,
  maxDiff: double,
  buf: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("filterSpeckles")(img.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], maxSpeckleSize.asInstanceOf[js.Any], maxDiff.asInstanceOf[js.Any], buf.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def find4QuadCornerSubpix(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  region_size: typings.mirada.distSrcTypesOpencvTypesMod.Size
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("find4QuadCornerSubpix")(img.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], region_size.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def findChessboardCorners(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  patternSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("findChessboardCorners")(image.asInstanceOf[js.Any], patternSize.asInstanceOf[js.Any], corners.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def findChessboardCorners(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  patternSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("findChessboardCorners")(image.asInstanceOf[js.Any], patternSize.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def findChessboardCornersSB(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  patternSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("findChessboardCornersSB")(image.asInstanceOf[js.Any], patternSize.asInstanceOf[js.Any], corners.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def findChessboardCornersSB(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  patternSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("findChessboardCornersSB")(image.asInstanceOf[js.Any], patternSize.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def findCirclesGrid(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  patternSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  centers: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("findCirclesGrid")(image.asInstanceOf[js.Any], patternSize.asInstanceOf[js.Any], centers.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def findCirclesGrid(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  patternSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  centers: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: Unit,
  blobDetector: Any
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("findCirclesGrid")(image.asInstanceOf[js.Any], patternSize.asInstanceOf[js.Any], centers.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], blobDetector.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def findCirclesGrid(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  patternSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  centers: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("findCirclesGrid")(image.asInstanceOf[js.Any], patternSize.asInstanceOf[js.Any], centers.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def findCirclesGrid(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  patternSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  centers: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int,
  blobDetector: Any
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("findCirclesGrid")(image.asInstanceOf[js.Any], patternSize.asInstanceOf[js.Any], centers.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], blobDetector.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def findCirclesGrid(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  patternSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  centers: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int,
  blobDetector: Any,
  parameters: Any
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("findCirclesGrid")(image.asInstanceOf[js.Any], patternSize.asInstanceOf[js.Any], centers.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], blobDetector.asInstanceOf[js.Any], parameters.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def findContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  hierarchy: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  mode: int,
  method: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("findContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], mode.asInstanceOf[js.Any], method.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def findContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  hierarchy: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  mode: int,
  method: int,
  offset: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("findContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], hierarchy.asInstanceOf[js.Any], mode.asInstanceOf[js.Any], method.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def findContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  mode: int,
  method: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("findContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], mode.asInstanceOf[js.Any], method.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def findContours(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  contours: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  mode: int,
  method: int,
  offset: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("findContours")(image.asInstanceOf[js.Any], contours.asInstanceOf[js.Any], mode.asInstanceOf[js.Any], method.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def findEssentialMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findEssentialMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  prob: Unit,
  threshold: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findEssentialMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  prob: Unit,
  threshold: double
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findEssentialMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  prob: Unit,
  threshold: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findEssentialMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  prob: double
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findEssentialMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  prob: double,
  threshold: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findEssentialMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  prob: double,
  threshold: double
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findEssentialMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  prob: double,
  threshold: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findEssentialMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findEssentialMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  prob: Unit,
  threshold: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findEssentialMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  prob: Unit,
  threshold: double
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findEssentialMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  prob: Unit,
  threshold: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findEssentialMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  prob: double
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findEssentialMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  prob: double,
  threshold: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findEssentialMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  prob: double,
  threshold: double
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findEssentialMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  prob: double,
  threshold: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findEssentialMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  focal: js.UndefOr[double],
  pp: js.UndefOr[typings.mirada.distSrcTypesOpencvTypesMod.Point2d],
  method: js.UndefOr[int],
  prob: js.UndefOr[double],
  threshold: js.UndefOr[double],
  mask: js.UndefOr[typings.mirada.distSrcTypesOpencvTypesMod.OutputArray]
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findEssentialMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], focal.asInstanceOf[js.Any], pp.asInstanceOf[js.Any], method.asInstanceOf[js.Any], prob.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]

inline def findFundamentalMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findFundamentalMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findFundamentalMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: Unit,
  ransacReprojThreshold: Unit,
  confidence: double
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findFundamentalMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: Unit,
  ransacReprojThreshold: double
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findFundamentalMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: Unit,
  ransacReprojThreshold: double,
  confidence: double
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findFundamentalMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: int
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], method.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findFundamentalMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: int,
  ransacReprojThreshold: Unit,
  confidence: double
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findFundamentalMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: int,
  ransacReprojThreshold: double
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findFundamentalMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: int,
  ransacReprojThreshold: double,
  confidence: double
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findFundamentalMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  ransacReprojThreshold: Unit,
  confidence: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findFundamentalMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  ransacReprojThreshold: Unit,
  confidence: double
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findFundamentalMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  ransacReprojThreshold: Unit,
  confidence: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findFundamentalMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  ransacReprojThreshold: double
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findFundamentalMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  ransacReprojThreshold: double,
  confidence: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findFundamentalMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  ransacReprojThreshold: double,
  confidence: double
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findFundamentalMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  ransacReprojThreshold: double,
  confidence: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findFundamentalMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findFundamentalMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  ransacReprojThreshold: Unit,
  confidence: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findFundamentalMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  ransacReprojThreshold: Unit,
  confidence: double
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findFundamentalMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  ransacReprojThreshold: Unit,
  confidence: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findFundamentalMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  ransacReprojThreshold: double
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findFundamentalMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  ransacReprojThreshold: double,
  confidence: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findFundamentalMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  ransacReprojThreshold: double,
  confidence: double
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findFundamentalMat(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  ransacReprojThreshold: double,
  confidence: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findFundamentalMat")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]

inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: Unit,
  ransacReprojThreshold: double
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: int
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], method.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: int,
  ransacReprojThreshold: double
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  ransacReprojThreshold: Unit,
  mask: Unit,
  maxIters: Any
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  ransacReprojThreshold: Unit,
  mask: Unit,
  maxIters: Any,
  confidence: Any
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  ransacReprojThreshold: Unit,
  mask: Unit,
  maxIters: Unit,
  confidence: Any
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  ransacReprojThreshold: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  ransacReprojThreshold: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxIters: Any
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  ransacReprojThreshold: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxIters: Any,
  confidence: Any
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  ransacReprojThreshold: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxIters: Unit,
  confidence: Any
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  ransacReprojThreshold: double
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  ransacReprojThreshold: double,
  mask: Unit,
  maxIters: Any
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  ransacReprojThreshold: double,
  mask: Unit,
  maxIters: Any,
  confidence: Any
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  ransacReprojThreshold: double,
  mask: Unit,
  maxIters: Unit,
  confidence: Any
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  ransacReprojThreshold: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  ransacReprojThreshold: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxIters: Any
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  ransacReprojThreshold: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxIters: Any,
  confidence: Any
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: Unit,
  ransacReprojThreshold: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxIters: Unit,
  confidence: Any
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  ransacReprojThreshold: Unit,
  mask: Unit,
  maxIters: Any
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  ransacReprojThreshold: Unit,
  mask: Unit,
  maxIters: Any,
  confidence: Any
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  ransacReprojThreshold: Unit,
  mask: Unit,
  maxIters: Unit,
  confidence: Any
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  ransacReprojThreshold: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  ransacReprojThreshold: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxIters: Any
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  ransacReprojThreshold: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxIters: Any,
  confidence: Any
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  ransacReprojThreshold: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxIters: Unit,
  confidence: Any
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  ransacReprojThreshold: double
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  ransacReprojThreshold: double,
  mask: Unit,
  maxIters: Any
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  ransacReprojThreshold: double,
  mask: Unit,
  maxIters: Any,
  confidence: Any
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  ransacReprojThreshold: double,
  mask: Unit,
  maxIters: Unit,
  confidence: Any
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  ransacReprojThreshold: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  ransacReprojThreshold: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxIters: Any
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  ransacReprojThreshold: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxIters: Any,
  confidence: Any
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def findHomography(
  srcPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dstPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  ransacReprojThreshold: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxIters: Unit,
  confidence: Any
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("findHomography")(srcPoints.asInstanceOf[js.Any], dstPoints.asInstanceOf[js.Any], method.asInstanceOf[js.Any], ransacReprojThreshold.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]

inline def findNonZero(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  idx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("findNonZero")(src.asInstanceOf[js.Any], idx.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def findTransformECC(
  templateImage: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  inputImage: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  warpMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("findTransformECC")(templateImage.asInstanceOf[js.Any], inputImage.asInstanceOf[js.Any], warpMatrix.asInstanceOf[js.Any])).asInstanceOf[double]
inline def findTransformECC(
  templateImage: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  inputImage: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  warpMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  motionType: Unit,
  criteria: Unit,
  inputMask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("findTransformECC")(templateImage.asInstanceOf[js.Any], inputImage.asInstanceOf[js.Any], warpMatrix.asInstanceOf[js.Any], motionType.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], inputMask.asInstanceOf[js.Any])).asInstanceOf[double]
inline def findTransformECC(
  templateImage: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  inputImage: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  warpMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  motionType: Unit,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("findTransformECC")(templateImage.asInstanceOf[js.Any], inputImage.asInstanceOf[js.Any], warpMatrix.asInstanceOf[js.Any], motionType.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]
inline def findTransformECC(
  templateImage: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  inputImage: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  warpMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  motionType: Unit,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria,
  inputMask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("findTransformECC")(templateImage.asInstanceOf[js.Any], inputImage.asInstanceOf[js.Any], warpMatrix.asInstanceOf[js.Any], motionType.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], inputMask.asInstanceOf[js.Any])).asInstanceOf[double]
inline def findTransformECC(
  templateImage: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  inputImage: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  warpMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  motionType: int
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("findTransformECC")(templateImage.asInstanceOf[js.Any], inputImage.asInstanceOf[js.Any], warpMatrix.asInstanceOf[js.Any], motionType.asInstanceOf[js.Any])).asInstanceOf[double]
inline def findTransformECC(
  templateImage: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  inputImage: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  warpMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  motionType: int,
  criteria: Unit,
  inputMask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("findTransformECC")(templateImage.asInstanceOf[js.Any], inputImage.asInstanceOf[js.Any], warpMatrix.asInstanceOf[js.Any], motionType.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], inputMask.asInstanceOf[js.Any])).asInstanceOf[double]
inline def findTransformECC(
  templateImage: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  inputImage: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  warpMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  motionType: int,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("findTransformECC")(templateImage.asInstanceOf[js.Any], inputImage.asInstanceOf[js.Any], warpMatrix.asInstanceOf[js.Any], motionType.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]
inline def findTransformECC(
  templateImage: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  inputImage: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  warpMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  motionType: int,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria,
  inputMask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("findTransformECC")(templateImage.asInstanceOf[js.Any], inputImage.asInstanceOf[js.Any], warpMatrix.asInstanceOf[js.Any], motionType.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], inputMask.asInstanceOf[js.Any])).asInstanceOf[double]
inline def findTransformECC(
  templateImage: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  inputImage: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  warpMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  motionType: int,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria,
  inputMask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  gaussFiltSize: int
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("findTransformECC")(templateImage.asInstanceOf[js.Any], inputImage.asInstanceOf[js.Any], warpMatrix.asInstanceOf[js.Any], motionType.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], inputMask.asInstanceOf[js.Any], gaussFiltSize.asInstanceOf[js.Any])).asInstanceOf[double]

inline def fitEllipse(points: typings.mirada.distSrcTypesOpencvTypesMod.InputArray): typings.mirada.distSrcTypesOpencvTypesMod.RotatedRect = ^.asInstanceOf[js.Dynamic].applyDynamic("fitEllipse")(points.asInstanceOf[js.Any]).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.RotatedRect]

inline def fitEllipseAMS(points: typings.mirada.distSrcTypesOpencvTypesMod.InputArray): typings.mirada.distSrcTypesOpencvTypesMod.RotatedRect = ^.asInstanceOf[js.Dynamic].applyDynamic("fitEllipseAMS")(points.asInstanceOf[js.Any]).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.RotatedRect]

inline def fitEllipseDirect(points: typings.mirada.distSrcTypesOpencvTypesMod.InputArray): typings.mirada.distSrcTypesOpencvTypesMod.RotatedRect = ^.asInstanceOf[js.Dynamic].applyDynamic("fitEllipseDirect")(points.asInstanceOf[js.Any]).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.RotatedRect]

inline def fitLine(
  points: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  line: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  distType: int,
  param: double,
  reps: double,
  aeps: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("fitLine")(points.asInstanceOf[js.Any], line.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], param.asInstanceOf[js.Any], reps.asInstanceOf[js.Any], aeps.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def flip(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flipCode: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("flip")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flipCode.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Any
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Any,
  loDiff: Unit,
  upDiff: Unit,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Any,
  loDiff: Unit,
  upDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Any,
  loDiff: Unit,
  upDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Any,
  loDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Any,
  loDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  upDiff: Unit,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Any,
  loDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  upDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Any,
  loDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  upDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Unit,
  loDiff: Unit,
  upDiff: Unit,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Unit,
  loDiff: Unit,
  upDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Unit,
  loDiff: Unit,
  upDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Unit,
  loDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Unit,
  loDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  upDiff: Unit,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Unit,
  loDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  upDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Unit,
  loDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  upDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Any
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Any,
  loDiff: Unit,
  upDiff: Unit,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Any,
  loDiff: Unit,
  upDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Any,
  loDiff: Unit,
  upDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Any,
  loDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Any,
  loDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  upDiff: Unit,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Any,
  loDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  upDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Any,
  loDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  upDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Unit,
  loDiff: Unit,
  upDiff: Unit,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Unit,
  loDiff: Unit,
  upDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Unit,
  loDiff: Unit,
  upDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Unit,
  loDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Unit,
  loDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  upDiff: Unit,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Unit,
  loDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  upDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any])).asInstanceOf[int]
inline def floodFill(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  seedPoint: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  newVal: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  rect: Unit,
  loDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  upDiff: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("floodFill")(image.asInstanceOf[js.Any], seedPoint.asInstanceOf[js.Any], newVal.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], loDiff.asInstanceOf[js.Any], upDiff.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]

inline def flushPendingDeletes(a: Any*): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("flushPendingDeletes")(a.asInstanceOf[Seq[js.Any]]*).asInstanceOf[Any]

inline def forEachImpl(arg94: Any, arg95: Any, operation: Any): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("forEach_impl")(arg94.asInstanceOf[js.Any], arg95.asInstanceOf[js.Any], operation.asInstanceOf[js.Any])).asInstanceOf[Any]

inline def gemm(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  alpha: double,
  src3: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  beta: double,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("gemm")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], src3.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def gemm(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  alpha: double,
  src3: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  beta: double,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("gemm")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], src3.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def getAffineTransform(src: Any, dst: Any): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getAffineTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def getAffineTransform(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getAffineTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]

inline def getAvailableBackends(): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("getAvailableBackends")().asInstanceOf[Any]

inline def getAvailableTargets(be: Backend): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("getAvailableTargets")(be.asInstanceOf[js.Any]).asInstanceOf[Any]

inline def getBuildInformation(): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("getBuildInformation")().asInstanceOf[Any]

inline def getCPUFeaturesLine(): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("getCPUFeaturesLine")().asInstanceOf[Any]

inline def getCPUTickCount(): int64 = ^.asInstanceOf[js.Dynamic].applyDynamic("getCPUTickCount")().asInstanceOf[int64]

inline def getDefaultNewCameraMatrix(cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray): typings.mirada.distSrcTypesOpencvTypesMod.Mat = ^.asInstanceOf[js.Dynamic].applyDynamic("getDefaultNewCameraMatrix")(cameraMatrix.asInstanceOf[js.Any]).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def getDefaultNewCameraMatrix(
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imgsize: Unit,
  centerPrincipalPoint: bool
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getDefaultNewCameraMatrix")(cameraMatrix.asInstanceOf[js.Any], imgsize.asInstanceOf[js.Any], centerPrincipalPoint.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def getDefaultNewCameraMatrix(
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imgsize: typings.mirada.distSrcTypesOpencvTypesMod.Size
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getDefaultNewCameraMatrix")(cameraMatrix.asInstanceOf[js.Any], imgsize.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def getDefaultNewCameraMatrix(
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imgsize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  centerPrincipalPoint: bool
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getDefaultNewCameraMatrix")(cameraMatrix.asInstanceOf[js.Any], imgsize.asInstanceOf[js.Any], centerPrincipalPoint.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]

inline def getDerivKernels(
  kx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ky: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dx: int,
  dy: int,
  ksize: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("getDerivKernels")(kx.asInstanceOf[js.Any], ky.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def getDerivKernels(
  kx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ky: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dx: int,
  dy: int,
  ksize: int,
  normalize: Unit,
  ktype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("getDerivKernels")(kx.asInstanceOf[js.Any], ky.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any], ktype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def getDerivKernels(
  kx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ky: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dx: int,
  dy: int,
  ksize: int,
  normalize: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("getDerivKernels")(kx.asInstanceOf[js.Any], ky.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def getDerivKernels(
  kx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ky: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dx: int,
  dy: int,
  ksize: int,
  normalize: bool,
  ktype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("getDerivKernels")(kx.asInstanceOf[js.Any], ky.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any], ktype.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def getElemSize(`type`: int): sizeT = ^.asInstanceOf[js.Dynamic].applyDynamic("getElemSize")(`type`.asInstanceOf[js.Any]).asInstanceOf[sizeT]

inline def getFontScaleFromHeight(fontFace: Any, pixelHeight: Any): double = (^.asInstanceOf[js.Dynamic].applyDynamic("getFontScaleFromHeight")(fontFace.asInstanceOf[js.Any], pixelHeight.asInstanceOf[js.Any])).asInstanceOf[double]
inline def getFontScaleFromHeight(fontFace: Any, pixelHeight: Any, thickness: Any): double = (^.asInstanceOf[js.Dynamic].applyDynamic("getFontScaleFromHeight")(fontFace.asInstanceOf[js.Any], pixelHeight.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[double]

inline def getGaborKernel(
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  sigma: double,
  theta: double,
  lambd: double,
  gamma: double
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getGaborKernel")(ksize.asInstanceOf[js.Any], sigma.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], lambd.asInstanceOf[js.Any], gamma.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def getGaborKernel(
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  sigma: double,
  theta: double,
  lambd: double,
  gamma: double,
  psi: Unit,
  ktype: int
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getGaborKernel")(ksize.asInstanceOf[js.Any], sigma.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], lambd.asInstanceOf[js.Any], gamma.asInstanceOf[js.Any], psi.asInstanceOf[js.Any], ktype.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def getGaborKernel(
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  sigma: double,
  theta: double,
  lambd: double,
  gamma: double,
  psi: double
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getGaborKernel")(ksize.asInstanceOf[js.Any], sigma.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], lambd.asInstanceOf[js.Any], gamma.asInstanceOf[js.Any], psi.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def getGaborKernel(
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  sigma: double,
  theta: double,
  lambd: double,
  gamma: double,
  psi: double,
  ktype: int
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getGaborKernel")(ksize.asInstanceOf[js.Any], sigma.asInstanceOf[js.Any], theta.asInstanceOf[js.Any], lambd.asInstanceOf[js.Any], gamma.asInstanceOf[js.Any], psi.asInstanceOf[js.Any], ktype.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]

inline def getGaussianKernel(ksize: int, sigma: double): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getGaussianKernel")(ksize.asInstanceOf[js.Any], sigma.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def getGaussianKernel(ksize: int, sigma: double, ktype: int): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getGaussianKernel")(ksize.asInstanceOf[js.Any], sigma.asInstanceOf[js.Any], ktype.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]

inline def getHardwareFeatureName(feature: int): String = ^.asInstanceOf[js.Dynamic].applyDynamic("getHardwareFeatureName")(feature.asInstanceOf[js.Any]).asInstanceOf[String]

inline def getInheritedInstanceCount(a: Any*): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("getInheritedInstanceCount")(a.asInstanceOf[Seq[js.Any]]*).asInstanceOf[Any]

inline def getLiveInheritedInstances(a: Any*): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("getLiveInheritedInstances")(a.asInstanceOf[Seq[js.Any]]*).asInstanceOf[Any]

inline def getNumThreads(): int = ^.asInstanceOf[js.Dynamic].applyDynamic("getNumThreads")().asInstanceOf[int]

inline def getNumberOfCPUs(): int = ^.asInstanceOf[js.Dynamic].applyDynamic("getNumberOfCPUs")().asInstanceOf[int]

inline def getOptimalDFTSize(vecsize: int): int = ^.asInstanceOf[js.Dynamic].applyDynamic("getOptimalDFTSize")(vecsize.asInstanceOf[js.Any]).asInstanceOf[int]

inline def getOptimalNewCameraMatrix(
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  alpha: double
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getOptimalNewCameraMatrix")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def getOptimalNewCameraMatrix(
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  alpha: double,
  newImgSize: Unit,
  validPixROI: Any
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getOptimalNewCameraMatrix")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImgSize.asInstanceOf[js.Any], validPixROI.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def getOptimalNewCameraMatrix(
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  alpha: double,
  newImgSize: Unit,
  validPixROI: Any,
  centerPrincipalPoint: bool
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getOptimalNewCameraMatrix")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImgSize.asInstanceOf[js.Any], validPixROI.asInstanceOf[js.Any], centerPrincipalPoint.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def getOptimalNewCameraMatrix(
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  alpha: double,
  newImgSize: Unit,
  validPixROI: Unit,
  centerPrincipalPoint: bool
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getOptimalNewCameraMatrix")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImgSize.asInstanceOf[js.Any], validPixROI.asInstanceOf[js.Any], centerPrincipalPoint.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def getOptimalNewCameraMatrix(
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  alpha: double,
  newImgSize: typings.mirada.distSrcTypesOpencvTypesMod.Size
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getOptimalNewCameraMatrix")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImgSize.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def getOptimalNewCameraMatrix(
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  alpha: double,
  newImgSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  validPixROI: Any
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getOptimalNewCameraMatrix")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImgSize.asInstanceOf[js.Any], validPixROI.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def getOptimalNewCameraMatrix(
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  alpha: double,
  newImgSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  validPixROI: Any,
  centerPrincipalPoint: bool
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getOptimalNewCameraMatrix")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImgSize.asInstanceOf[js.Any], validPixROI.asInstanceOf[js.Any], centerPrincipalPoint.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def getOptimalNewCameraMatrix(
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  alpha: double,
  newImgSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  validPixROI: Unit,
  centerPrincipalPoint: bool
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getOptimalNewCameraMatrix")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImgSize.asInstanceOf[js.Any], validPixROI.asInstanceOf[js.Any], centerPrincipalPoint.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]

inline def getPerspectiveTransform(src: Any, dst: Any): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getPerspectiveTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def getPerspectiveTransform(src: Any, dst: Any, solveMethod: int): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getPerspectiveTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], solveMethod.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def getPerspectiveTransform(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getPerspectiveTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def getPerspectiveTransform(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  solveMethod: int
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getPerspectiveTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], solveMethod.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]

inline def getRectSubPix(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  patchSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  center: typings.mirada.distSrcTypesOpencvTypesMod.Point2f,
  patch: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("getRectSubPix")(image.asInstanceOf[js.Any], patchSize.asInstanceOf[js.Any], center.asInstanceOf[js.Any], patch.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def getRectSubPix(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  patchSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  center: typings.mirada.distSrcTypesOpencvTypesMod.Point2f,
  patch: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  patchType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("getRectSubPix")(image.asInstanceOf[js.Any], patchSize.asInstanceOf[js.Any], center.asInstanceOf[js.Any], patch.asInstanceOf[js.Any], patchType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def getRotationMatrix2D(center: typings.mirada.distSrcTypesOpencvTypesMod.Point2f, angle: double, scale: double): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getRotationMatrix2D")(center.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]

inline def getStructuringElement(shape: int, ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getStructuringElement")(shape.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def getStructuringElement(
  shape: int,
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("getStructuringElement")(shape.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]

inline def getTextSize(text: Any, fontFace: int, fontScale: double, thickness: int, baseLine: Any): typings.mirada.distSrcTypesOpencvTypesMod.Size = (^.asInstanceOf[js.Dynamic].applyDynamic("getTextSize")(text.asInstanceOf[js.Any], fontFace.asInstanceOf[js.Any], fontScale.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], baseLine.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Size]

inline def getThreadNum(): int = ^.asInstanceOf[js.Dynamic].applyDynamic("getThreadNum")().asInstanceOf[int]

inline def getTickCount(): int64 = ^.asInstanceOf[js.Dynamic].applyDynamic("getTickCount")().asInstanceOf[int64]

inline def getTickFrequency(): double = ^.asInstanceOf[js.Dynamic].applyDynamic("getTickFrequency")().asInstanceOf[double]

inline def getValidDisparityROI(
  roi1: typings.mirada.distSrcTypesOpencvTypesMod.Rect,
  roi2: typings.mirada.distSrcTypesOpencvTypesMod.Rect,
  minDisparity: int,
  numberOfDisparities: int,
  SADWindowSize: int
): typings.mirada.distSrcTypesOpencvTypesMod.Rect = (^.asInstanceOf[js.Dynamic].applyDynamic("getValidDisparityROI")(roi1.asInstanceOf[js.Any], roi2.asInstanceOf[js.Any], minDisparity.asInstanceOf[js.Any], numberOfDisparities.asInstanceOf[js.Any], SADWindowSize.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Rect]

inline def getVersionMajor(): int = ^.asInstanceOf[js.Dynamic].applyDynamic("getVersionMajor")().asInstanceOf[int]

inline def getVersionMinor(): int = ^.asInstanceOf[js.Dynamic].applyDynamic("getVersionMinor")().asInstanceOf[int]

inline def getVersionRevision(): int = ^.asInstanceOf[js.Dynamic].applyDynamic("getVersionRevision")().asInstanceOf[int]

inline def getVersionString(): String = ^.asInstanceOf[js.Dynamic].applyDynamic("getVersionString")().asInstanceOf[String]

inline def glob(pattern: String, result: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("glob")(pattern.asInstanceOf[js.Any], result.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def glob(pattern: String, result: Any, recursive: bool): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("glob")(pattern.asInstanceOf[js.Any], result.asInstanceOf[js.Any], recursive.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def goodFeaturesToTrack(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: Unit,
  blockSize: Unit,
  useHarrisDetector: Unit,
  k: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any], k.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: Unit,
  blockSize: Unit,
  useHarrisDetector: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: Unit,
  blockSize: Unit,
  useHarrisDetector: bool,
  k: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any], k.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: Unit,
  blockSize: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: Unit,
  blockSize: int,
  useHarrisDetector: Unit,
  k: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any], k.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: Unit,
  blockSize: int,
  useHarrisDetector: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: Unit,
  blockSize: int,
  useHarrisDetector: bool,
  k: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any], k.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  blockSize: Unit,
  useHarrisDetector: Unit,
  k: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any], k.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  blockSize: Unit,
  useHarrisDetector: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  blockSize: Unit,
  useHarrisDetector: bool,
  k: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any], k.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  blockSize: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  blockSize: int,
  gradientSize: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], gradientSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  blockSize: int,
  gradientSize: int,
  useHarrisDetector: Unit,
  k: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], gradientSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any], k.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  blockSize: int,
  gradientSize: int,
  useHarrisDetector: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], gradientSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  blockSize: int,
  gradientSize: int,
  useHarrisDetector: bool,
  k: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], gradientSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any], k.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  blockSize: int,
  useHarrisDetector: Unit,
  k: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any], k.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  blockSize: int,
  useHarrisDetector: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def goodFeaturesToTrack(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  corners: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxCorners: int,
  qualityLevel: double,
  minDistance: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  blockSize: int,
  useHarrisDetector: bool,
  k: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("goodFeaturesToTrack")(image.asInstanceOf[js.Any], corners.asInstanceOf[js.Any], maxCorners.asInstanceOf[js.Any], qualityLevel.asInstanceOf[js.Any], minDistance.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], blockSize.asInstanceOf[js.Any], useHarrisDetector.asInstanceOf[js.Any], k.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def grabCut(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  rect: typings.mirada.distSrcTypesOpencvTypesMod.Rect,
  bgdModel: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  fgdModel: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  iterCount: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("grabCut")(img.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], bgdModel.asInstanceOf[js.Any], fgdModel.asInstanceOf[js.Any], iterCount.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def grabCut(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  rect: typings.mirada.distSrcTypesOpencvTypesMod.Rect,
  bgdModel: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  fgdModel: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  iterCount: int,
  mode: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("grabCut")(img.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], bgdModel.asInstanceOf[js.Any], fgdModel.asInstanceOf[js.Any], iterCount.asInstanceOf[js.Any], mode.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def groupRectangles(rectList: Any, groupThreshold: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("groupRectangles")(rectList.asInstanceOf[js.Any], groupThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def groupRectangles(rectList: Any, groupThreshold: int, eps: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("groupRectangles")(rectList.asInstanceOf[js.Any], groupThreshold.asInstanceOf[js.Any], eps.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def groupRectangles(rectList: Any, groupThreshold: int, eps: double, weights: Any, levelWeights: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("groupRectangles")(rectList.asInstanceOf[js.Any], groupThreshold.asInstanceOf[js.Any], eps.asInstanceOf[js.Any], weights.asInstanceOf[js.Any], levelWeights.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def groupRectangles(rectList: Any, rejectLevels: Any, levelWeights: Any, groupThreshold: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("groupRectangles")(rectList.asInstanceOf[js.Any], rejectLevels.asInstanceOf[js.Any], levelWeights.asInstanceOf[js.Any], groupThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def groupRectangles(rectList: Any, rejectLevels: Any, levelWeights: Any, groupThreshold: int, eps: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("groupRectangles")(rectList.asInstanceOf[js.Any], rejectLevels.asInstanceOf[js.Any], levelWeights.asInstanceOf[js.Any], groupThreshold.asInstanceOf[js.Any], eps.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def groupRectangles(rectList: Any, weights: Any, groupThreshold: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("groupRectangles")(rectList.asInstanceOf[js.Any], weights.asInstanceOf[js.Any], groupThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def groupRectangles(rectList: Any, weights: Any, groupThreshold: int, eps: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("groupRectangles")(rectList.asInstanceOf[js.Any], weights.asInstanceOf[js.Any], groupThreshold.asInstanceOf[js.Any], eps.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def groupRectanglesMeanshift(rectList: Any, foundWeights: Any, foundScales: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("groupRectangles_meanshift")(rectList.asInstanceOf[js.Any], foundWeights.asInstanceOf[js.Any], foundScales.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def groupRectanglesMeanshift(
  rectList: Any,
  foundWeights: Any,
  foundScales: Any,
  detectThreshold: Unit,
  winDetSize: typings.mirada.distSrcTypesOpencvTypesMod.Size
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("groupRectangles_meanshift")(rectList.asInstanceOf[js.Any], foundWeights.asInstanceOf[js.Any], foundScales.asInstanceOf[js.Any], detectThreshold.asInstanceOf[js.Any], winDetSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def groupRectanglesMeanshift(rectList: Any, foundWeights: Any, foundScales: Any, detectThreshold: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("groupRectangles_meanshift")(rectList.asInstanceOf[js.Any], foundWeights.asInstanceOf[js.Any], foundScales.asInstanceOf[js.Any], detectThreshold.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def groupRectanglesMeanshift(
  rectList: Any,
  foundWeights: Any,
  foundScales: Any,
  detectThreshold: double,
  winDetSize: typings.mirada.distSrcTypesOpencvTypesMod.Size
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("groupRectangles_meanshift")(rectList.asInstanceOf[js.Any], foundWeights.asInstanceOf[js.Any], foundScales.asInstanceOf[js.Any], detectThreshold.asInstanceOf[js.Any], winDetSize.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def halNiDct2D(context: cvhalDFT, src_data: uchar, src_step: sizeT, dst_data: uchar, dst_step: sizeT): cvhalDFT = (^.asInstanceOf[js.Dynamic].applyDynamic("hal_ni_dct2D")(context.asInstanceOf[js.Any], src_data.asInstanceOf[js.Any], src_step.asInstanceOf[js.Any], dst_data.asInstanceOf[js.Any], dst_step.asInstanceOf[js.Any])).asInstanceOf[cvhalDFT]

inline def halNiDctFree2D(context: cvhalDFT): cvhalDFT = ^.asInstanceOf[js.Dynamic].applyDynamic("hal_ni_dctFree2D")(context.asInstanceOf[js.Any]).asInstanceOf[cvhalDFT]

inline def halNiDctInit2D(context: cvhalDFT, width: int, height: int, depth: int, flags: int): cvhalDFT = (^.asInstanceOf[js.Dynamic].applyDynamic("hal_ni_dctInit2D")(context.asInstanceOf[js.Any], width.asInstanceOf[js.Any], height.asInstanceOf[js.Any], depth.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[cvhalDFT]

inline def halNiDft1D(context: cvhalDFT, src: uchar, dst: uchar): cvhalDFT = (^.asInstanceOf[js.Dynamic].applyDynamic("hal_ni_dft1D")(context.asInstanceOf[js.Any], src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[cvhalDFT]

inline def halNiDft2D(context: cvhalDFT, src_data: uchar, src_step: sizeT, dst_data: uchar, dst_step: sizeT): cvhalDFT = (^.asInstanceOf[js.Dynamic].applyDynamic("hal_ni_dft2D")(context.asInstanceOf[js.Any], src_data.asInstanceOf[js.Any], src_step.asInstanceOf[js.Any], dst_data.asInstanceOf[js.Any], dst_step.asInstanceOf[js.Any])).asInstanceOf[cvhalDFT]

inline def halNiDftFree1D(context: cvhalDFT): cvhalDFT = ^.asInstanceOf[js.Dynamic].applyDynamic("hal_ni_dftFree1D")(context.asInstanceOf[js.Any]).asInstanceOf[cvhalDFT]

inline def halNiDftFree2D(context: cvhalDFT): cvhalDFT = ^.asInstanceOf[js.Dynamic].applyDynamic("hal_ni_dftFree2D")(context.asInstanceOf[js.Any]).asInstanceOf[cvhalDFT]

inline def halNiDftInit1D(context: cvhalDFT, len: int, count: int, depth: int, flags: int, needBuffer: Any): cvhalDFT = (^.asInstanceOf[js.Dynamic].applyDynamic("hal_ni_dftInit1D")(context.asInstanceOf[js.Any], len.asInstanceOf[js.Any], count.asInstanceOf[js.Any], depth.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], needBuffer.asInstanceOf[js.Any])).asInstanceOf[cvhalDFT]

inline def halNiDftInit2D(
  context: cvhalDFT,
  width: int,
  height: int,
  depth: int,
  src_channels: int,
  dst_channels: int,
  flags: int,
  nonzero_rows: int
): cvhalDFT = (^.asInstanceOf[js.Dynamic].applyDynamic("hal_ni_dftInit2D")(context.asInstanceOf[js.Any], width.asInstanceOf[js.Any], height.asInstanceOf[js.Any], depth.asInstanceOf[js.Any], src_channels.asInstanceOf[js.Any], dst_channels.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], nonzero_rows.asInstanceOf[js.Any])).asInstanceOf[cvhalDFT]

inline def halNiMinMaxIdx(
  src_data: uchar,
  src_step: sizeT,
  width: int,
  height: int,
  depth: int,
  minVal: Any,
  maxVal: Any,
  minIdx: Any,
  maxIdx: Any,
  mask: uchar
): uchar = (^.asInstanceOf[js.Dynamic].applyDynamic("hal_ni_minMaxIdx")(src_data.asInstanceOf[js.Any], src_step.asInstanceOf[js.Any], width.asInstanceOf[js.Any], height.asInstanceOf[js.Any], depth.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[uchar]

inline def hconcat(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("hconcat")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def hconcat(src: Any, nsrc: sizeT, dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("hconcat")(src.asInstanceOf[js.Any], nsrc.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def hconcat(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("hconcat")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def idct(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("idct")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def idct(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("idct")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def idft(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("idft")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def idft(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: Unit,
  nonzeroRows: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("idft")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], nonzeroRows.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def idft(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("idft")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def idft(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int,
  nonzeroRows: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("idft")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], nonzeroRows.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def imagesFromBlob(blob_ : Any, images_ : typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("imagesFromBlob")(blob_.asInstanceOf[js.Any], images_.asInstanceOf[js.Any])).asInstanceOf[Any]

inline def imread(canvasOrImageHtmlElement: String): Mat = ^.asInstanceOf[js.Dynamic].applyDynamic("imread")(canvasOrImageHtmlElement.asInstanceOf[js.Any]).asInstanceOf[Mat]
inline def imread(canvasOrImageHtmlElement: HTMLElement): Mat = ^.asInstanceOf[js.Dynamic].applyDynamic("imread")(canvasOrImageHtmlElement.asInstanceOf[js.Any]).asInstanceOf[Mat]

inline def imshow(canvasSource: String, mat: Mat): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("imshow")(canvasSource.asInstanceOf[js.Any], mat.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def imshow(canvasSource: HTMLElement, mat: Mat): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("imshow")(canvasSource.asInstanceOf[js.Any], mat.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def inRange(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lowerb: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  upperb: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("inRange")(src.asInstanceOf[js.Any], lowerb.asInstanceOf[js.Any], upperb.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def initCameraMatrix2D(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("initCameraMatrix2D")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def initCameraMatrix2D(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  aspectRatio: double
): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("initCameraMatrix2D")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], aspectRatio.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]

inline def initUndistortRectifyMap(
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  newCameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  size: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  m1type: int,
  map1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  map2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("initUndistortRectifyMap")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], R.asInstanceOf[js.Any], newCameraMatrix.asInstanceOf[js.Any], size.asInstanceOf[js.Any], m1type.asInstanceOf[js.Any], map1.asInstanceOf[js.Any], map2.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def initWideAngleProjMap(
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  destImageWidth: int,
  m1type: int,
  map1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  map2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("initWideAngleProjMap")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], destImageWidth.asInstanceOf[js.Any], m1type.asInstanceOf[js.Any], map1.asInstanceOf[js.Any], map2.asInstanceOf[js.Any])).asInstanceOf[float]
inline def initWideAngleProjMap(
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  destImageWidth: int,
  m1type: int,
  map1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  map2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  projType: Any
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("initWideAngleProjMap")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], destImageWidth.asInstanceOf[js.Any], m1type.asInstanceOf[js.Any], map1.asInstanceOf[js.Any], map2.asInstanceOf[js.Any], projType.asInstanceOf[js.Any])).asInstanceOf[float]
inline def initWideAngleProjMap(
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  destImageWidth: int,
  m1type: int,
  map1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  map2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  projType: Any,
  alpha: double
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("initWideAngleProjMap")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], destImageWidth.asInstanceOf[js.Any], m1type.asInstanceOf[js.Any], map1.asInstanceOf[js.Any], map2.asInstanceOf[js.Any], projType.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any])).asInstanceOf[float]
inline def initWideAngleProjMap(
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  destImageWidth: int,
  m1type: int,
  map1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  map2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  projType: Unit,
  alpha: double
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("initWideAngleProjMap")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], destImageWidth.asInstanceOf[js.Any], m1type.asInstanceOf[js.Any], map1.asInstanceOf[js.Any], map2.asInstanceOf[js.Any], projType.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any])).asInstanceOf[float]
inline def initWideAngleProjMap(
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  destImageWidth: int,
  m1type: int,
  map1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  map2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  projType: int
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("initWideAngleProjMap")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], destImageWidth.asInstanceOf[js.Any], m1type.asInstanceOf[js.Any], map1.asInstanceOf[js.Any], map2.asInstanceOf[js.Any], projType.asInstanceOf[js.Any])).asInstanceOf[float]
inline def initWideAngleProjMap(
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  destImageWidth: int,
  m1type: int,
  map1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  map2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  projType: int,
  alpha: double
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("initWideAngleProjMap")(cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], destImageWidth.asInstanceOf[js.Any], m1type.asInstanceOf[js.Any], map1.asInstanceOf[js.Any], map2.asInstanceOf[js.Any], projType.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any])).asInstanceOf[float]

inline def inpaint(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  inpaintMask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  inpaintRadius: double,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("inpaint")(src.asInstanceOf[js.Any], inpaintMask.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], inpaintRadius.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def insertChannel(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  coi: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("insertChannel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], coi.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def integral(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  sum: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def integral(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  sum: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  sdepth: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sdepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def integral(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  sum: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  sqsum: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sqsum.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def integral(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  sum: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  sqsum: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  sdepth: Unit,
  sqdepth: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sqsum.asInstanceOf[js.Any], sdepth.asInstanceOf[js.Any], sqdepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def integral(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  sum: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  sqsum: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  sdepth: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sqsum.asInstanceOf[js.Any], sdepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def integral(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  sum: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  sqsum: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  sdepth: int,
  sqdepth: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sqsum.asInstanceOf[js.Any], sdepth.asInstanceOf[js.Any], sqdepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def integral(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  sum: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  sqsum: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  tilted: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sqsum.asInstanceOf[js.Any], tilted.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def integral(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  sum: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  sqsum: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  tilted: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  sdepth: Unit,
  sqdepth: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sqsum.asInstanceOf[js.Any], tilted.asInstanceOf[js.Any], sdepth.asInstanceOf[js.Any], sqdepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def integral(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  sum: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  sqsum: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  tilted: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  sdepth: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sqsum.asInstanceOf[js.Any], tilted.asInstanceOf[js.Any], sdepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def integral(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  sum: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  sqsum: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  tilted: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  sdepth: int,
  sqdepth: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("integral")(src.asInstanceOf[js.Any], sum.asInstanceOf[js.Any], sqsum.asInstanceOf[js.Any], tilted.asInstanceOf[js.Any], sdepth.asInstanceOf[js.Any], sqdepth.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def intersectConvexConvex(
  _p1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  _p2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  _p12: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("intersectConvexConvex")(_p1.asInstanceOf[js.Any], _p2.asInstanceOf[js.Any], _p12.asInstanceOf[js.Any])).asInstanceOf[float]
inline def intersectConvexConvex(
  _p1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  _p2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  _p12: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  handleNested: bool
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("intersectConvexConvex")(_p1.asInstanceOf[js.Any], _p2.asInstanceOf[js.Any], _p12.asInstanceOf[js.Any], handleNested.asInstanceOf[js.Any])).asInstanceOf[float]

inline def invert(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("invert")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[double]
inline def invert(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("invert")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[double]

inline def invertAffineTransform(
  M: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  iM: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("invertAffineTransform")(M.asInstanceOf[js.Any], iM.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def isContourConvex(contour: typings.mirada.distSrcTypesOpencvTypesMod.InputArray): bool = ^.asInstanceOf[js.Dynamic].applyDynamic("isContourConvex")(contour.asInstanceOf[js.Any]).asInstanceOf[bool]

inline def kArray: SpeedLevel = ^.asInstanceOf[js.Dynamic].selectDynamic("kArray").asInstanceOf[SpeedLevel]

inline def kBitsetHash: SpeedLevel = ^.asInstanceOf[js.Dynamic].selectDynamic("kBitsetHash").asInstanceOf[SpeedLevel]

inline def kHash: SpeedLevel = ^.asInstanceOf[js.Dynamic].selectDynamic("kHash").asInstanceOf[SpeedLevel]

inline def kmeans(
  data: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  K: int,
  bestLabels: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria,
  attempts: int,
  flags: int
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("kmeans")(data.asInstanceOf[js.Any], K.asInstanceOf[js.Any], bestLabels.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], attempts.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[double]
inline def kmeans(
  data: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  K: int,
  bestLabels: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria,
  attempts: int,
  flags: int,
  centers: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("kmeans")(data.asInstanceOf[js.Any], K.asInstanceOf[js.Any], bestLabels.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], attempts.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], centers.asInstanceOf[js.Any])).asInstanceOf[double]

inline def line(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("line")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def line(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("line")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def line(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: Unit,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("line")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def line(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: Unit,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("line")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def line(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("line")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def line(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: int,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("line")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def line(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: int,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("line")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def line(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: int,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("line")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def linearPolar(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  center: typings.mirada.distSrcTypesOpencvTypesMod.Point2f,
  maxRadius: double,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("linearPolar")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], center.asInstanceOf[js.Any], maxRadius.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def log(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("log")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def logPolar(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  center: typings.mirada.distSrcTypesOpencvTypesMod.Point2f,
  M: double,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("logPolar")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], center.asInstanceOf[js.Any], M.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def magnitude(
  x: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  y: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  magnitude: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("magnitude")(x.asInstanceOf[js.Any], y.asInstanceOf[js.Any], magnitude.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def matFromArray(rows: Double, cols: Double, `type`: Any, array: js.Array[Double]): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("matFromArray")(rows.asInstanceOf[js.Any], cols.asInstanceOf[js.Any], `type`.asInstanceOf[js.Any], array.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def matFromArray(rows: Double, cols: Double, `type`: Any, array: js.typedarray.ArrayBufferView): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("matFromArray")(rows.asInstanceOf[js.Any], cols.asInstanceOf[js.Any], `type`.asInstanceOf[js.Any], array.asInstanceOf[js.Any])).asInstanceOf[Mat]
inline def matFromArray(rows: Double, cols: Double, `type`: Any, array: Any): Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("matFromArray")(rows.asInstanceOf[js.Any], cols.asInstanceOf[js.Any], `type`.asInstanceOf[js.Any], array.asInstanceOf[js.Any])).asInstanceOf[Mat]

inline def matFromImageData(imageData: typings.mirada.distSrcTypesOpencvHacksMod.ImageData): Mat = ^.asInstanceOf[js.Dynamic].applyDynamic("matFromImageData")(imageData.asInstanceOf[js.Any]).asInstanceOf[Mat]

inline def matMulDeriv(
  A: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  B: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dABdA: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dABdB: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("matMulDeriv")(A.asInstanceOf[js.Any], B.asInstanceOf[js.Any], dABdA.asInstanceOf[js.Any], dABdB.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def matchShapes(
  contour1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  contour2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  method: int,
  parameter: double
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("matchShapes")(contour1.asInstanceOf[js.Any], contour2.asInstanceOf[js.Any], method.asInstanceOf[js.Any], parameter.asInstanceOf[js.Any])).asInstanceOf[double]

inline def matchTemplate(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  templ: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  result: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("matchTemplate")(image.asInstanceOf[js.Any], templ.asInstanceOf[js.Any], result.asInstanceOf[js.Any], method.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def matchTemplate(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  templ: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  result: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  method: int,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("matchTemplate")(image.asInstanceOf[js.Any], templ.asInstanceOf[js.Any], result.asInstanceOf[js.Any], method.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def max(src1: Any, src2: Any, dst: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("max")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def max(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("max")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def mean(src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray): typings.mirada.distSrcTypesOpencvTypesMod.Scalar = ^.asInstanceOf[js.Dynamic].applyDynamic("mean")(src.asInstanceOf[js.Any]).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Scalar]
inline def mean(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): typings.mirada.distSrcTypesOpencvTypesMod.Scalar = (^.asInstanceOf[js.Dynamic].applyDynamic("mean")(src.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Scalar]

inline def meanShift(
  probImage: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  window: Any,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("meanShift")(probImage.asInstanceOf[js.Any], window.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[int]

inline def meanStdDev(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mean: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  stddev: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("meanStdDev")(src.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], stddev.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def meanStdDev(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mean: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  stddev: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("meanStdDev")(src.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], stddev.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def medianBlur(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ksize: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("medianBlur")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def merge(mv: Any, count: sizeT, dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("merge")(mv.asInstanceOf[js.Any], count.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def merge(
  mv: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("merge")(mv.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def min(src1: Any, src2: Any, dst: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("min")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def min(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("min")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def minAreaRect(points: typings.mirada.distSrcTypesOpencvTypesMod.InputArray): typings.mirada.distSrcTypesOpencvTypesMod.RotatedRect = ^.asInstanceOf[js.Dynamic].applyDynamic("minAreaRect")(points.asInstanceOf[js.Any]).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.RotatedRect]

inline def minEnclosingCircle(points: typings.mirada.distSrcTypesOpencvTypesMod.InputArray, center: Any, radius: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minEnclosingCircle")(points.asInstanceOf[js.Any], center.asInstanceOf[js.Any], radius.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def minEnclosingTriangle(
  points: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  triangle: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("minEnclosingTriangle")(points.asInstanceOf[js.Any], triangle.asInstanceOf[js.Any])).asInstanceOf[double]

inline def minMaxIdx(src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray, minVal: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray, minVal: Any, maxVal: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray, minVal: Any, maxVal: Any, minIdx: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  minVal: Any,
  maxVal: Any,
  minIdx: Any,
  maxIdx: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  minVal: Any,
  maxVal: Any,
  minIdx: Any,
  maxIdx: Any,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  minVal: Any,
  maxVal: Any,
  minIdx: Any,
  maxIdx: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  minVal: Any,
  maxVal: Any,
  minIdx: Unit,
  maxIdx: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  minVal: Any,
  maxVal: Any,
  minIdx: Unit,
  maxIdx: Any,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  minVal: Any,
  maxVal: Any,
  minIdx: Unit,
  maxIdx: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray, minVal: Any, maxVal: Unit, minIdx: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  minVal: Any,
  maxVal: Unit,
  minIdx: Any,
  maxIdx: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  minVal: Any,
  maxVal: Unit,
  minIdx: Any,
  maxIdx: Any,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  minVal: Any,
  maxVal: Unit,
  minIdx: Any,
  maxIdx: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  minVal: Any,
  maxVal: Unit,
  minIdx: Unit,
  maxIdx: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  minVal: Any,
  maxVal: Unit,
  minIdx: Unit,
  maxIdx: Any,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxIdx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  minVal: Any,
  maxVal: Unit,
  minIdx: Unit,
  maxIdx: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxIdx")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def minMaxLoc(a: Any, minVal: Any, maxVal: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(a.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(a: Any, minVal: Any, maxVal: Any, minIdx: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(a.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(a: Any, minVal: Any, maxVal: Any, minIdx: Any, maxIdx: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(a.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(a: Any, minVal: Any, maxVal: Any, minIdx: Unit, maxIdx: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(a.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minIdx.asInstanceOf[js.Any], maxIdx.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray, minVal: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray, minVal: Any, maxVal: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray, minVal: Any, maxVal: Any, minLoc: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  minVal: Any,
  maxVal: Any,
  minLoc: Any,
  maxLoc: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  minVal: Any,
  maxVal: Any,
  minLoc: Any,
  maxLoc: Any,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  minVal: Any,
  maxVal: Any,
  minLoc: Any,
  maxLoc: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  minVal: Any,
  maxVal: Any,
  minLoc: Unit,
  maxLoc: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  minVal: Any,
  maxVal: Any,
  minLoc: Unit,
  maxLoc: Any,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  minVal: Any,
  maxVal: Any,
  minLoc: Unit,
  maxLoc: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray, minVal: Any, maxVal: Unit, minLoc: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  minVal: Any,
  maxVal: Unit,
  minLoc: Any,
  maxLoc: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  minVal: Any,
  maxVal: Unit,
  minLoc: Any,
  maxLoc: Any,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  minVal: Any,
  maxVal: Unit,
  minLoc: Any,
  maxLoc: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  minVal: Any,
  maxVal: Unit,
  minLoc: Unit,
  maxLoc: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  minVal: Any,
  maxVal: Unit,
  minLoc: Unit,
  maxLoc: Any,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def minMaxLoc(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  minVal: Any,
  maxVal: Unit,
  minLoc: Unit,
  maxLoc: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("minMaxLoc")(src.asInstanceOf[js.Any], minVal.asInstanceOf[js.Any], maxVal.asInstanceOf[js.Any], minLoc.asInstanceOf[js.Any], maxLoc.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def mixChannels(src: Any, nsrcs: sizeT, dst: Any, ndsts: sizeT, fromTo: Any, npairs: sizeT): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mixChannels")(src.asInstanceOf[js.Any], nsrcs.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ndsts.asInstanceOf[js.Any], fromTo.asInstanceOf[js.Any], npairs.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def mixChannels(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArrayOfArrays,
  fromTo: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mixChannels")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], fromTo.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def mixChannels(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArrayOfArrays,
  fromTo: Any,
  npairs: sizeT
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mixChannels")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], fromTo.asInstanceOf[js.Any], npairs.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def moments(array: typings.mirada.distSrcTypesOpencvTypesMod.InputArray): Moments = ^.asInstanceOf[js.Dynamic].applyDynamic("moments")(array.asInstanceOf[js.Any]).asInstanceOf[Moments]
inline def moments(array: typings.mirada.distSrcTypesOpencvTypesMod.InputArray, binaryImage: bool): Moments = (^.asInstanceOf[js.Dynamic].applyDynamic("moments")(array.asInstanceOf[js.Any], binaryImage.asInstanceOf[js.Any])).asInstanceOf[Moments]

inline def morphologyDefaultBorderValue(): typings.mirada.distSrcTypesOpencvTypesMod.Scalar = ^.asInstanceOf[js.Dynamic].applyDynamic("morphologyDefaultBorderValue")().asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Scalar]

inline def morphologyEx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  op: int,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  op: int,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  iterations: Unit,
  borderType: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  op: int,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  iterations: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  op: int,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  iterations: Unit,
  borderType: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  op: int,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  iterations: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  op: int,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  iterations: int,
  borderType: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  op: int,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  iterations: int,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  op: int,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  iterations: int,
  borderType: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  op: int,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  op: int,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  iterations: Unit,
  borderType: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  op: int,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  iterations: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  op: int,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  iterations: Unit,
  borderType: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  op: int,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  iterations: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  op: int,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  iterations: int,
  borderType: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  op: int,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  iterations: int,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def morphologyEx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  op: int,
  kernel: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  iterations: int,
  borderType: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("morphologyEx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], op.asInstanceOf[js.Any], kernel.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], iterations.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def mulSpectrums(
  a: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  b: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  c: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulSpectrums")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any], c.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def mulSpectrums(
  a: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  b: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  c: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int,
  conjB: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulSpectrums")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any], c.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], conjB.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def mulTransposed(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  aTa: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulTransposed")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], aTa.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def mulTransposed(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  aTa: bool,
  delta: Unit,
  scale: Unit,
  dtype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulTransposed")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], aTa.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def mulTransposed(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  aTa: bool,
  delta: Unit,
  scale: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulTransposed")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], aTa.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def mulTransposed(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  aTa: bool,
  delta: Unit,
  scale: double,
  dtype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulTransposed")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], aTa.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def mulTransposed(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  aTa: bool,
  delta: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulTransposed")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], aTa.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def mulTransposed(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  aTa: bool,
  delta: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  scale: Unit,
  dtype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulTransposed")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], aTa.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def mulTransposed(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  aTa: bool,
  delta: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  scale: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulTransposed")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], aTa.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def mulTransposed(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  aTa: bool,
  delta: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  scale: double,
  dtype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("mulTransposed")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], aTa.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def multiply(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("multiply")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def multiply(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  scale: Unit,
  dtype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("multiply")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def multiply(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  scale: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("multiply")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], scale.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def multiply(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  scale: double,
  dtype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("multiply")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], scale.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def norm(src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray): double = ^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src1.asInstanceOf[js.Any]).asInstanceOf[double]
inline def norm(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  normType: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src1.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[double]
inline def norm(src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray, normType: int): double = (^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src1.asInstanceOf[js.Any], normType.asInstanceOf[js.Any])).asInstanceOf[double]
inline def norm(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  normType: int,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src1.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[double]
inline def norm(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any])).asInstanceOf[double]
inline def norm(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  normType: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[double]
inline def norm(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  normType: int
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], normType.asInstanceOf[js.Any])).asInstanceOf[double]
inline def norm(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  normType: int,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], normType.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[double]
inline def norm(src: Any, normType: int): double = (^.asInstanceOf[js.Dynamic].applyDynamic("norm")(src.asInstanceOf[js.Any], normType.asInstanceOf[js.Any])).asInstanceOf[double]

inline def norm1(a: Mat, b: Mat, `type`: NormTypes): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("norm1")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any], `type`.asInstanceOf[js.Any])).asInstanceOf[Double]

inline def normInf(arg96: Any, arg97: Any, a: Any, n: int): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("normInf")(arg96.asInstanceOf[js.Any], arg97.asInstanceOf[js.Any], a.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[Any]
inline def normInf(arg98: Any, arg99: Any, a: Any, b: Any, n: int): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("normInf")(arg98.asInstanceOf[js.Any], arg99.asInstanceOf[js.Any], a.asInstanceOf[js.Any], b.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[Any]

inline def normL1(arg100: Any, arg101: Any, a: Any, n: int): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("normL1")(arg100.asInstanceOf[js.Any], arg101.asInstanceOf[js.Any], a.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[Any]
inline def normL1(arg102: Any, arg103: Any, a: Any, b: Any, n: int): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("normL1")(arg102.asInstanceOf[js.Any], arg103.asInstanceOf[js.Any], a.asInstanceOf[js.Any], b.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[Any]
inline def normL1(a: Any, b: Any, n: int): float = (^.asInstanceOf[js.Dynamic].applyDynamic("normL1")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[float]

inline def normL1_uchar(a: uchar, b: uchar, n: int): uchar = (^.asInstanceOf[js.Dynamic].applyDynamic("normL1")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[uchar]

inline def normL2Sqr(arg104: Any, arg105: Any, a: Any, n: int): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("normL2Sqr")(arg104.asInstanceOf[js.Any], arg105.asInstanceOf[js.Any], a.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[Any]
inline def normL2Sqr(arg106: Any, arg107: Any, a: Any, b: Any, n: int): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("normL2Sqr")(arg106.asInstanceOf[js.Any], arg107.asInstanceOf[js.Any], a.asInstanceOf[js.Any], b.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[Any]
inline def normL2Sqr(a: Any, b: Any, n: int): float = (^.asInstanceOf[js.Dynamic].applyDynamic("normL2Sqr")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[float]

inline def normalize(src: Any, dst: Any, alpha: double, normType: int): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], normType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: Unit,
  beta: Unit,
  norm_type: Unit,
  dtype: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: Unit,
  beta: Unit,
  norm_type: Unit,
  dtype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: Unit,
  beta: Unit,
  norm_type: Unit,
  dtype: int,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: Unit,
  beta: Unit,
  norm_type: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: Unit,
  beta: Unit,
  norm_type: int,
  dtype: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: Unit,
  beta: Unit,
  norm_type: int,
  dtype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: Unit,
  beta: Unit,
  norm_type: int,
  dtype: int,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: Unit,
  beta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: Unit,
  beta: double,
  norm_type: Unit,
  dtype: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: Unit,
  beta: double,
  norm_type: Unit,
  dtype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: Unit,
  beta: double,
  norm_type: Unit,
  dtype: int,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: Unit,
  beta: double,
  norm_type: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: Unit,
  beta: double,
  norm_type: int,
  dtype: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: Unit,
  beta: double,
  norm_type: int,
  dtype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: Unit,
  beta: double,
  norm_type: int,
  dtype: int,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: double,
  beta: Unit,
  norm_type: Unit,
  dtype: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: double,
  beta: Unit,
  norm_type: Unit,
  dtype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: double,
  beta: Unit,
  norm_type: Unit,
  dtype: int,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: double,
  beta: Unit,
  norm_type: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: double,
  beta: Unit,
  norm_type: int,
  dtype: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: double,
  beta: Unit,
  norm_type: int,
  dtype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: double,
  beta: Unit,
  norm_type: int,
  dtype: int,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: double,
  beta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: double,
  beta: double,
  norm_type: Unit,
  dtype: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: double,
  beta: double,
  norm_type: Unit,
  dtype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: double,
  beta: double,
  norm_type: Unit,
  dtype: int,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: double,
  beta: double,
  norm_type: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: double,
  beta: double,
  norm_type: int,
  dtype: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: double,
  beta: double,
  norm_type: int,
  dtype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def normalize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  alpha: double,
  beta: double,
  norm_type: int,
  dtype: int,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any], norm_type.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def onRuntimeInitialized(): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("onRuntimeInitialized")().asInstanceOf[Any]

inline def parallelFor(range: Any, body: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("parallel_for_")(range.asInstanceOf[js.Any], body.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def parallelFor(range: Any, body: Any, nstripes: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("parallel_for_")(range.asInstanceOf[js.Any], body.asInstanceOf[js.Any], nstripes.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def partition(arg119: Any, arg120: Any, _vec: Any, labels: Any): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("partition")(arg119.asInstanceOf[js.Any], arg120.asInstanceOf[js.Any], _vec.asInstanceOf[js.Any], labels.asInstanceOf[js.Any])).asInstanceOf[Any]
inline def partition(arg119: Any, arg120: Any, _vec: Any, labels: Any, predicate: EqPredicate): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("partition")(arg119.asInstanceOf[js.Any], arg120.asInstanceOf[js.Any], _vec.asInstanceOf[js.Any], labels.asInstanceOf[js.Any], predicate.asInstanceOf[js.Any])).asInstanceOf[Any]

inline def patchNaNs(a: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("patchNaNs")(a.asInstanceOf[js.Any]).asInstanceOf[Unit]
inline def patchNaNs(a: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray, `val`: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("patchNaNs")(a.asInstanceOf[js.Any], `val`.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def perspectiveTransform(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  m: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("perspectiveTransform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], m.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def phase(
  x: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  y: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  angle: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("phase")(x.asInstanceOf[js.Any], y.asInstanceOf[js.Any], angle.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def phase(
  x: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  y: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  angle: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  angleInDegrees: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("phase")(x.asInstanceOf[js.Any], y.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], angleInDegrees.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def pointPolygonTest(
  contour: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  pt: typings.mirada.distSrcTypesOpencvTypesMod.Point2f,
  measureDist: bool
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("pointPolygonTest")(contour.asInstanceOf[js.Any], pt.asInstanceOf[js.Any], measureDist.asInstanceOf[js.Any])).asInstanceOf[double]

inline def polarToCart(
  magnitude: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  angle: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  x: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  y: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polarToCart")(magnitude.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], x.asInstanceOf[js.Any], y.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polarToCart(
  magnitude: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  angle: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  x: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  y: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  angleInDegrees: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polarToCart")(magnitude.asInstanceOf[js.Any], angle.asInstanceOf[js.Any], x.asInstanceOf[js.Any], y.asInstanceOf[js.Any], angleInDegrees.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def polylines(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  isClosed: bool,
  color: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  isClosed: bool,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  isClosed: bool,
  color: Any,
  thickness: Unit,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  isClosed: bool,
  color: Any,
  thickness: Unit,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  isClosed: bool,
  color: Any,
  thickness: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  isClosed: bool,
  color: Any,
  thickness: int,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  isClosed: bool,
  color: Any,
  thickness: int,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: Any,
  npts: Any,
  ncontours: int,
  isClosed: bool,
  color: Any,
  thickness: int,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], npts.asInstanceOf[js.Any], ncontours.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  isClosed: bool,
  color: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  isClosed: bool,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  isClosed: bool,
  color: Any,
  thickness: Unit,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  isClosed: bool,
  color: Any,
  thickness: Unit,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  isClosed: bool,
  color: Any,
  thickness: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  isClosed: bool,
  color: Any,
  thickness: int,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  isClosed: bool,
  color: Any,
  thickness: int,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def polylines(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pts: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  isClosed: bool,
  color: Any,
  thickness: int,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("polylines")(img.asInstanceOf[js.Any], pts.asInstanceOf[js.Any], isClosed.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def pow(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  power: double,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pow")(src.asInstanceOf[js.Any], power.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def preCornerDetect(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ksize: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("preCornerDetect")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def preCornerDetect(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ksize: int,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("preCornerDetect")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def projectPoints(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("projectPoints")(objectPoints.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def projectPoints(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  jacobian: Unit,
  aspectRatio: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("projectPoints")(objectPoints.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], jacobian.asInstanceOf[js.Any], aspectRatio.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def projectPoints(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  jacobian: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("projectPoints")(objectPoints.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], jacobian.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def projectPoints(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  jacobian: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  aspectRatio: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("projectPoints")(objectPoints.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], jacobian.asInstanceOf[js.Any], aspectRatio.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def putText(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  text: Any,
  org_ : typings.mirada.distSrcTypesOpencvTypesMod.Point,
  fontFace: int,
  fontScale: double,
  color: typings.mirada.distSrcTypesOpencvTypesMod.Scalar
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("putText")(img.asInstanceOf[js.Any], text.asInstanceOf[js.Any], org_.asInstanceOf[js.Any], fontFace.asInstanceOf[js.Any], fontScale.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def putText(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  text: Any,
  org_ : typings.mirada.distSrcTypesOpencvTypesMod.Point,
  fontFace: int,
  fontScale: double,
  color: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  thickness: Unit,
  lineType: Unit,
  bottomLeftOrigin: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("putText")(img.asInstanceOf[js.Any], text.asInstanceOf[js.Any], org_.asInstanceOf[js.Any], fontFace.asInstanceOf[js.Any], fontScale.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], bottomLeftOrigin.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def putText(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  text: Any,
  org_ : typings.mirada.distSrcTypesOpencvTypesMod.Point,
  fontFace: int,
  fontScale: double,
  color: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  thickness: Unit,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("putText")(img.asInstanceOf[js.Any], text.asInstanceOf[js.Any], org_.asInstanceOf[js.Any], fontFace.asInstanceOf[js.Any], fontScale.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def putText(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  text: Any,
  org_ : typings.mirada.distSrcTypesOpencvTypesMod.Point,
  fontFace: int,
  fontScale: double,
  color: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  thickness: Unit,
  lineType: int,
  bottomLeftOrigin: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("putText")(img.asInstanceOf[js.Any], text.asInstanceOf[js.Any], org_.asInstanceOf[js.Any], fontFace.asInstanceOf[js.Any], fontScale.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], bottomLeftOrigin.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def putText(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  text: Any,
  org_ : typings.mirada.distSrcTypesOpencvTypesMod.Point,
  fontFace: int,
  fontScale: double,
  color: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  thickness: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("putText")(img.asInstanceOf[js.Any], text.asInstanceOf[js.Any], org_.asInstanceOf[js.Any], fontFace.asInstanceOf[js.Any], fontScale.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def putText(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  text: Any,
  org_ : typings.mirada.distSrcTypesOpencvTypesMod.Point,
  fontFace: int,
  fontScale: double,
  color: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  thickness: int,
  lineType: Unit,
  bottomLeftOrigin: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("putText")(img.asInstanceOf[js.Any], text.asInstanceOf[js.Any], org_.asInstanceOf[js.Any], fontFace.asInstanceOf[js.Any], fontScale.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], bottomLeftOrigin.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def putText(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  text: Any,
  org_ : typings.mirada.distSrcTypesOpencvTypesMod.Point,
  fontFace: int,
  fontScale: double,
  color: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  thickness: int,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("putText")(img.asInstanceOf[js.Any], text.asInstanceOf[js.Any], org_.asInstanceOf[js.Any], fontFace.asInstanceOf[js.Any], fontScale.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def putText(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  text: Any,
  org_ : typings.mirada.distSrcTypesOpencvTypesMod.Point,
  fontFace: int,
  fontScale: double,
  color: typings.mirada.distSrcTypesOpencvTypesMod.Scalar,
  thickness: int,
  lineType: int,
  bottomLeftOrigin: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("putText")(img.asInstanceOf[js.Any], text.asInstanceOf[js.Any], org_.asInstanceOf[js.Any], fontFace.asInstanceOf[js.Any], fontScale.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], bottomLeftOrigin.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def pyrDown(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pyrDown")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def pyrDown(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dstsize: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pyrDown")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dstsize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def pyrDown(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dstsize: Any,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pyrDown")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dstsize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def pyrDown(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dstsize: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pyrDown")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dstsize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def pyrMeanShiftFiltering(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  sp: double,
  sr: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pyrMeanShiftFiltering")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], sp.asInstanceOf[js.Any], sr.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def pyrMeanShiftFiltering(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  sp: double,
  sr: double,
  maxLevel: Unit,
  termcrit: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pyrMeanShiftFiltering")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], sp.asInstanceOf[js.Any], sr.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], termcrit.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def pyrMeanShiftFiltering(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  sp: double,
  sr: double,
  maxLevel: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pyrMeanShiftFiltering")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], sp.asInstanceOf[js.Any], sr.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def pyrMeanShiftFiltering(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  sp: double,
  sr: double,
  maxLevel: int,
  termcrit: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pyrMeanShiftFiltering")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], sp.asInstanceOf[js.Any], sr.asInstanceOf[js.Any], maxLevel.asInstanceOf[js.Any], termcrit.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def pyrUp(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pyrUp")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def pyrUp(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dstsize: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pyrUp")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dstsize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def pyrUp(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dstsize: Any,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pyrUp")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dstsize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def pyrUp(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dstsize: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("pyrUp")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dstsize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def randShuffle(dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("randShuffle")(dst.asInstanceOf[js.Any]).asInstanceOf[Unit]
inline def randShuffle(dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray, iterFactor: Unit, rng: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("randShuffle")(dst.asInstanceOf[js.Any], iterFactor.asInstanceOf[js.Any], rng.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def randShuffle(dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray, iterFactor: double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("randShuffle")(dst.asInstanceOf[js.Any], iterFactor.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def randShuffle(dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray, iterFactor: double, rng: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("randShuffle")(dst.asInstanceOf[js.Any], iterFactor.asInstanceOf[js.Any], rng.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def randn(
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  mean: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  stddev: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("randn")(dst.asInstanceOf[js.Any], mean.asInstanceOf[js.Any], stddev.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def randu(
  dst: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  low: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  high: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("randu")(dst.asInstanceOf[js.Any], low.asInstanceOf[js.Any], high.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def readNet(model: Any): Net = ^.asInstanceOf[js.Dynamic].applyDynamic("readNet")(model.asInstanceOf[js.Any]).asInstanceOf[Net]
inline def readNet(model: Any, config: Any): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNet")(model.asInstanceOf[js.Any], config.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNet(model: Any, config: Any, framework: Any): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNet")(model.asInstanceOf[js.Any], config.asInstanceOf[js.Any], framework.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNet(model: Any, config: Unit, framework: Any): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNet")(model.asInstanceOf[js.Any], config.asInstanceOf[js.Any], framework.asInstanceOf[js.Any])).asInstanceOf[Net]

inline def readNetFromCaffe(bufferProto: Any, lenProto: sizeT, bufferModel: Any): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromCaffe")(bufferProto.asInstanceOf[js.Any], lenProto.asInstanceOf[js.Any], bufferModel.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNetFromCaffe(bufferProto: Any, lenProto: sizeT, bufferModel: Any, lenModel: sizeT): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromCaffe")(bufferProto.asInstanceOf[js.Any], lenProto.asInstanceOf[js.Any], bufferModel.asInstanceOf[js.Any], lenModel.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNetFromCaffe(bufferProto: Any, lenProto: sizeT, bufferModel: Unit, lenModel: sizeT): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromCaffe")(bufferProto.asInstanceOf[js.Any], lenProto.asInstanceOf[js.Any], bufferModel.asInstanceOf[js.Any], lenModel.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNetFromCaffe(prototxt: Any): Net = ^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromCaffe")(prototxt.asInstanceOf[js.Any]).asInstanceOf[Net]
inline def readNetFromCaffe(prototxt: Any, caffeModel: Any | sizeT): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromCaffe")(prototxt.asInstanceOf[js.Any], caffeModel.asInstanceOf[js.Any])).asInstanceOf[Net]

inline def readNetFromCaffe_uchar(bufferProto: uchar): uchar = ^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromCaffe")(bufferProto.asInstanceOf[js.Any]).asInstanceOf[uchar]
inline def readNetFromCaffe_uchar(bufferProto: uchar, bufferModel: uchar): uchar = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromCaffe")(bufferProto.asInstanceOf[js.Any], bufferModel.asInstanceOf[js.Any])).asInstanceOf[uchar]

inline def readNetFromDarknet(bufferCfg: Any, lenCfg: sizeT, bufferModel: Any): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromDarknet")(bufferCfg.asInstanceOf[js.Any], lenCfg.asInstanceOf[js.Any], bufferModel.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNetFromDarknet(bufferCfg: Any, lenCfg: sizeT, bufferModel: Any, lenModel: sizeT): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromDarknet")(bufferCfg.asInstanceOf[js.Any], lenCfg.asInstanceOf[js.Any], bufferModel.asInstanceOf[js.Any], lenModel.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNetFromDarknet(bufferCfg: Any, lenCfg: sizeT, bufferModel: Unit, lenModel: sizeT): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromDarknet")(bufferCfg.asInstanceOf[js.Any], lenCfg.asInstanceOf[js.Any], bufferModel.asInstanceOf[js.Any], lenModel.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNetFromDarknet(cfgFile: Any): Net = ^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromDarknet")(cfgFile.asInstanceOf[js.Any]).asInstanceOf[Net]
inline def readNetFromDarknet(cfgFile: Any, darknetModel: Any | sizeT): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromDarknet")(cfgFile.asInstanceOf[js.Any], darknetModel.asInstanceOf[js.Any])).asInstanceOf[Net]

inline def readNetFromDarknet_uchar(bufferCfg: uchar): uchar = ^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromDarknet")(bufferCfg.asInstanceOf[js.Any]).asInstanceOf[uchar]
inline def readNetFromDarknet_uchar(bufferCfg: uchar, bufferModel: uchar): uchar = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromDarknet")(bufferCfg.asInstanceOf[js.Any], bufferModel.asInstanceOf[js.Any])).asInstanceOf[uchar]

inline def readNetFromModelOptimizer(xml: Any, bin: Any): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromModelOptimizer")(xml.asInstanceOf[js.Any], bin.asInstanceOf[js.Any])).asInstanceOf[Net]

inline def readNetFromONNX(buffer: Any, sizeBuffer: sizeT): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromONNX")(buffer.asInstanceOf[js.Any], sizeBuffer.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNetFromONNX(onnxFile: Any): Net = ^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromONNX")(onnxFile.asInstanceOf[js.Any]).asInstanceOf[Net]

inline def readNetFromONNX_uchar(buffer: uchar): uchar = ^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromONNX")(buffer.asInstanceOf[js.Any]).asInstanceOf[uchar]

inline def readNetFromTensorflow(bufferModel: Any, lenModel: sizeT, bufferConfig: Any): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromTensorflow")(bufferModel.asInstanceOf[js.Any], lenModel.asInstanceOf[js.Any], bufferConfig.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNetFromTensorflow(bufferModel: Any, lenModel: sizeT, bufferConfig: Any, lenConfig: sizeT): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromTensorflow")(bufferModel.asInstanceOf[js.Any], lenModel.asInstanceOf[js.Any], bufferConfig.asInstanceOf[js.Any], lenConfig.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNetFromTensorflow(bufferModel: Any, lenModel: sizeT, bufferConfig: Unit, lenConfig: sizeT): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromTensorflow")(bufferModel.asInstanceOf[js.Any], lenModel.asInstanceOf[js.Any], bufferConfig.asInstanceOf[js.Any], lenConfig.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNetFromTensorflow(model: Any): Net = ^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromTensorflow")(model.asInstanceOf[js.Any]).asInstanceOf[Net]
inline def readNetFromTensorflow(model: Any, config: Any | sizeT): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromTensorflow")(model.asInstanceOf[js.Any], config.asInstanceOf[js.Any])).asInstanceOf[Net]

inline def readNetFromTensorflow_uchar(bufferModel: uchar): uchar = ^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromTensorflow")(bufferModel.asInstanceOf[js.Any]).asInstanceOf[uchar]
inline def readNetFromTensorflow_uchar(bufferModel: uchar, bufferConfig: uchar): uchar = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromTensorflow")(bufferModel.asInstanceOf[js.Any], bufferConfig.asInstanceOf[js.Any])).asInstanceOf[uchar]

inline def readNetFromTorch(model: Any): Net = ^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromTorch")(model.asInstanceOf[js.Any]).asInstanceOf[Net]
inline def readNetFromTorch(model: Any, isBinary: Unit, evaluate: bool): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromTorch")(model.asInstanceOf[js.Any], isBinary.asInstanceOf[js.Any], evaluate.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNetFromTorch(model: Any, isBinary: bool): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromTorch")(model.asInstanceOf[js.Any], isBinary.asInstanceOf[js.Any])).asInstanceOf[Net]
inline def readNetFromTorch(model: Any, isBinary: bool, evaluate: bool): Net = (^.asInstanceOf[js.Dynamic].applyDynamic("readNetFromTorch")(model.asInstanceOf[js.Any], isBinary.asInstanceOf[js.Any], evaluate.asInstanceOf[js.Any])).asInstanceOf[Net]

inline def readNet_uchar(framework: Any, bufferModel: uchar): uchar = (^.asInstanceOf[js.Dynamic].applyDynamic("readNet")(framework.asInstanceOf[js.Any], bufferModel.asInstanceOf[js.Any])).asInstanceOf[uchar]
inline def readNet_uchar(framework: Any, bufferModel: uchar, bufferConfig: uchar): uchar = (^.asInstanceOf[js.Dynamic].applyDynamic("readNet")(framework.asInstanceOf[js.Any], bufferModel.asInstanceOf[js.Any], bufferConfig.asInstanceOf[js.Any])).asInstanceOf[uchar]

inline def readOpticalFlow(path: Any): typings.mirada.distSrcTypesOpencvTypesMod.Mat = ^.asInstanceOf[js.Dynamic].applyDynamic("readOpticalFlow")(path.asInstanceOf[js.Any]).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]

inline def readTensorFromONNX(path: Any): typings.mirada.distSrcTypesOpencvTypesMod.Mat = ^.asInstanceOf[js.Dynamic].applyDynamic("readTensorFromONNX")(path.asInstanceOf[js.Any]).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]

inline def readTorchBlob(filename: Any): typings.mirada.distSrcTypesOpencvTypesMod.Mat = ^.asInstanceOf[js.Dynamic].applyDynamic("readTorchBlob")(filename.asInstanceOf[js.Any]).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def readTorchBlob(filename: Any, isBinary: bool): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("readTorchBlob")(filename.asInstanceOf[js.Any], isBinary.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]

inline def recoverPose(
  E: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  t: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any])).asInstanceOf[int]
inline def recoverPose(
  E: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  t: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  focal: Unit,
  pp: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any], focal.asInstanceOf[js.Any], pp.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[int]
inline def recoverPose(
  E: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  t: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  focal: Unit,
  pp: typings.mirada.distSrcTypesOpencvTypesMod.Point2d
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any], focal.asInstanceOf[js.Any], pp.asInstanceOf[js.Any])).asInstanceOf[int]
inline def recoverPose(
  E: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  t: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  focal: Unit,
  pp: typings.mirada.distSrcTypesOpencvTypesMod.Point2d,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any], focal.asInstanceOf[js.Any], pp.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[int]
inline def recoverPose(
  E: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  t: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  focal: double
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any], focal.asInstanceOf[js.Any])).asInstanceOf[int]
inline def recoverPose(
  E: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  t: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  focal: double,
  pp: Unit,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any], focal.asInstanceOf[js.Any], pp.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[int]
inline def recoverPose(
  E: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  t: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  focal: double,
  pp: typings.mirada.distSrcTypesOpencvTypesMod.Point2d
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any], focal.asInstanceOf[js.Any], pp.asInstanceOf[js.Any])).asInstanceOf[int]
inline def recoverPose(
  E: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  t: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  focal: double,
  pp: typings.mirada.distSrcTypesOpencvTypesMod.Point2d,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any], focal.asInstanceOf[js.Any], pp.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[int]
inline def recoverPose(
  E: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  t: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any])).asInstanceOf[int]
inline def recoverPose(
  E: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  t: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  distanceThresh: double
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any], distanceThresh.asInstanceOf[js.Any])).asInstanceOf[int]
inline def recoverPose(
  E: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  t: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  distanceThresh: double,
  mask: Unit,
  triangulatedPoints: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any], distanceThresh.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], triangulatedPoints.asInstanceOf[js.Any])).asInstanceOf[int]
inline def recoverPose(
  E: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  t: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  distanceThresh: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any], distanceThresh.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[int]
inline def recoverPose(
  E: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  t: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  distanceThresh: double,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  triangulatedPoints: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any], distanceThresh.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], triangulatedPoints.asInstanceOf[js.Any])).asInstanceOf[int]
inline def recoverPose(
  E: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  t: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("recoverPose")(E.asInstanceOf[js.Any], points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], R.asInstanceOf[js.Any], t.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[int]

inline def rectangle(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: Unit,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: Unit,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: int,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: int,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  color: Any,
  thickness: int,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  rec: typings.mirada.distSrcTypesOpencvTypesMod.Rect,
  color: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], rec.asInstanceOf[js.Any], color.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  rec: typings.mirada.distSrcTypesOpencvTypesMod.Rect,
  color: Any,
  thickness: Unit,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], rec.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  rec: typings.mirada.distSrcTypesOpencvTypesMod.Rect,
  color: Any,
  thickness: Unit,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], rec.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  rec: typings.mirada.distSrcTypesOpencvTypesMod.Rect,
  color: Any,
  thickness: Unit,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], rec.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  rec: typings.mirada.distSrcTypesOpencvTypesMod.Rect,
  color: Any,
  thickness: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], rec.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  rec: typings.mirada.distSrcTypesOpencvTypesMod.Rect,
  color: Any,
  thickness: int,
  lineType: Unit,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], rec.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  rec: typings.mirada.distSrcTypesOpencvTypesMod.Rect,
  color: Any,
  thickness: int,
  lineType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], rec.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def rectangle(
  img: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  rec: typings.mirada.distSrcTypesOpencvTypesMod.Rect,
  color: Any,
  thickness: int,
  lineType: int,
  shift: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rectangle")(img.asInstanceOf[js.Any], rec.asInstanceOf[js.Any], color.asInstanceOf[js.Any], thickness.asInstanceOf[js.Any], lineType.asInstanceOf[js.Any], shift.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def rectify3Collinear(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix3: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs3: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imgpt1: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imgpt3: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R12: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T12: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R13: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T13: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R3: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P3: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  alpha: double,
  newImgSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  roi1: Any,
  roi2: Any,
  flags: int
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("rectify3Collinear")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], cameraMatrix3.asInstanceOf[js.Any], distCoeffs3.asInstanceOf[js.Any], imgpt1.asInstanceOf[js.Any], imgpt3.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R12.asInstanceOf[js.Any], T12.asInstanceOf[js.Any], R13.asInstanceOf[js.Any], T13.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], R3.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], P3.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImgSize.asInstanceOf[js.Any], roi1.asInstanceOf[js.Any], roi2.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[float]

inline def redirectError(errCallback: ErrorCallback): ErrorCallback = ^.asInstanceOf[js.Dynamic].applyDynamic("redirectError")(errCallback.asInstanceOf[js.Any]).asInstanceOf[ErrorCallback]
inline def redirectError(errCallback: ErrorCallback, userdata: Any): ErrorCallback = (^.asInstanceOf[js.Dynamic].applyDynamic("redirectError")(errCallback.asInstanceOf[js.Any], userdata.asInstanceOf[js.Any])).asInstanceOf[ErrorCallback]
inline def redirectError(errCallback: ErrorCallback, userdata: Any, prevUserdata: Any): ErrorCallback = (^.asInstanceOf[js.Dynamic].applyDynamic("redirectError")(errCallback.asInstanceOf[js.Any], userdata.asInstanceOf[js.Any], prevUserdata.asInstanceOf[js.Any])).asInstanceOf[ErrorCallback]
inline def redirectError(errCallback: ErrorCallback, userdata: Unit, prevUserdata: Any): ErrorCallback = (^.asInstanceOf[js.Dynamic].applyDynamic("redirectError")(errCallback.asInstanceOf[js.Any], userdata.asInstanceOf[js.Any], prevUserdata.asInstanceOf[js.Any])).asInstanceOf[ErrorCallback]

inline def reduce(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dim: int,
  rtype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("reduce")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dim.asInstanceOf[js.Any], rtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def reduce(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dim: int,
  rtype: int,
  dtype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("reduce")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dim.asInstanceOf[js.Any], rtype.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def remap(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  map1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  map2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  interpolation: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("remap")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], map1.asInstanceOf[js.Any], map2.asInstanceOf[js.Any], interpolation.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def remap(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  map1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  map2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  interpolation: int,
  borderMode: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("remap")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], map1.asInstanceOf[js.Any], map2.asInstanceOf[js.Any], interpolation.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def remap(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  map1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  map2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  interpolation: int,
  borderMode: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("remap")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], map1.asInstanceOf[js.Any], map2.asInstanceOf[js.Any], interpolation.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def remap(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  map1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  map2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  interpolation: int,
  borderMode: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("remap")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], map1.asInstanceOf[js.Any], map2.asInstanceOf[js.Any], interpolation.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def repeat(src: Any, ny: int, nx: int): typings.mirada.distSrcTypesOpencvTypesMod.Mat = (^.asInstanceOf[js.Dynamic].applyDynamic("repeat")(src.asInstanceOf[js.Any], ny.asInstanceOf[js.Any], nx.asInstanceOf[js.Any])).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Mat]
inline def repeat(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  ny: int,
  nx: int,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("repeat")(src.asInstanceOf[js.Any], ny.asInstanceOf[js.Any], nx.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def reprojectImageTo3D(
  disparity: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  _3dImage: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("reprojectImageTo3D")(disparity.asInstanceOf[js.Any], _3dImage.asInstanceOf[js.Any], Q.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def reprojectImageTo3D(
  disparity: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  _3dImage: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  handleMissingValues: Unit,
  ddepth: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("reprojectImageTo3D")(disparity.asInstanceOf[js.Any], _3dImage.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], handleMissingValues.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def reprojectImageTo3D(
  disparity: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  _3dImage: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  handleMissingValues: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("reprojectImageTo3D")(disparity.asInstanceOf[js.Any], _3dImage.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], handleMissingValues.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def reprojectImageTo3D(
  disparity: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  _3dImage: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  handleMissingValues: bool,
  ddepth: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("reprojectImageTo3D")(disparity.asInstanceOf[js.Any], _3dImage.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], handleMissingValues.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def resize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dsize: typings.mirada.distSrcTypesOpencvTypesMod.Size
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("resize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def resize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dsize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  fx: Unit,
  fy: Unit,
  interpolation: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("resize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], fx.asInstanceOf[js.Any], fy.asInstanceOf[js.Any], interpolation.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def resize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dsize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  fx: Unit,
  fy: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("resize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], fx.asInstanceOf[js.Any], fy.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def resize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dsize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  fx: Unit,
  fy: double,
  interpolation: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("resize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], fx.asInstanceOf[js.Any], fy.asInstanceOf[js.Any], interpolation.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def resize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dsize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  fx: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("resize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], fx.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def resize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dsize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  fx: double,
  fy: Unit,
  interpolation: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("resize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], fx.asInstanceOf[js.Any], fy.asInstanceOf[js.Any], interpolation.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def resize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dsize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  fx: double,
  fy: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("resize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], fx.asInstanceOf[js.Any], fy.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def resize(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dsize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  fx: double,
  fy: double,
  interpolation: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("resize")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], fx.asInstanceOf[js.Any], fy.asInstanceOf[js.Any], interpolation.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def rotate(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  rotateCode: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("rotate")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], rotateCode.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def rotatedRectangleIntersection(rect1: Any, rect2: Any, intersectingRegion: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray): int = (^.asInstanceOf[js.Dynamic].applyDynamic("rotatedRectangleIntersection")(rect1.asInstanceOf[js.Any], rect2.asInstanceOf[js.Any], intersectingRegion.asInstanceOf[js.Any])).asInstanceOf[int]

inline def roundUp(a: int, b: Any): int = (^.asInstanceOf[js.Dynamic].applyDynamic("roundUp")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[int]
inline def roundUp(a: sizeT, b: Any): sizeT = (^.asInstanceOf[js.Dynamic].applyDynamic("roundUp")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[sizeT]

inline def rows: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("rows").asInstanceOf[Any]

inline def sampsonDistance(
  pt1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  pt2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  F: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("sampsonDistance")(pt1.asInstanceOf[js.Any], pt2.asInstanceOf[js.Any], F.asInstanceOf[js.Any])).asInstanceOf[double]

inline def saturateCast(arg113: Any, v: double | float | int): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("saturate_cast")(arg113.asInstanceOf[js.Any], v.asInstanceOf[js.Any])).asInstanceOf[Any]
inline def saturateCast(arg116: Any, v: int64): int64 = (^.asInstanceOf[js.Dynamic].applyDynamic("saturate_cast")(arg116.asInstanceOf[js.Any], v.asInstanceOf[js.Any])).asInstanceOf[int64]

inline def saturateCast_Any(arg111: Any, v: float16T | short | unsigned): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("saturate_cast")(arg111.asInstanceOf[js.Any], v.asInstanceOf[js.Any])).asInstanceOf[Any]

inline def saturateCast_schar(arg109: Any, v: schar): schar = (^.asInstanceOf[js.Dynamic].applyDynamic("saturate_cast")(arg109.asInstanceOf[js.Any], v.asInstanceOf[js.Any])).asInstanceOf[schar]

inline def saturateCast_uchar(arg108: Any, v: uchar): uchar = (^.asInstanceOf[js.Dynamic].applyDynamic("saturate_cast")(arg108.asInstanceOf[js.Any], v.asInstanceOf[js.Any])).asInstanceOf[uchar]

inline def saturateCast_uint64(arg117: Any, v: uint64): uint64 = (^.asInstanceOf[js.Dynamic].applyDynamic("saturate_cast")(arg117.asInstanceOf[js.Any], v.asInstanceOf[js.Any])).asInstanceOf[uint64]

inline def saturateCast_ushort(arg110: Any, v: ushort): ushort = (^.asInstanceOf[js.Dynamic].applyDynamic("saturate_cast")(arg110.asInstanceOf[js.Any], v.asInstanceOf[js.Any])).asInstanceOf[ushort]

inline def scaleAdd(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  alpha: double,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleAdd")(src1.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def sepFilter2D(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  kernelX: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  kernelY: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sepFilter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernelX.asInstanceOf[js.Any], kernelY.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sepFilter2D(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  kernelX: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  kernelY: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sepFilter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernelX.asInstanceOf[js.Any], kernelY.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sepFilter2D(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  kernelX: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  kernelY: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  delta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sepFilter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernelX.asInstanceOf[js.Any], kernelY.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sepFilter2D(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  kernelX: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  kernelY: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: Unit,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sepFilter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernelX.asInstanceOf[js.Any], kernelY.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sepFilter2D(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  kernelX: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  kernelY: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sepFilter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernelX.asInstanceOf[js.Any], kernelY.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sepFilter2D(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  kernelX: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  kernelY: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  delta: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sepFilter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernelX.asInstanceOf[js.Any], kernelY.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sepFilter2D(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  kernelX: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  kernelY: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  delta: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sepFilter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernelX.asInstanceOf[js.Any], kernelY.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], delta.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sepFilter2D(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  kernelX: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  kernelY: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  delta: double,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sepFilter2D")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], kernelX.asInstanceOf[js.Any], kernelY.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], delta.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def setBreakOnError(flag: bool): bool = ^.asInstanceOf[js.Dynamic].applyDynamic("setBreakOnError")(flag.asInstanceOf[js.Any]).asInstanceOf[bool]

inline def setDelayFunction(a: Any*): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("setDelayFunction")(a.asInstanceOf[Seq[js.Any]]*).asInstanceOf[Any]

inline def setIdentity(mtx: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("setIdentity")(mtx.asInstanceOf[js.Any]).asInstanceOf[Unit]
inline def setIdentity(mtx: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray, s: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("setIdentity")(mtx.asInstanceOf[js.Any], s.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def setNumThreads(nthreads: int): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("setNumThreads")(nthreads.asInstanceOf[js.Any]).asInstanceOf[Unit]

inline def setRNGSeed(seed: int): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("setRNGSeed")(seed.asInstanceOf[js.Any]).asInstanceOf[Unit]

inline def setUseOptimized(onoff: bool): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("setUseOptimized")(onoff.asInstanceOf[js.Any]).asInstanceOf[Unit]

inline def shortdim: Any = ^.asInstanceOf[js.Dynamic].selectDynamic("shortdim").asInstanceOf[Any]

inline def shrinkCaffeModel(src: Any, dst: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("shrinkCaffeModel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def shrinkCaffeModel(src: Any, dst: Any, layersTypes: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("shrinkCaffeModel")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], layersTypes.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def solve(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("solve")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def solve(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("solve")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def solveCubic(
  coeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  roots: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solveCubic")(coeffs.asInstanceOf[js.Any], roots.asInstanceOf[js.Any])).asInstanceOf[int]

inline def solveP3P(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  flags: int
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solveP3P")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]

inline def solvePnP(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnP")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def solvePnP(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  useExtrinsicGuess: Unit,
  flags: int
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnP")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def solvePnP(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  useExtrinsicGuess: bool
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnP")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def solvePnP(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  useExtrinsicGuess: bool,
  flags: int
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnP")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: Unit,
  rvec: Unit,
  tvec: Unit,
  reprojectionError: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: Unit,
  rvec: Unit,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: Unit,
  rvec: Unit,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  reprojectionError: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: Unit,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: Unit,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  tvec: Unit,
  reprojectionError: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: Unit,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: Unit,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  reprojectionError: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: SolvePnPMethod
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: SolvePnPMethod,
  rvec: Unit,
  tvec: Unit,
  reprojectionError: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: SolvePnPMethod,
  rvec: Unit,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: SolvePnPMethod,
  rvec: Unit,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  reprojectionError: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: SolvePnPMethod,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: SolvePnPMethod,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  tvec: Unit,
  reprojectionError: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: SolvePnPMethod,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: Unit,
  flags: SolvePnPMethod,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  reprojectionError: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: bool
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: Unit,
  rvec: Unit,
  tvec: Unit,
  reprojectionError: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: Unit,
  rvec: Unit,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: Unit,
  rvec: Unit,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  reprojectionError: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: Unit,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: Unit,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  tvec: Unit,
  reprojectionError: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: Unit,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: Unit,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  reprojectionError: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: SolvePnPMethod
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: SolvePnPMethod,
  rvec: Unit,
  tvec: Unit,
  reprojectionError: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: SolvePnPMethod,
  rvec: Unit,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: SolvePnPMethod,
  rvec: Unit,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  reprojectionError: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: SolvePnPMethod,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: SolvePnPMethod,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  tvec: Unit,
  reprojectionError: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: SolvePnPMethod,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any])).asInstanceOf[int]
inline def solvePnPGeneric(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  tvecs: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays,
  useExtrinsicGuess: bool,
  flags: SolvePnPMethod,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  reprojectionError: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): int = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPGeneric")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvecs.asInstanceOf[js.Any], tvecs.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any])).asInstanceOf[int]

inline def solvePnPRansac(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  useExtrinsicGuess: js.UndefOr[bool],
  iterationsCount: js.UndefOr[int],
  reprojectionError: js.UndefOr[float],
  confidence: js.UndefOr[double],
  inliers: js.UndefOr[typings.mirada.distSrcTypesOpencvTypesMod.OutputArray],
  flags: js.UndefOr[int]
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPRansac")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], useExtrinsicGuess.asInstanceOf[js.Any], iterationsCount.asInstanceOf[js.Any], reprojectionError.asInstanceOf[js.Any], confidence.asInstanceOf[js.Any], inliers.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def solvePnPRefineLM(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPRefineLM")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def solvePnPRefineLM(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPRefineLM")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def solvePnPRefineVVS(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPRefineVVS")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def solvePnPRefineVVS(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  criteria: Unit,
  VVSlambda: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPRefineVVS")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], VVSlambda.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def solvePnPRefineVVS(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPRefineVVS")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def solvePnPRefineVVS(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imagePoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  rvec: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  tvec: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria,
  VVSlambda: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePnPRefineVVS")(objectPoints.asInstanceOf[js.Any], imagePoints.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], rvec.asInstanceOf[js.Any], tvec.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any], VVSlambda.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def solvePoly(
  coeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  roots: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePoly")(coeffs.asInstanceOf[js.Any], roots.asInstanceOf[js.Any])).asInstanceOf[double]
inline def solvePoly(
  coeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  roots: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  maxIters: int
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("solvePoly")(coeffs.asInstanceOf[js.Any], roots.asInstanceOf[js.Any], maxIters.asInstanceOf[js.Any])).asInstanceOf[double]

inline def sort(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sort")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def sortIdx(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sortIdx")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def spatialGradient(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dy: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("spatialGradient")(src.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def spatialGradient(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dy: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ksize: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("spatialGradient")(src.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def spatialGradient(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dy: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ksize: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("spatialGradient")(src.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def spatialGradient(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dx: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dy: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ksize: int,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("spatialGradient")(src.asInstanceOf[js.Any], dx.asInstanceOf[js.Any], dy.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def split(
  m: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  mv: typings.mirada.distSrcTypesOpencvTypesMod.OutputArrayOfArrays
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("split")(m.asInstanceOf[js.Any], mv.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def split(src: Any, mvbegin: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("split")(src.asInstanceOf[js.Any], mvbegin.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def sqrBoxFilter(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sqrBoxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sqrBoxFilter(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  anchor: Unit,
  normalize: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sqrBoxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sqrBoxFilter(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  anchor: Unit,
  normalize: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sqrBoxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sqrBoxFilter(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  anchor: Unit,
  normalize: bool,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sqrBoxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sqrBoxFilter(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sqrBoxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sqrBoxFilter(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  normalize: Unit,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sqrBoxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sqrBoxFilter(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  normalize: bool
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sqrBoxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def sqrBoxFilter(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  ddepth: int,
  ksize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  anchor: typings.mirada.distSrcTypesOpencvTypesMod.Point,
  normalize: bool,
  borderType: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sqrBoxFilter")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], ddepth.asInstanceOf[js.Any], ksize.asInstanceOf[js.Any], anchor.asInstanceOf[js.Any], normalize.asInstanceOf[js.Any], borderType.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def sqrt(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("sqrt")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def stereoCalibrate(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints1: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints2: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  E: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  F: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  perViewErrors: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoCalibrate")(objectPoints.asInstanceOf[js.Any], imagePoints1.asInstanceOf[js.Any], imagePoints2.asInstanceOf[js.Any], cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], E.asInstanceOf[js.Any], F.asInstanceOf[js.Any], perViewErrors.asInstanceOf[js.Any])).asInstanceOf[double]
inline def stereoCalibrate(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints1: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints2: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  E: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  F: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  perViewErrors: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: Unit,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoCalibrate")(objectPoints.asInstanceOf[js.Any], imagePoints1.asInstanceOf[js.Any], imagePoints2.asInstanceOf[js.Any], cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], E.asInstanceOf[js.Any], F.asInstanceOf[js.Any], perViewErrors.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]
inline def stereoCalibrate(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints1: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints2: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  E: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  F: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  perViewErrors: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoCalibrate")(objectPoints.asInstanceOf[js.Any], imagePoints1.asInstanceOf[js.Any], imagePoints2.asInstanceOf[js.Any], cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], E.asInstanceOf[js.Any], F.asInstanceOf[js.Any], perViewErrors.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[double]
inline def stereoCalibrate(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints1: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints2: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  E: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  F: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  perViewErrors: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoCalibrate")(objectPoints.asInstanceOf[js.Any], imagePoints1.asInstanceOf[js.Any], imagePoints2.asInstanceOf[js.Any], cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], E.asInstanceOf[js.Any], F.asInstanceOf[js.Any], perViewErrors.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]
inline def stereoCalibrate(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints1: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints2: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  E: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  F: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoCalibrate")(objectPoints.asInstanceOf[js.Any], imagePoints1.asInstanceOf[js.Any], imagePoints2.asInstanceOf[js.Any], cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], E.asInstanceOf[js.Any], F.asInstanceOf[js.Any])).asInstanceOf[double]
inline def stereoCalibrate(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints1: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints2: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  E: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  F: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: Unit,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoCalibrate")(objectPoints.asInstanceOf[js.Any], imagePoints1.asInstanceOf[js.Any], imagePoints2.asInstanceOf[js.Any], cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], E.asInstanceOf[js.Any], F.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]
inline def stereoCalibrate(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints1: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints2: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  E: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  F: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoCalibrate")(objectPoints.asInstanceOf[js.Any], imagePoints1.asInstanceOf[js.Any], imagePoints2.asInstanceOf[js.Any], cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], E.asInstanceOf[js.Any], F.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[double]
inline def stereoCalibrate(
  objectPoints: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints1: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  imagePoints2: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  E: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  F: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoCalibrate")(objectPoints.asInstanceOf[js.Any], imagePoints1.asInstanceOf[js.Any], imagePoints2.asInstanceOf[js.Any], cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], E.asInstanceOf[js.Any], F.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[double]

inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: Unit,
  alpha: Unit,
  newImageSize: Unit,
  validPixROI1: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: Unit,
  alpha: Unit,
  newImageSize: Unit,
  validPixROI1: Any,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: Unit,
  alpha: Unit,
  newImageSize: Unit,
  validPixROI1: Unit,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: Unit,
  alpha: Unit,
  newImageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: Unit,
  alpha: Unit,
  newImageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  validPixROI1: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: Unit,
  alpha: Unit,
  newImageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  validPixROI1: Any,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: Unit,
  alpha: Unit,
  newImageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  validPixROI1: Unit,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: Unit,
  alpha: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: Unit,
  alpha: double,
  newImageSize: Unit,
  validPixROI1: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: Unit,
  alpha: double,
  newImageSize: Unit,
  validPixROI1: Any,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: Unit,
  alpha: double,
  newImageSize: Unit,
  validPixROI1: Unit,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: Unit,
  alpha: double,
  newImageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: Unit,
  alpha: double,
  newImageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  validPixROI1: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: Unit,
  alpha: double,
  newImageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  validPixROI1: Any,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: Unit,
  alpha: double,
  newImageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  validPixROI1: Unit,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int,
  alpha: Unit,
  newImageSize: Unit,
  validPixROI1: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int,
  alpha: Unit,
  newImageSize: Unit,
  validPixROI1: Any,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int,
  alpha: Unit,
  newImageSize: Unit,
  validPixROI1: Unit,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int,
  alpha: Unit,
  newImageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int,
  alpha: Unit,
  newImageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  validPixROI1: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int,
  alpha: Unit,
  newImageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  validPixROI1: Any,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int,
  alpha: Unit,
  newImageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  validPixROI1: Unit,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int,
  alpha: double
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int,
  alpha: double,
  newImageSize: Unit,
  validPixROI1: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int,
  alpha: double,
  newImageSize: Unit,
  validPixROI1: Any,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int,
  alpha: double,
  newImageSize: Unit,
  validPixROI1: Unit,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int,
  alpha: double,
  newImageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int,
  alpha: double,
  newImageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  validPixROI1: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int,
  alpha: double,
  newImageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  validPixROI1: Any,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def stereoRectify(
  cameraMatrix1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  cameraMatrix2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  T: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  R2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  P2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  Q: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  flags: int,
  alpha: double,
  newImageSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  validPixROI1: Unit,
  validPixROI2: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectify")(cameraMatrix1.asInstanceOf[js.Any], distCoeffs1.asInstanceOf[js.Any], cameraMatrix2.asInstanceOf[js.Any], distCoeffs2.asInstanceOf[js.Any], imageSize.asInstanceOf[js.Any], R.asInstanceOf[js.Any], T.asInstanceOf[js.Any], R1.asInstanceOf[js.Any], R2.asInstanceOf[js.Any], P1.asInstanceOf[js.Any], P2.asInstanceOf[js.Any], Q.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], alpha.asInstanceOf[js.Any], newImageSize.asInstanceOf[js.Any], validPixROI1.asInstanceOf[js.Any], validPixROI2.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def stereoRectifyUncalibrated(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  F: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imgSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  H1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  H2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectifyUncalibrated")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], F.asInstanceOf[js.Any], imgSize.asInstanceOf[js.Any], H1.asInstanceOf[js.Any], H2.asInstanceOf[js.Any])).asInstanceOf[bool]
inline def stereoRectifyUncalibrated(
  points1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  F: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  imgSize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  H1: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  H2: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  threshold: double
): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("stereoRectifyUncalibrated")(points1.asInstanceOf[js.Any], points2.asInstanceOf[js.Any], F.asInstanceOf[js.Any], imgSize.asInstanceOf[js.Any], H1.asInstanceOf[js.Any], H2.asInstanceOf[js.Any], threshold.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def subtract(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("subtract")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def subtract(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  mask: Unit,
  dtype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("subtract")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def subtract(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("subtract")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def subtract(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  mask: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dtype: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("subtract")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], mask.asInstanceOf[js.Any], dtype.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def sum(src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray): typings.mirada.distSrcTypesOpencvTypesMod.Scalar = ^.asInstanceOf[js.Dynamic].applyDynamic("sum")(src.asInstanceOf[js.Any]).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Scalar]

inline def tempfile(): String = ^.asInstanceOf[js.Dynamic].applyDynamic("tempfile")().asInstanceOf[String]
inline def tempfile(suffix: Any): String = ^.asInstanceOf[js.Dynamic].applyDynamic("tempfile")(suffix.asInstanceOf[js.Any]).asInstanceOf[String]

inline def testAsyncArray(argument: typings.mirada.distSrcTypesOpencvTypesMod.InputArray): AsyncArray = ^.asInstanceOf[js.Dynamic].applyDynamic("testAsyncArray")(argument.asInstanceOf[js.Any]).asInstanceOf[AsyncArray]

inline def testAsyncException(): AsyncArray = ^.asInstanceOf[js.Dynamic].applyDynamic("testAsyncException")().asInstanceOf[AsyncArray]

inline def theRNG(): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("theRNG")().asInstanceOf[Any]

inline def threshold(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  thresh: double,
  maxval: double,
  `type`: int
): double = (^.asInstanceOf[js.Dynamic].applyDynamic("threshold")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], thresh.asInstanceOf[js.Any], maxval.asInstanceOf[js.Any], `type`.asInstanceOf[js.Any])).asInstanceOf[double]

inline def trace(mtx: typings.mirada.distSrcTypesOpencvTypesMod.InputArray): typings.mirada.distSrcTypesOpencvTypesMod.Scalar = ^.asInstanceOf[js.Dynamic].applyDynamic("trace")(mtx.asInstanceOf[js.Any]).asInstanceOf[typings.mirada.distSrcTypesOpencvTypesMod.Scalar]

inline def transform(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  m: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("transform")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], m.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def transpose(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("transpose")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def triangulatePoints(
  projMatr1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  projMatr2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  projPoints1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  projPoints2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  points4D: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("triangulatePoints")(projMatr1.asInstanceOf[js.Any], projMatr2.asInstanceOf[js.Any], projPoints1.asInstanceOf[js.Any], projPoints2.asInstanceOf[js.Any], points4D.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def undistort(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("undistort")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def undistort(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  newCameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("undistort")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], newCameraMatrix.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def undistortPoints(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("undistortPoints")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def undistortPoints(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R: Unit,
  P: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("undistortPoints")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], R.asInstanceOf[js.Any], P.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def undistortPoints(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("undistortPoints")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], R.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def undistortPoints(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  P: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("undistortPoints")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], R.asInstanceOf[js.Any], P.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def undistortPoints(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  cameraMatrix: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distCoeffs: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  R: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  P: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  criteria: typings.mirada.distSrcTypesOpencvTypesMod.TermCriteria
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("undistortPoints")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], cameraMatrix.asInstanceOf[js.Any], distCoeffs.asInstanceOf[js.Any], R.asInstanceOf[js.Any], P.asInstanceOf[js.Any], criteria.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def useOptimized(): bool = ^.asInstanceOf[js.Dynamic].applyDynamic("useOptimized")().asInstanceOf[bool]

inline def validateDisparity(
  disparity: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  cost: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  minDisparity: int,
  numberOfDisparities: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("validateDisparity")(disparity.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], minDisparity.asInstanceOf[js.Any], numberOfDisparities.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def validateDisparity(
  disparity: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray,
  cost: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  minDisparity: int,
  numberOfDisparities: int,
  disp12MaxDisp: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("validateDisparity")(disparity.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], minDisparity.asInstanceOf[js.Any], numberOfDisparities.asInstanceOf[js.Any], disp12MaxDisp.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def vconcat(
  src1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  src2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("vconcat")(src1.asInstanceOf[js.Any], src2.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def vconcat(src: Any, nsrc: sizeT, dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("vconcat")(src.asInstanceOf[js.Any], nsrc.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def vconcat(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArrayOfArrays,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("vconcat")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def warpAffine(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  M: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dsize: typings.mirada.distSrcTypesOpencvTypesMod.Size
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpAffine")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpAffine(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  M: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dsize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  flags: Unit,
  borderMode: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpAffine")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpAffine(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  M: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dsize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  flags: Unit,
  borderMode: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpAffine")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpAffine(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  M: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dsize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  flags: Unit,
  borderMode: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpAffine")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpAffine(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  M: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dsize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpAffine")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpAffine(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  M: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dsize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  flags: int,
  borderMode: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpAffine")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpAffine(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  M: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dsize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  flags: int,
  borderMode: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpAffine")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpAffine(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  M: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dsize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  flags: int,
  borderMode: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpAffine")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def warpPerspective(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  M: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dsize: typings.mirada.distSrcTypesOpencvTypesMod.Size
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpPerspective")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpPerspective(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  M: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dsize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  flags: Unit,
  borderMode: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpPerspective")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpPerspective(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  M: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dsize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  flags: Unit,
  borderMode: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpPerspective")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpPerspective(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  M: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dsize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  flags: Unit,
  borderMode: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpPerspective")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpPerspective(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  M: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dsize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpPerspective")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpPerspective(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  M: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dsize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  flags: int,
  borderMode: Unit,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpPerspective")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpPerspective(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  M: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dsize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  flags: int,
  borderMode: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpPerspective")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def warpPerspective(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  M: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dsize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  flags: int,
  borderMode: int,
  borderValue: Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpPerspective")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], M.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], flags.asInstanceOf[js.Any], borderMode.asInstanceOf[js.Any], borderValue.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def warpPolar(
  src: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  dst: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray,
  dsize: typings.mirada.distSrcTypesOpencvTypesMod.Size,
  center: typings.mirada.distSrcTypesOpencvTypesMod.Point2f,
  maxRadius: double,
  flags: int
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("warpPolar")(src.asInstanceOf[js.Any], dst.asInstanceOf[js.Any], dsize.asInstanceOf[js.Any], center.asInstanceOf[js.Any], maxRadius.asInstanceOf[js.Any], flags.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def watershed(
  image: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  markers: typings.mirada.distSrcTypesOpencvTypesMod.InputOutputArray
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("watershed")(image.asInstanceOf[js.Any], markers.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def wrapperEMD(
  signature1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  signature2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distType: int
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("wrapperEMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any])).asInstanceOf[float]
inline def wrapperEMD(
  signature1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  signature2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distType: int,
  cost: Unit,
  lowerBound: Any
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("wrapperEMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], lowerBound.asInstanceOf[js.Any])).asInstanceOf[float]
inline def wrapperEMD(
  signature1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  signature2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distType: int,
  cost: Unit,
  lowerBound: Any,
  flow: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("wrapperEMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], lowerBound.asInstanceOf[js.Any], flow.asInstanceOf[js.Any])).asInstanceOf[float]
inline def wrapperEMD(
  signature1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  signature2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distType: int,
  cost: Unit,
  lowerBound: Unit,
  flow: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("wrapperEMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], lowerBound.asInstanceOf[js.Any], flow.asInstanceOf[js.Any])).asInstanceOf[float]
inline def wrapperEMD(
  signature1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  signature2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distType: int,
  cost: typings.mirada.distSrcTypesOpencvTypesMod.InputArray
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("wrapperEMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any])).asInstanceOf[float]
inline def wrapperEMD(
  signature1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  signature2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distType: int,
  cost: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lowerBound: Any
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("wrapperEMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], lowerBound.asInstanceOf[js.Any])).asInstanceOf[float]
inline def wrapperEMD(
  signature1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  signature2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distType: int,
  cost: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lowerBound: Any,
  flow: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("wrapperEMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], lowerBound.asInstanceOf[js.Any], flow.asInstanceOf[js.Any])).asInstanceOf[float]
inline def wrapperEMD(
  signature1: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  signature2: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  distType: int,
  cost: typings.mirada.distSrcTypesOpencvTypesMod.InputArray,
  lowerBound: Unit,
  flow: typings.mirada.distSrcTypesOpencvTypesMod.OutputArray
): float = (^.asInstanceOf[js.Dynamic].applyDynamic("wrapperEMD")(signature1.asInstanceOf[js.Any], signature2.asInstanceOf[js.Any], distType.asInstanceOf[js.Any], cost.asInstanceOf[js.Any], lowerBound.asInstanceOf[js.Any], flow.asInstanceOf[js.Any])).asInstanceOf[float]

inline def writeOpticalFlow(path: Any, flow: typings.mirada.distSrcTypesOpencvTypesMod.InputArray): bool = (^.asInstanceOf[js.Dynamic].applyDynamic("writeOpticalFlow")(path.asInstanceOf[js.Any], flow.asInstanceOf[js.Any])).asInstanceOf[bool]

inline def writeTextGraph(model: Any, output: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("writeTextGraph")(model.asInstanceOf[js.Any], output.asInstanceOf[js.Any])).asInstanceOf[Unit]
