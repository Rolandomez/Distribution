package typings.esprima

import typings.esprima.esprimaStrings.ArrayExpression
import typings.esprima.esprimaStrings.ArrayPattern
import typings.esprima.esprimaStrings.ArrowFunctionExpression
import typings.esprima.esprimaStrings.AssignmentExpression
import typings.esprima.esprimaStrings.AssignmentPattern
import typings.esprima.esprimaStrings.AwaitExpression
import typings.esprima.esprimaStrings.BinaryExpression
import typings.esprima.esprimaStrings.BlockStatement
import typings.esprima.esprimaStrings.BreakStatement
import typings.esprima.esprimaStrings.CallExpression
import typings.esprima.esprimaStrings.CatchClause
import typings.esprima.esprimaStrings.ClassBody
import typings.esprima.esprimaStrings.ClassDeclaration
import typings.esprima.esprimaStrings.ClassExpression
import typings.esprima.esprimaStrings.ConditionalExpression
import typings.esprima.esprimaStrings.ContinueStatement
import typings.esprima.esprimaStrings.DebuggerStatement
import typings.esprima.esprimaStrings.DoWhileStatement
import typings.esprima.esprimaStrings.EmptyStatement
import typings.esprima.esprimaStrings.ExportAllDeclaration
import typings.esprima.esprimaStrings.ExportDefaultDeclaration
import typings.esprima.esprimaStrings.ExportNamedDeclaration
import typings.esprima.esprimaStrings.ExportSpecifier
import typings.esprima.esprimaStrings.ExpressionStatement
import typings.esprima.esprimaStrings.ForInStatement
import typings.esprima.esprimaStrings.ForOfStatement
import typings.esprima.esprimaStrings.ForStatement
import typings.esprima.esprimaStrings.FunctionDeclaration
import typings.esprima.esprimaStrings.FunctionExpression
import typings.esprima.esprimaStrings.Identifier
import typings.esprima.esprimaStrings.IfStatement
import typings.esprima.esprimaStrings.Import
import typings.esprima.esprimaStrings.ImportDeclaration
import typings.esprima.esprimaStrings.ImportDefaultSpecifier
import typings.esprima.esprimaStrings.ImportNamespaceSpecifier
import typings.esprima.esprimaStrings.ImportSpecifier
import typings.esprima.esprimaStrings.LabeledStatement
import typings.esprima.esprimaStrings.Literal
import typings.esprima.esprimaStrings.LogicalExpression
import typings.esprima.esprimaStrings.MemberExpression
import typings.esprima.esprimaStrings.MetaProperty
import typings.esprima.esprimaStrings.MethodDefinition
import typings.esprima.esprimaStrings.NewExpression
import typings.esprima.esprimaStrings.ObjectExpression
import typings.esprima.esprimaStrings.ObjectPattern
import typings.esprima.esprimaStrings.Property
import typings.esprima.esprimaStrings.RestElement
import typings.esprima.esprimaStrings.ReturnStatement
import typings.esprima.esprimaStrings.SequenceExpression
import typings.esprima.esprimaStrings.SpreadElement
import typings.esprima.esprimaStrings.Super
import typings.esprima.esprimaStrings.SwitchCase
import typings.esprima.esprimaStrings.SwitchStatement
import typings.esprima.esprimaStrings.TaggedTemplateExpression
import typings.esprima.esprimaStrings.TemplateElement
import typings.esprima.esprimaStrings.TemplateLiteral
import typings.esprima.esprimaStrings.ThisExpression
import typings.esprima.esprimaStrings.ThrowStatement
import typings.esprima.esprimaStrings.TryStatement
import typings.esprima.esprimaStrings.UnaryExpression
import typings.esprima.esprimaStrings.UpdateExpression
import typings.esprima.esprimaStrings.VariableDeclaration
import typings.esprima.esprimaStrings.VariableDeclarator
import typings.esprima.esprimaStrings.WhileStatement
import typings.esprima.esprimaStrings.WithStatement
import typings.esprima.esprimaStrings.YieldExpression
import typings.estree.estreeStrings.module
import typings.estree.estreeStrings.script
import typings.estree.mod.Directive
import typings.estree.mod.ModuleDeclaration
import typings.estree.mod.Node
import typings.estree.mod.Statement
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object mod {
  
  @JSImport("esprima", JSImport.Namespace)
  @js.native
  val ^ : js.Any = js.native
  
  object Syntax {
    
    @JSImport("esprima", "Syntax")
    @js.native
    val ^ : js.Any = js.native
    
    @JSImport("esprima", "Syntax.ArrayExpression")
    @js.native
    def ArrayExpression: typings.esprima.esprimaStrings.ArrayExpression = js.native
    inline def ArrayExpression_=(x: ArrayExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ArrayExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ArrayPattern")
    @js.native
    def ArrayPattern: typings.esprima.esprimaStrings.ArrayPattern = js.native
    inline def ArrayPattern_=(x: ArrayPattern): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ArrayPattern")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ArrowFunctionExpression")
    @js.native
    def ArrowFunctionExpression: typings.esprima.esprimaStrings.ArrowFunctionExpression = js.native
    inline def ArrowFunctionExpression_=(x: ArrowFunctionExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ArrowFunctionExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.AssignmentExpression")
    @js.native
    def AssignmentExpression: typings.esprima.esprimaStrings.AssignmentExpression = js.native
    inline def AssignmentExpression_=(x: AssignmentExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AssignmentExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.AssignmentPattern")
    @js.native
    def AssignmentPattern: typings.esprima.esprimaStrings.AssignmentPattern = js.native
    inline def AssignmentPattern_=(x: AssignmentPattern): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AssignmentPattern")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.AwaitExpression")
    @js.native
    def AwaitExpression: typings.esprima.esprimaStrings.AwaitExpression = js.native
    inline def AwaitExpression_=(x: AwaitExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AwaitExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.BinaryExpression")
    @js.native
    def BinaryExpression: typings.esprima.esprimaStrings.BinaryExpression = js.native
    inline def BinaryExpression_=(x: BinaryExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("BinaryExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.BlockStatement")
    @js.native
    def BlockStatement: typings.esprima.esprimaStrings.BlockStatement = js.native
    inline def BlockStatement_=(x: BlockStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("BlockStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.BreakStatement")
    @js.native
    def BreakStatement: typings.esprima.esprimaStrings.BreakStatement = js.native
    inline def BreakStatement_=(x: BreakStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("BreakStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.CallExpression")
    @js.native
    def CallExpression: typings.esprima.esprimaStrings.CallExpression = js.native
    inline def CallExpression_=(x: CallExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CallExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.CatchClause")
    @js.native
    def CatchClause: typings.esprima.esprimaStrings.CatchClause = js.native
    inline def CatchClause_=(x: CatchClause): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CatchClause")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ClassBody")
    @js.native
    def ClassBody: typings.esprima.esprimaStrings.ClassBody = js.native
    inline def ClassBody_=(x: ClassBody): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ClassBody")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ClassDeclaration")
    @js.native
    def ClassDeclaration: typings.esprima.esprimaStrings.ClassDeclaration = js.native
    inline def ClassDeclaration_=(x: ClassDeclaration): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ClassDeclaration")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ClassExpression")
    @js.native
    def ClassExpression: typings.esprima.esprimaStrings.ClassExpression = js.native
    inline def ClassExpression_=(x: ClassExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ClassExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ConditionalExpression")
    @js.native
    def ConditionalExpression: typings.esprima.esprimaStrings.ConditionalExpression = js.native
    inline def ConditionalExpression_=(x: ConditionalExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ConditionalExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ContinueStatement")
    @js.native
    def ContinueStatement: typings.esprima.esprimaStrings.ContinueStatement = js.native
    inline def ContinueStatement_=(x: ContinueStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ContinueStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.DebuggerStatement")
    @js.native
    def DebuggerStatement: typings.esprima.esprimaStrings.DebuggerStatement = js.native
    inline def DebuggerStatement_=(x: DebuggerStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DebuggerStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.DoWhileStatement")
    @js.native
    def DoWhileStatement: typings.esprima.esprimaStrings.DoWhileStatement = js.native
    inline def DoWhileStatement_=(x: DoWhileStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DoWhileStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.EmptyStatement")
    @js.native
    def EmptyStatement: typings.esprima.esprimaStrings.EmptyStatement = js.native
    inline def EmptyStatement_=(x: EmptyStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("EmptyStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ExportAllDeclaration")
    @js.native
    def ExportAllDeclaration: typings.esprima.esprimaStrings.ExportAllDeclaration = js.native
    inline def ExportAllDeclaration_=(x: ExportAllDeclaration): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ExportAllDeclaration")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ExportDefaultDeclaration")
    @js.native
    def ExportDefaultDeclaration: typings.esprima.esprimaStrings.ExportDefaultDeclaration = js.native
    inline def ExportDefaultDeclaration_=(x: ExportDefaultDeclaration): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ExportDefaultDeclaration")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ExportNamedDeclaration")
    @js.native
    def ExportNamedDeclaration: typings.esprima.esprimaStrings.ExportNamedDeclaration = js.native
    inline def ExportNamedDeclaration_=(x: ExportNamedDeclaration): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ExportNamedDeclaration")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ExportSpecifier")
    @js.native
    def ExportSpecifier: typings.esprima.esprimaStrings.ExportSpecifier = js.native
    inline def ExportSpecifier_=(x: ExportSpecifier): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ExportSpecifier")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ExpressionStatement")
    @js.native
    def ExpressionStatement: typings.esprima.esprimaStrings.ExpressionStatement = js.native
    inline def ExpressionStatement_=(x: ExpressionStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ExpressionStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ForInStatement")
    @js.native
    def ForInStatement: typings.esprima.esprimaStrings.ForInStatement = js.native
    inline def ForInStatement_=(x: ForInStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ForInStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ForOfStatement")
    @js.native
    def ForOfStatement: typings.esprima.esprimaStrings.ForOfStatement = js.native
    inline def ForOfStatement_=(x: ForOfStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ForOfStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ForStatement")
    @js.native
    def ForStatement: typings.esprima.esprimaStrings.ForStatement = js.native
    inline def ForStatement_=(x: ForStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ForStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.FunctionDeclaration")
    @js.native
    def FunctionDeclaration: typings.esprima.esprimaStrings.FunctionDeclaration = js.native
    inline def FunctionDeclaration_=(x: FunctionDeclaration): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FunctionDeclaration")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.FunctionExpression")
    @js.native
    def FunctionExpression: typings.esprima.esprimaStrings.FunctionExpression = js.native
    inline def FunctionExpression_=(x: FunctionExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FunctionExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.Identifier")
    @js.native
    def Identifier: typings.esprima.esprimaStrings.Identifier = js.native
    inline def Identifier_=(x: Identifier): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("Identifier")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.IfStatement")
    @js.native
    def IfStatement: typings.esprima.esprimaStrings.IfStatement = js.native
    inline def IfStatement_=(x: IfStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("IfStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.Import")
    @js.native
    def Import: typings.esprima.esprimaStrings.Import = js.native
    
    @JSImport("esprima", "Syntax.ImportDeclaration")
    @js.native
    def ImportDeclaration: typings.esprima.esprimaStrings.ImportDeclaration = js.native
    inline def ImportDeclaration_=(x: ImportDeclaration): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ImportDeclaration")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ImportDefaultSpecifier")
    @js.native
    def ImportDefaultSpecifier: typings.esprima.esprimaStrings.ImportDefaultSpecifier = js.native
    inline def ImportDefaultSpecifier_=(x: ImportDefaultSpecifier): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ImportDefaultSpecifier")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ImportNamespaceSpecifier")
    @js.native
    def ImportNamespaceSpecifier: typings.esprima.esprimaStrings.ImportNamespaceSpecifier = js.native
    inline def ImportNamespaceSpecifier_=(x: ImportNamespaceSpecifier): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ImportNamespaceSpecifier")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ImportSpecifier")
    @js.native
    def ImportSpecifier: typings.esprima.esprimaStrings.ImportSpecifier = js.native
    inline def ImportSpecifier_=(x: ImportSpecifier): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ImportSpecifier")(x.asInstanceOf[js.Any])
    
    inline def Import_=(x: Import): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("Import")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.LabeledStatement")
    @js.native
    def LabeledStatement: typings.esprima.esprimaStrings.LabeledStatement = js.native
    inline def LabeledStatement_=(x: LabeledStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("LabeledStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.Literal")
    @js.native
    def Literal: typings.esprima.esprimaStrings.Literal = js.native
    inline def Literal_=(x: Literal): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("Literal")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.LogicalExpression")
    @js.native
    def LogicalExpression: typings.esprima.esprimaStrings.LogicalExpression = js.native
    inline def LogicalExpression_=(x: LogicalExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("LogicalExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.MemberExpression")
    @js.native
    def MemberExpression: typings.esprima.esprimaStrings.MemberExpression = js.native
    inline def MemberExpression_=(x: MemberExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MemberExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.MetaProperty")
    @js.native
    def MetaProperty: typings.esprima.esprimaStrings.MetaProperty = js.native
    inline def MetaProperty_=(x: MetaProperty): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MetaProperty")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.MethodDefinition")
    @js.native
    def MethodDefinition: typings.esprima.esprimaStrings.MethodDefinition = js.native
    inline def MethodDefinition_=(x: MethodDefinition): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MethodDefinition")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.NewExpression")
    @js.native
    def NewExpression: typings.esprima.esprimaStrings.NewExpression = js.native
    inline def NewExpression_=(x: NewExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NewExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ObjectExpression")
    @js.native
    def ObjectExpression: typings.esprima.esprimaStrings.ObjectExpression = js.native
    inline def ObjectExpression_=(x: ObjectExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ObjectExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ObjectPattern")
    @js.native
    def ObjectPattern: typings.esprima.esprimaStrings.ObjectPattern = js.native
    inline def ObjectPattern_=(x: ObjectPattern): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ObjectPattern")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.Program")
    @js.native
    def Program: typings.esprima.esprimaStrings.Program = js.native
    inline def Program_=(x: typings.esprima.esprimaStrings.Program): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("Program")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.Property")
    @js.native
    def Property: typings.esprima.esprimaStrings.Property = js.native
    inline def Property_=(x: Property): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("Property")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.RestElement")
    @js.native
    def RestElement: typings.esprima.esprimaStrings.RestElement = js.native
    inline def RestElement_=(x: RestElement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("RestElement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ReturnStatement")
    @js.native
    def ReturnStatement: typings.esprima.esprimaStrings.ReturnStatement = js.native
    inline def ReturnStatement_=(x: ReturnStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ReturnStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.SequenceExpression")
    @js.native
    def SequenceExpression: typings.esprima.esprimaStrings.SequenceExpression = js.native
    inline def SequenceExpression_=(x: SequenceExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SequenceExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.SpreadElement")
    @js.native
    def SpreadElement: typings.esprima.esprimaStrings.SpreadElement = js.native
    inline def SpreadElement_=(x: SpreadElement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SpreadElement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.Super")
    @js.native
    def Super: typings.esprima.esprimaStrings.Super = js.native
    inline def Super_=(x: Super): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("Super")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.SwitchCase")
    @js.native
    def SwitchCase: typings.esprima.esprimaStrings.SwitchCase = js.native
    inline def SwitchCase_=(x: SwitchCase): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SwitchCase")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.SwitchStatement")
    @js.native
    def SwitchStatement: typings.esprima.esprimaStrings.SwitchStatement = js.native
    inline def SwitchStatement_=(x: SwitchStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SwitchStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.TaggedTemplateExpression")
    @js.native
    def TaggedTemplateExpression: typings.esprima.esprimaStrings.TaggedTemplateExpression = js.native
    inline def TaggedTemplateExpression_=(x: TaggedTemplateExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("TaggedTemplateExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.TemplateElement")
    @js.native
    def TemplateElement: typings.esprima.esprimaStrings.TemplateElement = js.native
    inline def TemplateElement_=(x: TemplateElement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("TemplateElement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.TemplateLiteral")
    @js.native
    def TemplateLiteral: typings.esprima.esprimaStrings.TemplateLiteral = js.native
    inline def TemplateLiteral_=(x: TemplateLiteral): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("TemplateLiteral")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ThisExpression")
    @js.native
    def ThisExpression: typings.esprima.esprimaStrings.ThisExpression = js.native
    inline def ThisExpression_=(x: ThisExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ThisExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ThrowStatement")
    @js.native
    def ThrowStatement: typings.esprima.esprimaStrings.ThrowStatement = js.native
    inline def ThrowStatement_=(x: ThrowStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ThrowStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.TryStatement")
    @js.native
    def TryStatement: typings.esprima.esprimaStrings.TryStatement = js.native
    inline def TryStatement_=(x: TryStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("TryStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.UnaryExpression")
    @js.native
    def UnaryExpression: typings.esprima.esprimaStrings.UnaryExpression = js.native
    inline def UnaryExpression_=(x: UnaryExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("UnaryExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.UpdateExpression")
    @js.native
    def UpdateExpression: typings.esprima.esprimaStrings.UpdateExpression = js.native
    inline def UpdateExpression_=(x: UpdateExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("UpdateExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.VariableDeclaration")
    @js.native
    def VariableDeclaration: typings.esprima.esprimaStrings.VariableDeclaration = js.native
    inline def VariableDeclaration_=(x: VariableDeclaration): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("VariableDeclaration")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.VariableDeclarator")
    @js.native
    def VariableDeclarator: typings.esprima.esprimaStrings.VariableDeclarator = js.native
    inline def VariableDeclarator_=(x: VariableDeclarator): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("VariableDeclarator")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.WhileStatement")
    @js.native
    def WhileStatement: typings.esprima.esprimaStrings.WhileStatement = js.native
    inline def WhileStatement_=(x: WhileStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("WhileStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.WithStatement")
    @js.native
    def WithStatement: typings.esprima.esprimaStrings.WithStatement = js.native
    inline def WithStatement_=(x: WithStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("WithStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.YieldExpression")
    @js.native
    def YieldExpression: typings.esprima.esprimaStrings.YieldExpression = js.native
    inline def YieldExpression_=(x: YieldExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("YieldExpression")(x.asInstanceOf[js.Any])
  }
  
  inline def parseModule(input: String): Program = ^.asInstanceOf[js.Dynamic].applyDynamic("parseModule")(input.asInstanceOf[js.Any]).asInstanceOf[Program]
  inline def parseModule(input: String, config: Unit, delegate: js.Function2[/* node */ Node, /* meta */ Any, Unit]): Program = (^.asInstanceOf[js.Dynamic].applyDynamic("parseModule")(input.asInstanceOf[js.Any], config.asInstanceOf[js.Any], delegate.asInstanceOf[js.Any])).asInstanceOf[Program]
  inline def parseModule(input: String, config: ParseOptions): Program = (^.asInstanceOf[js.Dynamic].applyDynamic("parseModule")(input.asInstanceOf[js.Any], config.asInstanceOf[js.Any])).asInstanceOf[Program]
  inline def parseModule(input: String, config: ParseOptions, delegate: js.Function2[/* node */ Node, /* meta */ Any, Unit]): Program = (^.asInstanceOf[js.Dynamic].applyDynamic("parseModule")(input.asInstanceOf[js.Any], config.asInstanceOf[js.Any], delegate.asInstanceOf[js.Any])).asInstanceOf[Program]
  
  inline def parseScript(input: String): Program = ^.asInstanceOf[js.Dynamic].applyDynamic("parseScript")(input.asInstanceOf[js.Any]).asInstanceOf[Program]
  inline def parseScript(input: String, config: Unit, delegate: js.Function2[/* node */ Node, /* meta */ Any, Unit]): Program = (^.asInstanceOf[js.Dynamic].applyDynamic("parseScript")(input.asInstanceOf[js.Any], config.asInstanceOf[js.Any], delegate.asInstanceOf[js.Any])).asInstanceOf[Program]
  inline def parseScript(input: String, config: ParseOptions): Program = (^.asInstanceOf[js.Dynamic].applyDynamic("parseScript")(input.asInstanceOf[js.Any], config.asInstanceOf[js.Any])).asInstanceOf[Program]
  inline def parseScript(input: String, config: ParseOptions, delegate: js.Function2[/* node */ Node, /* meta */ Any, Unit]): Program = (^.asInstanceOf[js.Dynamic].applyDynamic("parseScript")(input.asInstanceOf[js.Any], config.asInstanceOf[js.Any], delegate.asInstanceOf[js.Any])).asInstanceOf[Program]
  
  inline def tokenize(input: String): js.Array[Token] = ^.asInstanceOf[js.Dynamic].applyDynamic("tokenize")(input.asInstanceOf[js.Any]).asInstanceOf[js.Array[Token]]
  inline def tokenize(input: String, config: TokenizeOptions): js.Array[Token] = (^.asInstanceOf[js.Dynamic].applyDynamic("tokenize")(input.asInstanceOf[js.Any], config.asInstanceOf[js.Any])).asInstanceOf[js.Array[Token]]
  
  @JSImport("esprima", "version")
  @js.native
  val version: String = js.native
  
  trait ParseOptions extends StObject {
    
    var comment: js.UndefOr[Boolean] = js.undefined
    
    var jsx: js.UndefOr[Boolean] = js.undefined
    
    var loc: js.UndefOr[Boolean] = js.undefined
    
    var range: js.UndefOr[Boolean] = js.undefined
    
    var tokens: js.UndefOr[Boolean] = js.undefined
    
    var tolerant: js.UndefOr[Boolean] = js.undefined
  }
  object ParseOptions {
    
    inline def apply(): ParseOptions = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[ParseOptions]
    }
    
    extension [Self <: ParseOptions](x: Self) {
      
      inline def setComment(value: Boolean): Self = StObject.set(x, "comment", value.asInstanceOf[js.Any])
      
      inline def setCommentUndefined: Self = StObject.set(x, "comment", js.undefined)
      
      inline def setJsx(value: Boolean): Self = StObject.set(x, "jsx", value.asInstanceOf[js.Any])
      
      inline def setJsxUndefined: Self = StObject.set(x, "jsx", js.undefined)
      
      inline def setLoc(value: Boolean): Self = StObject.set(x, "loc", value.asInstanceOf[js.Any])
      
      inline def setLocUndefined: Self = StObject.set(x, "loc", js.undefined)
      
      inline def setRange(value: Boolean): Self = StObject.set(x, "range", value.asInstanceOf[js.Any])
      
      inline def setRangeUndefined: Self = StObject.set(x, "range", js.undefined)
      
      inline def setTokens(value: Boolean): Self = StObject.set(x, "tokens", value.asInstanceOf[js.Any])
      
      inline def setTokensUndefined: Self = StObject.set(x, "tokens", js.undefined)
      
      inline def setTolerant(value: Boolean): Self = StObject.set(x, "tolerant", value.asInstanceOf[js.Any])
      
      inline def setTolerantUndefined: Self = StObject.set(x, "tolerant", js.undefined)
    }
  }
  
  trait Program
    extends StObject
       with typings.estree.mod.Program {
    
    var tokens: js.UndefOr[js.Array[Token]] = js.undefined
  }
  object Program {
    
    inline def apply(body: js.Array[Directive | Statement | ModuleDeclaration], sourceType: script | module): Program = {
      val __obj = js.Dynamic.literal(body = body.asInstanceOf[js.Any], sourceType = sourceType.asInstanceOf[js.Any])
      __obj.updateDynamic("type")("Program")
      __obj.asInstanceOf[Program]
    }
    
    extension [Self <: Program](x: Self) {
      
      inline def setTokens(value: js.Array[Token]): Self = StObject.set(x, "tokens", value.asInstanceOf[js.Any])
      
      inline def setTokensUndefined: Self = StObject.set(x, "tokens", js.undefined)
      
      inline def setTokensVarargs(value: Token*): Self = StObject.set(x, "tokens", js.Array(value*))
    }
  }
  
  trait Token extends StObject {
    
    var `type`: String
    
    var value: String
  }
  object Token {
    
    inline def apply(`type`: String, value: String): Token = {
      val __obj = js.Dynamic.literal(value = value.asInstanceOf[js.Any])
      __obj.updateDynamic("type")(`type`.asInstanceOf[js.Any])
      __obj.asInstanceOf[Token]
    }
    
    extension [Self <: Token](x: Self) {
      
      inline def setType(value: String): Self = StObject.set(x, "type", value.asInstanceOf[js.Any])
      
      inline def setValue(value: String): Self = StObject.set(x, "value", value.asInstanceOf[js.Any])
    }
  }
  
  trait TokenizeOptions extends StObject {
    
    var comment: js.UndefOr[Boolean] = js.undefined
    
    var loc: js.UndefOr[Boolean] = js.undefined
    
    var range: js.UndefOr[Boolean] = js.undefined
    
    var tolerant: js.UndefOr[Boolean] = js.undefined
  }
  object TokenizeOptions {
    
    inline def apply(): TokenizeOptions = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[TokenizeOptions]
    }
    
    extension [Self <: TokenizeOptions](x: Self) {
      
      inline def setComment(value: Boolean): Self = StObject.set(x, "comment", value.asInstanceOf[js.Any])
      
      inline def setCommentUndefined: Self = StObject.set(x, "comment", js.undefined)
      
      inline def setLoc(value: Boolean): Self = StObject.set(x, "loc", value.asInstanceOf[js.Any])
      
      inline def setLocUndefined: Self = StObject.set(x, "loc", js.undefined)
      
      inline def setRange(value: Boolean): Self = StObject.set(x, "range", value.asInstanceOf[js.Any])
      
      inline def setRangeUndefined: Self = StObject.set(x, "range", js.undefined)
      
      inline def setTolerant(value: Boolean): Self = StObject.set(x, "tolerant", value.asInstanceOf[js.Any])
      
      inline def setTolerantUndefined: Self = StObject.set(x, "tolerant", js.undefined)
    }
  }
}
