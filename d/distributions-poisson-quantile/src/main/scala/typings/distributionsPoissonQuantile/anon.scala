package typings.distributionsPoissonQuantile

import typings.distributionsPoissonQuantile.mod.Data
import typings.distributionsPoissonQuantile.mod.DataType
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object anon {
  
  /* Inlined distributions-poisson-quantile.distributions-poisson-quantile.Options & {  dtype :'float32'} */
  trait Optionsdtypefloat32 extends StObject {
    
    /** accessor function for accessing array values */
    var accessor: js.UndefOr[js.Function2[/* d */ Data, /* i */ Double, Any]] = js.undefined
    
    /** boolean indicating if the function should return a new data structure, default=true */
    var copy: js.UndefOr[Boolean] = js.undefined
    
    /** output data type, default="float64" */
    var dtype: js.UndefOr[DataType] = js.undefined
    
    /** mean parameter, default=1 */
    var lambda: js.UndefOr[Double] = js.undefined
    
    /** deep get/set key path */
    var path: js.UndefOr[String] = js.undefined
    
    /** deep get/set key path separator, default="." */
    var sep: js.UndefOr[String] = js.undefined
  }
  object Optionsdtypefloat32 {
    
    inline def apply(): Optionsdtypefloat32 = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[Optionsdtypefloat32]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: Optionsdtypefloat32] (val x: Self) extends AnyVal {
      
      inline def setAccessor(value: (/* d */ Data, /* i */ Double) => Any): Self = StObject.set(x, "accessor", js.Any.fromFunction2(value))
      
      inline def setAccessorUndefined: Self = StObject.set(x, "accessor", js.undefined)
      
      inline def setCopy(value: Boolean): Self = StObject.set(x, "copy", value.asInstanceOf[js.Any])
      
      inline def setCopyUndefined: Self = StObject.set(x, "copy", js.undefined)
      
      inline def setDtype(value: DataType): Self = StObject.set(x, "dtype", value.asInstanceOf[js.Any])
      
      inline def setDtypeUndefined: Self = StObject.set(x, "dtype", js.undefined)
      
      inline def setLambda(value: Double): Self = StObject.set(x, "lambda", value.asInstanceOf[js.Any])
      
      inline def setLambdaUndefined: Self = StObject.set(x, "lambda", js.undefined)
      
      inline def setPath(value: String): Self = StObject.set(x, "path", value.asInstanceOf[js.Any])
      
      inline def setPathUndefined: Self = StObject.set(x, "path", js.undefined)
      
      inline def setSep(value: String): Self = StObject.set(x, "sep", value.asInstanceOf[js.Any])
      
      inline def setSepUndefined: Self = StObject.set(x, "sep", js.undefined)
    }
  }
  
  /* Inlined distributions-poisson-quantile.distributions-poisson-quantile.Options & {  dtype :'float64' | undefined} */
  trait Optionsdtypefloat64undefi extends StObject {
    
    /** accessor function for accessing array values */
    var accessor: js.UndefOr[js.Function2[/* d */ Data, /* i */ Double, Any]] = js.undefined
    
    /** boolean indicating if the function should return a new data structure, default=true */
    var copy: js.UndefOr[Boolean] = js.undefined
    
    /** output data type, default="float64" */
    var dtype: js.UndefOr[DataType] = js.undefined
    
    /** mean parameter, default=1 */
    var lambda: js.UndefOr[Double] = js.undefined
    
    /** deep get/set key path */
    var path: js.UndefOr[String] = js.undefined
    
    /** deep get/set key path separator, default="." */
    var sep: js.UndefOr[String] = js.undefined
  }
  object Optionsdtypefloat64undefi {
    
    inline def apply(): Optionsdtypefloat64undefi = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[Optionsdtypefloat64undefi]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: Optionsdtypefloat64undefi] (val x: Self) extends AnyVal {
      
      inline def setAccessor(value: (/* d */ Data, /* i */ Double) => Any): Self = StObject.set(x, "accessor", js.Any.fromFunction2(value))
      
      inline def setAccessorUndefined: Self = StObject.set(x, "accessor", js.undefined)
      
      inline def setCopy(value: Boolean): Self = StObject.set(x, "copy", value.asInstanceOf[js.Any])
      
      inline def setCopyUndefined: Self = StObject.set(x, "copy", js.undefined)
      
      inline def setDtype(value: DataType): Self = StObject.set(x, "dtype", value.asInstanceOf[js.Any])
      
      inline def setDtypeUndefined: Self = StObject.set(x, "dtype", js.undefined)
      
      inline def setLambda(value: Double): Self = StObject.set(x, "lambda", value.asInstanceOf[js.Any])
      
      inline def setLambdaUndefined: Self = StObject.set(x, "lambda", js.undefined)
      
      inline def setPath(value: String): Self = StObject.set(x, "path", value.asInstanceOf[js.Any])
      
      inline def setPathUndefined: Self = StObject.set(x, "path", js.undefined)
      
      inline def setSep(value: String): Self = StObject.set(x, "sep", value.asInstanceOf[js.Any])
      
      inline def setSepUndefined: Self = StObject.set(x, "sep", js.undefined)
    }
  }
  
  /* Inlined distributions-poisson-quantile.distributions-poisson-quantile.Options & {  dtype :'int16'} */
  trait Optionsdtypeint16 extends StObject {
    
    /** accessor function for accessing array values */
    var accessor: js.UndefOr[js.Function2[/* d */ Data, /* i */ Double, Any]] = js.undefined
    
    /** boolean indicating if the function should return a new data structure, default=true */
    var copy: js.UndefOr[Boolean] = js.undefined
    
    /** output data type, default="float64" */
    var dtype: js.UndefOr[DataType] = js.undefined
    
    /** mean parameter, default=1 */
    var lambda: js.UndefOr[Double] = js.undefined
    
    /** deep get/set key path */
    var path: js.UndefOr[String] = js.undefined
    
    /** deep get/set key path separator, default="." */
    var sep: js.UndefOr[String] = js.undefined
  }
  object Optionsdtypeint16 {
    
    inline def apply(): Optionsdtypeint16 = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[Optionsdtypeint16]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: Optionsdtypeint16] (val x: Self) extends AnyVal {
      
      inline def setAccessor(value: (/* d */ Data, /* i */ Double) => Any): Self = StObject.set(x, "accessor", js.Any.fromFunction2(value))
      
      inline def setAccessorUndefined: Self = StObject.set(x, "accessor", js.undefined)
      
      inline def setCopy(value: Boolean): Self = StObject.set(x, "copy", value.asInstanceOf[js.Any])
      
      inline def setCopyUndefined: Self = StObject.set(x, "copy", js.undefined)
      
      inline def setDtype(value: DataType): Self = StObject.set(x, "dtype", value.asInstanceOf[js.Any])
      
      inline def setDtypeUndefined: Self = StObject.set(x, "dtype", js.undefined)
      
      inline def setLambda(value: Double): Self = StObject.set(x, "lambda", value.asInstanceOf[js.Any])
      
      inline def setLambdaUndefined: Self = StObject.set(x, "lambda", js.undefined)
      
      inline def setPath(value: String): Self = StObject.set(x, "path", value.asInstanceOf[js.Any])
      
      inline def setPathUndefined: Self = StObject.set(x, "path", js.undefined)
      
      inline def setSep(value: String): Self = StObject.set(x, "sep", value.asInstanceOf[js.Any])
      
      inline def setSepUndefined: Self = StObject.set(x, "sep", js.undefined)
    }
  }
  
  /* Inlined distributions-poisson-quantile.distributions-poisson-quantile.Options & {  dtype :'int32'} */
  trait Optionsdtypeint32 extends StObject {
    
    /** accessor function for accessing array values */
    var accessor: js.UndefOr[js.Function2[/* d */ Data, /* i */ Double, Any]] = js.undefined
    
    /** boolean indicating if the function should return a new data structure, default=true */
    var copy: js.UndefOr[Boolean] = js.undefined
    
    /** output data type, default="float64" */
    var dtype: js.UndefOr[DataType] = js.undefined
    
    /** mean parameter, default=1 */
    var lambda: js.UndefOr[Double] = js.undefined
    
    /** deep get/set key path */
    var path: js.UndefOr[String] = js.undefined
    
    /** deep get/set key path separator, default="." */
    var sep: js.UndefOr[String] = js.undefined
  }
  object Optionsdtypeint32 {
    
    inline def apply(): Optionsdtypeint32 = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[Optionsdtypeint32]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: Optionsdtypeint32] (val x: Self) extends AnyVal {
      
      inline def setAccessor(value: (/* d */ Data, /* i */ Double) => Any): Self = StObject.set(x, "accessor", js.Any.fromFunction2(value))
      
      inline def setAccessorUndefined: Self = StObject.set(x, "accessor", js.undefined)
      
      inline def setCopy(value: Boolean): Self = StObject.set(x, "copy", value.asInstanceOf[js.Any])
      
      inline def setCopyUndefined: Self = StObject.set(x, "copy", js.undefined)
      
      inline def setDtype(value: DataType): Self = StObject.set(x, "dtype", value.asInstanceOf[js.Any])
      
      inline def setDtypeUndefined: Self = StObject.set(x, "dtype", js.undefined)
      
      inline def setLambda(value: Double): Self = StObject.set(x, "lambda", value.asInstanceOf[js.Any])
      
      inline def setLambdaUndefined: Self = StObject.set(x, "lambda", js.undefined)
      
      inline def setPath(value: String): Self = StObject.set(x, "path", value.asInstanceOf[js.Any])
      
      inline def setPathUndefined: Self = StObject.set(x, "path", js.undefined)
      
      inline def setSep(value: String): Self = StObject.set(x, "sep", value.asInstanceOf[js.Any])
      
      inline def setSepUndefined: Self = StObject.set(x, "sep", js.undefined)
    }
  }
  
  /* Inlined distributions-poisson-quantile.distributions-poisson-quantile.Options & {  dtype :'int8'} */
  trait Optionsdtypeint8 extends StObject {
    
    /** accessor function for accessing array values */
    var accessor: js.UndefOr[js.Function2[/* d */ Data, /* i */ Double, Any]] = js.undefined
    
    /** boolean indicating if the function should return a new data structure, default=true */
    var copy: js.UndefOr[Boolean] = js.undefined
    
    /** output data type, default="float64" */
    var dtype: js.UndefOr[DataType] = js.undefined
    
    /** mean parameter, default=1 */
    var lambda: js.UndefOr[Double] = js.undefined
    
    /** deep get/set key path */
    var path: js.UndefOr[String] = js.undefined
    
    /** deep get/set key path separator, default="." */
    var sep: js.UndefOr[String] = js.undefined
  }
  object Optionsdtypeint8 {
    
    inline def apply(): Optionsdtypeint8 = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[Optionsdtypeint8]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: Optionsdtypeint8] (val x: Self) extends AnyVal {
      
      inline def setAccessor(value: (/* d */ Data, /* i */ Double) => Any): Self = StObject.set(x, "accessor", js.Any.fromFunction2(value))
      
      inline def setAccessorUndefined: Self = StObject.set(x, "accessor", js.undefined)
      
      inline def setCopy(value: Boolean): Self = StObject.set(x, "copy", value.asInstanceOf[js.Any])
      
      inline def setCopyUndefined: Self = StObject.set(x, "copy", js.undefined)
      
      inline def setDtype(value: DataType): Self = StObject.set(x, "dtype", value.asInstanceOf[js.Any])
      
      inline def setDtypeUndefined: Self = StObject.set(x, "dtype", js.undefined)
      
      inline def setLambda(value: Double): Self = StObject.set(x, "lambda", value.asInstanceOf[js.Any])
      
      inline def setLambdaUndefined: Self = StObject.set(x, "lambda", js.undefined)
      
      inline def setPath(value: String): Self = StObject.set(x, "path", value.asInstanceOf[js.Any])
      
      inline def setPathUndefined: Self = StObject.set(x, "path", js.undefined)
      
      inline def setSep(value: String): Self = StObject.set(x, "sep", value.asInstanceOf[js.Any])
      
      inline def setSepUndefined: Self = StObject.set(x, "sep", js.undefined)
    }
  }
  
  /* Inlined distributions-poisson-quantile.distributions-poisson-quantile.Options & {  dtype :'uint16'} */
  trait Optionsdtypeuint16 extends StObject {
    
    /** accessor function for accessing array values */
    var accessor: js.UndefOr[js.Function2[/* d */ Data, /* i */ Double, Any]] = js.undefined
    
    /** boolean indicating if the function should return a new data structure, default=true */
    var copy: js.UndefOr[Boolean] = js.undefined
    
    /** output data type, default="float64" */
    var dtype: js.UndefOr[DataType] = js.undefined
    
    /** mean parameter, default=1 */
    var lambda: js.UndefOr[Double] = js.undefined
    
    /** deep get/set key path */
    var path: js.UndefOr[String] = js.undefined
    
    /** deep get/set key path separator, default="." */
    var sep: js.UndefOr[String] = js.undefined
  }
  object Optionsdtypeuint16 {
    
    inline def apply(): Optionsdtypeuint16 = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[Optionsdtypeuint16]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: Optionsdtypeuint16] (val x: Self) extends AnyVal {
      
      inline def setAccessor(value: (/* d */ Data, /* i */ Double) => Any): Self = StObject.set(x, "accessor", js.Any.fromFunction2(value))
      
      inline def setAccessorUndefined: Self = StObject.set(x, "accessor", js.undefined)
      
      inline def setCopy(value: Boolean): Self = StObject.set(x, "copy", value.asInstanceOf[js.Any])
      
      inline def setCopyUndefined: Self = StObject.set(x, "copy", js.undefined)
      
      inline def setDtype(value: DataType): Self = StObject.set(x, "dtype", value.asInstanceOf[js.Any])
      
      inline def setDtypeUndefined: Self = StObject.set(x, "dtype", js.undefined)
      
      inline def setLambda(value: Double): Self = StObject.set(x, "lambda", value.asInstanceOf[js.Any])
      
      inline def setLambdaUndefined: Self = StObject.set(x, "lambda", js.undefined)
      
      inline def setPath(value: String): Self = StObject.set(x, "path", value.asInstanceOf[js.Any])
      
      inline def setPathUndefined: Self = StObject.set(x, "path", js.undefined)
      
      inline def setSep(value: String): Self = StObject.set(x, "sep", value.asInstanceOf[js.Any])
      
      inline def setSepUndefined: Self = StObject.set(x, "sep", js.undefined)
    }
  }
  
  /* Inlined distributions-poisson-quantile.distributions-poisson-quantile.Options & {  dtype :'uint32'} */
  trait Optionsdtypeuint32 extends StObject {
    
    /** accessor function for accessing array values */
    var accessor: js.UndefOr[js.Function2[/* d */ Data, /* i */ Double, Any]] = js.undefined
    
    /** boolean indicating if the function should return a new data structure, default=true */
    var copy: js.UndefOr[Boolean] = js.undefined
    
    /** output data type, default="float64" */
    var dtype: js.UndefOr[DataType] = js.undefined
    
    /** mean parameter, default=1 */
    var lambda: js.UndefOr[Double] = js.undefined
    
    /** deep get/set key path */
    var path: js.UndefOr[String] = js.undefined
    
    /** deep get/set key path separator, default="." */
    var sep: js.UndefOr[String] = js.undefined
  }
  object Optionsdtypeuint32 {
    
    inline def apply(): Optionsdtypeuint32 = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[Optionsdtypeuint32]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: Optionsdtypeuint32] (val x: Self) extends AnyVal {
      
      inline def setAccessor(value: (/* d */ Data, /* i */ Double) => Any): Self = StObject.set(x, "accessor", js.Any.fromFunction2(value))
      
      inline def setAccessorUndefined: Self = StObject.set(x, "accessor", js.undefined)
      
      inline def setCopy(value: Boolean): Self = StObject.set(x, "copy", value.asInstanceOf[js.Any])
      
      inline def setCopyUndefined: Self = StObject.set(x, "copy", js.undefined)
      
      inline def setDtype(value: DataType): Self = StObject.set(x, "dtype", value.asInstanceOf[js.Any])
      
      inline def setDtypeUndefined: Self = StObject.set(x, "dtype", js.undefined)
      
      inline def setLambda(value: Double): Self = StObject.set(x, "lambda", value.asInstanceOf[js.Any])
      
      inline def setLambdaUndefined: Self = StObject.set(x, "lambda", js.undefined)
      
      inline def setPath(value: String): Self = StObject.set(x, "path", value.asInstanceOf[js.Any])
      
      inline def setPathUndefined: Self = StObject.set(x, "path", js.undefined)
      
      inline def setSep(value: String): Self = StObject.set(x, "sep", value.asInstanceOf[js.Any])
      
      inline def setSepUndefined: Self = StObject.set(x, "sep", js.undefined)
    }
  }
  
  /* Inlined distributions-poisson-quantile.distributions-poisson-quantile.Options & {  dtype :'uint8'} */
  trait Optionsdtypeuint8 extends StObject {
    
    /** accessor function for accessing array values */
    var accessor: js.UndefOr[js.Function2[/* d */ Data, /* i */ Double, Any]] = js.undefined
    
    /** boolean indicating if the function should return a new data structure, default=true */
    var copy: js.UndefOr[Boolean] = js.undefined
    
    /** output data type, default="float64" */
    var dtype: js.UndefOr[DataType] = js.undefined
    
    /** mean parameter, default=1 */
    var lambda: js.UndefOr[Double] = js.undefined
    
    /** deep get/set key path */
    var path: js.UndefOr[String] = js.undefined
    
    /** deep get/set key path separator, default="." */
    var sep: js.UndefOr[String] = js.undefined
  }
  object Optionsdtypeuint8 {
    
    inline def apply(): Optionsdtypeuint8 = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[Optionsdtypeuint8]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: Optionsdtypeuint8] (val x: Self) extends AnyVal {
      
      inline def setAccessor(value: (/* d */ Data, /* i */ Double) => Any): Self = StObject.set(x, "accessor", js.Any.fromFunction2(value))
      
      inline def setAccessorUndefined: Self = StObject.set(x, "accessor", js.undefined)
      
      inline def setCopy(value: Boolean): Self = StObject.set(x, "copy", value.asInstanceOf[js.Any])
      
      inline def setCopyUndefined: Self = StObject.set(x, "copy", js.undefined)
      
      inline def setDtype(value: DataType): Self = StObject.set(x, "dtype", value.asInstanceOf[js.Any])
      
      inline def setDtypeUndefined: Self = StObject.set(x, "dtype", js.undefined)
      
      inline def setLambda(value: Double): Self = StObject.set(x, "lambda", value.asInstanceOf[js.Any])
      
      inline def setLambdaUndefined: Self = StObject.set(x, "lambda", js.undefined)
      
      inline def setPath(value: String): Self = StObject.set(x, "path", value.asInstanceOf[js.Any])
      
      inline def setPathUndefined: Self = StObject.set(x, "path", js.undefined)
      
      inline def setSep(value: String): Self = StObject.set(x, "sep", value.asInstanceOf[js.Any])
      
      inline def setSepUndefined: Self = StObject.set(x, "sep", js.undefined)
    }
  }
  
  /* Inlined distributions-poisson-quantile.distributions-poisson-quantile.Options & {  dtype :'uint8_clamped'} */
  trait Optionsdtypeuint8clamped extends StObject {
    
    /** accessor function for accessing array values */
    var accessor: js.UndefOr[js.Function2[/* d */ Data, /* i */ Double, Any]] = js.undefined
    
    /** boolean indicating if the function should return a new data structure, default=true */
    var copy: js.UndefOr[Boolean] = js.undefined
    
    /** output data type, default="float64" */
    var dtype: js.UndefOr[DataType] = js.undefined
    
    /** mean parameter, default=1 */
    var lambda: js.UndefOr[Double] = js.undefined
    
    /** deep get/set key path */
    var path: js.UndefOr[String] = js.undefined
    
    /** deep get/set key path separator, default="." */
    var sep: js.UndefOr[String] = js.undefined
  }
  object Optionsdtypeuint8clamped {
    
    inline def apply(): Optionsdtypeuint8clamped = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[Optionsdtypeuint8clamped]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: Optionsdtypeuint8clamped] (val x: Self) extends AnyVal {
      
      inline def setAccessor(value: (/* d */ Data, /* i */ Double) => Any): Self = StObject.set(x, "accessor", js.Any.fromFunction2(value))
      
      inline def setAccessorUndefined: Self = StObject.set(x, "accessor", js.undefined)
      
      inline def setCopy(value: Boolean): Self = StObject.set(x, "copy", value.asInstanceOf[js.Any])
      
      inline def setCopyUndefined: Self = StObject.set(x, "copy", js.undefined)
      
      inline def setDtype(value: DataType): Self = StObject.set(x, "dtype", value.asInstanceOf[js.Any])
      
      inline def setDtypeUndefined: Self = StObject.set(x, "dtype", js.undefined)
      
      inline def setLambda(value: Double): Self = StObject.set(x, "lambda", value.asInstanceOf[js.Any])
      
      inline def setLambdaUndefined: Self = StObject.set(x, "lambda", js.undefined)
      
      inline def setPath(value: String): Self = StObject.set(x, "path", value.asInstanceOf[js.Any])
      
      inline def setPathUndefined: Self = StObject.set(x, "path", js.undefined)
      
      inline def setSep(value: String): Self = StObject.set(x, "sep", value.asInstanceOf[js.Any])
      
      inline def setSepUndefined: Self = StObject.set(x, "sep", js.undefined)
    }
  }
  
  /* Inlined distributions-poisson-quantile.distributions-poisson-quantile.Options & {  dtype :undefined} */
  trait Optionsdtypeundefined extends StObject {
    
    /** accessor function for accessing array values */
    var accessor: js.UndefOr[js.Function2[/* d */ Data, /* i */ Double, Any]] = js.undefined
    
    /** boolean indicating if the function should return a new data structure, default=true */
    var copy: js.UndefOr[Boolean] = js.undefined
    
    /** output data type, default="float64" */
    var dtype: js.UndefOr[DataType] = js.undefined
    
    /** mean parameter, default=1 */
    var lambda: js.UndefOr[Double] = js.undefined
    
    /** deep get/set key path */
    var path: js.UndefOr[String] = js.undefined
    
    /** deep get/set key path separator, default="." */
    var sep: js.UndefOr[String] = js.undefined
  }
  object Optionsdtypeundefined {
    
    inline def apply(): Optionsdtypeundefined = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[Optionsdtypeundefined]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: Optionsdtypeundefined] (val x: Self) extends AnyVal {
      
      inline def setAccessor(value: (/* d */ Data, /* i */ Double) => Any): Self = StObject.set(x, "accessor", js.Any.fromFunction2(value))
      
      inline def setAccessorUndefined: Self = StObject.set(x, "accessor", js.undefined)
      
      inline def setCopy(value: Boolean): Self = StObject.set(x, "copy", value.asInstanceOf[js.Any])
      
      inline def setCopyUndefined: Self = StObject.set(x, "copy", js.undefined)
      
      inline def setDtype(value: DataType): Self = StObject.set(x, "dtype", value.asInstanceOf[js.Any])
      
      inline def setDtypeUndefined: Self = StObject.set(x, "dtype", js.undefined)
      
      inline def setLambda(value: Double): Self = StObject.set(x, "lambda", value.asInstanceOf[js.Any])
      
      inline def setLambdaUndefined: Self = StObject.set(x, "lambda", js.undefined)
      
      inline def setPath(value: String): Self = StObject.set(x, "path", value.asInstanceOf[js.Any])
      
      inline def setPathUndefined: Self = StObject.set(x, "path", js.undefined)
      
      inline def setSep(value: String): Self = StObject.set(x, "sep", value.asInstanceOf[js.Any])
      
      inline def setSepUndefined: Self = StObject.set(x, "sep", js.undefined)
    }
  }
}
