package typings.rollupPluginTypescript2

import org.scalablytyped.runtime.Instantiable0
import typings.rollupPluginTypescript2.rollupPluginTypescript2Booleans.`false`
import typings.rollupPluginTypescript2.rollupPluginTypescript2Strings.dts
import typings.rollupPluginTypescript2.rollupPluginTypescript2Strings.js_
import typings.rollupPluginTypescript2.rollupPluginTypescript2Strings.quit
import typings.std.Map
import typings.std.NonNullable
import typings.typescript.anon.Config
import typings.typescript.anon.Errors
import typings.typescript.anon.FileExists
import typings.typescript.anon.FnCall
import typings.typescript.anon.ImpliedNodeFormat
import typings.typescript.anon.Options
import typings.typescript.mod.AccessExpression
import typings.typescript.mod.ArrayBindingElement
import typings.typescript.mod.BindingElement
import typings.typescript.mod.BindingName
import typings.typescript.mod.BuildOptions
import typings.typescript.mod.BuilderProgram
import typings.typescript.mod.BuilderProgramHost
import typings.typescript.mod.CancellationToken
import typings.typescript.mod.Classifier
import typings.typescript.mod.CommentKind
import typings.typescript.mod.CommentRange
import typings.typescript.mod.CompilerHost
import typings.typescript.mod.CompilerOptions
import typings.typescript.mod.ConciseBody
import typings.typescript.mod.CreateProgramOptions
import typings.typescript.mod.CreateProgram_
import typings.typescript.mod.CreateSourceFileOptions
import typings.typescript.mod.Declaration
import typings.typescript.mod.DeclarationName
import typings.typescript.mod.DeclarationWithTypeParameters
import typings.typescript.mod.Decorator
import typings.typescript.mod.Diagnostic
import typings.typescript.mod.DiagnosticMessageChain
import typings.typescript.mod.DiagnosticReporter
import typings.typescript.mod.DocumentRegistry
import typings.typescript.mod.EditorOptions
import typings.typescript.mod.EditorSettings
import typings.typescript.mod.EmitAndSemanticDiagnosticsBuilderProgram
import typings.typescript.mod.EmitFlags
import typings.typescript.mod.EmitHelper
import typings.typescript.mod.EntityName
import typings.typescript.mod.ErrorCallback
import typings.typescript.mod.Expression
import typings.typescript.mod.ExtendedConfigCacheEntry
import typings.typescript.mod.FileExtensionInfo
import typings.typescript.mod.FileReference
import typings.typescript.mod.FormatCodeSettings
import typings.typescript.mod.FormatDiagnosticsHost
import typings.typescript.mod.FunctionBody
import typings.typescript.mod.FunctionLikeDeclaration
import typings.typescript.mod.GetEffectiveTypeRootsHost
import typings.typescript.mod.HasDecorators
import typings.typescript.mod.HasModifiers
import typings.typescript.mod.IScriptSnapshot
import typings.typescript.mod.Identifier
import typings.typescript.mod.IncrementalProgramOptions
import typings.typescript.mod.InputFiles
import typings.typescript.mod.JSDocAugmentsTag
import typings.typescript.mod.JSDocClassTag
import typings.typescript.mod.JSDocComment
import typings.typescript.mod.JSDocDeprecatedTag
import typings.typescript.mod.JSDocEnumTag
import typings.typescript.mod.JSDocImplementsTag
import typings.typescript.mod.JSDocOverrideTag
import typings.typescript.mod.JSDocParameterTag
import typings.typescript.mod.JSDocPrivateTag
import typings.typescript.mod.JSDocProtectedTag
import typings.typescript.mod.JSDocPublicTag
import typings.typescript.mod.JSDocReadonlyTag
import typings.typescript.mod.JSDocReturnTag
import typings.typescript.mod.JSDocSatisfiesTag
import typings.typescript.mod.JSDocSignature
import typings.typescript.mod.JSDocTag
import typings.typescript.mod.JSDocTemplateTag
import typings.typescript.mod.JSDocThisTag
import typings.typescript.mod.JSDocTypeTag
import typings.typescript.mod.JSDocTypedefTag
import typings.typescript.mod.JsonSourceFile
import typings.typescript.mod.KeywordSyntaxKind
import typings.typescript.mod.LanguageService
import typings.typescript.mod.LanguageServiceHost
import typings.typescript.mod.LanguageServiceMode
import typings.typescript.mod.LanguageVariant
import typings.typescript.mod.LineAndCharacter
import typings.typescript.mod.Modifier
import typings.typescript.mod.ModifierFlags
import typings.typescript.mod.ModuleKind.CommonJS
import typings.typescript.mod.ModuleKind.ESNext
import typings.typescript.mod.ModuleResolutionCache
import typings.typescript.mod.ModuleResolutionHost
import typings.typescript.mod.Node
import typings.typescript.mod.NodeArray
import typings.typescript.mod.NodeFactory
import typings.typescript.mod.NodeFlags
import typings.typescript.mod.NodesVisitor
import typings.typescript.mod.NonRelativeModuleNameResolutionCache
import typings.typescript.mod.PackageJsonInfoCache
import typings.typescript.mod.ParameterDeclaration
import typings.typescript.mod.ParseConfigFileHost
import typings.typescript.mod.ParseConfigHost
import typings.typescript.mod.ParsedCommandLine
import typings.typescript.mod.Path
import typings.typescript.mod.PreProcessedFileInfo
import typings.typescript.mod.PrintHandlers
import typings.typescript.mod.Printer
import typings.typescript.mod.PrinterOptions
import typings.typescript.mod.PrivateIdentifier
import typings.typescript.mod.Program
import typings.typescript.mod.ProjectReference
import typings.typescript.mod.ReadBuildProgramHost
import typings.typescript.mod.ReportEmitErrorSummary
import typings.typescript.mod.ResolutionMode
import typings.typescript.mod.ResolvedConfigFileName
import typings.typescript.mod.ResolvedModuleWithFailedLookupLocations
import typings.typescript.mod.ResolvedProjectReference
import typings.typescript.mod.ResolvedTypeReferenceDirectiveWithFailedLookupLocations
import typings.typescript.mod.Scanner
import typings.typescript.mod.ScriptKind
import typings.typescript.mod.ScriptTarget
import typings.typescript.mod.SemanticDiagnosticsBuilderProgram
import typings.typescript.mod.SignatureDeclaration
import typings.typescript.mod.SolutionBuilder
import typings.typescript.mod.SolutionBuilderHost
import typings.typescript.mod.SolutionBuilderWithWatchHost
import typings.typescript.mod.SortedReadonlyArray
import typings.typescript.mod.SourceFile
import typings.typescript.mod.SourceFileLike
import typings.typescript.mod.SourceMapRange
import typings.typescript.mod.SourceMapSource
import typings.typescript.mod.Statement
import typings.typescript.mod.StringLiteralLike
import typings.typescript.mod.Symbol
import typings.typescript.mod.SymbolDisplayPart
import typings.typescript.mod.SyntaxKind
import typings.typescript.mod.SyntaxKind.MultiLineCommentTrivia
import typings.typescript.mod.SyntaxKind.SingleLineCommentTrivia
import typings.typescript.mod.SynthesizedComment
import typings.typescript.mod.System
import typings.typescript.mod.TextChangeRange
import typings.typescript.mod.TextRange
import typings.typescript.mod.TextSpan
import typings.typescript.mod.TransformationContext
import typings.typescript.mod.TransformationResult
import typings.typescript.mod.TransformerFactory
import typings.typescript.mod.TranspileOptions
import typings.typescript.mod.TranspileOutput
import typings.typescript.mod.TsConfigSourceFile
import typings.typescript.mod.TypeNode
import typings.typescript.mod.TypeParameterDeclaration
import typings.typescript.mod.TypeReferenceDirectiveResolutionCache
import typings.typescript.mod.UnparsedSource
import typings.typescript.mod.VariableDeclaration
import typings.typescript.mod.Visitor
import typings.typescript.mod.WatchCompilerHostOfConfigFile
import typings.typescript.mod.WatchCompilerHostOfFilesAndCompilerOptions
import typings.typescript.mod.WatchOfConfigFile
import typings.typescript.mod.WatchOfFilesAndCompilerOptions
import typings.typescript.mod.WatchOptions
import typings.typescript.mod.WatchStatusReporter
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object anon {
  
  trait FileName extends StObject {
    
    var fileName: js.UndefOr[String] = js.undefined
    
    var parsedTsConfig: ParsedCommandLine
  }
  object FileName {
    
    inline def apply(parsedTsConfig: ParsedCommandLine): FileName = {
      val __obj = js.Dynamic.literal(parsedTsConfig = parsedTsConfig.asInstanceOf[js.Any])
      __obj.asInstanceOf[FileName]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: FileName] (val x: Self) extends AnyVal {
      
      inline def setFileName(value: String): Self = StObject.set(x, "fileName", value.asInstanceOf[js.Any])
      
      inline def setFileNameUndefined: Self = StObject.set(x, "fileName", js.undefined)
      
      inline def setParsedTsConfig(value: ParsedCommandLine): Self = StObject.set(x, "parsedTsConfig", value.asInstanceOf[js.Any])
    }
  }
  
  trait TypeofScriptSnapshot extends StObject {
    
    def fromString(text: String): IScriptSnapshot
  }
  object TypeofScriptSnapshot {
    
    inline def apply(fromString: String => IScriptSnapshot): TypeofScriptSnapshot = {
      val __obj = js.Dynamic.literal(fromString = js.Any.fromFunction1(fromString))
      __obj.asInstanceOf[TypeofScriptSnapshot]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: TypeofScriptSnapshot] (val x: Self) extends AnyVal {
      
      inline def setFromString(value: String => IScriptSnapshot): Self = StObject.set(x, "fromString", js.Any.fromFunction1(value))
    }
  }
  
  @js.native
  trait TypeoftsTypes extends StObject {
    
    var OperationCanceledException: Instantiable0[typings.typescript.mod.OperationCanceledException] = js.native
    
    val ScriptSnapshot: TypeofScriptSnapshot = js.native
    
    /**
      * Adds an EmitHelper to a node.
      */
    def addEmitHelper[T /* <: Node */](node: T, helper: EmitHelper): T = js.native
    
    /**
      * Add EmitHelpers to a node.
      */
    def addEmitHelpers[T /* <: Node */](node: T): T = js.native
    def addEmitHelpers[T /* <: Node */](node: T, helpers: js.Array[EmitHelper]): T = js.native
    
    def addSyntheticLeadingComment[T /* <: Node */](node: T, kind: MultiLineCommentTrivia, text: String): T = js.native
    def addSyntheticLeadingComment[T /* <: Node */](node: T, kind: MultiLineCommentTrivia, text: String, hasTrailingNewLine: Boolean): T = js.native
    def addSyntheticLeadingComment[T /* <: Node */](node: T, kind: SingleLineCommentTrivia, text: String): T = js.native
    def addSyntheticLeadingComment[T /* <: Node */](node: T, kind: SingleLineCommentTrivia, text: String, hasTrailingNewLine: Boolean): T = js.native
    
    def addSyntheticTrailingComment[T /* <: Node */](node: T, kind: MultiLineCommentTrivia, text: String): T = js.native
    def addSyntheticTrailingComment[T /* <: Node */](node: T, kind: MultiLineCommentTrivia, text: String, hasTrailingNewLine: Boolean): T = js.native
    def addSyntheticTrailingComment[T /* <: Node */](node: T, kind: SingleLineCommentTrivia, text: String): T = js.native
    def addSyntheticTrailingComment[T /* <: Node */](node: T, kind: SingleLineCommentTrivia, text: String, hasTrailingNewLine: Boolean): T = js.native
    
    def bundlerModuleNameResolver(
      moduleName: String,
      containingFile: String,
      compilerOptions: CompilerOptions,
      host: ModuleResolutionHost
    ): ResolvedModuleWithFailedLookupLocations = js.native
    def bundlerModuleNameResolver(
      moduleName: String,
      containingFile: String,
      compilerOptions: CompilerOptions,
      host: ModuleResolutionHost,
      cache: Unit,
      redirectedReference: ResolvedProjectReference
    ): ResolvedModuleWithFailedLookupLocations = js.native
    def bundlerModuleNameResolver(
      moduleName: String,
      containingFile: String,
      compilerOptions: CompilerOptions,
      host: ModuleResolutionHost,
      cache: ModuleResolutionCache
    ): ResolvedModuleWithFailedLookupLocations = js.native
    def bundlerModuleNameResolver(
      moduleName: String,
      containingFile: String,
      compilerOptions: CompilerOptions,
      host: ModuleResolutionHost,
      cache: ModuleResolutionCache,
      redirectedReference: ResolvedProjectReference
    ): ResolvedModuleWithFailedLookupLocations = js.native
    
    def canHaveDecorators(node: Node): /* is typescript.typescript.HasDecorators */ Boolean = js.native
    
    def canHaveModifiers(node: Node): /* is typescript.typescript.HasModifiers */ Boolean = js.native
    
    def classicNameResolver(
      moduleName: String,
      containingFile: String,
      compilerOptions: CompilerOptions,
      host: ModuleResolutionHost
    ): ResolvedModuleWithFailedLookupLocations = js.native
    def classicNameResolver(
      moduleName: String,
      containingFile: String,
      compilerOptions: CompilerOptions,
      host: ModuleResolutionHost,
      cache: Unit,
      redirectedReference: ResolvedProjectReference
    ): ResolvedModuleWithFailedLookupLocations = js.native
    def classicNameResolver(
      moduleName: String,
      containingFile: String,
      compilerOptions: CompilerOptions,
      host: ModuleResolutionHost,
      cache: NonRelativeModuleNameResolutionCache
    ): ResolvedModuleWithFailedLookupLocations = js.native
    def classicNameResolver(
      moduleName: String,
      containingFile: String,
      compilerOptions: CompilerOptions,
      host: ModuleResolutionHost,
      cache: NonRelativeModuleNameResolutionCache,
      redirectedReference: ResolvedProjectReference
    ): ResolvedModuleWithFailedLookupLocations = js.native
    
    /**
      * Called to merge all the changes that occurred across several versions of a script snapshot
      * into a single change.  i.e. if a user keeps making successive edits to a script we will
      * have a text change from V1 to V2, V2 to V3, ..., Vn.
      *
      * This function will then merge those changes into a single change range valid between V1 and
      * Vn.
      */
    def collapseTextChangeRangesAcrossMultipleVersions(changes: js.Array[TextChangeRange]): TextChangeRange = js.native
    
    def convertCompilerOptionsFromJson(jsonOptions: Any, basePath: String): Errors = js.native
    def convertCompilerOptionsFromJson(jsonOptions: Any, basePath: String, configFileName: String): Errors = js.native
    
    /**
      * Convert the json syntax tree into the json value
      */
    def convertToObject(sourceFile: JsonSourceFile, errors: js.Array[Diagnostic]): Any = js.native
    
    def convertTypeAcquisitionFromJson(jsonOptions: Any, basePath: String): Options = js.native
    def convertTypeAcquisitionFromJson(jsonOptions: Any, basePath: String, configFileName: String): Options = js.native
    
    def couldStartTrivia(text: String, pos: Double): Boolean = js.native
    
    /**
      * Creates a builder thats just abstraction over program and can be used with watch
      */
    def createAbstractBuilder(newProgram: Program, host: BuilderProgramHost): BuilderProgram = js.native
    def createAbstractBuilder(
      newProgram: Program,
      host: BuilderProgramHost,
      oldProgram: Unit,
      configFileParsingDiagnostics: js.Array[Diagnostic]
    ): BuilderProgram = js.native
    def createAbstractBuilder(newProgram: Program, host: BuilderProgramHost, oldProgram: BuilderProgram): BuilderProgram = js.native
    def createAbstractBuilder(
      newProgram: Program,
      host: BuilderProgramHost,
      oldProgram: BuilderProgram,
      configFileParsingDiagnostics: js.Array[Diagnostic]
    ): BuilderProgram = js.native
    def createAbstractBuilder(
      rootNames: js.UndefOr[js.Array[String]],
      options: js.UndefOr[CompilerOptions],
      host: js.UndefOr[CompilerHost],
      oldProgram: js.UndefOr[BuilderProgram],
      configFileParsingDiagnostics: js.UndefOr[js.Array[Diagnostic]],
      projectReferences: js.UndefOr[js.Array[ProjectReference]]
    ): BuilderProgram = js.native
    
    /**
      * Create a function that reports watch status by writing to the system and handles the formating of the diagnostic
      */
    def createBuilderStatusReporter(system: System): DiagnosticReporter = js.native
    def createBuilderStatusReporter(system: System, pretty: Boolean): DiagnosticReporter = js.native
    
    /** The classifier is used for syntactic highlighting in editors via the TSServer */
    def createClassifier(): Classifier = js.native
    
    def createCompilerHost(options: CompilerOptions): CompilerHost = js.native
    def createCompilerHost(options: CompilerOptions, setParentNodes: Boolean): CompilerHost = js.native
    
    def createDocumentRegistry(): DocumentRegistry = js.native
    def createDocumentRegistry(useCaseSensitiveFileNames: Boolean): DocumentRegistry = js.native
    def createDocumentRegistry(useCaseSensitiveFileNames: Boolean, currentDirectory: String): DocumentRegistry = js.native
    def createDocumentRegistry(useCaseSensitiveFileNames: Unit, currentDirectory: String): DocumentRegistry = js.native
    
    /**
      * Create the builder that can handle the changes in program and iterate through changed files
      * to emit the those files and manage semantic diagnostics cache as well
      */
    def createEmitAndSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost): EmitAndSemanticDiagnosticsBuilderProgram = js.native
    def createEmitAndSemanticDiagnosticsBuilderProgram(
      newProgram: Program,
      host: BuilderProgramHost,
      oldProgram: Unit,
      configFileParsingDiagnostics: js.Array[Diagnostic]
    ): EmitAndSemanticDiagnosticsBuilderProgram = js.native
    def createEmitAndSemanticDiagnosticsBuilderProgram(
      newProgram: Program,
      host: BuilderProgramHost,
      oldProgram: EmitAndSemanticDiagnosticsBuilderProgram
    ): EmitAndSemanticDiagnosticsBuilderProgram = js.native
    def createEmitAndSemanticDiagnosticsBuilderProgram(
      newProgram: Program,
      host: BuilderProgramHost,
      oldProgram: EmitAndSemanticDiagnosticsBuilderProgram,
      configFileParsingDiagnostics: js.Array[Diagnostic]
    ): EmitAndSemanticDiagnosticsBuilderProgram = js.native
    def createEmitAndSemanticDiagnosticsBuilderProgram(
      rootNames: js.UndefOr[js.Array[String]],
      options: js.UndefOr[CompilerOptions],
      host: js.UndefOr[CompilerHost],
      oldProgram: js.UndefOr[EmitAndSemanticDiagnosticsBuilderProgram],
      configFileParsingDiagnostics: js.UndefOr[js.Array[Diagnostic]],
      projectReferences: js.UndefOr[js.Array[ProjectReference]]
    ): EmitAndSemanticDiagnosticsBuilderProgram = js.native
    
    def createIncrementalCompilerHost(options: CompilerOptions): CompilerHost = js.native
    def createIncrementalCompilerHost(options: CompilerOptions, system: System): CompilerHost = js.native
    
    def createIncrementalProgram[T /* <: BuilderProgram */](param0: IncrementalProgramOptions[T]): T = js.native
    
    /** @deprecated */
    def createInputFiles(javascriptText: String, declarationText: String): InputFiles = js.native
    def createInputFiles(javascriptText: String, declarationText: String, javascriptMapPath: String): InputFiles = js.native
    def createInputFiles(
      javascriptText: String,
      declarationText: String,
      javascriptMapPath: String,
      javascriptMapText: String
    ): InputFiles = js.native
    def createInputFiles(
      javascriptText: String,
      declarationText: String,
      javascriptMapPath: String,
      javascriptMapText: String,
      declarationMapPath: String
    ): InputFiles = js.native
    def createInputFiles(
      javascriptText: String,
      declarationText: String,
      javascriptMapPath: String,
      javascriptMapText: String,
      declarationMapPath: String,
      declarationMapText: String
    ): InputFiles = js.native
    def createInputFiles(
      javascriptText: String,
      declarationText: String,
      javascriptMapPath: String,
      javascriptMapText: String,
      declarationMapPath: Unit,
      declarationMapText: String
    ): InputFiles = js.native
    def createInputFiles(
      javascriptText: String,
      declarationText: String,
      javascriptMapPath: String,
      javascriptMapText: Unit,
      declarationMapPath: String
    ): InputFiles = js.native
    def createInputFiles(
      javascriptText: String,
      declarationText: String,
      javascriptMapPath: String,
      javascriptMapText: Unit,
      declarationMapPath: String,
      declarationMapText: String
    ): InputFiles = js.native
    def createInputFiles(
      javascriptText: String,
      declarationText: String,
      javascriptMapPath: String,
      javascriptMapText: Unit,
      declarationMapPath: Unit,
      declarationMapText: String
    ): InputFiles = js.native
    def createInputFiles(
      javascriptText: String,
      declarationText: String,
      javascriptMapPath: Unit,
      javascriptMapText: String
    ): InputFiles = js.native
    def createInputFiles(
      javascriptText: String,
      declarationText: String,
      javascriptMapPath: Unit,
      javascriptMapText: String,
      declarationMapPath: String
    ): InputFiles = js.native
    def createInputFiles(
      javascriptText: String,
      declarationText: String,
      javascriptMapPath: Unit,
      javascriptMapText: String,
      declarationMapPath: String,
      declarationMapText: String
    ): InputFiles = js.native
    def createInputFiles(
      javascriptText: String,
      declarationText: String,
      javascriptMapPath: Unit,
      javascriptMapText: String,
      declarationMapPath: Unit,
      declarationMapText: String
    ): InputFiles = js.native
    def createInputFiles(
      javascriptText: String,
      declarationText: String,
      javascriptMapPath: Unit,
      javascriptMapText: Unit,
      declarationMapPath: String
    ): InputFiles = js.native
    def createInputFiles(
      javascriptText: String,
      declarationText: String,
      javascriptMapPath: Unit,
      javascriptMapText: Unit,
      declarationMapPath: String,
      declarationMapText: String
    ): InputFiles = js.native
    def createInputFiles(
      javascriptText: String,
      declarationText: String,
      javascriptMapPath: Unit,
      javascriptMapText: Unit,
      declarationMapPath: Unit,
      declarationMapText: String
    ): InputFiles = js.native
    /** @deprecated */
    def createInputFiles(
      readFileText: js.Function1[/* path */ String, js.UndefOr[String]],
      javascriptPath: String,
      javascriptMapPath: String,
      declarationPath: String
    ): InputFiles = js.native
    def createInputFiles(
      readFileText: js.Function1[/* path */ String, js.UndefOr[String]],
      javascriptPath: String,
      javascriptMapPath: String,
      declarationPath: String,
      declarationMapPath: String
    ): InputFiles = js.native
    def createInputFiles(
      readFileText: js.Function1[/* path */ String, js.UndefOr[String]],
      javascriptPath: String,
      javascriptMapPath: String,
      declarationPath: String,
      declarationMapPath: String,
      buildInfoPath: String
    ): InputFiles = js.native
    def createInputFiles(
      readFileText: js.Function1[/* path */ String, js.UndefOr[String]],
      javascriptPath: String,
      javascriptMapPath: String,
      declarationPath: String,
      declarationMapPath: Unit,
      buildInfoPath: String
    ): InputFiles = js.native
    def createInputFiles(
      readFileText: js.Function1[/* path */ String, js.UndefOr[String]],
      javascriptPath: String,
      javascriptMapPath: Unit,
      declarationPath: String
    ): InputFiles = js.native
    def createInputFiles(
      readFileText: js.Function1[/* path */ String, js.UndefOr[String]],
      javascriptPath: String,
      javascriptMapPath: Unit,
      declarationPath: String,
      declarationMapPath: String
    ): InputFiles = js.native
    def createInputFiles(
      readFileText: js.Function1[/* path */ String, js.UndefOr[String]],
      javascriptPath: String,
      javascriptMapPath: Unit,
      declarationPath: String,
      declarationMapPath: String,
      buildInfoPath: String
    ): InputFiles = js.native
    def createInputFiles(
      readFileText: js.Function1[/* path */ String, js.UndefOr[String]],
      javascriptPath: String,
      javascriptMapPath: Unit,
      declarationPath: String,
      declarationMapPath: Unit,
      buildInfoPath: String
    ): InputFiles = js.native
    
    def createLanguageService(host: LanguageServiceHost): LanguageService = js.native
    def createLanguageService(host: LanguageServiceHost, documentRegistry: Unit, syntaxOnlyOrLanguageServiceMode: Boolean): LanguageService = js.native
    def createLanguageService(
      host: LanguageServiceHost,
      documentRegistry: Unit,
      syntaxOnlyOrLanguageServiceMode: LanguageServiceMode
    ): LanguageService = js.native
    def createLanguageService(host: LanguageServiceHost, documentRegistry: DocumentRegistry): LanguageService = js.native
    def createLanguageService(
      host: LanguageServiceHost,
      documentRegistry: DocumentRegistry,
      syntaxOnlyOrLanguageServiceMode: Boolean
    ): LanguageService = js.native
    def createLanguageService(
      host: LanguageServiceHost,
      documentRegistry: DocumentRegistry,
      syntaxOnlyOrLanguageServiceMode: LanguageServiceMode
    ): LanguageService = js.native
    
    def createLanguageServiceSourceFile(
      fileName: String,
      scriptSnapshot: IScriptSnapshot,
      scriptTargetOrOptions: CreateSourceFileOptions,
      version: String,
      setNodeParents: Boolean
    ): SourceFile = js.native
    def createLanguageServiceSourceFile(
      fileName: String,
      scriptSnapshot: IScriptSnapshot,
      scriptTargetOrOptions: CreateSourceFileOptions,
      version: String,
      setNodeParents: Boolean,
      scriptKind: ScriptKind
    ): SourceFile = js.native
    def createLanguageServiceSourceFile(
      fileName: String,
      scriptSnapshot: IScriptSnapshot,
      scriptTargetOrOptions: ScriptTarget,
      version: String,
      setNodeParents: Boolean
    ): SourceFile = js.native
    def createLanguageServiceSourceFile(
      fileName: String,
      scriptSnapshot: IScriptSnapshot,
      scriptTargetOrOptions: ScriptTarget,
      version: String,
      setNodeParents: Boolean,
      scriptKind: ScriptKind
    ): SourceFile = js.native
    
    def createModuleResolutionCache(currentDirectory: String, getCanonicalFileName: js.Function1[/* s */ String, String]): ModuleResolutionCache = js.native
    def createModuleResolutionCache(
      currentDirectory: String,
      getCanonicalFileName: js.Function1[/* s */ String, String],
      options: CompilerOptions
    ): ModuleResolutionCache = js.native
    
    def createPrinter(): Printer = js.native
    def createPrinter(printerOptions: Unit, handlers: PrintHandlers): Printer = js.native
    def createPrinter(printerOptions: PrinterOptions): Printer = js.native
    def createPrinter(printerOptions: PrinterOptions, handlers: PrintHandlers): Printer = js.native
    
    /**
      * Create a new 'Program' instance. A Program is an immutable collection of 'SourceFile's and a 'CompilerOptions'
      * that represent a compilation unit.
      *
      * Creating a program proceeds from a set of root files, expanding the set of inputs by following imports and
      * triple-slash-reference-path directives transitively. '@types' and triple-slash-reference-types are also pulled in.
      *
      * @param createProgramOptions - The options for creating a program.
      * @returns A 'Program' object.
      */
    def createProgram(createProgramOptions: CreateProgramOptions): Program = js.native
    /**
      * Create a new 'Program' instance. A Program is an immutable collection of 'SourceFile's and a 'CompilerOptions'
      * that represent a compilation unit.
      *
      * Creating a program proceeds from a set of root files, expanding the set of inputs by following imports and
      * triple-slash-reference-path directives transitively. '@types' and triple-slash-reference-types are also pulled in.
      *
      * @param rootNames - A set of root files.
      * @param options - The compiler options which should be used.
      * @param host - The host interacts with the underlying file system.
      * @param oldProgram - Reuses an old program structure.
      * @param configFileParsingDiagnostics - error during config file parsing
      * @returns A 'Program' object.
      */
    def createProgram(rootNames: js.Array[String], options: CompilerOptions): Program = js.native
    def createProgram(
      rootNames: js.Array[String],
      options: CompilerOptions,
      host: Unit,
      oldProgram: Unit,
      configFileParsingDiagnostics: js.Array[Diagnostic]
    ): Program = js.native
    def createProgram(rootNames: js.Array[String], options: CompilerOptions, host: Unit, oldProgram: Program): Program = js.native
    def createProgram(
      rootNames: js.Array[String],
      options: CompilerOptions,
      host: Unit,
      oldProgram: Program,
      configFileParsingDiagnostics: js.Array[Diagnostic]
    ): Program = js.native
    def createProgram(rootNames: js.Array[String], options: CompilerOptions, host: CompilerHost): Program = js.native
    def createProgram(
      rootNames: js.Array[String],
      options: CompilerOptions,
      host: CompilerHost,
      oldProgram: Unit,
      configFileParsingDiagnostics: js.Array[Diagnostic]
    ): Program = js.native
    def createProgram(rootNames: js.Array[String], options: CompilerOptions, host: CompilerHost, oldProgram: Program): Program = js.native
    def createProgram(
      rootNames: js.Array[String],
      options: CompilerOptions,
      host: CompilerHost,
      oldProgram: Program,
      configFileParsingDiagnostics: js.Array[Diagnostic]
    ): Program = js.native
    
    def createScanner(languageVersion: ScriptTarget, skipTrivia: Boolean): Scanner = js.native
    def createScanner(languageVersion: ScriptTarget, skipTrivia: Boolean, languageVariant: Unit, textInitial: String): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: Unit,
      textInitial: String,
      onError: Unit,
      start: Double
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: Unit,
      textInitial: String,
      onError: Unit,
      start: Double,
      length: Double
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: Unit,
      textInitial: String,
      onError: Unit,
      start: Unit,
      length: Double
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: Unit,
      textInitial: String,
      onError: ErrorCallback
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: Unit,
      textInitial: String,
      onError: ErrorCallback,
      start: Double
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: Unit,
      textInitial: String,
      onError: ErrorCallback,
      start: Double,
      length: Double
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: Unit,
      textInitial: String,
      onError: ErrorCallback,
      start: Unit,
      length: Double
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: Unit,
      textInitial: Unit,
      onError: Unit,
      start: Double
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: Unit,
      textInitial: Unit,
      onError: Unit,
      start: Double,
      length: Double
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: Unit,
      textInitial: Unit,
      onError: Unit,
      start: Unit,
      length: Double
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: Unit,
      textInitial: Unit,
      onError: ErrorCallback
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: Unit,
      textInitial: Unit,
      onError: ErrorCallback,
      start: Double
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: Unit,
      textInitial: Unit,
      onError: ErrorCallback,
      start: Double,
      length: Double
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: Unit,
      textInitial: Unit,
      onError: ErrorCallback,
      start: Unit,
      length: Double
    ): Scanner = js.native
    def createScanner(languageVersion: ScriptTarget, skipTrivia: Boolean, languageVariant: LanguageVariant): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: LanguageVariant,
      textInitial: String
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: LanguageVariant,
      textInitial: String,
      onError: Unit,
      start: Double
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: LanguageVariant,
      textInitial: String,
      onError: Unit,
      start: Double,
      length: Double
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: LanguageVariant,
      textInitial: String,
      onError: Unit,
      start: Unit,
      length: Double
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: LanguageVariant,
      textInitial: String,
      onError: ErrorCallback
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: LanguageVariant,
      textInitial: String,
      onError: ErrorCallback,
      start: Double
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: LanguageVariant,
      textInitial: String,
      onError: ErrorCallback,
      start: Double,
      length: Double
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: LanguageVariant,
      textInitial: String,
      onError: ErrorCallback,
      start: Unit,
      length: Double
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: LanguageVariant,
      textInitial: Unit,
      onError: Unit,
      start: Double
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: LanguageVariant,
      textInitial: Unit,
      onError: Unit,
      start: Double,
      length: Double
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: LanguageVariant,
      textInitial: Unit,
      onError: Unit,
      start: Unit,
      length: Double
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: LanguageVariant,
      textInitial: Unit,
      onError: ErrorCallback
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: LanguageVariant,
      textInitial: Unit,
      onError: ErrorCallback,
      start: Double
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: LanguageVariant,
      textInitial: Unit,
      onError: ErrorCallback,
      start: Double,
      length: Double
    ): Scanner = js.native
    def createScanner(
      languageVersion: ScriptTarget,
      skipTrivia: Boolean,
      languageVariant: LanguageVariant,
      textInitial: Unit,
      onError: ErrorCallback,
      start: Unit,
      length: Double
    ): Scanner = js.native
    
    /**
      * Create the builder to manage semantic diagnostics and cache them
      */
    def createSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost): SemanticDiagnosticsBuilderProgram = js.native
    def createSemanticDiagnosticsBuilderProgram(
      newProgram: Program,
      host: BuilderProgramHost,
      oldProgram: Unit,
      configFileParsingDiagnostics: js.Array[Diagnostic]
    ): SemanticDiagnosticsBuilderProgram = js.native
    def createSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost, oldProgram: SemanticDiagnosticsBuilderProgram): SemanticDiagnosticsBuilderProgram = js.native
    def createSemanticDiagnosticsBuilderProgram(
      newProgram: Program,
      host: BuilderProgramHost,
      oldProgram: SemanticDiagnosticsBuilderProgram,
      configFileParsingDiagnostics: js.Array[Diagnostic]
    ): SemanticDiagnosticsBuilderProgram = js.native
    def createSemanticDiagnosticsBuilderProgram(
      rootNames: js.UndefOr[js.Array[String]],
      options: js.UndefOr[CompilerOptions],
      host: js.UndefOr[CompilerHost],
      oldProgram: js.UndefOr[SemanticDiagnosticsBuilderProgram],
      configFileParsingDiagnostics: js.UndefOr[js.Array[Diagnostic]],
      projectReferences: js.UndefOr[js.Array[ProjectReference]]
    ): SemanticDiagnosticsBuilderProgram = js.native
    
    def createSolutionBuilder[T /* <: BuilderProgram */](host: SolutionBuilderHost[T], rootNames: js.Array[String], defaultOptions: BuildOptions): SolutionBuilder[T] = js.native
    
    def createSolutionBuilderHost[T /* <: BuilderProgram */](): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](
      system: Unit,
      createProgram: Unit,
      reportDiagnostic: Unit,
      reportSolutionBuilderStatus: Unit,
      reportErrorSummary: ReportEmitErrorSummary
    ): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](
      system: Unit,
      createProgram: Unit,
      reportDiagnostic: Unit,
      reportSolutionBuilderStatus: DiagnosticReporter
    ): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](
      system: Unit,
      createProgram: Unit,
      reportDiagnostic: Unit,
      reportSolutionBuilderStatus: DiagnosticReporter,
      reportErrorSummary: ReportEmitErrorSummary
    ): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](system: Unit, createProgram: Unit, reportDiagnostic: DiagnosticReporter): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](
      system: Unit,
      createProgram: Unit,
      reportDiagnostic: DiagnosticReporter,
      reportSolutionBuilderStatus: Unit,
      reportErrorSummary: ReportEmitErrorSummary
    ): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](
      system: Unit,
      createProgram: Unit,
      reportDiagnostic: DiagnosticReporter,
      reportSolutionBuilderStatus: DiagnosticReporter
    ): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](
      system: Unit,
      createProgram: Unit,
      reportDiagnostic: DiagnosticReporter,
      reportSolutionBuilderStatus: DiagnosticReporter,
      reportErrorSummary: ReportEmitErrorSummary
    ): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](system: Unit, createProgram: CreateProgram_[T]): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](
      system: Unit,
      createProgram: CreateProgram_[T],
      reportDiagnostic: Unit,
      reportSolutionBuilderStatus: Unit,
      reportErrorSummary: ReportEmitErrorSummary
    ): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](
      system: Unit,
      createProgram: CreateProgram_[T],
      reportDiagnostic: Unit,
      reportSolutionBuilderStatus: DiagnosticReporter
    ): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](
      system: Unit,
      createProgram: CreateProgram_[T],
      reportDiagnostic: Unit,
      reportSolutionBuilderStatus: DiagnosticReporter,
      reportErrorSummary: ReportEmitErrorSummary
    ): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](system: Unit, createProgram: CreateProgram_[T], reportDiagnostic: DiagnosticReporter): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](
      system: Unit,
      createProgram: CreateProgram_[T],
      reportDiagnostic: DiagnosticReporter,
      reportSolutionBuilderStatus: Unit,
      reportErrorSummary: ReportEmitErrorSummary
    ): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](
      system: Unit,
      createProgram: CreateProgram_[T],
      reportDiagnostic: DiagnosticReporter,
      reportSolutionBuilderStatus: DiagnosticReporter
    ): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](
      system: Unit,
      createProgram: CreateProgram_[T],
      reportDiagnostic: DiagnosticReporter,
      reportSolutionBuilderStatus: DiagnosticReporter,
      reportErrorSummary: ReportEmitErrorSummary
    ): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](system: System): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](
      system: System,
      createProgram: Unit,
      reportDiagnostic: Unit,
      reportSolutionBuilderStatus: Unit,
      reportErrorSummary: ReportEmitErrorSummary
    ): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](
      system: System,
      createProgram: Unit,
      reportDiagnostic: Unit,
      reportSolutionBuilderStatus: DiagnosticReporter
    ): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](
      system: System,
      createProgram: Unit,
      reportDiagnostic: Unit,
      reportSolutionBuilderStatus: DiagnosticReporter,
      reportErrorSummary: ReportEmitErrorSummary
    ): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](system: System, createProgram: Unit, reportDiagnostic: DiagnosticReporter): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](
      system: System,
      createProgram: Unit,
      reportDiagnostic: DiagnosticReporter,
      reportSolutionBuilderStatus: Unit,
      reportErrorSummary: ReportEmitErrorSummary
    ): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](
      system: System,
      createProgram: Unit,
      reportDiagnostic: DiagnosticReporter,
      reportSolutionBuilderStatus: DiagnosticReporter
    ): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](
      system: System,
      createProgram: Unit,
      reportDiagnostic: DiagnosticReporter,
      reportSolutionBuilderStatus: DiagnosticReporter,
      reportErrorSummary: ReportEmitErrorSummary
    ): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](system: System, createProgram: CreateProgram_[T]): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: Unit,
      reportSolutionBuilderStatus: Unit,
      reportErrorSummary: ReportEmitErrorSummary
    ): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: Unit,
      reportSolutionBuilderStatus: DiagnosticReporter
    ): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: Unit,
      reportSolutionBuilderStatus: DiagnosticReporter,
      reportErrorSummary: ReportEmitErrorSummary
    ): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](system: System, createProgram: CreateProgram_[T], reportDiagnostic: DiagnosticReporter): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: DiagnosticReporter,
      reportSolutionBuilderStatus: Unit,
      reportErrorSummary: ReportEmitErrorSummary
    ): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: DiagnosticReporter,
      reportSolutionBuilderStatus: DiagnosticReporter
    ): SolutionBuilderHost[T] = js.native
    def createSolutionBuilderHost[T /* <: BuilderProgram */](
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: DiagnosticReporter,
      reportSolutionBuilderStatus: DiagnosticReporter,
      reportErrorSummary: ReportEmitErrorSummary
    ): SolutionBuilderHost[T] = js.native
    
    def createSolutionBuilderWithWatch[T /* <: BuilderProgram */](host: SolutionBuilderWithWatchHost[T], rootNames: js.Array[String], defaultOptions: BuildOptions): SolutionBuilder[T] = js.native
    def createSolutionBuilderWithWatch[T /* <: BuilderProgram */](
      host: SolutionBuilderWithWatchHost[T],
      rootNames: js.Array[String],
      defaultOptions: BuildOptions,
      baseWatchOptions: WatchOptions
    ): SolutionBuilder[T] = js.native
    
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](
      system: Unit,
      createProgram: Unit,
      reportDiagnostic: Unit,
      reportSolutionBuilderStatus: Unit,
      reportWatchStatus: WatchStatusReporter
    ): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](
      system: Unit,
      createProgram: Unit,
      reportDiagnostic: Unit,
      reportSolutionBuilderStatus: DiagnosticReporter
    ): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](
      system: Unit,
      createProgram: Unit,
      reportDiagnostic: Unit,
      reportSolutionBuilderStatus: DiagnosticReporter,
      reportWatchStatus: WatchStatusReporter
    ): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](system: Unit, createProgram: Unit, reportDiagnostic: DiagnosticReporter): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](
      system: Unit,
      createProgram: Unit,
      reportDiagnostic: DiagnosticReporter,
      reportSolutionBuilderStatus: Unit,
      reportWatchStatus: WatchStatusReporter
    ): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](
      system: Unit,
      createProgram: Unit,
      reportDiagnostic: DiagnosticReporter,
      reportSolutionBuilderStatus: DiagnosticReporter
    ): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](
      system: Unit,
      createProgram: Unit,
      reportDiagnostic: DiagnosticReporter,
      reportSolutionBuilderStatus: DiagnosticReporter,
      reportWatchStatus: WatchStatusReporter
    ): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](system: Unit, createProgram: CreateProgram_[T]): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](
      system: Unit,
      createProgram: CreateProgram_[T],
      reportDiagnostic: Unit,
      reportSolutionBuilderStatus: Unit,
      reportWatchStatus: WatchStatusReporter
    ): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](
      system: Unit,
      createProgram: CreateProgram_[T],
      reportDiagnostic: Unit,
      reportSolutionBuilderStatus: DiagnosticReporter
    ): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](
      system: Unit,
      createProgram: CreateProgram_[T],
      reportDiagnostic: Unit,
      reportSolutionBuilderStatus: DiagnosticReporter,
      reportWatchStatus: WatchStatusReporter
    ): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](system: Unit, createProgram: CreateProgram_[T], reportDiagnostic: DiagnosticReporter): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](
      system: Unit,
      createProgram: CreateProgram_[T],
      reportDiagnostic: DiagnosticReporter,
      reportSolutionBuilderStatus: Unit,
      reportWatchStatus: WatchStatusReporter
    ): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](
      system: Unit,
      createProgram: CreateProgram_[T],
      reportDiagnostic: DiagnosticReporter,
      reportSolutionBuilderStatus: DiagnosticReporter
    ): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](
      system: Unit,
      createProgram: CreateProgram_[T],
      reportDiagnostic: DiagnosticReporter,
      reportSolutionBuilderStatus: DiagnosticReporter,
      reportWatchStatus: WatchStatusReporter
    ): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](system: System): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](
      system: System,
      createProgram: Unit,
      reportDiagnostic: Unit,
      reportSolutionBuilderStatus: Unit,
      reportWatchStatus: WatchStatusReporter
    ): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](
      system: System,
      createProgram: Unit,
      reportDiagnostic: Unit,
      reportSolutionBuilderStatus: DiagnosticReporter
    ): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](
      system: System,
      createProgram: Unit,
      reportDiagnostic: Unit,
      reportSolutionBuilderStatus: DiagnosticReporter,
      reportWatchStatus: WatchStatusReporter
    ): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](system: System, createProgram: Unit, reportDiagnostic: DiagnosticReporter): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](
      system: System,
      createProgram: Unit,
      reportDiagnostic: DiagnosticReporter,
      reportSolutionBuilderStatus: Unit,
      reportWatchStatus: WatchStatusReporter
    ): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](
      system: System,
      createProgram: Unit,
      reportDiagnostic: DiagnosticReporter,
      reportSolutionBuilderStatus: DiagnosticReporter
    ): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](
      system: System,
      createProgram: Unit,
      reportDiagnostic: DiagnosticReporter,
      reportSolutionBuilderStatus: DiagnosticReporter,
      reportWatchStatus: WatchStatusReporter
    ): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](system: System, createProgram: CreateProgram_[T]): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: Unit,
      reportSolutionBuilderStatus: Unit,
      reportWatchStatus: WatchStatusReporter
    ): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: Unit,
      reportSolutionBuilderStatus: DiagnosticReporter
    ): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: Unit,
      reportSolutionBuilderStatus: DiagnosticReporter,
      reportWatchStatus: WatchStatusReporter
    ): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](system: System, createProgram: CreateProgram_[T], reportDiagnostic: DiagnosticReporter): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: DiagnosticReporter,
      reportSolutionBuilderStatus: Unit,
      reportWatchStatus: WatchStatusReporter
    ): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: DiagnosticReporter,
      reportSolutionBuilderStatus: DiagnosticReporter
    ): SolutionBuilderWithWatchHost[T] = js.native
    def createSolutionBuilderWithWatchHost[T /* <: BuilderProgram */](
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: DiagnosticReporter,
      reportSolutionBuilderStatus: DiagnosticReporter,
      reportWatchStatus: WatchStatusReporter
    ): SolutionBuilderWithWatchHost[T] = js.native
    
    def createSourceFile(fileName: String, sourceText: String, languageVersionOrOptions: CreateSourceFileOptions): SourceFile = js.native
    def createSourceFile(
      fileName: String,
      sourceText: String,
      languageVersionOrOptions: CreateSourceFileOptions,
      setParentNodes: Boolean
    ): SourceFile = js.native
    def createSourceFile(
      fileName: String,
      sourceText: String,
      languageVersionOrOptions: CreateSourceFileOptions,
      setParentNodes: Boolean,
      scriptKind: ScriptKind
    ): SourceFile = js.native
    def createSourceFile(
      fileName: String,
      sourceText: String,
      languageVersionOrOptions: CreateSourceFileOptions,
      setParentNodes: Unit,
      scriptKind: ScriptKind
    ): SourceFile = js.native
    def createSourceFile(fileName: String, sourceText: String, languageVersionOrOptions: ScriptTarget): SourceFile = js.native
    def createSourceFile(
      fileName: String,
      sourceText: String,
      languageVersionOrOptions: ScriptTarget,
      setParentNodes: Boolean
    ): SourceFile = js.native
    def createSourceFile(
      fileName: String,
      sourceText: String,
      languageVersionOrOptions: ScriptTarget,
      setParentNodes: Boolean,
      scriptKind: ScriptKind
    ): SourceFile = js.native
    def createSourceFile(
      fileName: String,
      sourceText: String,
      languageVersionOrOptions: ScriptTarget,
      setParentNodes: Unit,
      scriptKind: ScriptKind
    ): SourceFile = js.native
    
    /**
      * Create an external source map source file reference
      */
    def createSourceMapSource(fileName: String, text: String): SourceMapSource = js.native
    def createSourceMapSource(fileName: String, text: String, skipTrivia: js.Function1[/* pos */ Double, Double]): SourceMapSource = js.native
    
    def createTextChangeRange(span: TextSpan, newLength: Double): TextChangeRange = js.native
    
    def createTextSpan(start: Double, length: Double): TextSpan = js.native
    
    def createTextSpanFromBounds(start: Double, end: Double): TextSpan = js.native
    
    def createTypeReferenceDirectiveResolutionCache(currentDirectory: String, getCanonicalFileName: js.Function1[/* s */ String, String]): TypeReferenceDirectiveResolutionCache = js.native
    def createTypeReferenceDirectiveResolutionCache(
      currentDirectory: String,
      getCanonicalFileName: js.Function1[/* s */ String, String],
      options: Unit,
      packageJsonInfoCache: PackageJsonInfoCache
    ): TypeReferenceDirectiveResolutionCache = js.native
    def createTypeReferenceDirectiveResolutionCache(
      currentDirectory: String,
      getCanonicalFileName: js.Function1[/* s */ String, String],
      options: CompilerOptions
    ): TypeReferenceDirectiveResolutionCache = js.native
    def createTypeReferenceDirectiveResolutionCache(
      currentDirectory: String,
      getCanonicalFileName: js.Function1[/* s */ String, String],
      options: CompilerOptions,
      packageJsonInfoCache: PackageJsonInfoCache
    ): TypeReferenceDirectiveResolutionCache = js.native
    
    /** @deprecated */
    def createUnparsedSourceFile(inputFile: InputFiles, `type`: js_ | dts): UnparsedSource = js.native
    def createUnparsedSourceFile(inputFile: InputFiles, `type`: js_ | dts, stripInternal: Boolean): UnparsedSource = js.native
    /** @deprecated */
    def createUnparsedSourceFile(text: String): UnparsedSource = js.native
    def createUnparsedSourceFile(text: String, mapPath: String): UnparsedSource = js.native
    def createUnparsedSourceFile(text: String, mapPath: String, map: String): UnparsedSource = js.native
    def createUnparsedSourceFile(text: String, mapPath: Unit, map: String): UnparsedSource = js.native
    
    /**
      * Create the watch compiler host for either configFile or fileNames and its options
      */
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      configFileName: String,
      optionsToExtend: js.UndefOr[CompilerOptions],
      system: System,
      createProgram: js.UndefOr[CreateProgram_[T]],
      reportDiagnostic: js.UndefOr[DiagnosticReporter],
      reportWatchStatus: js.UndefOr[WatchStatusReporter],
      watchOptionsToExtend: js.UndefOr[WatchOptions],
      extraFileExtensions: js.UndefOr[js.Array[FileExtensionInfo]]
    ): WatchCompilerHostOfConfigFile[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](rootFiles: js.Array[String], options: CompilerOptions, system: System): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: Unit,
      reportDiagnostic: Unit,
      reportWatchStatus: Unit,
      projectReferences: js.Array[ProjectReference]
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: Unit,
      reportDiagnostic: Unit,
      reportWatchStatus: Unit,
      projectReferences: js.Array[ProjectReference],
      watchOptions: WatchOptions
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: Unit,
      reportDiagnostic: Unit,
      reportWatchStatus: Unit,
      projectReferences: Unit,
      watchOptions: WatchOptions
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: Unit,
      reportDiagnostic: Unit,
      reportWatchStatus: WatchStatusReporter
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: Unit,
      reportDiagnostic: Unit,
      reportWatchStatus: WatchStatusReporter,
      projectReferences: js.Array[ProjectReference]
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: Unit,
      reportDiagnostic: Unit,
      reportWatchStatus: WatchStatusReporter,
      projectReferences: js.Array[ProjectReference],
      watchOptions: WatchOptions
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: Unit,
      reportDiagnostic: Unit,
      reportWatchStatus: WatchStatusReporter,
      projectReferences: Unit,
      watchOptions: WatchOptions
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: Unit,
      reportDiagnostic: DiagnosticReporter
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: Unit,
      reportDiagnostic: DiagnosticReporter,
      reportWatchStatus: Unit,
      projectReferences: js.Array[ProjectReference]
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: Unit,
      reportDiagnostic: DiagnosticReporter,
      reportWatchStatus: Unit,
      projectReferences: js.Array[ProjectReference],
      watchOptions: WatchOptions
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: Unit,
      reportDiagnostic: DiagnosticReporter,
      reportWatchStatus: Unit,
      projectReferences: Unit,
      watchOptions: WatchOptions
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: Unit,
      reportDiagnostic: DiagnosticReporter,
      reportWatchStatus: WatchStatusReporter
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: Unit,
      reportDiagnostic: DiagnosticReporter,
      reportWatchStatus: WatchStatusReporter,
      projectReferences: js.Array[ProjectReference]
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: Unit,
      reportDiagnostic: DiagnosticReporter,
      reportWatchStatus: WatchStatusReporter,
      projectReferences: js.Array[ProjectReference],
      watchOptions: WatchOptions
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: Unit,
      reportDiagnostic: DiagnosticReporter,
      reportWatchStatus: WatchStatusReporter,
      projectReferences: Unit,
      watchOptions: WatchOptions
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: CreateProgram_[T]
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: Unit,
      reportWatchStatus: Unit,
      projectReferences: js.Array[ProjectReference]
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: Unit,
      reportWatchStatus: Unit,
      projectReferences: js.Array[ProjectReference],
      watchOptions: WatchOptions
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: Unit,
      reportWatchStatus: Unit,
      projectReferences: Unit,
      watchOptions: WatchOptions
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: Unit,
      reportWatchStatus: WatchStatusReporter
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: Unit,
      reportWatchStatus: WatchStatusReporter,
      projectReferences: js.Array[ProjectReference]
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: Unit,
      reportWatchStatus: WatchStatusReporter,
      projectReferences: js.Array[ProjectReference],
      watchOptions: WatchOptions
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: Unit,
      reportWatchStatus: WatchStatusReporter,
      projectReferences: Unit,
      watchOptions: WatchOptions
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: DiagnosticReporter
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: DiagnosticReporter,
      reportWatchStatus: Unit,
      projectReferences: js.Array[ProjectReference]
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: DiagnosticReporter,
      reportWatchStatus: Unit,
      projectReferences: js.Array[ProjectReference],
      watchOptions: WatchOptions
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: DiagnosticReporter,
      reportWatchStatus: Unit,
      projectReferences: Unit,
      watchOptions: WatchOptions
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: DiagnosticReporter,
      reportWatchStatus: WatchStatusReporter
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: DiagnosticReporter,
      reportWatchStatus: WatchStatusReporter,
      projectReferences: js.Array[ProjectReference]
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: DiagnosticReporter,
      reportWatchStatus: WatchStatusReporter,
      projectReferences: js.Array[ProjectReference],
      watchOptions: WatchOptions
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    def createWatchCompilerHost[T /* <: BuilderProgram */](
      rootFiles: js.Array[String],
      options: CompilerOptions,
      system: System,
      createProgram: CreateProgram_[T],
      reportDiagnostic: DiagnosticReporter,
      reportWatchStatus: WatchStatusReporter,
      projectReferences: Unit,
      watchOptions: WatchOptions
    ): WatchCompilerHostOfFilesAndCompilerOptions[T] = js.native
    
    /**
      * Creates the watch from the host for config file
      */
    def createWatchProgram[T /* <: BuilderProgram */](host: WatchCompilerHostOfConfigFile[T]): WatchOfConfigFile[T] = js.native
    /**
      * Creates the watch from the host for root files and compiler options
      */
    def createWatchProgram[T /* <: BuilderProgram */](host: WatchCompilerHostOfFilesAndCompilerOptions[T]): WatchOfFilesAndCompilerOptions[T] = js.native
    
    def decodedTextSpanIntersectsWith(start1: Double, length1: Double, start2: Double, length2: Double): Boolean = js.native
    
    def displayPartsToString(): String = js.native
    def displayPartsToString(displayParts: js.Array[SymbolDisplayPart]): String = js.native
    
    /**
      * Clears any `EmitNode` entries from parse-tree nodes.
      * @param sourceFile A source file.
      */
    def disposeEmitNodes(): Unit = js.native
    def disposeEmitNodes(sourceFile: SourceFile): Unit = js.native
    
    /** Add an extra underscore to identifiers that start with two underscores to avoid issues with magic names like '__proto__' */
    def escapeLeadingUnderscores(identifier: String): typings.typescript.mod.String = js.native
    
    val factory: NodeFactory = js.native
    
    def findAncestor[T /* <: Node */](node: Unit, callback: js.Function1[/* element */ Node, /* is T */ Boolean]): js.UndefOr[T] = js.native
    /**
      * Iterates through the parent chain of a node and performs the callback on each parent until the callback
      * returns a truthy value, then returns that value.
      * If no such value is found, it applies the callback until the parent pointer is undefined or the callback returns "quit"
      * At that point findAncestor returns undefined.
      */
    def findAncestor[T /* <: Node */](node: Node, callback: js.Function1[/* element */ Node, /* is T */ Boolean]): js.UndefOr[T] = js.native
    @JSName("findAncestor")
    def findAncestor_quit(node: Unit, callback: js.Function1[/* element */ Node, Boolean | quit]): js.UndefOr[Node] = js.native
    @JSName("findAncestor")
    def findAncestor_quit(node: Node, callback: js.Function1[/* element */ Node, Boolean | quit]): js.UndefOr[Node] = js.native
    
    def findConfigFile(searchPath: String, fileExists: js.Function1[/* fileName */ String, Boolean]): js.UndefOr[String] = js.native
    def findConfigFile(searchPath: String, fileExists: js.Function1[/* fileName */ String, Boolean], configName: String): js.UndefOr[String] = js.native
    
    def flattenDiagnosticMessageText(diag: String, newLine: String): String = js.native
    def flattenDiagnosticMessageText(diag: String, newLine: String, indent: Double): String = js.native
    def flattenDiagnosticMessageText(diag: Unit, newLine: String): String = js.native
    def flattenDiagnosticMessageText(diag: Unit, newLine: String, indent: Double): String = js.native
    def flattenDiagnosticMessageText(diag: DiagnosticMessageChain, newLine: String): String = js.native
    def flattenDiagnosticMessageText(diag: DiagnosticMessageChain, newLine: String, indent: Double): String = js.native
    
    /**
      * Invokes a callback for each child of the given node. The 'cbNode' callback is invoked for all child nodes
      * stored in properties. If a 'cbNodes' callback is specified, it is invoked for embedded arrays; otherwise,
      * embedded arrays are flattened and the 'cbNode' callback is invoked for each element. If a callback returns
      * a truthy value, iteration stops and that value is returned. Otherwise, undefined is returned.
      *
      * @param node a given node to visit its children
      * @param cbNode a callback to be invoked for all child nodes
      * @param cbNodes a callback to be invoked for embedded array
      *
      * @remarks `forEachChild` must visit the children of a node in the order
      * that they appear in the source code. The language service depends on this property to locate nodes by position.
      */
    def forEachChild[T](node: Node, cbNode: js.Function1[/* node */ Node, js.UndefOr[T]]): js.UndefOr[T] = js.native
    def forEachChild[T](
      node: Node,
      cbNode: js.Function1[/* node */ Node, js.UndefOr[T]],
      cbNodes: js.Function1[/* nodes */ NodeArray[Node], js.UndefOr[T]]
    ): js.UndefOr[T] = js.native
    
    def forEachLeadingCommentRange[U](
      text: String,
      pos: Double,
      cb: js.Function4[
          /* pos */ Double, 
          /* end */ Double, 
          /* kind */ CommentKind, 
          /* hasTrailingNewLine */ Boolean, 
          U
        ]
    ): js.UndefOr[U] = js.native
    def forEachLeadingCommentRange[T, U](
      text: String,
      pos: Double,
      cb: js.Function5[
          /* pos */ Double, 
          /* end */ Double, 
          /* kind */ CommentKind, 
          /* hasTrailingNewLine */ Boolean, 
          /* state */ T, 
          U
        ],
      state: T
    ): js.UndefOr[U] = js.native
    
    def forEachTrailingCommentRange[U](
      text: String,
      pos: Double,
      cb: js.Function4[
          /* pos */ Double, 
          /* end */ Double, 
          /* kind */ CommentKind, 
          /* hasTrailingNewLine */ Boolean, 
          U
        ]
    ): js.UndefOr[U] = js.native
    def forEachTrailingCommentRange[T, U](
      text: String,
      pos: Double,
      cb: js.Function5[
          /* pos */ Double, 
          /* end */ Double, 
          /* kind */ CommentKind, 
          /* hasTrailingNewLine */ Boolean, 
          /* state */ T, 
          U
        ],
      state: T
    ): js.UndefOr[U] = js.native
    
    def formatDiagnostic(diagnostic: Diagnostic, host: FormatDiagnosticsHost): String = js.native
    
    def formatDiagnostics(diagnostics: js.Array[Diagnostic], host: FormatDiagnosticsHost): String = js.native
    
    def formatDiagnosticsWithColorAndContext(diagnostics: js.Array[Diagnostic], host: FormatDiagnosticsHost): String = js.native
    
    /** Gets all JSDoc tags that match a specified predicate */
    def getAllJSDocTags[T /* <: JSDocTag */](node: Node, predicate: js.Function1[/* tag */ JSDocTag, /* is T */ Boolean]): js.Array[T] = js.native
    
    /** Gets all JSDoc tags of a specified kind */
    def getAllJSDocTagsOfKind(node: Node, kind: SyntaxKind): js.Array[JSDocTag] = js.native
    
    /**
      * Given a set of options, returns the set of type directive names
      *   that should be included for this program automatically.
      * This list could either come from the config file,
      *   or from enumerating the types root + initial secondary types lookup location.
      * More type directives might appear in the program later as a result of loading actual source files;
      *   this list is only the set of defaults that are implicitly included.
      */
    def getAutomaticTypeDirectiveNames(options: CompilerOptions, host: ModuleResolutionHost): js.Array[String] = js.native
    
    def getCombinedModifierFlags(node: Declaration): ModifierFlags = js.native
    
    def getCombinedNodeFlags(node: Node): NodeFlags = js.native
    
    /**
      * Gets a custom text range to use when emitting comments.
      */
    def getCommentRange(node: Node): TextRange = js.native
    
    def getConfigFileParsingDiagnostics(configFileParseResult: ParsedCommandLine): js.Array[Diagnostic] = js.native
    
    /**
      * Gets the constant value to emit for an expression representing an enum.
      */
    def getConstantValue(node: AccessExpression): js.UndefOr[String | Double] = js.native
    
    def getDecorators(node: HasDecorators): js.UndefOr[js.Array[Decorator]] = js.native
    
    def getDefaultCompilerOptions(): CompilerOptions = js.native
    
    def getDefaultFormatCodeSettings(): FormatCodeSettings = js.native
    def getDefaultFormatCodeSettings(newLineCharacter: String): FormatCodeSettings = js.native
    
    def getDefaultLibFileName(options: CompilerOptions): String = js.native
    
    /**
      * Get the path of the default library files (lib.d.ts) as distributed with the typescript
      * node package.
      * The functionality is not supported if the ts module is consumed outside of a node module.
      */
    def getDefaultLibFilePath(options: CompilerOptions): String = js.native
    
    def getEffectiveConstraintOfTypeParameter(node: TypeParameterDeclaration): js.UndefOr[TypeNode] = js.native
    
    /**
      * Gets the effective type parameters. If the node was parsed in a
      * JavaScript file, gets the type parameters from the `@template` tag from JSDoc.
      *
      * This does *not* return type parameters from a jsdoc reference to a generic type, eg
      *
      * type Id = <T>(x: T) => T
      * / ** @type {Id} /
      * function id(x) { return x }
      */
    def getEffectiveTypeParameterDeclarations(node: DeclarationWithTypeParameters): js.Array[TypeParameterDeclaration] = js.native
    
    def getEffectiveTypeRoots(options: CompilerOptions, host: GetEffectiveTypeRootsHost): js.UndefOr[js.Array[String]] = js.native
    
    /**
      * Gets the EmitHelpers of a node.
      */
    def getEmitHelpers(node: Node): js.UndefOr[js.Array[EmitHelper]] = js.native
    
    def getImpliedNodeFormatForFile(fileName: Path, packageJsonInfoCache: Unit, host: ModuleResolutionHost, options: CompilerOptions): ResolutionMode = js.native
    /**
      * A function for determining if a given file is esm or cjs format, assuming modern node module resolution rules, as configured by the
      * `options` parameter.
      *
      * @param fileName The normalized absolute path to check the format of (it need not exist on disk)
      * @param [packageJsonInfoCache] A cache for package file lookups - it's best to have a cache when this function is called often
      * @param host The ModuleResolutionHost which can perform the filesystem lookups for package json data
      * @param options The compiler options to perform the analysis under - relevant options are `moduleResolution` and `traceResolution`
      * @returns `undefined` if the path has no relevant implied format, `ModuleKind.ESNext` for esm format, and `ModuleKind.CommonJS` for cjs format
      */
    def getImpliedNodeFormatForFile(
      fileName: Path,
      packageJsonInfoCache: PackageJsonInfoCache,
      host: ModuleResolutionHost,
      options: CompilerOptions
    ): ResolutionMode = js.native
    
    /** Gets the JSDoc augments tag for the node if present */
    def getJSDocAugmentsTag(node: Node): js.UndefOr[JSDocAugmentsTag] = js.native
    
    /** Gets the JSDoc class tag for the node if present */
    def getJSDocClassTag(node: Node): js.UndefOr[JSDocClassTag] = js.native
    
    /** Gets the JSDoc deprecated tag for the node if present */
    def getJSDocDeprecatedTag(node: Node): js.UndefOr[JSDocDeprecatedTag] = js.native
    
    /** Gets the JSDoc enum tag for the node if present */
    def getJSDocEnumTag(node: Node): js.UndefOr[JSDocEnumTag] = js.native
    
    /** Gets the JSDoc implements tags for the node if present */
    def getJSDocImplementsTags(node: Node): js.Array[JSDocImplementsTag] = js.native
    
    def getJSDocOverrideTagNoCache(node: Node): js.UndefOr[JSDocOverrideTag] = js.native
    
    /**
      * Gets the JSDoc parameter tags for the node if present.
      *
      * @remarks Returns any JSDoc param tag whose name matches the provided
      * parameter, whether a param tag on a containing function
      * expression, or a param tag on a variable declaration whose
      * initializer is the containing function. The tags closest to the
      * node are returned first, so in the previous example, the param
      * tag on the containing function expression would be first.
      *
      * For binding patterns, parameter tags are matched by position.
      */
    def getJSDocParameterTags(param: ParameterDeclaration): js.Array[JSDocParameterTag] = js.native
    
    /** Gets the JSDoc private tag for the node if present */
    def getJSDocPrivateTag(node: Node): js.UndefOr[JSDocPrivateTag] = js.native
    
    /** Gets the JSDoc protected tag for the node if present */
    def getJSDocProtectedTag(node: Node): js.UndefOr[JSDocProtectedTag] = js.native
    
    /** Gets the JSDoc public tag for the node if present */
    def getJSDocPublicTag(node: Node): js.UndefOr[JSDocPublicTag] = js.native
    
    /** Gets the JSDoc protected tag for the node if present */
    def getJSDocReadonlyTag(node: Node): js.UndefOr[JSDocReadonlyTag] = js.native
    
    /** Gets the JSDoc return tag for the node if present */
    def getJSDocReturnTag(node: Node): js.UndefOr[JSDocReturnTag] = js.native
    
    /**
      * Gets the return type node for the node if provided via JSDoc return tag or type tag.
      *
      * @remarks `getJSDocReturnTag` just gets the whole JSDoc tag. This function
      * gets the type from inside the braces, after the fat arrow, etc.
      */
    def getJSDocReturnType(node: Node): js.UndefOr[TypeNode] = js.native
    
    def getJSDocSatisfiesTag(node: Node): js.UndefOr[JSDocSatisfiesTag] = js.native
    
    /** Get all JSDoc tags related to a node, including those on parent nodes. */
    def getJSDocTags(node: Node): js.Array[JSDocTag] = js.native
    
    /** Gets the JSDoc template tag for the node if present */
    def getJSDocTemplateTag(node: Node): js.UndefOr[JSDocTemplateTag] = js.native
    
    /** Gets the JSDoc this tag for the node if present */
    def getJSDocThisTag(node: Node): js.UndefOr[JSDocThisTag] = js.native
    
    /**
      * Gets the type node for the node if provided via JSDoc.
      *
      * @remarks The search includes any JSDoc param tag that relates
      * to the provided parameter, for example a type tag on the
      * parameter itself, or a param tag on a containing function
      * expression, or a param tag on a variable declaration whose
      * initializer is the containing function. The tags closest to the
      * node are examined first, so in the previous example, the type
      * tag directly on the node would be returned.
      */
    def getJSDocType(node: Node): js.UndefOr[TypeNode] = js.native
    
    /**
      * Gets the JSDoc type parameter tags for the node if present.
      *
      * @remarks Returns any JSDoc template tag whose names match the provided
      * parameter, whether a template tag on a containing function
      * expression, or a template tag on a variable declaration whose
      * initializer is the containing function. The tags closest to the
      * node are returned first, so in the previous example, the template
      * tag on the containing function expression would be first.
      */
    def getJSDocTypeParameterTags(param: TypeParameterDeclaration): js.Array[JSDocTemplateTag] = js.native
    
    /** Gets the JSDoc type tag for the node if present and valid */
    def getJSDocTypeTag(node: Node): js.UndefOr[JSDocTypeTag] = js.native
    
    def getLeadingCommentRanges(text: String, pos: Double): js.UndefOr[js.Array[CommentRange]] = js.native
    
    def getLineAndCharacterOfPosition(sourceFile: SourceFileLike, position: Double): LineAndCharacter = js.native
    
    def getModeForFileReference(ref: String, containingFileMode: ResolutionMode): ResolutionMode = js.native
    /**
      * Calculates the resulting resolution mode for some reference in some file - this is generally the explicitly
      * provided resolution mode in the reference, unless one is not present, in which case it is the mode of the containing file.
      */
    def getModeForFileReference(ref: FileReference, containingFileMode: ResolutionMode): ResolutionMode = js.native
    
    /**
      * Calculates the final resolution mode for an import at some index within a file's imports list. This is generally the explicitly
      * defined mode of the import if provided, or, if not, the mode of the containing file (with some exceptions: import=require is always commonjs, dynamic import is always esm).
      * If you have an actual import node, prefer using getModeForUsageLocation on the reference string node.
      * @param file File to fetch the resolution mode within
      * @param index Index into the file's complete resolution list to get the resolution of - this is a concatenation of the file's imports and module augmentations
      */
    def getModeForResolutionAtIndex(file: SourceFile, index: Double): ResolutionMode = js.native
    
    /**
      * Calculates the final resolution mode for a given module reference node. This is generally the explicitly provided resolution mode, if
      * one exists, or the mode of the containing source file. (Excepting import=require, which is always commonjs, and dynamic import, which is always esm).
      * Notably, this function always returns `undefined` if the containing file has an `undefined` `impliedNodeFormat` - this field is only set when
      * `moduleResolution` is `node16`+.
      * @param file The file the import or import-like reference is contained within
      * @param usage The module reference string
      * @returns The final resolution mode of the import
      */
    def getModeForUsageLocation(file: ImpliedNodeFormat, usage: StringLiteralLike): js.UndefOr[CommonJS | ESNext] = js.native
    
    def getModifiers(node: HasModifiers): js.UndefOr[js.Array[Modifier]] = js.native
    
    def getNameOfDeclaration(): js.UndefOr[DeclarationName] = js.native
    def getNameOfDeclaration(declaration: Declaration): js.UndefOr[DeclarationName] = js.native
    def getNameOfDeclaration(declaration: Expression): js.UndefOr[DeclarationName] = js.native
    
    def getNameOfJSDocTypedef(declaration: JSDocTypedefTag): js.UndefOr[Identifier | PrivateIdentifier] = js.native
    
    def getOriginalNode(): js.UndefOr[Node] = js.native
    def getOriginalNode(node: Node): js.UndefOr[Node] = js.native
    def getOriginalNode[T /* <: Node */](node: Unit, nodeTest: js.Function1[/* node */ Node, /* is T */ Boolean]): js.UndefOr[T] = js.native
    def getOriginalNode[T /* <: Node */](node: Node, nodeTest: js.Function1[/* node */ Node, /* is T */ Boolean]): js.UndefOr[T] = js.native
    @JSName("getOriginalNode")
    def getOriginalNode_Node(node: Node): Node = js.native
    @JSName("getOriginalNode")
    def getOriginalNode_T_T[T /* <: Node */](node: Node, nodeTest: js.Function1[/* node */ Node, /* is T */ Boolean]): T = js.native
    
    def getOutputFileNames(commandLine: ParsedCommandLine, inputFileName: String, ignoreCase: Boolean): js.Array[String] = js.native
    
    /**
      * Gets the original parse tree node for a node.
      *
      * @param node The original node.
      * @returns The original parse tree node if found; otherwise, undefined.
      */
    def getParseTreeNode(): js.UndefOr[Node] = js.native
    def getParseTreeNode(node: Node): js.UndefOr[Node] = js.native
    def getParseTreeNode[T /* <: Node */](node: T): js.UndefOr[T] = js.native
    def getParseTreeNode[T /* <: Node */](node: T, nodeTest: js.Function1[/* node */ Node, /* is T */ Boolean]): js.UndefOr[T] = js.native
    def getParseTreeNode[T /* <: Node */](node: Unit, nodeTest: js.Function1[/* node */ Node, /* is T */ Boolean]): js.UndefOr[T] = js.native
    /**
      * Gets the original parse tree node for a node.
      *
      * @param node The original node.
      * @param nodeTest A callback used to ensure the correct type of parse tree node is returned.
      * @returns The original parse tree node if found; otherwise, undefined.
      */
    @JSName("getParseTreeNode")
    def getParseTreeNode_T[T /* <: Node */](): js.UndefOr[T] = js.native
    
    def getParsedCommandLineOfConfigFile(configFileName: String, optionsToExtend: Unit, host: ParseConfigFileHost): js.UndefOr[ParsedCommandLine] = js.native
    def getParsedCommandLineOfConfigFile(
      configFileName: String,
      optionsToExtend: Unit,
      host: ParseConfigFileHost,
      extendedConfigCache: Unit,
      watchOptionsToExtend: Unit,
      extraFileExtensions: js.Array[FileExtensionInfo]
    ): js.UndefOr[ParsedCommandLine] = js.native
    def getParsedCommandLineOfConfigFile(
      configFileName: String,
      optionsToExtend: Unit,
      host: ParseConfigFileHost,
      extendedConfigCache: Unit,
      watchOptionsToExtend: WatchOptions
    ): js.UndefOr[ParsedCommandLine] = js.native
    def getParsedCommandLineOfConfigFile(
      configFileName: String,
      optionsToExtend: Unit,
      host: ParseConfigFileHost,
      extendedConfigCache: Unit,
      watchOptionsToExtend: WatchOptions,
      extraFileExtensions: js.Array[FileExtensionInfo]
    ): js.UndefOr[ParsedCommandLine] = js.native
    def getParsedCommandLineOfConfigFile(
      configFileName: String,
      optionsToExtend: Unit,
      host: ParseConfigFileHost,
      extendedConfigCache: Map[String, ExtendedConfigCacheEntry]
    ): js.UndefOr[ParsedCommandLine] = js.native
    def getParsedCommandLineOfConfigFile(
      configFileName: String,
      optionsToExtend: Unit,
      host: ParseConfigFileHost,
      extendedConfigCache: Map[String, ExtendedConfigCacheEntry],
      watchOptionsToExtend: Unit,
      extraFileExtensions: js.Array[FileExtensionInfo]
    ): js.UndefOr[ParsedCommandLine] = js.native
    def getParsedCommandLineOfConfigFile(
      configFileName: String,
      optionsToExtend: Unit,
      host: ParseConfigFileHost,
      extendedConfigCache: Map[String, ExtendedConfigCacheEntry],
      watchOptionsToExtend: WatchOptions
    ): js.UndefOr[ParsedCommandLine] = js.native
    def getParsedCommandLineOfConfigFile(
      configFileName: String,
      optionsToExtend: Unit,
      host: ParseConfigFileHost,
      extendedConfigCache: Map[String, ExtendedConfigCacheEntry],
      watchOptionsToExtend: WatchOptions,
      extraFileExtensions: js.Array[FileExtensionInfo]
    ): js.UndefOr[ParsedCommandLine] = js.native
    /**
      * Reads the config file, reports errors if any and exits if the config file cannot be found
      */
    def getParsedCommandLineOfConfigFile(configFileName: String, optionsToExtend: CompilerOptions, host: ParseConfigFileHost): js.UndefOr[ParsedCommandLine] = js.native
    def getParsedCommandLineOfConfigFile(
      configFileName: String,
      optionsToExtend: CompilerOptions,
      host: ParseConfigFileHost,
      extendedConfigCache: Unit,
      watchOptionsToExtend: Unit,
      extraFileExtensions: js.Array[FileExtensionInfo]
    ): js.UndefOr[ParsedCommandLine] = js.native
    def getParsedCommandLineOfConfigFile(
      configFileName: String,
      optionsToExtend: CompilerOptions,
      host: ParseConfigFileHost,
      extendedConfigCache: Unit,
      watchOptionsToExtend: WatchOptions
    ): js.UndefOr[ParsedCommandLine] = js.native
    def getParsedCommandLineOfConfigFile(
      configFileName: String,
      optionsToExtend: CompilerOptions,
      host: ParseConfigFileHost,
      extendedConfigCache: Unit,
      watchOptionsToExtend: WatchOptions,
      extraFileExtensions: js.Array[FileExtensionInfo]
    ): js.UndefOr[ParsedCommandLine] = js.native
    def getParsedCommandLineOfConfigFile(
      configFileName: String,
      optionsToExtend: CompilerOptions,
      host: ParseConfigFileHost,
      extendedConfigCache: Map[String, ExtendedConfigCacheEntry]
    ): js.UndefOr[ParsedCommandLine] = js.native
    def getParsedCommandLineOfConfigFile(
      configFileName: String,
      optionsToExtend: CompilerOptions,
      host: ParseConfigFileHost,
      extendedConfigCache: Map[String, ExtendedConfigCacheEntry],
      watchOptionsToExtend: Unit,
      extraFileExtensions: js.Array[FileExtensionInfo]
    ): js.UndefOr[ParsedCommandLine] = js.native
    def getParsedCommandLineOfConfigFile(
      configFileName: String,
      optionsToExtend: CompilerOptions,
      host: ParseConfigFileHost,
      extendedConfigCache: Map[String, ExtendedConfigCacheEntry],
      watchOptionsToExtend: WatchOptions
    ): js.UndefOr[ParsedCommandLine] = js.native
    def getParsedCommandLineOfConfigFile(
      configFileName: String,
      optionsToExtend: CompilerOptions,
      host: ParseConfigFileHost,
      extendedConfigCache: Map[String, ExtendedConfigCacheEntry],
      watchOptionsToExtend: WatchOptions,
      extraFileExtensions: js.Array[FileExtensionInfo]
    ): js.UndefOr[ParsedCommandLine] = js.native
    
    def getPositionOfLineAndCharacter(sourceFile: SourceFileLike, line: Double, character: Double): Double = js.native
    
    def getPreEmitDiagnostics(program: Program): js.Array[Diagnostic] = js.native
    def getPreEmitDiagnostics(program: Program, sourceFile: Unit, cancellationToken: CancellationToken): js.Array[Diagnostic] = js.native
    def getPreEmitDiagnostics(program: Program, sourceFile: SourceFile): js.Array[Diagnostic] = js.native
    def getPreEmitDiagnostics(program: Program, sourceFile: SourceFile, cancellationToken: CancellationToken): js.Array[Diagnostic] = js.native
    
    /** Optionally, get the shebang */
    def getShebang(text: String): js.UndefOr[String] = js.native
    
    /**
      * Gets a custom text range to use when emitting source maps.
      */
    def getSourceMapRange(node: Node): SourceMapRange = js.native
    
    def getSupportedCodeFixes(): js.Array[String] = js.native
    
    def getSyntheticLeadingComments(node: Node): js.UndefOr[js.Array[SynthesizedComment]] = js.native
    
    def getSyntheticTrailingComments(node: Node): js.UndefOr[js.Array[SynthesizedComment]] = js.native
    
    /** Gets the text of a jsdoc comment, flattening links to their text. */
    def getTextOfJSDocComment(): js.UndefOr[String] = js.native
    def getTextOfJSDocComment(comment: String): js.UndefOr[String] = js.native
    def getTextOfJSDocComment(comment: NodeArray[JSDocComment]): js.UndefOr[String] = js.native
    
    /**
      * Gets the TextRange to use for source maps for a token of a node.
      */
    def getTokenSourceMapRange(node: Node, token: SyntaxKind): js.UndefOr[SourceMapRange] = js.native
    
    def getTrailingCommentRanges(text: String, pos: Double): js.UndefOr[js.Array[CommentRange]] = js.native
    
    def getTsBuildInfoEmitOutputFilePath(options: CompilerOptions): js.UndefOr[String] = js.native
    
    def getTypeParameterOwner(d: Declaration): js.UndefOr[Declaration] = js.native
    
    /**
      * Return true if the node has JSDoc parameter tags.
      *
      * @remarks Includes parameter tags that are not directly on the node,
      * for example on a variable declaration whose initializer is a function expression.
      */
    def hasJSDocParameterTags(node: FunctionLikeDeclaration): Boolean = js.native
    def hasJSDocParameterTags(node: SignatureDeclaration): Boolean = js.native
    
    /** True if has initializer node attached to it. */
    def hasOnlyExpressionInitializer(node: Node): /* is typescript.typescript.HasExpressionInitializer */ Boolean = js.native
    
    def hasRestParameter(s: JSDocSignature): Boolean = js.native
    def hasRestParameter(s: SignatureDeclaration): Boolean = js.native
    
    def idText(identifierOrPrivateName: Identifier): String = js.native
    def idText(identifierOrPrivateName: PrivateIdentifier): String = js.native
    
    /**
      * If the text of an Identifier matches a keyword (including contextual and TypeScript-specific keywords), returns the
      * SyntaxKind for the matching keyword.
      */
    def identifierToKeywordKind(node: Identifier): js.UndefOr[KeywordSyntaxKind] = js.native
    
    def isAccessor(node: Node): /* is typescript.typescript.AccessorDeclaration */ Boolean = js.native
    
    def isArrayBindingElement(node: Node): /* is typescript.typescript.ArrayBindingElement */ Boolean = js.native
    
    def isArrayBindingPattern(node: Node): /* is typescript.typescript.ArrayBindingPattern */ Boolean = js.native
    
    def isArrayLiteralExpression(node: Node): /* is typescript.typescript.ArrayLiteralExpression */ Boolean = js.native
    
    def isArrayTypeNode(node: Node): /* is typescript.typescript.ArrayTypeNode */ Boolean = js.native
    
    def isArrowFunction(node: Node): /* is typescript.typescript.ArrowFunction */ Boolean = js.native
    
    def isAsExpression(node: Node): /* is typescript.typescript.AsExpression */ Boolean = js.native
    
    def isAssertClause(node: Node): /* is typescript.typescript.AssertClause */ Boolean = js.native
    
    def isAssertEntry(node: Node): /* is typescript.typescript.AssertEntry */ Boolean = js.native
    
    def isAssertionExpression(node: Node): /* is typescript.typescript.AssertionExpression */ Boolean = js.native
    
    def isAssertionKey(node: Node): /* is typescript.typescript.AssertionKey */ Boolean = js.native
    
    def isAssertsKeyword(node: Node): /* is typescript.typescript.AssertsKeyword */ Boolean = js.native
    
    def isAsteriskToken(node: Node): /* is typescript.typescript.AsteriskToken */ Boolean = js.native
    
    def isAutoAccessorPropertyDeclaration(node: Node): /* is typescript.typescript.AutoAccessorPropertyDeclaration */ Boolean = js.native
    
    def isAwaitExpression(node: Node): /* is typescript.typescript.AwaitExpression */ Boolean = js.native
    
    def isAwaitKeyword(node: Node): /* is typescript.typescript.AwaitKeyword */ Boolean = js.native
    
    def isBigIntLiteral(node: Node): /* is typescript.typescript.BigIntLiteral */ Boolean = js.native
    
    def isBinaryExpression(node: Node): /* is typescript.typescript.BinaryExpression */ Boolean = js.native
    
    def isBinaryOperatorToken(node: Node): /* is typescript.typescript.BinaryOperatorToken */ Boolean = js.native
    
    def isBindingElement(node: Node): /* is typescript.typescript.BindingElement */ Boolean = js.native
    
    def isBindingName(node: Node): /* is typescript.typescript.BindingName */ Boolean = js.native
    
    def isBlock(node: Node): /* is typescript.typescript.Block */ Boolean = js.native
    
    def isBreakOrContinueStatement(node: Node): /* is typescript.typescript.BreakOrContinueStatement */ Boolean = js.native
    
    def isBreakStatement(node: Node): /* is typescript.typescript.BreakStatement */ Boolean = js.native
    
    def isBundle(node: Node): /* is typescript.typescript.Bundle */ Boolean = js.native
    
    def isCallChain(node: Node): /* is typescript.typescript.CallChain */ Boolean = js.native
    
    def isCallExpression(node: Node): /* is typescript.typescript.CallExpression */ Boolean = js.native
    
    def isCallLikeExpression(node: Node): /* is typescript.typescript.CallLikeExpression */ Boolean = js.native
    
    def isCallOrNewExpression(node: Node): Boolean = js.native
    
    def isCallSignatureDeclaration(node: Node): /* is typescript.typescript.CallSignatureDeclaration */ Boolean = js.native
    
    def isCaseBlock(node: Node): /* is typescript.typescript.CaseBlock */ Boolean = js.native
    
    def isCaseClause(node: Node): /* is typescript.typescript.CaseClause */ Boolean = js.native
    
    def isCaseOrDefaultClause(node: Node): /* is typescript.typescript.CaseOrDefaultClause */ Boolean = js.native
    
    def isCatchClause(node: Node): /* is typescript.typescript.CatchClause */ Boolean = js.native
    
    def isClassDeclaration(node: Node): /* is typescript.typescript.ClassDeclaration */ Boolean = js.native
    
    def isClassElement(node: Node): /* is typescript.typescript.ClassElement */ Boolean = js.native
    
    def isClassExpression(node: Node): /* is typescript.typescript.ClassExpression */ Boolean = js.native
    
    def isClassLike(node: Node): /* is typescript.typescript.ClassLikeDeclaration */ Boolean = js.native
    
    def isClassOrTypeElement(node: Node): Boolean = js.native
    
    def isClassStaticBlockDeclaration(node: Node): /* is typescript.typescript.ClassStaticBlockDeclaration */ Boolean = js.native
    
    def isColonToken(node: Node): /* is typescript.typescript.ColonToken */ Boolean = js.native
    
    def isCommaListExpression(node: Node): /* is typescript.typescript.CommaListExpression */ Boolean = js.native
    
    def isComputedPropertyName(node: Node): /* is typescript.typescript.ComputedPropertyName */ Boolean = js.native
    
    def isConciseBody(node: Node): /* is typescript.typescript.ConciseBody */ Boolean = js.native
    
    def isConditionalExpression(node: Node): /* is typescript.typescript.ConditionalExpression */ Boolean = js.native
    
    def isConditionalTypeNode(node: Node): /* is typescript.typescript.ConditionalTypeNode */ Boolean = js.native
    
    def isConstTypeReference(node: Node): Boolean = js.native
    
    def isConstructSignatureDeclaration(node: Node): /* is typescript.typescript.ConstructSignatureDeclaration */ Boolean = js.native
    
    def isConstructorDeclaration(node: Node): /* is typescript.typescript.ConstructorDeclaration */ Boolean = js.native
    
    def isConstructorTypeNode(node: Node): /* is typescript.typescript.ConstructorTypeNode */ Boolean = js.native
    
    def isContinueStatement(node: Node): /* is typescript.typescript.ContinueStatement */ Boolean = js.native
    
    def isDebuggerStatement(node: Node): /* is typescript.typescript.DebuggerStatement */ Boolean = js.native
    
    def isDecorator(node: Node): /* is typescript.typescript.Decorator */ Boolean = js.native
    
    def isDefaultClause(node: Node): /* is typescript.typescript.DefaultClause */ Boolean = js.native
    
    def isDeleteExpression(node: Node): /* is typescript.typescript.DeleteExpression */ Boolean = js.native
    
    def isDoStatement(node: Node): /* is typescript.typescript.DoStatement */ Boolean = js.native
    
    def isDotDotDotToken(node: Node): /* is typescript.typescript.DotDotDotToken */ Boolean = js.native
    
    def isElementAccessChain(node: Node): /* is typescript.typescript.ElementAccessChain */ Boolean = js.native
    
    def isElementAccessExpression(node: Node): /* is typescript.typescript.ElementAccessExpression */ Boolean = js.native
    
    def isEmptyBindingElement(node: ArrayBindingElement): Boolean = js.native
    def isEmptyBindingElement(node: BindingElement): Boolean = js.native
    
    def isEmptyBindingPattern(node: BindingName): /* is typescript.typescript.BindingPattern */ Boolean = js.native
    
    def isEmptyStatement(node: Node): /* is typescript.typescript.EmptyStatement */ Boolean = js.native
    
    def isEntityName(node: Node): /* is typescript.typescript.EntityName */ Boolean = js.native
    
    def isEnumDeclaration(node: Node): /* is typescript.typescript.EnumDeclaration */ Boolean = js.native
    
    def isEnumMember(node: Node): /* is typescript.typescript.EnumMember */ Boolean = js.native
    
    def isEqualsGreaterThanToken(node: Node): /* is typescript.typescript.EqualsGreaterThanToken */ Boolean = js.native
    
    def isExclamationToken(node: Node): /* is typescript.typescript.ExclamationToken */ Boolean = js.native
    
    def isExportAssignment(node: Node): /* is typescript.typescript.ExportAssignment */ Boolean = js.native
    
    def isExportDeclaration(node: Node): /* is typescript.typescript.ExportDeclaration */ Boolean = js.native
    
    def isExportSpecifier(node: Node): /* is typescript.typescript.ExportSpecifier */ Boolean = js.native
    
    /**
      * Determines whether a node is an expression based only on its kind.
      */
    def isExpression(node: Node): /* is typescript.typescript.Expression */ Boolean = js.native
    
    def isExpressionStatement(node: Node): /* is typescript.typescript.ExpressionStatement */ Boolean = js.native
    
    def isExpressionWithTypeArguments(node: Node): /* is typescript.typescript.ExpressionWithTypeArguments */ Boolean = js.native
    
    def isExternalModule(file: SourceFile): Boolean = js.native
    
    def isExternalModuleNameRelative(moduleName: String): Boolean = js.native
    
    def isExternalModuleReference(node: Node): /* is typescript.typescript.ExternalModuleReference */ Boolean = js.native
    
    def isForInStatement(node: Node): /* is typescript.typescript.ForInStatement */ Boolean = js.native
    
    def isForInitializer(node: Node): /* is typescript.typescript.ForInitializer */ Boolean = js.native
    
    def isForOfStatement(node: Node): /* is typescript.typescript.ForOfStatement */ Boolean = js.native
    
    def isForStatement(node: Node): /* is typescript.typescript.ForStatement */ Boolean = js.native
    
    def isFunctionDeclaration(node: Node): /* is typescript.typescript.FunctionDeclaration */ Boolean = js.native
    
    def isFunctionExpression(node: Node): /* is typescript.typescript.FunctionExpression */ Boolean = js.native
    
    def isFunctionLike(): /* is typescript.typescript.SignatureDeclaration */ Boolean = js.native
    def isFunctionLike(node: Node): /* is typescript.typescript.SignatureDeclaration */ Boolean = js.native
    
    def isFunctionOrConstructorTypeNode(node: Node): Boolean = js.native
    
    def isFunctionTypeNode(node: Node): /* is typescript.typescript.FunctionTypeNode */ Boolean = js.native
    
    def isGetAccessor(node: Node): /* is typescript.typescript.GetAccessorDeclaration */ Boolean = js.native
    
    def isGetAccessorDeclaration(node: Node): /* is typescript.typescript.GetAccessorDeclaration */ Boolean = js.native
    
    def isHeritageClause(node: Node): /* is typescript.typescript.HeritageClause */ Boolean = js.native
    
    def isIdentifier(node: Node): /* is typescript.typescript.Identifier */ Boolean = js.native
    
    def isIdentifierOrThisTypeNode(node: Node): Boolean = js.native
    
    def isIdentifierPart(ch: Double): Boolean = js.native
    def isIdentifierPart(ch: Double, languageVersion: Unit, identifierVariant: LanguageVariant): Boolean = js.native
    def isIdentifierPart(ch: Double, languageVersion: ScriptTarget): Boolean = js.native
    def isIdentifierPart(ch: Double, languageVersion: ScriptTarget, identifierVariant: LanguageVariant): Boolean = js.native
    
    def isIdentifierStart(ch: Double): Boolean = js.native
    def isIdentifierStart(ch: Double, languageVersion: ScriptTarget): Boolean = js.native
    
    def isIfStatement(node: Node): /* is typescript.typescript.IfStatement */ Boolean = js.native
    
    def isImportClause(node: Node): /* is typescript.typescript.ImportClause */ Boolean = js.native
    
    def isImportDeclaration(node: Node): /* is typescript.typescript.ImportDeclaration */ Boolean = js.native
    
    def isImportEqualsDeclaration(node: Node): /* is typescript.typescript.ImportEqualsDeclaration */ Boolean = js.native
    
    def isImportOrExportSpecifier(node: Node): Boolean = js.native
    
    def isImportSpecifier(node: Node): /* is typescript.typescript.ImportSpecifier */ Boolean = js.native
    
    def isImportTypeAssertionContainer(node: Node): /* is typescript.typescript.ImportTypeAssertionContainer */ Boolean = js.native
    
    def isImportTypeNode(node: Node): /* is typescript.typescript.ImportTypeNode */ Boolean = js.native
    
    def isIndexSignatureDeclaration(node: Node): /* is typescript.typescript.IndexSignatureDeclaration */ Boolean = js.native
    
    def isIndexedAccessTypeNode(node: Node): /* is typescript.typescript.IndexedAccessTypeNode */ Boolean = js.native
    
    def isInferTypeNode(node: Node): /* is typescript.typescript.InferTypeNode */ Boolean = js.native
    
    def isInterfaceDeclaration(node: Node): /* is typescript.typescript.InterfaceDeclaration */ Boolean = js.native
    
    def isIntersectionTypeNode(node: Node): /* is typescript.typescript.IntersectionTypeNode */ Boolean = js.native
    
    def isIterationStatement(node: Node, lookInLabeledStatements: Boolean): Boolean = js.native
    @JSName("isIterationStatement")
    def isIterationStatement_false(node: Node, lookInLabeledStatements: `false`): /* is typescript.typescript.IterationStatement */ Boolean = js.native
    
    def isJSDoc(node: Node): /* is typescript.typescript.JSDoc */ Boolean = js.native
    
    def isJSDocAllType(node: Node): /* is typescript.typescript.JSDocAllType */ Boolean = js.native
    
    def isJSDocAugmentsTag(node: Node): /* is typescript.typescript.JSDocAugmentsTag */ Boolean = js.native
    
    def isJSDocAuthorTag(node: Node): /* is typescript.typescript.JSDocAuthorTag */ Boolean = js.native
    
    def isJSDocCallbackTag(node: Node): /* is typescript.typescript.JSDocCallbackTag */ Boolean = js.native
    
    def isJSDocClassTag(node: Node): /* is typescript.typescript.JSDocClassTag */ Boolean = js.native
    
    /** True if node is of a kind that may contain comment text. */
    def isJSDocCommentContainingNode(node: Node): Boolean = js.native
    
    def isJSDocDeprecatedTag(node: Node): /* is typescript.typescript.JSDocDeprecatedTag */ Boolean = js.native
    
    def isJSDocEnumTag(node: Node): /* is typescript.typescript.JSDocEnumTag */ Boolean = js.native
    
    def isJSDocFunctionType(node: Node): /* is typescript.typescript.JSDocFunctionType */ Boolean = js.native
    
    def isJSDocImplementsTag(node: Node): /* is typescript.typescript.JSDocImplementsTag */ Boolean = js.native
    
    def isJSDocLink(node: Node): /* is typescript.typescript.JSDocLink */ Boolean = js.native
    
    def isJSDocLinkCode(node: Node): /* is typescript.typescript.JSDocLinkCode */ Boolean = js.native
    
    def isJSDocLinkLike(node: Node): Boolean = js.native
    
    def isJSDocLinkPlain(node: Node): /* is typescript.typescript.JSDocLinkPlain */ Boolean = js.native
    
    def isJSDocMemberName(node: Node): /* is typescript.typescript.JSDocMemberName */ Boolean = js.native
    
    def isJSDocNameReference(node: Node): /* is typescript.typescript.JSDocNameReference */ Boolean = js.native
    
    def isJSDocNamepathType(node: Node): /* is typescript.typescript.JSDocNamepathType */ Boolean = js.native
    
    def isJSDocNonNullableType(node: Node): /* is typescript.typescript.JSDocNonNullableType */ Boolean = js.native
    
    def isJSDocNullableType(node: Node): /* is typescript.typescript.JSDocNullableType */ Boolean = js.native
    
    def isJSDocOptionalType(node: Node): /* is typescript.typescript.JSDocOptionalType */ Boolean = js.native
    
    def isJSDocOverloadTag(node: Node): /* is typescript.typescript.JSDocOverloadTag */ Boolean = js.native
    
    def isJSDocOverrideTag(node: Node): /* is typescript.typescript.JSDocOverrideTag */ Boolean = js.native
    
    def isJSDocParameterTag(node: Node): /* is typescript.typescript.JSDocParameterTag */ Boolean = js.native
    
    def isJSDocPrivateTag(node: Node): /* is typescript.typescript.JSDocPrivateTag */ Boolean = js.native
    
    def isJSDocPropertyLikeTag(node: Node): /* is typescript.typescript.JSDocPropertyLikeTag */ Boolean = js.native
    
    def isJSDocPropertyTag(node: Node): /* is typescript.typescript.JSDocPropertyTag */ Boolean = js.native
    
    def isJSDocProtectedTag(node: Node): /* is typescript.typescript.JSDocProtectedTag */ Boolean = js.native
    
    def isJSDocPublicTag(node: Node): /* is typescript.typescript.JSDocPublicTag */ Boolean = js.native
    
    def isJSDocReadonlyTag(node: Node): /* is typescript.typescript.JSDocReadonlyTag */ Boolean = js.native
    
    def isJSDocReturnTag(node: Node): /* is typescript.typescript.JSDocReturnTag */ Boolean = js.native
    
    def isJSDocSatisfiesTag(node: Node): /* is typescript.typescript.JSDocSatisfiesTag */ Boolean = js.native
    
    def isJSDocSeeTag(node: Node): /* is typescript.typescript.JSDocSeeTag */ Boolean = js.native
    
    def isJSDocSignature(node: Node): /* is typescript.typescript.JSDocSignature */ Boolean = js.native
    
    def isJSDocTemplateTag(node: Node): /* is typescript.typescript.JSDocTemplateTag */ Boolean = js.native
    
    def isJSDocThisTag(node: Node): /* is typescript.typescript.JSDocThisTag */ Boolean = js.native
    
    def isJSDocThrowsTag(node: Node): /* is typescript.typescript.JSDocThrowsTag */ Boolean = js.native
    
    def isJSDocTypeExpression(node: Node): /* is typescript.typescript.JSDocTypeExpression */ Boolean = js.native
    
    def isJSDocTypeLiteral(node: Node): /* is typescript.typescript.JSDocTypeLiteral */ Boolean = js.native
    
    def isJSDocTypeTag(node: Node): /* is typescript.typescript.JSDocTypeTag */ Boolean = js.native
    
    def isJSDocTypedefTag(node: Node): /* is typescript.typescript.JSDocTypedefTag */ Boolean = js.native
    
    def isJSDocUnknownTag(node: Node): /* is typescript.typescript.JSDocUnknownTag */ Boolean = js.native
    
    def isJSDocUnknownType(node: Node): /* is typescript.typescript.JSDocUnknownType */ Boolean = js.native
    
    def isJSDocVariadicType(node: Node): /* is typescript.typescript.JSDocVariadicType */ Boolean = js.native
    
    def isJsxAttribute(node: Node): /* is typescript.typescript.JsxAttribute */ Boolean = js.native
    
    def isJsxAttributeLike(node: Node): /* is typescript.typescript.JsxAttributeLike */ Boolean = js.native
    
    def isJsxAttributes(node: Node): /* is typescript.typescript.JsxAttributes */ Boolean = js.native
    
    def isJsxChild(node: Node): /* is typescript.typescript.JsxChild */ Boolean = js.native
    
    def isJsxClosingElement(node: Node): /* is typescript.typescript.JsxClosingElement */ Boolean = js.native
    
    def isJsxClosingFragment(node: Node): /* is typescript.typescript.JsxClosingFragment */ Boolean = js.native
    
    def isJsxElement(node: Node): /* is typescript.typescript.JsxElement */ Boolean = js.native
    
    def isJsxExpression(node: Node): /* is typescript.typescript.JsxExpression */ Boolean = js.native
    
    def isJsxFragment(node: Node): /* is typescript.typescript.JsxFragment */ Boolean = js.native
    
    def isJsxOpeningElement(node: Node): /* is typescript.typescript.JsxOpeningElement */ Boolean = js.native
    
    def isJsxOpeningFragment(node: Node): /* is typescript.typescript.JsxOpeningFragment */ Boolean = js.native
    
    def isJsxOpeningLikeElement(node: Node): /* is typescript.typescript.JsxOpeningLikeElement */ Boolean = js.native
    
    def isJsxSelfClosingElement(node: Node): /* is typescript.typescript.JsxSelfClosingElement */ Boolean = js.native
    
    def isJsxSpreadAttribute(node: Node): /* is typescript.typescript.JsxSpreadAttribute */ Boolean = js.native
    
    def isJsxTagNameExpression(node: Node): /* is typescript.typescript.JsxTagNameExpression */ Boolean = js.native
    
    def isJsxText(node: Node): /* is typescript.typescript.JsxText */ Boolean = js.native
    
    def isLabeledStatement(node: Node): /* is typescript.typescript.LabeledStatement */ Boolean = js.native
    
    def isLeftHandSideExpression(node: Node): /* is typescript.typescript.LeftHandSideExpression */ Boolean = js.native
    
    def isLineBreak(ch: Double): Boolean = js.native
    
    def isLiteralExpression(node: Node): /* is typescript.typescript.LiteralExpression */ Boolean = js.native
    
    def isLiteralTypeLiteral(node: Node): Boolean = js.native
    
    def isLiteralTypeNode(node: Node): /* is typescript.typescript.LiteralTypeNode */ Boolean = js.native
    
    def isMappedTypeNode(node: Node): /* is typescript.typescript.MappedTypeNode */ Boolean = js.native
    
    def isMemberName(node: Node): /* is typescript.typescript.MemberName */ Boolean = js.native
    
    def isMetaProperty(node: Node): /* is typescript.typescript.MetaProperty */ Boolean = js.native
    
    def isMethodDeclaration(node: Node): /* is typescript.typescript.MethodDeclaration */ Boolean = js.native
    
    def isMethodSignature(node: Node): /* is typescript.typescript.MethodSignature */ Boolean = js.native
    
    def isMinusToken(node: Node): /* is typescript.typescript.MinusToken */ Boolean = js.native
    
    def isMissingDeclaration(node: Node): /* is typescript.typescript.MissingDeclaration */ Boolean = js.native
    
    def isModifier(node: Node): /* is typescript.typescript.Modifier */ Boolean = js.native
    
    def isModifierLike(node: Node): /* is typescript.typescript.ModifierLike */ Boolean = js.native
    
    def isModuleBlock(node: Node): /* is typescript.typescript.ModuleBlock */ Boolean = js.native
    
    def isModuleBody(node: Node): /* is typescript.typescript.ModuleBody */ Boolean = js.native
    
    def isModuleDeclaration(node: Node): /* is typescript.typescript.ModuleDeclaration */ Boolean = js.native
    
    def isModuleName(node: Node): /* is typescript.typescript.ModuleName */ Boolean = js.native
    
    def isModuleReference(node: Node): /* is typescript.typescript.ModuleReference */ Boolean = js.native
    
    def isNamedExportBindings(node: Node): /* is typescript.typescript.NamedExportBindings */ Boolean = js.native
    
    def isNamedExports(node: Node): /* is typescript.typescript.NamedExports */ Boolean = js.native
    
    def isNamedImportBindings(node: Node): /* is typescript.typescript.NamedImportBindings */ Boolean = js.native
    
    def isNamedImports(node: Node): /* is typescript.typescript.NamedImports */ Boolean = js.native
    
    def isNamedTupleMember(node: Node): /* is typescript.typescript.NamedTupleMember */ Boolean = js.native
    
    def isNamespaceExport(node: Node): /* is typescript.typescript.NamespaceExport */ Boolean = js.native
    
    def isNamespaceExportDeclaration(node: Node): /* is typescript.typescript.NamespaceExportDeclaration */ Boolean = js.native
    
    def isNamespaceImport(node: Node): /* is typescript.typescript.NamespaceImport */ Boolean = js.native
    
    def isNewExpression(node: Node): /* is typescript.typescript.NewExpression */ Boolean = js.native
    
    def isNoSubstitutionTemplateLiteral(node: Node): /* is typescript.typescript.NoSubstitutionTemplateLiteral */ Boolean = js.native
    
    def isNonNullChain(node: Node): /* is typescript.typescript.NonNullChain */ Boolean = js.native
    
    def isNonNullExpression(node: Node): /* is typescript.typescript.NonNullExpression */ Boolean = js.native
    
    def isNotEmittedStatement(node: Node): /* is typescript.typescript.NotEmittedStatement */ Boolean = js.native
    
    def isNullishCoalesce(node: Node): Boolean = js.native
    
    def isNumericLiteral(node: Node): /* is typescript.typescript.NumericLiteral */ Boolean = js.native
    
    def isObjectBindingPattern(node: Node): /* is typescript.typescript.ObjectBindingPattern */ Boolean = js.native
    
    def isObjectLiteralElement(node: Node): /* is typescript.typescript.ObjectLiteralElement */ Boolean = js.native
    
    def isObjectLiteralElementLike(node: Node): /* is typescript.typescript.ObjectLiteralElementLike */ Boolean = js.native
    
    def isObjectLiteralExpression(node: Node): /* is typescript.typescript.ObjectLiteralExpression */ Boolean = js.native
    
    def isOmittedExpression(node: Node): /* is typescript.typescript.OmittedExpression */ Boolean = js.native
    
    def isOptionalChain(node: Node): Boolean = js.native
    
    def isOptionalTypeNode(node: Node): /* is typescript.typescript.OptionalTypeNode */ Boolean = js.native
    
    def isParameter(node: Node): /* is typescript.typescript.ParameterDeclaration */ Boolean = js.native
    
    def isParameterPropertyDeclaration(node: Node, parent: Node): /* is typescript.typescript.ParameterPropertyDeclaration */ Boolean = js.native
    
    def isParenthesizedExpression(node: Node): /* is typescript.typescript.ParenthesizedExpression */ Boolean = js.native
    
    def isParenthesizedTypeNode(node: Node): /* is typescript.typescript.ParenthesizedTypeNode */ Boolean = js.native
    
    /**
      * Gets a value indicating whether a node originated in the parse tree.
      *
      * @param node The node to test.
      */
    def isParseTreeNode(node: Node): Boolean = js.native
    
    def isPartiallyEmittedExpression(node: Node): /* is typescript.typescript.PartiallyEmittedExpression */ Boolean = js.native
    
    def isPlusToken(node: Node): /* is typescript.typescript.PlusToken */ Boolean = js.native
    
    def isPostfixUnaryExpression(node: Node): /* is typescript.typescript.PostfixUnaryExpression */ Boolean = js.native
    
    def isPrefixUnaryExpression(node: Node): /* is typescript.typescript.PrefixUnaryExpression */ Boolean = js.native
    
    def isPrivateIdentifier(node: Node): /* is typescript.typescript.PrivateIdentifier */ Boolean = js.native
    
    def isPropertyAccessChain(node: Node): /* is typescript.typescript.PropertyAccessChain */ Boolean = js.native
    
    def isPropertyAccessExpression(node: Node): /* is typescript.typescript.PropertyAccessExpression */ Boolean = js.native
    
    def isPropertyAccessOrQualifiedName(node: Node): Boolean = js.native
    
    def isPropertyAssignment(node: Node): /* is typescript.typescript.PropertyAssignment */ Boolean = js.native
    
    def isPropertyDeclaration(node: Node): /* is typescript.typescript.PropertyDeclaration */ Boolean = js.native
    
    def isPropertyName(node: Node): /* is typescript.typescript.PropertyName */ Boolean = js.native
    
    def isPropertySignature(node: Node): /* is typescript.typescript.PropertySignature */ Boolean = js.native
    
    def isQualifiedName(node: Node): /* is typescript.typescript.QualifiedName */ Boolean = js.native
    
    def isQuestionDotToken(node: Node): /* is typescript.typescript.QuestionDotToken */ Boolean = js.native
    
    def isQuestionOrExclamationToken(node: Node): Boolean = js.native
    
    def isQuestionOrPlusOrMinusToken(node: Node): Boolean = js.native
    
    def isQuestionToken(node: Node): /* is typescript.typescript.QuestionToken */ Boolean = js.native
    
    def isReadonlyKeywordOrPlusOrMinusToken(node: Node): Boolean = js.native
    
    def isRegularExpressionLiteral(node: Node): /* is typescript.typescript.RegularExpressionLiteral */ Boolean = js.native
    
    def isRestParameter(node: JSDocParameterTag): Boolean = js.native
    def isRestParameter(node: ParameterDeclaration): Boolean = js.native
    
    def isRestTypeNode(node: Node): /* is typescript.typescript.RestTypeNode */ Boolean = js.native
    
    def isReturnStatement(node: Node): /* is typescript.typescript.ReturnStatement */ Boolean = js.native
    
    def isSatisfiesExpression(node: Node): /* is typescript.typescript.SatisfiesExpression */ Boolean = js.native
    
    def isSemicolonClassElement(node: Node): /* is typescript.typescript.SemicolonClassElement */ Boolean = js.native
    
    def isSetAccessor(node: Node): /* is typescript.typescript.SetAccessorDeclaration */ Boolean = js.native
    
    def isSetAccessorDeclaration(node: Node): /* is typescript.typescript.SetAccessorDeclaration */ Boolean = js.native
    
    def isShorthandPropertyAssignment(node: Node): /* is typescript.typescript.ShorthandPropertyAssignment */ Boolean = js.native
    
    def isSourceFile(node: Node): /* is typescript.typescript.SourceFile */ Boolean = js.native
    
    def isSpreadAssignment(node: Node): /* is typescript.typescript.SpreadAssignment */ Boolean = js.native
    
    def isSpreadElement(node: Node): /* is typescript.typescript.SpreadElement */ Boolean = js.native
    
    def isStatement(node: Node): /* is typescript.typescript.Statement */ Boolean = js.native
    
    def isStringLiteral(node: Node): /* is typescript.typescript.StringLiteral */ Boolean = js.native
    
    def isStringLiteralLike(node: FileReference): /* is typescript.typescript.StringLiteralLike */ Boolean = js.native
    def isStringLiteralLike(node: Node): /* is typescript.typescript.StringLiteralLike */ Boolean = js.native
    
    def isStringLiteralOrJsxExpression(node: Node): Boolean = js.native
    
    def isStringTextContainingNode(node: Node): Boolean = js.native
    
    def isSwitchStatement(node: Node): /* is typescript.typescript.SwitchStatement */ Boolean = js.native
    
    def isSyntheticExpression(node: Node): /* is typescript.typescript.SyntheticExpression */ Boolean = js.native
    
    def isTaggedTemplateExpression(node: Node): /* is typescript.typescript.TaggedTemplateExpression */ Boolean = js.native
    
    def isTemplateExpression(node: Node): /* is typescript.typescript.TemplateExpression */ Boolean = js.native
    
    def isTemplateHead(node: Node): /* is typescript.typescript.TemplateHead */ Boolean = js.native
    
    def isTemplateLiteral(node: Node): /* is typescript.typescript.TemplateLiteral */ Boolean = js.native
    
    def isTemplateLiteralToken(node: Node): /* is typescript.typescript.TemplateLiteralToken */ Boolean = js.native
    
    def isTemplateLiteralTypeNode(node: Node): /* is typescript.typescript.TemplateLiteralTypeNode */ Boolean = js.native
    
    def isTemplateLiteralTypeSpan(node: Node): /* is typescript.typescript.TemplateLiteralTypeSpan */ Boolean = js.native
    
    def isTemplateMiddle(node: Node): /* is typescript.typescript.TemplateMiddle */ Boolean = js.native
    
    def isTemplateMiddleOrTemplateTail(node: Node): Boolean = js.native
    
    def isTemplateSpan(node: Node): /* is typescript.typescript.TemplateSpan */ Boolean = js.native
    
    def isTemplateTail(node: Node): /* is typescript.typescript.TemplateTail */ Boolean = js.native
    
    def isThisTypeNode(node: Node): /* is typescript.typescript.ThisTypeNode */ Boolean = js.native
    
    def isThrowStatement(node: Node): /* is typescript.typescript.ThrowStatement */ Boolean = js.native
    
    /**
      * True if node is of some token syntax kind.
      * For example, this is true for an IfKeyword but not for an IfStatement.
      * Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.
      */
    def isToken(n: Node): Boolean = js.native
    
    /**
      * True if kind is of some token syntax kind.
      * For example, this is true for an IfKeyword but not for an IfStatement.
      * Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.
      */
    def isTokenKind(kind: SyntaxKind): Boolean = js.native
    
    def isTryStatement(node: Node): /* is typescript.typescript.TryStatement */ Boolean = js.native
    
    def isTupleTypeNode(node: Node): /* is typescript.typescript.TupleTypeNode */ Boolean = js.native
    
    def isTypeAliasDeclaration(node: Node): /* is typescript.typescript.TypeAliasDeclaration */ Boolean = js.native
    
    def isTypeAssertionExpression(node: Node): /* is typescript.typescript.TypeAssertion */ Boolean = js.native
    
    def isTypeElement(node: Node): /* is typescript.typescript.TypeElement */ Boolean = js.native
    
    def isTypeLiteralNode(node: Node): /* is typescript.typescript.TypeLiteralNode */ Boolean = js.native
    
    /**
      * Node test that determines whether a node is a valid type node.
      * This differs from the `isPartOfTypeNode` function which determines whether a node is *part*
      * of a TypeNode.
      */
    def isTypeNode(node: Node): /* is typescript.typescript.TypeNode */ Boolean = js.native
    
    def isTypeOfExpression(node: Node): /* is typescript.typescript.TypeOfExpression */ Boolean = js.native
    
    def isTypeOnlyExportDeclaration(node: Node): /* is typescript.typescript.TypeOnlyExportDeclaration */ Boolean = js.native
    
    def isTypeOnlyImportDeclaration(node: Node): /* is typescript.typescript.TypeOnlyImportDeclaration */ Boolean = js.native
    
    def isTypeOnlyImportOrExportDeclaration(node: Node): /* is typescript.typescript.TypeOnlyAliasDeclaration */ Boolean = js.native
    
    def isTypeOperatorNode(node: Node): /* is typescript.typescript.TypeOperatorNode */ Boolean = js.native
    
    def isTypeParameterDeclaration(node: Node): /* is typescript.typescript.TypeParameterDeclaration */ Boolean = js.native
    
    def isTypePredicateNode(node: Node): /* is typescript.typescript.TypePredicateNode */ Boolean = js.native
    
    def isTypeQueryNode(node: Node): /* is typescript.typescript.TypeQueryNode */ Boolean = js.native
    
    def isTypeReferenceNode(node: Node): /* is typescript.typescript.TypeReferenceNode */ Boolean = js.native
    
    def isUnionTypeNode(node: Node): /* is typescript.typescript.UnionTypeNode */ Boolean = js.native
    
    /** @deprecated */
    def isUnparsedNode(node: Node): /* is typescript.typescript.UnparsedNode */ Boolean = js.native
    
    /** @deprecated */
    def isUnparsedPrepend(node: Node): /* is typescript.typescript.UnparsedPrepend */ Boolean = js.native
    
    /** @deprecated */
    def isUnparsedSource(node: Node): /* is typescript.typescript.UnparsedSource */ Boolean = js.native
    
    /** @deprecated */
    def isUnparsedTextLike(node: Node): /* is typescript.typescript.UnparsedTextLike */ Boolean = js.native
    
    def isVariableDeclaration(node: Node): /* is typescript.typescript.VariableDeclaration */ Boolean = js.native
    
    def isVariableDeclarationList(node: Node): /* is typescript.typescript.VariableDeclarationList */ Boolean = js.native
    
    def isVariableStatement(node: Node): /* is typescript.typescript.VariableStatement */ Boolean = js.native
    
    def isVoidExpression(node: Node): /* is typescript.typescript.VoidExpression */ Boolean = js.native
    
    def isWhileStatement(node: Node): /* is typescript.typescript.WhileStatement */ Boolean = js.native
    
    def isWhiteSpaceLike(ch: Double): Boolean = js.native
    
    /** Does not include line breaks. For that, see isWhiteSpaceLike. */
    def isWhiteSpaceSingleLine(ch: Double): Boolean = js.native
    
    def isWithStatement(node: Node): /* is typescript.typescript.WithStatement */ Boolean = js.native
    
    def isYieldExpression(node: Node): /* is typescript.typescript.YieldExpression */ Boolean = js.native
    
    /**
      * Moves matching emit helpers from a source node to a target node.
      */
    def moveEmitHelpers(source: Node, target: Node, predicate: js.Function1[/* helper */ EmitHelper, Boolean]): Unit = js.native
    
    def moveSyntheticComments[T /* <: Node */](node: T, original: Node): T = js.native
    
    def nodeModuleNameResolver(
      moduleName: String,
      containingFile: String,
      compilerOptions: CompilerOptions,
      host: ModuleResolutionHost
    ): ResolvedModuleWithFailedLookupLocations = js.native
    def nodeModuleNameResolver(
      moduleName: String,
      containingFile: String,
      compilerOptions: CompilerOptions,
      host: ModuleResolutionHost,
      cache: Unit,
      redirectedReference: ResolvedProjectReference
    ): ResolvedModuleWithFailedLookupLocations = js.native
    def nodeModuleNameResolver(
      moduleName: String,
      containingFile: String,
      compilerOptions: CompilerOptions,
      host: ModuleResolutionHost,
      cache: ModuleResolutionCache
    ): ResolvedModuleWithFailedLookupLocations = js.native
    def nodeModuleNameResolver(
      moduleName: String,
      containingFile: String,
      compilerOptions: CompilerOptions,
      host: ModuleResolutionHost,
      cache: ModuleResolutionCache,
      redirectedReference: ResolvedProjectReference
    ): ResolvedModuleWithFailedLookupLocations = js.native
    
    def parseCommandLine(commandLine: js.Array[String]): ParsedCommandLine = js.native
    def parseCommandLine(commandLine: js.Array[String], readFile: js.Function1[/* path */ String, js.UndefOr[String]]): ParsedCommandLine = js.native
    
    /**
      * Parse the text of the tsconfig.json file
      * @param fileName The path to the config file
      * @param jsonText The text of the config file
      */
    def parseConfigFileTextToJson(fileName: String, jsonText: String): Config = js.native
    
    def parseIsolatedEntityName(text: String, languageVersion: ScriptTarget): js.UndefOr[EntityName] = js.native
    
    /**
      * Parse the contents of a config file (tsconfig.json).
      * @param json The contents of the config file to parse
      * @param host Instance of ParseConfigHost used to enumerate files in folder.
      * @param basePath A root directory to resolve relative path entries in the config
      *    file to. e.g. outDir
      */
    def parseJsonConfigFileContent(
      json: Any,
      host: ParseConfigHost,
      basePath: String,
      existingOptions: js.UndefOr[CompilerOptions],
      configFileName: js.UndefOr[String],
      resolutionStack: js.UndefOr[js.Array[Path]],
      extraFileExtensions: js.UndefOr[js.Array[FileExtensionInfo]],
      extendedConfigCache: js.UndefOr[Map[String, ExtendedConfigCacheEntry]],
      existingWatchOptions: js.UndefOr[WatchOptions]
    ): ParsedCommandLine = js.native
    
    /**
      * Parse the contents of a config file (tsconfig.json).
      * @param jsonNode The contents of the config file to parse
      * @param host Instance of ParseConfigHost used to enumerate files in folder.
      * @param basePath A root directory to resolve relative path entries in the config
      *    file to. e.g. outDir
      */
    def parseJsonSourceFileConfigFileContent(
      sourceFile: TsConfigSourceFile,
      host: ParseConfigHost,
      basePath: String,
      existingOptions: js.UndefOr[CompilerOptions],
      configFileName: js.UndefOr[String],
      resolutionStack: js.UndefOr[js.Array[Path]],
      extraFileExtensions: js.UndefOr[js.Array[FileExtensionInfo]],
      extendedConfigCache: js.UndefOr[Map[String, ExtendedConfigCacheEntry]],
      existingWatchOptions: js.UndefOr[WatchOptions]
    ): ParsedCommandLine = js.native
    
    /**
      * Parse json text into SyntaxTree and return node and parse errors if any
      * @param fileName
      * @param sourceText
      */
    def parseJsonText(fileName: String, sourceText: String): JsonSourceFile = js.native
    
    def preProcessFile(sourceText: String): PreProcessedFileInfo = js.native
    def preProcessFile(sourceText: String, readImportFiles: Boolean): PreProcessedFileInfo = js.native
    def preProcessFile(sourceText: String, readImportFiles: Boolean, detectJavaScriptImports: Boolean): PreProcessedFileInfo = js.native
    def preProcessFile(sourceText: String, readImportFiles: Unit, detectJavaScriptImports: Boolean): PreProcessedFileInfo = js.native
    
    def readBuilderProgram(compilerOptions: CompilerOptions, host: ReadBuildProgramHost): js.UndefOr[EmitAndSemanticDiagnosticsBuilderProgram] = js.native
    
    /**
      * Read tsconfig.json file
      * @param fileName The path to the config file
      */
    def readConfigFile(fileName: String, readFile: js.Function1[/* path */ String, js.UndefOr[String]]): Config = js.native
    
    /**
      * Read tsconfig.json file
      * @param fileName The path to the config file
      */
    def readJsonConfigFile(fileName: String, readFile: js.Function1[/* path */ String, js.UndefOr[String]]): TsConfigSourceFile = js.native
    
    def reduceEachLeadingCommentRange[T, U](
      text: String,
      pos: Double,
      cb: js.Function5[
          /* pos */ Double, 
          /* end */ Double, 
          /* kind */ CommentKind, 
          /* hasTrailingNewLine */ Boolean, 
          /* state */ T, 
          U
        ],
      state: T,
      initial: U
    ): js.UndefOr[U] = js.native
    
    def reduceEachTrailingCommentRange[T, U](
      text: String,
      pos: Double,
      cb: js.Function5[
          /* pos */ Double, 
          /* end */ Double, 
          /* kind */ CommentKind, 
          /* hasTrailingNewLine */ Boolean, 
          /* state */ T, 
          U
        ],
      state: T,
      initial: U
    ): js.UndefOr[U] = js.native
    
    /**
      * Removes an EmitHelper from a node.
      */
    def removeEmitHelper(node: Node, helper: EmitHelper): Boolean = js.native
    
    def resolveModuleName(
      moduleName: String,
      containingFile: String,
      compilerOptions: CompilerOptions,
      host: ModuleResolutionHost
    ): ResolvedModuleWithFailedLookupLocations = js.native
    def resolveModuleName(
      moduleName: String,
      containingFile: String,
      compilerOptions: CompilerOptions,
      host: ModuleResolutionHost,
      cache: Unit,
      redirectedReference: Unit,
      resolutionMode: ResolutionMode
    ): ResolvedModuleWithFailedLookupLocations = js.native
    def resolveModuleName(
      moduleName: String,
      containingFile: String,
      compilerOptions: CompilerOptions,
      host: ModuleResolutionHost,
      cache: Unit,
      redirectedReference: ResolvedProjectReference
    ): ResolvedModuleWithFailedLookupLocations = js.native
    def resolveModuleName(
      moduleName: String,
      containingFile: String,
      compilerOptions: CompilerOptions,
      host: ModuleResolutionHost,
      cache: Unit,
      redirectedReference: ResolvedProjectReference,
      resolutionMode: ResolutionMode
    ): ResolvedModuleWithFailedLookupLocations = js.native
    def resolveModuleName(
      moduleName: String,
      containingFile: String,
      compilerOptions: CompilerOptions,
      host: ModuleResolutionHost,
      cache: ModuleResolutionCache
    ): ResolvedModuleWithFailedLookupLocations = js.native
    def resolveModuleName(
      moduleName: String,
      containingFile: String,
      compilerOptions: CompilerOptions,
      host: ModuleResolutionHost,
      cache: ModuleResolutionCache,
      redirectedReference: Unit,
      resolutionMode: ResolutionMode
    ): ResolvedModuleWithFailedLookupLocations = js.native
    def resolveModuleName(
      moduleName: String,
      containingFile: String,
      compilerOptions: CompilerOptions,
      host: ModuleResolutionHost,
      cache: ModuleResolutionCache,
      redirectedReference: ResolvedProjectReference
    ): ResolvedModuleWithFailedLookupLocations = js.native
    def resolveModuleName(
      moduleName: String,
      containingFile: String,
      compilerOptions: CompilerOptions,
      host: ModuleResolutionHost,
      cache: ModuleResolutionCache,
      redirectedReference: ResolvedProjectReference,
      resolutionMode: ResolutionMode
    ): ResolvedModuleWithFailedLookupLocations = js.native
    
    def resolveModuleNameFromCache(moduleName: String, containingFile: String, cache: ModuleResolutionCache): js.UndefOr[ResolvedModuleWithFailedLookupLocations] = js.native
    def resolveModuleNameFromCache(moduleName: String, containingFile: String, cache: ModuleResolutionCache, mode: ResolutionMode): js.UndefOr[ResolvedModuleWithFailedLookupLocations] = js.native
    
    /**
      * Returns the target config filename of a project reference.
      * Note: The file might not exist.
      */
    def resolveProjectReferencePath(ref: ProjectReference): ResolvedConfigFileName = js.native
    
    def resolveTripleslashReference(moduleName: String, containingFile: String): String = js.native
    
    /**
      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.
      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups
      * is assumed to be the same as root directory of the project.
      */
    def resolveTypeReferenceDirective(
      typeReferenceDirectiveName: String,
      containingFile: String,
      options: CompilerOptions,
      host: ModuleResolutionHost
    ): ResolvedTypeReferenceDirectiveWithFailedLookupLocations = js.native
    def resolveTypeReferenceDirective(
      typeReferenceDirectiveName: String,
      containingFile: String,
      options: CompilerOptions,
      host: ModuleResolutionHost,
      redirectedReference: Unit,
      cache: Unit,
      resolutionMode: ResolutionMode
    ): ResolvedTypeReferenceDirectiveWithFailedLookupLocations = js.native
    def resolveTypeReferenceDirective(
      typeReferenceDirectiveName: String,
      containingFile: String,
      options: CompilerOptions,
      host: ModuleResolutionHost,
      redirectedReference: Unit,
      cache: TypeReferenceDirectiveResolutionCache
    ): ResolvedTypeReferenceDirectiveWithFailedLookupLocations = js.native
    def resolveTypeReferenceDirective(
      typeReferenceDirectiveName: String,
      containingFile: String,
      options: CompilerOptions,
      host: ModuleResolutionHost,
      redirectedReference: Unit,
      cache: TypeReferenceDirectiveResolutionCache,
      resolutionMode: ResolutionMode
    ): ResolvedTypeReferenceDirectiveWithFailedLookupLocations = js.native
    def resolveTypeReferenceDirective(
      typeReferenceDirectiveName: String,
      containingFile: String,
      options: CompilerOptions,
      host: ModuleResolutionHost,
      redirectedReference: ResolvedProjectReference
    ): ResolvedTypeReferenceDirectiveWithFailedLookupLocations = js.native
    def resolveTypeReferenceDirective(
      typeReferenceDirectiveName: String,
      containingFile: String,
      options: CompilerOptions,
      host: ModuleResolutionHost,
      redirectedReference: ResolvedProjectReference,
      cache: Unit,
      resolutionMode: ResolutionMode
    ): ResolvedTypeReferenceDirectiveWithFailedLookupLocations = js.native
    def resolveTypeReferenceDirective(
      typeReferenceDirectiveName: String,
      containingFile: String,
      options: CompilerOptions,
      host: ModuleResolutionHost,
      redirectedReference: ResolvedProjectReference,
      cache: TypeReferenceDirectiveResolutionCache
    ): ResolvedTypeReferenceDirectiveWithFailedLookupLocations = js.native
    def resolveTypeReferenceDirective(
      typeReferenceDirectiveName: String,
      containingFile: String,
      options: CompilerOptions,
      host: ModuleResolutionHost,
      redirectedReference: ResolvedProjectReference,
      cache: TypeReferenceDirectiveResolutionCache,
      resolutionMode: ResolutionMode
    ): ResolvedTypeReferenceDirectiveWithFailedLookupLocations = js.native
    def resolveTypeReferenceDirective(
      typeReferenceDirectiveName: String,
      containingFile: Unit,
      options: CompilerOptions,
      host: ModuleResolutionHost
    ): ResolvedTypeReferenceDirectiveWithFailedLookupLocations = js.native
    def resolveTypeReferenceDirective(
      typeReferenceDirectiveName: String,
      containingFile: Unit,
      options: CompilerOptions,
      host: ModuleResolutionHost,
      redirectedReference: Unit,
      cache: Unit,
      resolutionMode: ResolutionMode
    ): ResolvedTypeReferenceDirectiveWithFailedLookupLocations = js.native
    def resolveTypeReferenceDirective(
      typeReferenceDirectiveName: String,
      containingFile: Unit,
      options: CompilerOptions,
      host: ModuleResolutionHost,
      redirectedReference: Unit,
      cache: TypeReferenceDirectiveResolutionCache
    ): ResolvedTypeReferenceDirectiveWithFailedLookupLocations = js.native
    def resolveTypeReferenceDirective(
      typeReferenceDirectiveName: String,
      containingFile: Unit,
      options: CompilerOptions,
      host: ModuleResolutionHost,
      redirectedReference: Unit,
      cache: TypeReferenceDirectiveResolutionCache,
      resolutionMode: ResolutionMode
    ): ResolvedTypeReferenceDirectiveWithFailedLookupLocations = js.native
    def resolveTypeReferenceDirective(
      typeReferenceDirectiveName: String,
      containingFile: Unit,
      options: CompilerOptions,
      host: ModuleResolutionHost,
      redirectedReference: ResolvedProjectReference
    ): ResolvedTypeReferenceDirectiveWithFailedLookupLocations = js.native
    def resolveTypeReferenceDirective(
      typeReferenceDirectiveName: String,
      containingFile: Unit,
      options: CompilerOptions,
      host: ModuleResolutionHost,
      redirectedReference: ResolvedProjectReference,
      cache: Unit,
      resolutionMode: ResolutionMode
    ): ResolvedTypeReferenceDirectiveWithFailedLookupLocations = js.native
    def resolveTypeReferenceDirective(
      typeReferenceDirectiveName: String,
      containingFile: Unit,
      options: CompilerOptions,
      host: ModuleResolutionHost,
      redirectedReference: ResolvedProjectReference,
      cache: TypeReferenceDirectiveResolutionCache
    ): ResolvedTypeReferenceDirectiveWithFailedLookupLocations = js.native
    def resolveTypeReferenceDirective(
      typeReferenceDirectiveName: String,
      containingFile: Unit,
      options: CompilerOptions,
      host: ModuleResolutionHost,
      redirectedReference: ResolvedProjectReference,
      cache: TypeReferenceDirectiveResolutionCache,
      resolutionMode: ResolutionMode
    ): ResolvedTypeReferenceDirectiveWithFailedLookupLocations = js.native
    
    val server: Any = js.native
    
    /** The version of the language service API */
    val servicesVersion: /* "0.8" */ String = js.native
    
    /**
      * Sets a custom text range to use when emitting comments.
      */
    def setCommentRange[T /* <: Node */](node: T, range: TextRange): T = js.native
    
    /**
      * Sets the constant value to emit for an expression.
      */
    def setConstantValue(node: AccessExpression, value: String): AccessExpression = js.native
    def setConstantValue(node: AccessExpression, value: Double): AccessExpression = js.native
    
    /**
      * Sets flags that control emit behavior of a node.
      */
    def setEmitFlags[T /* <: Node */](node: T, emitFlags: EmitFlags): T = js.native
    
    def setOriginalNode[T /* <: Node */](node: T): T = js.native
    def setOriginalNode[T /* <: Node */](node: T, original: Node): T = js.native
    
    /**
      * Sets a custom text range to use when emitting source maps.
      */
    def setSourceMapRange[T /* <: Node */](node: T): T = js.native
    def setSourceMapRange[T /* <: Node */](node: T, range: SourceMapRange): T = js.native
    
    def setSyntheticLeadingComments[T /* <: Node */](node: T): T = js.native
    def setSyntheticLeadingComments[T /* <: Node */](node: T, comments: js.Array[SynthesizedComment]): T = js.native
    
    def setSyntheticTrailingComments[T /* <: Node */](node: T): T = js.native
    def setSyntheticTrailingComments[T /* <: Node */](node: T, comments: js.Array[SynthesizedComment]): T = js.native
    
    def setTextRange[T /* <: TextRange */](range: T): T = js.native
    def setTextRange[T /* <: TextRange */](range: T, location: TextRange): T = js.native
    
    /**
      * Sets the TextRange to use for source maps for a token of a node.
      */
    def setTokenSourceMapRange[T /* <: Node */](node: T, token: SyntaxKind): T = js.native
    def setTokenSourceMapRange[T /* <: Node */](node: T, token: SyntaxKind, range: SourceMapRange): T = js.native
    
    def skipPartiallyEmittedExpressions(node: Expression): Expression = js.native
    def skipPartiallyEmittedExpressions(node: Node): Node = js.native
    
    def sortAndDeduplicateDiagnostics[T /* <: Diagnostic */](diagnostics: js.Array[T]): SortedReadonlyArray[T] = js.native
    
    def symbolName(symbol: Symbol): String = js.native
    
    var sys: System = js.native
    
    def textChangeRangeIsUnchanged(range: TextChangeRange): Boolean = js.native
    
    def textChangeRangeNewSpan(range: TextChangeRange): TextSpan = js.native
    
    def textSpanContainsPosition(span: TextSpan, position: Double): Boolean = js.native
    
    def textSpanContainsTextSpan(span: TextSpan, other: TextSpan): Boolean = js.native
    
    def textSpanEnd(span: TextSpan): Double = js.native
    
    def textSpanIntersection(span1: TextSpan, span2: TextSpan): js.UndefOr[TextSpan] = js.native
    
    def textSpanIntersectsWith(span: TextSpan, start: Double, length: Double): Boolean = js.native
    
    def textSpanIntersectsWithPosition(span: TextSpan, position: Double): Boolean = js.native
    
    def textSpanIntersectsWithTextSpan(span: TextSpan, other: TextSpan): Boolean = js.native
    
    def textSpanIsEmpty(span: TextSpan): Boolean = js.native
    
    def textSpanOverlap(span1: TextSpan, span2: TextSpan): js.UndefOr[TextSpan] = js.native
    
    def textSpanOverlapsWith(span: TextSpan, other: TextSpan): Boolean = js.native
    
    def toEditorSettings(options: EditorOptions): EditorSettings = js.native
    def toEditorSettings(options: EditorSettings): EditorSettings = js.native
    
    def tokenToString(t: SyntaxKind): js.UndefOr[String] = js.native
    
    /**
      * Transform one or more nodes using the supplied transformers.
      * @param source A single `Node` or an array of `Node` objects.
      * @param transformers An array of `TransformerFactory` callbacks used to process the transformation.
      * @param compilerOptions Optional compiler options.
      */
    def transform[T /* <: Node */](source: T, transformers: js.Array[TransformerFactory[T]]): TransformationResult[T] = js.native
    def transform[T /* <: Node */](source: T, transformers: js.Array[TransformerFactory[T]], compilerOptions: CompilerOptions): TransformationResult[T] = js.native
    def transform[T /* <: Node */](source: js.Array[T], transformers: js.Array[TransformerFactory[T]]): TransformationResult[T] = js.native
    def transform[T /* <: Node */](
      source: js.Array[T],
      transformers: js.Array[TransformerFactory[T]],
      compilerOptions: CompilerOptions
    ): TransformationResult[T] = js.native
    
    def transpile(input: String): String = js.native
    def transpile(input: String, compilerOptions: Unit, fileName: String): String = js.native
    def transpile(input: String, compilerOptions: Unit, fileName: String, diagnostics: js.Array[Diagnostic]): String = js.native
    def transpile(
      input: String,
      compilerOptions: Unit,
      fileName: String,
      diagnostics: js.Array[Diagnostic],
      moduleName: String
    ): String = js.native
    def transpile(input: String, compilerOptions: Unit, fileName: String, diagnostics: Unit, moduleName: String): String = js.native
    def transpile(input: String, compilerOptions: Unit, fileName: Unit, diagnostics: js.Array[Diagnostic]): String = js.native
    def transpile(
      input: String,
      compilerOptions: Unit,
      fileName: Unit,
      diagnostics: js.Array[Diagnostic],
      moduleName: String
    ): String = js.native
    def transpile(input: String, compilerOptions: Unit, fileName: Unit, diagnostics: Unit, moduleName: String): String = js.native
    def transpile(input: String, compilerOptions: CompilerOptions): String = js.native
    def transpile(input: String, compilerOptions: CompilerOptions, fileName: String): String = js.native
    def transpile(
      input: String,
      compilerOptions: CompilerOptions,
      fileName: String,
      diagnostics: js.Array[Diagnostic]
    ): String = js.native
    def transpile(
      input: String,
      compilerOptions: CompilerOptions,
      fileName: String,
      diagnostics: js.Array[Diagnostic],
      moduleName: String
    ): String = js.native
    def transpile(
      input: String,
      compilerOptions: CompilerOptions,
      fileName: String,
      diagnostics: Unit,
      moduleName: String
    ): String = js.native
    def transpile(input: String, compilerOptions: CompilerOptions, fileName: Unit, diagnostics: js.Array[Diagnostic]): String = js.native
    def transpile(
      input: String,
      compilerOptions: CompilerOptions,
      fileName: Unit,
      diagnostics: js.Array[Diagnostic],
      moduleName: String
    ): String = js.native
    def transpile(
      input: String,
      compilerOptions: CompilerOptions,
      fileName: Unit,
      diagnostics: Unit,
      moduleName: String
    ): String = js.native
    
    def transpileModule(input: String, transpileOptions: TranspileOptions): TranspileOutput = js.native
    
    var unchangedTextChangeRange: TextChangeRange = js.native
    
    /**
      * Remove extra underscore from escaped identifier text content.
      *
      * @param identifier The escaped identifier text.
      * @returns The unescaped identifier text.
      */
    def unescapeLeadingUnderscores(identifier: typings.typescript.mod.String): String = js.native
    
    def updateLanguageServiceSourceFile(sourceFile: SourceFile, scriptSnapshot: IScriptSnapshot, version: String): SourceFile = js.native
    def updateLanguageServiceSourceFile(
      sourceFile: SourceFile,
      scriptSnapshot: IScriptSnapshot,
      version: String,
      textChangeRange: Unit,
      aggressiveChecks: Boolean
    ): SourceFile = js.native
    def updateLanguageServiceSourceFile(
      sourceFile: SourceFile,
      scriptSnapshot: IScriptSnapshot,
      version: String,
      textChangeRange: TextChangeRange
    ): SourceFile = js.native
    def updateLanguageServiceSourceFile(
      sourceFile: SourceFile,
      scriptSnapshot: IScriptSnapshot,
      version: String,
      textChangeRange: TextChangeRange,
      aggressiveChecks: Boolean
    ): SourceFile = js.native
    
    def updateSourceFile(sourceFile: SourceFile, newText: String, textChangeRange: TextChangeRange): SourceFile = js.native
    def updateSourceFile(
      sourceFile: SourceFile,
      newText: String,
      textChangeRange: TextChangeRange,
      aggressiveChecks: Boolean
    ): SourceFile = js.native
    
    /**
      * Checks to see if the locale is in the appropriate format,
      * and if it is, attempts to set the appropriate language.
      */
    def validateLocaleAndSetLanguage(locale: String, sys: FileExists): Unit = js.native
    def validateLocaleAndSetLanguage(locale: String, sys: FileExists, errors: js.Array[Diagnostic]): Unit = js.native
    
    /** The version of the TypeScript compiler release */
    val version: String = js.native
    
    val versionMajorMinor: /* "5.0" */ String = js.native
    
    /**
      * Visits the elements of a {@link CommaListExpression}.
      * @param visitor The visitor to use when visiting expressions whose result will not be discarded at runtime.
      * @param discardVisitor The visitor to use when visiting expressions whose result will be discarded at runtime. Defaults to {@link visitor}.
      */
    def visitCommaListElements(elements: NodeArray[Expression], visitor: Visitor[Node, js.UndefOr[Node]]): NodeArray[Expression] = js.native
    def visitCommaListElements(
      elements: NodeArray[Expression],
      visitor: Visitor[Node, js.UndefOr[Node]],
      discardVisitor: Visitor[Node, js.UndefOr[Node]]
    ): NodeArray[Expression] = js.native
    
    /**
      * Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place.
      *
      * @param node The Node whose children will be visited.
      * @param visitor The callback used to visit each child.
      * @param context A lexical environment context for the visitor.
      */
    def visitEachChild[T /* <: Node */](node: T, visitor: Visitor[Node, js.UndefOr[Node]], context: TransformationContext): js.UndefOr[T] = js.native
    def visitEachChild[T /* <: Node */](
      node: T,
      visitor: Visitor[Node, js.UndefOr[Node]],
      context: TransformationContext,
      nodesVisitor: Unit,
      tokenVisitor: Visitor[Node, js.UndefOr[Node]]
    ): js.UndefOr[T] = js.native
    def visitEachChild[T /* <: Node */](
      node: T,
      visitor: Visitor[Node, js.UndefOr[Node]],
      context: TransformationContext,
      nodesVisitor: FnCall
    ): js.UndefOr[T] = js.native
    def visitEachChild[T /* <: Node */](
      node: T,
      visitor: Visitor[Node, js.UndefOr[Node]],
      context: TransformationContext,
      nodesVisitor: FnCall,
      tokenVisitor: Visitor[Node, js.UndefOr[Node]]
    ): js.UndefOr[T] = js.native
    def visitEachChild[T /* <: Node */](node: Unit, visitor: Visitor[Node, js.UndefOr[Node]], context: TransformationContext): js.UndefOr[T] = js.native
    def visitEachChild[T /* <: Node */](
      node: Unit,
      visitor: Visitor[Node, js.UndefOr[Node]],
      context: TransformationContext,
      nodesVisitor: Unit,
      tokenVisitor: Visitor[Node, js.UndefOr[Node]]
    ): js.UndefOr[T] = js.native
    def visitEachChild[T /* <: Node */](
      node: Unit,
      visitor: Visitor[Node, js.UndefOr[Node]],
      context: TransformationContext,
      nodesVisitor: FnCall
    ): js.UndefOr[T] = js.native
    def visitEachChild[T /* <: Node */](
      node: Unit,
      visitor: Visitor[Node, js.UndefOr[Node]],
      context: TransformationContext,
      nodesVisitor: FnCall,
      tokenVisitor: Visitor[Node, js.UndefOr[Node]]
    ): js.UndefOr[T] = js.native
    /**
      * Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place.
      *
      * @param node The Node whose children will be visited.
      * @param visitor The callback used to visit each child.
      * @param context A lexical environment context for the visitor.
      */
    @JSName("visitEachChild")
    def visitEachChild_T_T[T /* <: Node */](node: T, visitor: Visitor[Node, js.UndefOr[Node]], context: TransformationContext): T = js.native
    
    def visitFunctionBody(node: Unit, visitor: Visitor[Node, js.UndefOr[Node]], context: TransformationContext): js.UndefOr[FunctionBody] = js.native
    /**
      * Resumes a suspended lexical environment and visits a concise body, ending the lexical
      * environment and merging hoisted declarations upon completion.
      */
    def visitFunctionBody(node: ConciseBody, visitor: Visitor[Node, js.UndefOr[Node]], context: TransformationContext): ConciseBody = js.native
    /**
      * Resumes a suspended lexical environment and visits a function body, ending the lexical
      * environment and merging hoisted declarations upon completion.
      */
    def visitFunctionBody(node: FunctionBody, visitor: Visitor[Node, js.UndefOr[Node]], context: TransformationContext): js.UndefOr[FunctionBody] = js.native
    /**
      * Resumes a suspended lexical environment and visits a function body, ending the lexical
      * environment and merging hoisted declarations upon completion.
      */
    @JSName("visitFunctionBody")
    def visitFunctionBody_FunctionBody(node: FunctionBody, visitor: Visitor[Node, js.UndefOr[Node]], context: TransformationContext): FunctionBody = js.native
    
    /**
      * Visits an iteration body, adding any block-scoped variables required by the transformation.
      */
    def visitIterationBody(body: Statement, visitor: Visitor[Node, js.UndefOr[Node]], context: TransformationContext): Statement = js.native
    
    /**
      * Starts a new lexical environment and visits a statement list, ending the lexical environment
      * and merging hoisted declarations upon completion.
      */
    def visitLexicalEnvironment(
      statements: NodeArray[Statement],
      visitor: Visitor[Node, js.UndefOr[Node]],
      context: TransformationContext
    ): NodeArray[Statement] = js.native
    def visitLexicalEnvironment(
      statements: NodeArray[Statement],
      visitor: Visitor[Node, js.UndefOr[Node]],
      context: TransformationContext,
      start: Double
    ): NodeArray[Statement] = js.native
    def visitLexicalEnvironment(
      statements: NodeArray[Statement],
      visitor: Visitor[Node, js.UndefOr[Node]],
      context: TransformationContext,
      start: Double,
      ensureUseStrict: Boolean
    ): NodeArray[Statement] = js.native
    def visitLexicalEnvironment(
      statements: NodeArray[Statement],
      visitor: Visitor[Node, js.UndefOr[Node]],
      context: TransformationContext,
      start: Double,
      ensureUseStrict: Boolean,
      nodesVisitor: NodesVisitor
    ): NodeArray[Statement] = js.native
    def visitLexicalEnvironment(
      statements: NodeArray[Statement],
      visitor: Visitor[Node, js.UndefOr[Node]],
      context: TransformationContext,
      start: Double,
      ensureUseStrict: Unit,
      nodesVisitor: NodesVisitor
    ): NodeArray[Statement] = js.native
    def visitLexicalEnvironment(
      statements: NodeArray[Statement],
      visitor: Visitor[Node, js.UndefOr[Node]],
      context: TransformationContext,
      start: Unit,
      ensureUseStrict: Boolean
    ): NodeArray[Statement] = js.native
    def visitLexicalEnvironment(
      statements: NodeArray[Statement],
      visitor: Visitor[Node, js.UndefOr[Node]],
      context: TransformationContext,
      start: Unit,
      ensureUseStrict: Boolean,
      nodesVisitor: NodesVisitor
    ): NodeArray[Statement] = js.native
    def visitLexicalEnvironment(
      statements: NodeArray[Statement],
      visitor: Visitor[Node, js.UndefOr[Node]],
      context: TransformationContext,
      start: Unit,
      ensureUseStrict: Unit,
      nodesVisitor: NodesVisitor
    ): NodeArray[Statement] = js.native
    
    /**
      * Visits a Node using the supplied visitor, possibly returning a new Node in its place.
      *
      * - If the input node is undefined, then the output is undefined.
      * - If the visitor returns undefined, then the output is undefined.
      * - If the output node is not undefined, then it will satisfy the test function.
      * - In order to obtain a return type that is more specific than `Node`, a test
      *   function _must_ be provided, and that function must be a type predicate.
      *
      * @param node The Node to visit.
      * @param visitor The callback used to visit the Node.
      * @param test A callback to execute to verify the Node is valid.
      * @param lift An optional callback to execute to lift a NodeArray into a valid Node.
      */
    def visitNode[TIn /* <: js.UndefOr[Node] */, TVisited /* <: js.UndefOr[Node] */](node: TIn, visitor: Visitor[NonNullable[TIn], TVisited]): Node | (TIn & Unit) | (TVisited & Unit) = js.native
    def visitNode[TIn /* <: js.UndefOr[Node] */, TVisited /* <: js.UndefOr[Node] */](
      node: TIn,
      visitor: Visitor[NonNullable[TIn], TVisited],
      test: js.Function1[/* node */ Node, Boolean]
    ): Node | (TIn & Unit) | (TVisited & Unit) = js.native
    def visitNode[TIn /* <: js.UndefOr[Node] */, TVisited /* <: js.UndefOr[Node] */](
      node: TIn,
      visitor: Visitor[NonNullable[TIn], TVisited],
      test: js.Function1[/* node */ Node, Boolean],
      lift: js.Function1[/* node */ js.Array[Node], Node]
    ): Node | (TIn & Unit) | (TVisited & Unit) = js.native
    def visitNode[TIn /* <: js.UndefOr[Node] */, TVisited /* <: js.UndefOr[Node] */](
      node: TIn,
      visitor: Visitor[NonNullable[TIn], TVisited],
      test: Unit,
      lift: js.Function1[/* node */ js.Array[Node], Node]
    ): Node | (TIn & Unit) | (TVisited & Unit) = js.native
    /**
      * Visits a Node using the supplied visitor, possibly returning a new Node in its place.
      *
      * - If the input node is undefined, then the output is undefined.
      * - If the visitor returns undefined, then the output is undefined.
      * - If the output node is not undefined, then it will satisfy the test function.
      * - In order to obtain a return type that is more specific than `Node`, a test
      *   function _must_ be provided, and that function must be a type predicate.
      *
      * @param node The Node to visit.
      * @param visitor The callback used to visit the Node.
      * @param test A callback to execute to verify the Node is valid.
      * @param lift An optional callback to execute to lift a NodeArray into a valid Node.
      */
    @JSName("visitNode")
    def visitNode_TInTVisitedTOut[TIn /* <: js.UndefOr[Node] */, TVisited /* <: js.UndefOr[Node] */, TOut /* <: Node */](
      node: TIn,
      visitor: Visitor[NonNullable[TIn], TVisited],
      test: js.Function1[/* node */ Node, /* is TOut */ Boolean]
    ): TOut | (TIn & Unit) | (TVisited & Unit) = js.native
    @JSName("visitNode")
    def visitNode_TInTVisitedTOut[TIn /* <: js.UndefOr[Node] */, TVisited /* <: js.UndefOr[Node] */, TOut /* <: Node */](
      node: TIn,
      visitor: Visitor[NonNullable[TIn], TVisited],
      test: js.Function1[/* node */ Node, /* is TOut */ Boolean],
      lift: js.Function1[/* node */ js.Array[Node], Node]
    ): TOut | (TIn & Unit) | (TVisited & Unit) = js.native
    
    /**
      * Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place.
      *
      * - If the input node array is undefined, the output is undefined.
      * - If the visitor can return undefined, the node it visits in the array will be reused.
      * - If the output node array is not undefined, then its contents will satisfy the test.
      * - In order to obtain a return type that is more specific than `NodeArray<Node>`, a test
      *   function _must_ be provided, and that function must be a type predicate.
      *
      * @param nodes The NodeArray to visit.
      * @param visitor The callback used to visit a Node.
      * @param test A node test to execute for each node.
      * @param start An optional value indicating the starting offset at which to start visiting.
      * @param count An optional value indicating the maximum number of nodes to visit.
      */
    def visitNodes[TIn /* <: Node */, TInArray /* <: js.UndefOr[NodeArray[TIn]] */](nodes: TInArray, visitor: Visitor[TIn, js.UndefOr[Node]]): NodeArray[Node] | (TInArray & Unit) = js.native
    def visitNodes[TIn /* <: Node */, TInArray /* <: js.UndefOr[NodeArray[TIn]] */](
      nodes: TInArray,
      visitor: Visitor[TIn, js.UndefOr[Node]],
      test: js.Function1[/* node */ Node, Boolean]
    ): NodeArray[Node] | (TInArray & Unit) = js.native
    def visitNodes[TIn /* <: Node */, TInArray /* <: js.UndefOr[NodeArray[TIn]] */](
      nodes: TInArray,
      visitor: Visitor[TIn, js.UndefOr[Node]],
      test: js.Function1[/* node */ Node, Boolean],
      start: Double
    ): NodeArray[Node] | (TInArray & Unit) = js.native
    def visitNodes[TIn /* <: Node */, TInArray /* <: js.UndefOr[NodeArray[TIn]] */](
      nodes: TInArray,
      visitor: Visitor[TIn, js.UndefOr[Node]],
      test: js.Function1[/* node */ Node, Boolean],
      start: Double,
      count: Double
    ): NodeArray[Node] | (TInArray & Unit) = js.native
    def visitNodes[TIn /* <: Node */, TInArray /* <: js.UndefOr[NodeArray[TIn]] */](
      nodes: TInArray,
      visitor: Visitor[TIn, js.UndefOr[Node]],
      test: js.Function1[/* node */ Node, Boolean],
      start: Unit,
      count: Double
    ): NodeArray[Node] | (TInArray & Unit) = js.native
    def visitNodes[TIn /* <: Node */, TInArray /* <: js.UndefOr[NodeArray[TIn]] */](nodes: TInArray, visitor: Visitor[TIn, js.UndefOr[Node]], test: Unit, start: Double): NodeArray[Node] | (TInArray & Unit) = js.native
    def visitNodes[TIn /* <: Node */, TInArray /* <: js.UndefOr[NodeArray[TIn]] */](nodes: TInArray, visitor: Visitor[TIn, js.UndefOr[Node]], test: Unit, start: Double, count: Double): NodeArray[Node] | (TInArray & Unit) = js.native
    def visitNodes[TIn /* <: Node */, TInArray /* <: js.UndefOr[NodeArray[TIn]] */](nodes: TInArray, visitor: Visitor[TIn, js.UndefOr[Node]], test: Unit, start: Unit, count: Double): NodeArray[Node] | (TInArray & Unit) = js.native
    /**
      * Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place.
      *
      * - If the input node array is undefined, the output is undefined.
      * - If the visitor can return undefined, the node it visits in the array will be reused.
      * - If the output node array is not undefined, then its contents will satisfy the test.
      * - In order to obtain a return type that is more specific than `NodeArray<Node>`, a test
      *   function _must_ be provided, and that function must be a type predicate.
      *
      * @param nodes The NodeArray to visit.
      * @param visitor The callback used to visit a Node.
      * @param test A node test to execute for each node.
      * @param start An optional value indicating the starting offset at which to start visiting.
      * @param count An optional value indicating the maximum number of nodes to visit.
      */
    @JSName("visitNodes")
    def visitNodes_TInTInArrayTOut[TIn /* <: Node */, TInArray /* <: js.UndefOr[NodeArray[TIn]] */, TOut /* <: Node */](
      nodes: TInArray,
      visitor: Visitor[TIn, js.UndefOr[Node]],
      test: js.Function1[/* node */ Node, /* is TOut */ Boolean]
    ): NodeArray[TOut] | (TInArray & Unit) = js.native
    @JSName("visitNodes")
    def visitNodes_TInTInArrayTOut[TIn /* <: Node */, TInArray /* <: js.UndefOr[NodeArray[TIn]] */, TOut /* <: Node */](
      nodes: TInArray,
      visitor: Visitor[TIn, js.UndefOr[Node]],
      test: js.Function1[/* node */ Node, /* is TOut */ Boolean],
      start: Double
    ): NodeArray[TOut] | (TInArray & Unit) = js.native
    @JSName("visitNodes")
    def visitNodes_TInTInArrayTOut[TIn /* <: Node */, TInArray /* <: js.UndefOr[NodeArray[TIn]] */, TOut /* <: Node */](
      nodes: TInArray,
      visitor: Visitor[TIn, js.UndefOr[Node]],
      test: js.Function1[/* node */ Node, /* is TOut */ Boolean],
      start: Double,
      count: Double
    ): NodeArray[TOut] | (TInArray & Unit) = js.native
    @JSName("visitNodes")
    def visitNodes_TInTInArrayTOut[TIn /* <: Node */, TInArray /* <: js.UndefOr[NodeArray[TIn]] */, TOut /* <: Node */](
      nodes: TInArray,
      visitor: Visitor[TIn, js.UndefOr[Node]],
      test: js.Function1[/* node */ Node, /* is TOut */ Boolean],
      start: Unit,
      count: Double
    ): NodeArray[TOut] | (TInArray & Unit) = js.native
    
    def visitParameterList(nodes: Unit, visitor: Visitor[Node, js.UndefOr[Node]], context: TransformationContext): js.UndefOr[NodeArray[ParameterDeclaration]] = js.native
    def visitParameterList(
      nodes: Unit,
      visitor: Visitor[Node, js.UndefOr[Node]],
      context: TransformationContext,
      nodesVisitor: NodesVisitor
    ): js.UndefOr[NodeArray[ParameterDeclaration]] = js.native
    def visitParameterList(
      nodes: NodeArray[ParameterDeclaration],
      visitor: Visitor[Node, js.UndefOr[Node]],
      context: TransformationContext
    ): js.UndefOr[NodeArray[ParameterDeclaration]] = js.native
    def visitParameterList(
      nodes: NodeArray[ParameterDeclaration],
      visitor: Visitor[Node, js.UndefOr[Node]],
      context: TransformationContext,
      nodesVisitor: NodesVisitor
    ): js.UndefOr[NodeArray[ParameterDeclaration]] = js.native
    /**
      * Starts a new lexical environment and visits a parameter list, suspending the lexical
      * environment upon completion.
      */
    @JSName("visitParameterList")
    def visitParameterList_NodeArray(
      nodes: NodeArray[ParameterDeclaration],
      visitor: Visitor[Node, js.UndefOr[Node]],
      context: TransformationContext
    ): NodeArray[ParameterDeclaration] = js.native
    @JSName("visitParameterList")
    def visitParameterList_NodeArray(
      nodes: NodeArray[ParameterDeclaration],
      visitor: Visitor[Node, js.UndefOr[Node]],
      context: TransformationContext,
      nodesVisitor: NodesVisitor
    ): NodeArray[ParameterDeclaration] = js.native
    
    def walkUpBindingElementsAndPatterns(binding: BindingElement): VariableDeclaration | ParameterDeclaration = js.native
  }
}
