package typings.fpTs.pipeableMod

import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}


@scala.inline
def pipe[A](a: A): A = typings.fpTs.pipeableMod.^.asInstanceOf[js.Dynamic].applyDynamic("pipe")(a.asInstanceOf[js.Any]).asInstanceOf[A]
@scala.inline
def pipe[A, B](a: A, ab: js.Function1[/* a */ A, B]): B = (typings.fpTs.pipeableMod.^.asInstanceOf[js.Dynamic].applyDynamic("pipe")(a.asInstanceOf[js.Any], ab.asInstanceOf[js.Any])).asInstanceOf[B]
@scala.inline
def pipe[A, B, C](a: A, ab: js.Function1[/* a */ A, B], bc: js.Function1[/* b */ B, C]): C = (typings.fpTs.pipeableMod.^.asInstanceOf[js.Dynamic].applyDynamic("pipe")(a.asInstanceOf[js.Any], ab.asInstanceOf[js.Any], bc.asInstanceOf[js.Any])).asInstanceOf[C]
@scala.inline
def pipe[A, B, C, D](
  a: A,
  ab: js.Function1[/* a */ A, B],
  bc: js.Function1[/* b */ B, C],
  cd: js.Function1[/* c */ C, D]
): D = (typings.fpTs.pipeableMod.^.asInstanceOf[js.Dynamic].applyDynamic("pipe")(a.asInstanceOf[js.Any], ab.asInstanceOf[js.Any], bc.asInstanceOf[js.Any], cd.asInstanceOf[js.Any])).asInstanceOf[D]
@scala.inline
def pipe[A, B, C, D, E](
  a: A,
  ab: js.Function1[/* a */ A, B],
  bc: js.Function1[/* b */ B, C],
  cd: js.Function1[/* c */ C, D],
  de: js.Function1[/* d */ D, E]
): E = (typings.fpTs.pipeableMod.^.asInstanceOf[js.Dynamic].applyDynamic("pipe")(a.asInstanceOf[js.Any], ab.asInstanceOf[js.Any], bc.asInstanceOf[js.Any], cd.asInstanceOf[js.Any], de.asInstanceOf[js.Any])).asInstanceOf[E]
@scala.inline
def pipe[A, B, C, D, E, F](
  a: A,
  ab: js.Function1[/* a */ A, B],
  bc: js.Function1[/* b */ B, C],
  cd: js.Function1[/* c */ C, D],
  de: js.Function1[/* d */ D, E],
  ef: js.Function1[/* e */ E, F]
): F = (typings.fpTs.pipeableMod.^.asInstanceOf[js.Dynamic].applyDynamic("pipe")(a.asInstanceOf[js.Any], ab.asInstanceOf[js.Any], bc.asInstanceOf[js.Any], cd.asInstanceOf[js.Any], de.asInstanceOf[js.Any], ef.asInstanceOf[js.Any])).asInstanceOf[F]
@scala.inline
def pipe[A, B, C, D, E, F, G](
  a: A,
  ab: js.Function1[/* a */ A, B],
  bc: js.Function1[/* b */ B, C],
  cd: js.Function1[/* c */ C, D],
  de: js.Function1[/* d */ D, E],
  ef: js.Function1[/* e */ E, F],
  fg: js.Function1[/* f */ F, G]
): G = (typings.fpTs.pipeableMod.^.asInstanceOf[js.Dynamic].applyDynamic("pipe")(a.asInstanceOf[js.Any], ab.asInstanceOf[js.Any], bc.asInstanceOf[js.Any], cd.asInstanceOf[js.Any], de.asInstanceOf[js.Any], ef.asInstanceOf[js.Any], fg.asInstanceOf[js.Any])).asInstanceOf[G]
@scala.inline
def pipe[A, B, C, D, E, F, G, H](
  a: A,
  ab: js.Function1[/* a */ A, B],
  bc: js.Function1[/* b */ B, C],
  cd: js.Function1[/* c */ C, D],
  de: js.Function1[/* d */ D, E],
  ef: js.Function1[/* e */ E, F],
  fg: js.Function1[/* f */ F, G],
  gh: js.Function1[/* g */ G, H]
): H = (typings.fpTs.pipeableMod.^.asInstanceOf[js.Dynamic].applyDynamic("pipe")(a.asInstanceOf[js.Any], ab.asInstanceOf[js.Any], bc.asInstanceOf[js.Any], cd.asInstanceOf[js.Any], de.asInstanceOf[js.Any], ef.asInstanceOf[js.Any], fg.asInstanceOf[js.Any], gh.asInstanceOf[js.Any])).asInstanceOf[H]
@scala.inline
def pipe[A, B, C, D, E, F, G, H, I](
  a: A,
  ab: js.Function1[/* a */ A, B],
  bc: js.Function1[/* b */ B, C],
  cd: js.Function1[/* c */ C, D],
  de: js.Function1[/* d */ D, E],
  ef: js.Function1[/* e */ E, F],
  fg: js.Function1[/* f */ F, G],
  gh: js.Function1[/* g */ G, H],
  hi: js.Function1[/* h */ H, I]
): I = (typings.fpTs.pipeableMod.^.asInstanceOf[js.Dynamic].applyDynamic("pipe")(a.asInstanceOf[js.Any], ab.asInstanceOf[js.Any], bc.asInstanceOf[js.Any], cd.asInstanceOf[js.Any], de.asInstanceOf[js.Any], ef.asInstanceOf[js.Any], fg.asInstanceOf[js.Any], gh.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[I]
@scala.inline
def pipe[A, B, C, D, E, F, G, H, I, J](
  a: A,
  ab: js.Function1[/* a */ A, B],
  bc: js.Function1[/* b */ B, C],
  cd: js.Function1[/* c */ C, D],
  de: js.Function1[/* d */ D, E],
  ef: js.Function1[/* e */ E, F],
  fg: js.Function1[/* f */ F, G],
  gh: js.Function1[/* g */ G, H],
  hi: js.Function1[/* h */ H, I],
  ij: js.Function1[/* i */ I, J]
): J = (typings.fpTs.pipeableMod.^.asInstanceOf[js.Dynamic].applyDynamic("pipe")(a.asInstanceOf[js.Any], ab.asInstanceOf[js.Any], bc.asInstanceOf[js.Any], cd.asInstanceOf[js.Any], de.asInstanceOf[js.Any], ef.asInstanceOf[js.Any], fg.asInstanceOf[js.Any], gh.asInstanceOf[js.Any], hi.asInstanceOf[js.Any], ij.asInstanceOf[js.Any])).asInstanceOf[J]
@scala.inline
def pipe[A, B, C, D, E, F, G, H, I, J, K](
  a: A,
  ab: js.Function1[/* a */ A, B],
  bc: js.Function1[/* b */ B, C],
  cd: js.Function1[/* c */ C, D],
  de: js.Function1[/* d */ D, E],
  ef: js.Function1[/* e */ E, F],
  fg: js.Function1[/* f */ F, G],
  gh: js.Function1[/* g */ G, H],
  hi: js.Function1[/* h */ H, I],
  ij: js.Function1[/* i */ I, J],
  jk: js.Function1[/* j */ J, K]
): K = (typings.fpTs.pipeableMod.^.asInstanceOf[js.Dynamic].applyDynamic("pipe")(a.asInstanceOf[js.Any], ab.asInstanceOf[js.Any], bc.asInstanceOf[js.Any], cd.asInstanceOf[js.Any], de.asInstanceOf[js.Any], ef.asInstanceOf[js.Any], fg.asInstanceOf[js.Any], gh.asInstanceOf[js.Any], hi.asInstanceOf[js.Any], ij.asInstanceOf[js.Any], jk.asInstanceOf[js.Any])).asInstanceOf[K]
@scala.inline
def pipe[A, B, C, D, E, F, G, H, I, J, K, L](
  a: A,
  ab: js.Function1[/* a */ A, B],
  bc: js.Function1[/* b */ B, C],
  cd: js.Function1[/* c */ C, D],
  de: js.Function1[/* d */ D, E],
  ef: js.Function1[/* e */ E, F],
  fg: js.Function1[/* f */ F, G],
  gh: js.Function1[/* g */ G, H],
  hi: js.Function1[/* h */ H, I],
  ij: js.Function1[/* i */ I, J],
  jk: js.Function1[/* j */ J, K],
  kl: js.Function1[/* k */ K, L]
): L = (typings.fpTs.pipeableMod.^.asInstanceOf[js.Dynamic].applyDynamic("pipe")(a.asInstanceOf[js.Any], ab.asInstanceOf[js.Any], bc.asInstanceOf[js.Any], cd.asInstanceOf[js.Any], de.asInstanceOf[js.Any], ef.asInstanceOf[js.Any], fg.asInstanceOf[js.Any], gh.asInstanceOf[js.Any], hi.asInstanceOf[js.Any], ij.asInstanceOf[js.Any], jk.asInstanceOf[js.Any], kl.asInstanceOf[js.Any])).asInstanceOf[L]
@scala.inline
def pipe[A, B, C, D, E, F, G, H, I, J, K, L, M](
  a: A,
  ab: js.Function1[/* a */ A, B],
  bc: js.Function1[/* b */ B, C],
  cd: js.Function1[/* c */ C, D],
  de: js.Function1[/* d */ D, E],
  ef: js.Function1[/* e */ E, F],
  fg: js.Function1[/* f */ F, G],
  gh: js.Function1[/* g */ G, H],
  hi: js.Function1[/* h */ H, I],
  ij: js.Function1[/* i */ I, J],
  jk: js.Function1[/* j */ J, K],
  kl: js.Function1[/* k */ K, L],
  lm: js.Function1[/* l */ L, M]
): M = (typings.fpTs.pipeableMod.^.asInstanceOf[js.Dynamic].applyDynamic("pipe")(a.asInstanceOf[js.Any], ab.asInstanceOf[js.Any], bc.asInstanceOf[js.Any], cd.asInstanceOf[js.Any], de.asInstanceOf[js.Any], ef.asInstanceOf[js.Any], fg.asInstanceOf[js.Any], gh.asInstanceOf[js.Any], hi.asInstanceOf[js.Any], ij.asInstanceOf[js.Any], jk.asInstanceOf[js.Any], kl.asInstanceOf[js.Any], lm.asInstanceOf[js.Any])).asInstanceOf[M]
@scala.inline
def pipe[A, B, C, D, E, F, G, H, I, J, K, L, M, N](
  a: A,
  ab: js.Function1[/* a */ A, B],
  bc: js.Function1[/* b */ B, C],
  cd: js.Function1[/* c */ C, D],
  de: js.Function1[/* d */ D, E],
  ef: js.Function1[/* e */ E, F],
  fg: js.Function1[/* f */ F, G],
  gh: js.Function1[/* g */ G, H],
  hi: js.Function1[/* h */ H, I],
  ij: js.Function1[/* i */ I, J],
  jk: js.Function1[/* j */ J, K],
  kl: js.Function1[/* k */ K, L],
  lm: js.Function1[/* l */ L, M],
  mn: js.Function1[/* m */ M, N]
): N = (typings.fpTs.pipeableMod.^.asInstanceOf[js.Dynamic].applyDynamic("pipe")(a.asInstanceOf[js.Any], ab.asInstanceOf[js.Any], bc.asInstanceOf[js.Any], cd.asInstanceOf[js.Any], de.asInstanceOf[js.Any], ef.asInstanceOf[js.Any], fg.asInstanceOf[js.Any], gh.asInstanceOf[js.Any], hi.asInstanceOf[js.Any], ij.asInstanceOf[js.Any], jk.asInstanceOf[js.Any], kl.asInstanceOf[js.Any], lm.asInstanceOf[js.Any], mn.asInstanceOf[js.Any])).asInstanceOf[N]
@scala.inline
def pipe[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O](
  a: A,
  ab: js.Function1[/* a */ A, B],
  bc: js.Function1[/* b */ B, C],
  cd: js.Function1[/* c */ C, D],
  de: js.Function1[/* d */ D, E],
  ef: js.Function1[/* e */ E, F],
  fg: js.Function1[/* f */ F, G],
  gh: js.Function1[/* g */ G, H],
  hi: js.Function1[/* h */ H, I],
  ij: js.Function1[/* i */ I, J],
  jk: js.Function1[/* j */ J, K],
  kl: js.Function1[/* k */ K, L],
  lm: js.Function1[/* l */ L, M],
  mn: js.Function1[/* m */ M, N],
  no: js.Function1[/* n */ N, O]
): O = (typings.fpTs.pipeableMod.^.asInstanceOf[js.Dynamic].applyDynamic("pipe")(a.asInstanceOf[js.Any], ab.asInstanceOf[js.Any], bc.asInstanceOf[js.Any], cd.asInstanceOf[js.Any], de.asInstanceOf[js.Any], ef.asInstanceOf[js.Any], fg.asInstanceOf[js.Any], gh.asInstanceOf[js.Any], hi.asInstanceOf[js.Any], ij.asInstanceOf[js.Any], jk.asInstanceOf[js.Any], kl.asInstanceOf[js.Any], lm.asInstanceOf[js.Any], mn.asInstanceOf[js.Any], no.asInstanceOf[js.Any])).asInstanceOf[O]
@scala.inline
def pipe[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P](
  a: A,
  ab: js.Function1[/* a */ A, B],
  bc: js.Function1[/* b */ B, C],
  cd: js.Function1[/* c */ C, D],
  de: js.Function1[/* d */ D, E],
  ef: js.Function1[/* e */ E, F],
  fg: js.Function1[/* f */ F, G],
  gh: js.Function1[/* g */ G, H],
  hi: js.Function1[/* h */ H, I],
  ij: js.Function1[/* i */ I, J],
  jk: js.Function1[/* j */ J, K],
  kl: js.Function1[/* k */ K, L],
  lm: js.Function1[/* l */ L, M],
  mn: js.Function1[/* m */ M, N],
  no: js.Function1[/* n */ N, O],
  op: js.Function1[/* o */ O, P]
): P = (typings.fpTs.pipeableMod.^.asInstanceOf[js.Dynamic].applyDynamic("pipe")(a.asInstanceOf[js.Any], ab.asInstanceOf[js.Any], bc.asInstanceOf[js.Any], cd.asInstanceOf[js.Any], de.asInstanceOf[js.Any], ef.asInstanceOf[js.Any], fg.asInstanceOf[js.Any], gh.asInstanceOf[js.Any], hi.asInstanceOf[js.Any], ij.asInstanceOf[js.Any], jk.asInstanceOf[js.Any], kl.asInstanceOf[js.Any], lm.asInstanceOf[js.Any], mn.asInstanceOf[js.Any], no.asInstanceOf[js.Any], op.asInstanceOf[js.Any])).asInstanceOf[P]
@scala.inline
def pipe[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q](
  a: A,
  ab: js.Function1[/* a */ A, B],
  bc: js.Function1[/* b */ B, C],
  cd: js.Function1[/* c */ C, D],
  de: js.Function1[/* d */ D, E],
  ef: js.Function1[/* e */ E, F],
  fg: js.Function1[/* f */ F, G],
  gh: js.Function1[/* g */ G, H],
  hi: js.Function1[/* h */ H, I],
  ij: js.Function1[/* i */ I, J],
  jk: js.Function1[/* j */ J, K],
  kl: js.Function1[/* k */ K, L],
  lm: js.Function1[/* l */ L, M],
  mn: js.Function1[/* m */ M, N],
  no: js.Function1[/* n */ N, O],
  op: js.Function1[/* o */ O, P],
  pq: js.Function1[/* p */ P, Q]
): Q = (typings.fpTs.pipeableMod.^.asInstanceOf[js.Dynamic].applyDynamic("pipe")(a.asInstanceOf[js.Any], ab.asInstanceOf[js.Any], bc.asInstanceOf[js.Any], cd.asInstanceOf[js.Any], de.asInstanceOf[js.Any], ef.asInstanceOf[js.Any], fg.asInstanceOf[js.Any], gh.asInstanceOf[js.Any], hi.asInstanceOf[js.Any], ij.asInstanceOf[js.Any], jk.asInstanceOf[js.Any], kl.asInstanceOf[js.Any], lm.asInstanceOf[js.Any], mn.asInstanceOf[js.Any], no.asInstanceOf[js.Any], op.asInstanceOf[js.Any], pq.asInstanceOf[js.Any])).asInstanceOf[Q]
@scala.inline
def pipe[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R](
  a: A,
  ab: js.Function1[/* a */ A, B],
  bc: js.Function1[/* b */ B, C],
  cd: js.Function1[/* c */ C, D],
  de: js.Function1[/* d */ D, E],
  ef: js.Function1[/* e */ E, F],
  fg: js.Function1[/* f */ F, G],
  gh: js.Function1[/* g */ G, H],
  hi: js.Function1[/* h */ H, I],
  ij: js.Function1[/* i */ I, J],
  jk: js.Function1[/* j */ J, K],
  kl: js.Function1[/* k */ K, L],
  lm: js.Function1[/* l */ L, M],
  mn: js.Function1[/* m */ M, N],
  no: js.Function1[/* n */ N, O],
  op: js.Function1[/* o */ O, P],
  pq: js.Function1[/* p */ P, Q],
  qr: js.Function1[/* q */ Q, R]
): R = (typings.fpTs.pipeableMod.^.asInstanceOf[js.Dynamic].applyDynamic("pipe")(a.asInstanceOf[js.Any], ab.asInstanceOf[js.Any], bc.asInstanceOf[js.Any], cd.asInstanceOf[js.Any], de.asInstanceOf[js.Any], ef.asInstanceOf[js.Any], fg.asInstanceOf[js.Any], gh.asInstanceOf[js.Any], hi.asInstanceOf[js.Any], ij.asInstanceOf[js.Any], jk.asInstanceOf[js.Any], kl.asInstanceOf[js.Any], lm.asInstanceOf[js.Any], mn.asInstanceOf[js.Any], no.asInstanceOf[js.Any], op.asInstanceOf[js.Any], pq.asInstanceOf[js.Any], qr.asInstanceOf[js.Any])).asInstanceOf[R]
@scala.inline
def pipe[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S](
  a: A,
  ab: js.Function1[/* a */ A, B],
  bc: js.Function1[/* b */ B, C],
  cd: js.Function1[/* c */ C, D],
  de: js.Function1[/* d */ D, E],
  ef: js.Function1[/* e */ E, F],
  fg: js.Function1[/* f */ F, G],
  gh: js.Function1[/* g */ G, H],
  hi: js.Function1[/* h */ H, I],
  ij: js.Function1[/* i */ I, J],
  jk: js.Function1[/* j */ J, K],
  kl: js.Function1[/* k */ K, L],
  lm: js.Function1[/* l */ L, M],
  mn: js.Function1[/* m */ M, N],
  no: js.Function1[/* n */ N, O],
  op: js.Function1[/* o */ O, P],
  pq: js.Function1[/* p */ P, Q],
  qr: js.Function1[/* q */ Q, R],
  rs: js.Function1[/* r */ R, S]
): S = (typings.fpTs.pipeableMod.^.asInstanceOf[js.Dynamic].applyDynamic("pipe")(a.asInstanceOf[js.Any], ab.asInstanceOf[js.Any], bc.asInstanceOf[js.Any], cd.asInstanceOf[js.Any], de.asInstanceOf[js.Any], ef.asInstanceOf[js.Any], fg.asInstanceOf[js.Any], gh.asInstanceOf[js.Any], hi.asInstanceOf[js.Any], ij.asInstanceOf[js.Any], jk.asInstanceOf[js.Any], kl.asInstanceOf[js.Any], lm.asInstanceOf[js.Any], mn.asInstanceOf[js.Any], no.asInstanceOf[js.Any], op.asInstanceOf[js.Any], pq.asInstanceOf[js.Any], qr.asInstanceOf[js.Any], rs.asInstanceOf[js.Any])).asInstanceOf[S]
@scala.inline
def pipe[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T](
  a: A,
  ab: js.Function1[/* a */ A, B],
  bc: js.Function1[/* b */ B, C],
  cd: js.Function1[/* c */ C, D],
  de: js.Function1[/* d */ D, E],
  ef: js.Function1[/* e */ E, F],
  fg: js.Function1[/* f */ F, G],
  gh: js.Function1[/* g */ G, H],
  hi: js.Function1[/* h */ H, I],
  ij: js.Function1[/* i */ I, J],
  jk: js.Function1[/* j */ J, K],
  kl: js.Function1[/* k */ K, L],
  lm: js.Function1[/* l */ L, M],
  mn: js.Function1[/* m */ M, N],
  no: js.Function1[/* n */ N, O],
  op: js.Function1[/* o */ O, P],
  pq: js.Function1[/* p */ P, Q],
  qr: js.Function1[/* q */ Q, R],
  rs: js.Function1[/* r */ R, S],
  st: js.Function1[/* s */ S, T]
): T = (typings.fpTs.pipeableMod.^.asInstanceOf[js.Dynamic].applyDynamic("pipe")(a.asInstanceOf[js.Any], ab.asInstanceOf[js.Any], bc.asInstanceOf[js.Any], cd.asInstanceOf[js.Any], de.asInstanceOf[js.Any], ef.asInstanceOf[js.Any], fg.asInstanceOf[js.Any], gh.asInstanceOf[js.Any], hi.asInstanceOf[js.Any], ij.asInstanceOf[js.Any], jk.asInstanceOf[js.Any], kl.asInstanceOf[js.Any], lm.asInstanceOf[js.Any], mn.asInstanceOf[js.Any], no.asInstanceOf[js.Any], op.asInstanceOf[js.Any], pq.asInstanceOf[js.Any], qr.asInstanceOf[js.Any], rs.asInstanceOf[js.Any], st.asInstanceOf[js.Any])).asInstanceOf[T]

@scala.inline
def pipeable[F /* <: /* import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify URIS4 */ js.Any */, I](I: typings.fpTs.anon.URI[F] & I): (js.Object | typings.fpTs.pipeableMod.PipeableFunctor4[F] | typings.fpTs.pipeableMod.PipeableApply4[F] | typings.fpTs.pipeableMod.PipeableChain4[F]) & (js.Object | typings.fpTs.pipeableMod.PipeableContravariant4[F]) & (js.Object | (typings.fpTs.pipeableMod.PipeableFunctorWithIndex4[F, js.Any])) & (js.Object | typings.fpTs.pipeableMod.PipeableBifunctor4[F]) & (js.Object | typings.fpTs.pipeableMod.PipeableExtend4[F]) & (js.Object | typings.fpTs.pipeableMod.PipeableFoldable4[F] | (typings.fpTs.pipeableMod.PipeableFoldableWithIndex4[F, js.Any])) & (js.Object | typings.fpTs.pipeableMod.PipeableAlt4[F]) & (js.Object | typings.fpTs.pipeableMod.PipeableCompactable4[F] | typings.fpTs.pipeableMod.PipeableFilterable4[F] | (typings.fpTs.pipeableMod.PipeableFilterableWithIndex4[F, js.Any])) & (js.Object | typings.fpTs.pipeableMod.PipeableProfunctor4[F]) & (js.Object | typings.fpTs.pipeableMod.PipeableSemigroupoid4[F]) & (js.Object | typings.fpTs.pipeableMod.PipeableMonadThrow4[F]) = typings.fpTs.pipeableMod.^.asInstanceOf[js.Dynamic].applyDynamic("pipeable")(I.asInstanceOf[js.Any]).asInstanceOf[(js.Object | typings.fpTs.pipeableMod.PipeableFunctor4[F] | typings.fpTs.pipeableMod.PipeableApply4[F] | typings.fpTs.pipeableMod.PipeableChain4[F]) & (js.Object | typings.fpTs.pipeableMod.PipeableContravariant4[F]) & (js.Object | (typings.fpTs.pipeableMod.PipeableFunctorWithIndex4[F, js.Any])) & (js.Object | typings.fpTs.pipeableMod.PipeableBifunctor4[F]) & (js.Object | typings.fpTs.pipeableMod.PipeableExtend4[F]) & (js.Object | typings.fpTs.pipeableMod.PipeableFoldable4[F] | (typings.fpTs.pipeableMod.PipeableFoldableWithIndex4[F, js.Any])) & (js.Object | typings.fpTs.pipeableMod.PipeableAlt4[F]) & (js.Object | typings.fpTs.pipeableMod.PipeableCompactable4[F] | typings.fpTs.pipeableMod.PipeableFilterable4[F] | (typings.fpTs.pipeableMod.PipeableFilterableWithIndex4[F, js.Any])) & (js.Object | typings.fpTs.pipeableMod.PipeableProfunctor4[F]) & (js.Object | typings.fpTs.pipeableMod.PipeableSemigroupoid4[F]) & (js.Object | typings.fpTs.pipeableMod.PipeableMonadThrow4[F])]

@scala.inline
def pipeable_FI[F, I](I: typings.fpTs.anon.URIF[F] & I): (js.Object | typings.fpTs.pipeableMod.PipeableFunctor[F] | typings.fpTs.pipeableMod.PipeableApply[F] | typings.fpTs.pipeableMod.PipeableChain[F]) & (js.Object | typings.fpTs.pipeableMod.PipeableContravariant[F]) & (js.Object | (typings.fpTs.pipeableMod.PipeableFunctorWithIndex[F, js.Any])) & (js.Object | typings.fpTs.pipeableMod.PipeableBifunctor[F]) & (js.Object | typings.fpTs.pipeableMod.PipeableExtend[F]) & (js.Object | typings.fpTs.pipeableMod.PipeableFoldable[F] | (typings.fpTs.pipeableMod.PipeableFoldableWithIndex[F, js.Any])) & (js.Object | typings.fpTs.pipeableMod.PipeableAlt[F]) & (js.Object | typings.fpTs.pipeableMod.PipeableCompactable[F] | typings.fpTs.pipeableMod.PipeableFilterable[F] | (typings.fpTs.pipeableMod.PipeableFilterableWithIndex[F, js.Any])) & (js.Object | typings.fpTs.pipeableMod.PipeableProfunctor[F]) & (js.Object | typings.fpTs.pipeableMod.PipeableSemigroupoid[F]) & (js.Object | typings.fpTs.pipeableMod.PipeableMonadThrow[F]) = typings.fpTs.pipeableMod.^.asInstanceOf[js.Dynamic].applyDynamic("pipeable")(I.asInstanceOf[js.Any]).asInstanceOf[(js.Object | typings.fpTs.pipeableMod.PipeableFunctor[F] | typings.fpTs.pipeableMod.PipeableApply[F] | typings.fpTs.pipeableMod.PipeableChain[F]) & (js.Object | typings.fpTs.pipeableMod.PipeableContravariant[F]) & (js.Object | (typings.fpTs.pipeableMod.PipeableFunctorWithIndex[F, js.Any])) & (js.Object | typings.fpTs.pipeableMod.PipeableBifunctor[F]) & (js.Object | typings.fpTs.pipeableMod.PipeableExtend[F]) & (js.Object | typings.fpTs.pipeableMod.PipeableFoldable[F] | (typings.fpTs.pipeableMod.PipeableFoldableWithIndex[F, js.Any])) & (js.Object | typings.fpTs.pipeableMod.PipeableAlt[F]) & (js.Object | typings.fpTs.pipeableMod.PipeableCompactable[F] | typings.fpTs.pipeableMod.PipeableFilterable[F] | (typings.fpTs.pipeableMod.PipeableFilterableWithIndex[F, js.Any])) & (js.Object | typings.fpTs.pipeableMod.PipeableProfunctor[F]) & (js.Object | typings.fpTs.pipeableMod.PipeableSemigroupoid[F]) & (js.Object | typings.fpTs.pipeableMod.PipeableMonadThrow[F])]

@scala.inline
def pipeable_F_AnyIE[F /* <: /* import warning: transforms.QualifyReferences#resolveTypeRef many Couldn't qualify URIS3 */ js.Any */, I, E](I: typings.fpTs.anon.URI[F] & I & (typings.fpTs.anon.EURI[F, E])): (js.Object | (typings.fpTs.pipeableMod.PipeableFunctor3C[F, E]) | (typings.fpTs.pipeableMod.PipeableApply3C[F, E]) | (typings.fpTs.pipeableMod.PipeableChain3C[F, E])) & (js.Object | (typings.fpTs.pipeableMod.PipeableContravariant3C[F, E])) & (js.Object | (typings.fpTs.pipeableMod.PipeableFunctorWithIndex3C[F, js.Any, E])) & (js.Object | (typings.fpTs.pipeableMod.PipeableBifunctor3C[F, E])) & (js.Object | (typings.fpTs.pipeableMod.PipeableExtend3C[F, E])) & (js.Object | (typings.fpTs.pipeableMod.PipeableFoldable3C[F, E]) | (typings.fpTs.pipeableMod.PipeableFoldableWithIndex3C[F, js.Any, E])) & (js.Object | (typings.fpTs.pipeableMod.PipeableAlt3C[F, E])) & (js.Object | (typings.fpTs.pipeableMod.PipeableCompactable3C[F, E]) | (typings.fpTs.pipeableMod.PipeableFilterable3C[F, E]) | (typings.fpTs.pipeableMod.PipeableFilterableWithIndex3C[F, js.Any, E])) & (js.Object | (typings.fpTs.pipeableMod.PipeableProfunctor3C[F, E])) & (js.Object | (typings.fpTs.pipeableMod.PipeableSemigroupoid3C[F, E])) & (js.Object | (typings.fpTs.pipeableMod.PipeableMonadThrow3C[F, E])) = typings.fpTs.pipeableMod.^.asInstanceOf[js.Dynamic].applyDynamic("pipeable")(I.asInstanceOf[js.Any]).asInstanceOf[(js.Object | (typings.fpTs.pipeableMod.PipeableFunctor3C[F, E]) | (typings.fpTs.pipeableMod.PipeableApply3C[F, E]) | (typings.fpTs.pipeableMod.PipeableChain3C[F, E])) & (js.Object | (typings.fpTs.pipeableMod.PipeableContravariant3C[F, E])) & (js.Object | (typings.fpTs.pipeableMod.PipeableFunctorWithIndex3C[F, js.Any, E])) & (js.Object | (typings.fpTs.pipeableMod.PipeableBifunctor3C[F, E])) & (js.Object | (typings.fpTs.pipeableMod.PipeableExtend3C[F, E])) & (js.Object | (typings.fpTs.pipeableMod.PipeableFoldable3C[F, E]) | (typings.fpTs.pipeableMod.PipeableFoldableWithIndex3C[F, js.Any, E])) & (js.Object | (typings.fpTs.pipeableMod.PipeableAlt3C[F, E])) & (js.Object | (typings.fpTs.pipeableMod.PipeableCompactable3C[F, E]) | (typings.fpTs.pipeableMod.PipeableFilterable3C[F, E]) | (typings.fpTs.pipeableMod.PipeableFilterableWithIndex3C[F, js.Any, E])) & (js.Object | (typings.fpTs.pipeableMod.PipeableProfunctor3C[F, E])) & (js.Object | (typings.fpTs.pipeableMod.PipeableSemigroupoid3C[F, E])) & (js.Object | (typings.fpTs.pipeableMod.PipeableMonadThrow3C[F, E]))]
