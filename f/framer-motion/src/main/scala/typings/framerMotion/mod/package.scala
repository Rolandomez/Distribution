package typings.framerMotion.mod

import org.scalablytyped.runtime.StringDictionary
import typings.framerMotion.anon.FnCallFromToOptions
import typings.framerMotion.anon.PartialBoundingBox
import typings.framerMotion.anon.PartialScaleMotionValues
import typings.framerMotion.anon.ReadonlyArraystring
import typings.framerMotion.anon.ScrollX
import typings.framerMotion.framerMotionBooleans.`false`
import typings.framerMotion.framerMotionBooleans.`true`
import typings.framerMotion.framerMotionStrings.Lessthansign
import typings.framerMotion.framerMotionStrings.animationCancel
import typings.framerMotion.framerMotionStrings.animationComplete_
import typings.framerMotion.framerMotionStrings.animationStart_
import typings.framerMotion.framerMotionStrings.change
import typings.framerMotion.framerMotionStrings.id
import typings.framerMotion.framerMotionStrings.renderRequest
import typings.framerMotion.framerMotionStrings.velocityChange
import typings.framerMotion.mod.^
import typings.react.mod.ComponentType
import typings.react.mod.Context
import typings.react.mod.DependencyList
import typings.react.mod.EffectCallback
import typings.react.mod.ForwardRefExoticComponent
import typings.react.mod.FunctionComponent
import typings.react.mod.HTMLAttributes
import typings.react.mod.PropsWithChildren
import typings.react.mod.PropsWithoutRef
import typings.react.mod.Ref
import typings.react.mod.RefAttributes
import typings.react.mod.global.JSX.Element
import typings.std.AddEventListenerOptions
import typings.std.Animation
import typings.std.EventListener
import typings.std.EventTarget
import typings.std.Exclude
import typings.std.HTMLElement
import typings.std.IntersectionObserverEntry
import typings.std.NodeListOf
import typings.std.Pick
import typings.std.PointerEvent
import typings.std.SVGElement
import typings.std.TemplateStringsArray
import typings.std.VoidFunction
import typings.std.WeakMap
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}


/**
  * `AnimatePresence` enables the animation of components that have been removed from the tree.
  *
  * When adding/removing more than a single child, every child **must** be given a unique `key` prop.
  *
  * Any `motion` components that have an `exit` property defined will animate out when removed from
  * the tree.
  *
  * ```jsx
  * import { motion, AnimatePresence } from 'framer-motion'
  *
  * export const Items = ({ items }) => (
  *   <AnimatePresence>
  *     {items.map(item => (
  *       <motion.div
  *         key={item.id}
  *         initial={{ opacity: 0 }}
  *         animate={{ opacity: 1 }}
  *         exit={{ opacity: 0 }}
  *       />
  *     ))}
  *   </AnimatePresence>
  * )
  * ```
  *
  * You can sequence exit animations throughout a tree using variants.
  *
  * If a child contains multiple `motion` components with `exit` props, it will only unmount the child
  * once all `motion` components have finished animating out. Likewise, any components using
  * `usePresence` all need to call `safeToRemove`.
  *
  * @public
  */
inline def AnimatePresence: FunctionComponent[PropsWithChildren[AnimatePresenceProps]] = ^.asInstanceOf[js.Dynamic].selectDynamic("AnimatePresence").asInstanceOf[FunctionComponent[PropsWithChildren[AnimatePresenceProps]]]

inline def AnimateSharedLayout: FunctionComponent[PropsWithChildren[Any]] = ^.asInstanceOf[js.Dynamic].selectDynamic("AnimateSharedLayout").asInstanceOf[FunctionComponent[PropsWithChildren[Any]]]

/**
  * Note: Still used by components generated by old versions of Framer
  *
  * @deprecated
  */
inline def DeprecatedLayoutGroupContext: Context[String | Null] = ^.asInstanceOf[js.Dynamic].selectDynamic("DeprecatedLayoutGroupContext").asInstanceOf[Context[String | Null]]

inline def LayoutGroup: FunctionComponent[PropsWithChildren[Props2]] = ^.asInstanceOf[js.Dynamic].selectDynamic("LayoutGroup").asInstanceOf[FunctionComponent[PropsWithChildren[Props2]]]

inline def LayoutGroupContext: Context[LayoutGroupContextProps] = ^.asInstanceOf[js.Dynamic].selectDynamic("LayoutGroupContext").asInstanceOf[Context[LayoutGroupContextProps]]

/**
  * Used in conjunction with the `m` component to reduce bundle size.
  *
  * `m` is a version of the `motion` component that only loads functionality
  * critical for the initial render.
  *
  * `LazyMotion` can then be used to either synchronously or asynchronously
  * load animation and gesture support.
  *
  * ```jsx
  * // Synchronous loading
  * import { LazyMotion, m, domAnimation } from "framer-motion"
  *
  * function App() {
  *   return (
  *     <LazyMotion features={domAnimation}>
  *       <m.div animate={{ scale: 2 }} />
  *     </LazyMotion>
  *   )
  * }
  *
  * // Asynchronous loading
  * import { LazyMotion, m } from "framer-motion"
  *
  * function App() {
  *   return (
  *     <LazyMotion features={() => import('./path/to/domAnimation')}>
  *       <m.div animate={{ scale: 2 }} />
  *     </LazyMotion>
  *   )
  * }
  * ```
  *
  * @public
  */
inline def LazyMotion(param0: LazyProps): Element = ^.asInstanceOf[js.Dynamic].applyDynamic("LazyMotion")(param0.asInstanceOf[js.Any]).asInstanceOf[Element]

/**
  * `MotionConfig` is used to set configuration options for all children `motion` components.
  *
  * ```jsx
  * import { motion, MotionConfig } from "framer-motion"
  *
  * export function App() {
  *   return (
  *     <MotionConfig transition={{ type: "spring" }}>
  *       <motion.div animate={{ x: 100 }} />
  *     </MotionConfig>
  *   )
  * }
  * ```
  *
  * @public
  */
inline def MotionConfig(param0: MotionConfigProps): Element = ^.asInstanceOf[js.Dynamic].applyDynamic("MotionConfig")(param0.asInstanceOf[js.Any]).asInstanceOf[Element]

inline def MotionContext: Context[MotionContextProps[Any]] = ^.asInstanceOf[js.Dynamic].selectDynamic("MotionContext").asInstanceOf[Context[MotionContextProps[Any]]]

/**
  * @public
  */
inline def PresenceContext: Context[PresenceContextProps | Null] = ^.asInstanceOf[js.Dynamic].selectDynamic("PresenceContext").asInstanceOf[Context[PresenceContextProps | Null]]

inline def addPointerEvent(target: EventTarget, eventName: String, handler: EventListenerWithPointInfo): js.Function0[Unit] = (^.asInstanceOf[js.Dynamic].applyDynamic("addPointerEvent")(target.asInstanceOf[js.Any], eventName.asInstanceOf[js.Any], handler.asInstanceOf[js.Any])).asInstanceOf[js.Function0[Unit]]
inline def addPointerEvent(
  target: EventTarget,
  eventName: String,
  handler: EventListenerWithPointInfo,
  options: AddEventListenerOptions
): js.Function0[Unit] = (^.asInstanceOf[js.Dynamic].applyDynamic("addPointerEvent")(target.asInstanceOf[js.Any], eventName.asInstanceOf[js.Any], handler.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[js.Function0[Unit]]

inline def addPointerInfo(handler: EventListenerWithPointInfo): EventListener = ^.asInstanceOf[js.Dynamic].applyDynamic("addPointerInfo")(handler.asInstanceOf[js.Any]).asInstanceOf[EventListener]

inline def addScaleCorrector(correctors: ScaleCorrectorMap): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("addScaleCorrector")(correctors.asInstanceOf[js.Any]).asInstanceOf[Unit]

inline def animate(sequence: AnimationSequence): AnimationPlaybackControls = ^.asInstanceOf[js.Dynamic].applyDynamic("animate")(sequence.asInstanceOf[js.Any]).asInstanceOf[AnimationPlaybackControls]
inline def animate(sequence: AnimationSequence, options: SequenceOptions): AnimationPlaybackControls = (^.asInstanceOf[js.Dynamic].applyDynamic("animate")(sequence.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[AnimationPlaybackControls]
inline def animate(value: ElementOrSelector, keyframes: DOMKeyframesDefinition): AnimationPlaybackControls = (^.asInstanceOf[js.Dynamic].applyDynamic("animate")(value.asInstanceOf[js.Any], keyframes.asInstanceOf[js.Any])).asInstanceOf[AnimationPlaybackControls]
inline def animate(value: ElementOrSelector, keyframes: DOMKeyframesDefinition, options: DynamicAnimationOptions): AnimationPlaybackControls = (^.asInstanceOf[js.Dynamic].applyDynamic("animate")(value.asInstanceOf[js.Any], keyframes.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[AnimationPlaybackControls]
inline def animate[V](from: V, to: GenericKeyframesTarget[V] | V): AnimationPlaybackControls = (^.asInstanceOf[js.Dynamic].applyDynamic("animate")(from.asInstanceOf[js.Any], to.asInstanceOf[js.Any])).asInstanceOf[AnimationPlaybackControls]
inline def animate[V](from: V, to: GenericKeyframesTarget[V] | V, options: ValueAnimationTransition[V]): AnimationPlaybackControls = (^.asInstanceOf[js.Dynamic].applyDynamic("animate")(from.asInstanceOf[js.Any], to.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[AnimationPlaybackControls]
inline def animate[V_1](value: MotionValue_[V_1], keyframes: GenericKeyframesTarget[V_1] | V_1): AnimationPlaybackControls = (^.asInstanceOf[js.Dynamic].applyDynamic("animate")(value.asInstanceOf[js.Any], keyframes.asInstanceOf[js.Any])).asInstanceOf[AnimationPlaybackControls]
inline def animate[V_1](
  value: MotionValue_[V_1],
  keyframes: GenericKeyframesTarget[V_1] | V_1,
  options: ValueAnimationTransition[V_1]
): AnimationPlaybackControls = (^.asInstanceOf[js.Dynamic].applyDynamic("animate")(value.asInstanceOf[js.Any], keyframes.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[AnimationPlaybackControls]

/**
  * Animate a single value on the main thread.
  *
  * This function is written, where functionality overlaps,
  * to be largely spec-compliant with WAAPI to allow fungibility
  * between the two.
  */
inline def animateValue[V](param0: ValueAnimationOptions[V]): MainThreadAnimationControls[V] = ^.asInstanceOf[js.Dynamic].applyDynamic("animateValue")(param0.asInstanceOf[js.Any]).asInstanceOf[MainThreadAnimationControls[V]]

inline def animateVisualElement(visualElement: VisualElement[Any, Any, js.Object], definition: AnimationDefinition): js.Promise[Unit] = (^.asInstanceOf[js.Dynamic].applyDynamic("animateVisualElement")(visualElement.asInstanceOf[js.Any], definition.asInstanceOf[js.Any])).asInstanceOf[js.Promise[Unit]]
inline def animateVisualElement(
  visualElement: VisualElement[Any, Any, js.Object],
  definition: AnimationDefinition,
  options: VisualElementAnimationOptions
): js.Promise[Unit] = (^.asInstanceOf[js.Dynamic].applyDynamic("animateVisualElement")(visualElement.asInstanceOf[js.Any], definition.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[js.Promise[Unit]]

/**
  * @public
  */
inline def animationControls(): AnimationControls_ = ^.asInstanceOf[js.Dynamic].applyDynamic("animationControls")().asInstanceOf[AnimationControls_]

inline def animations: FeaturePackages = ^.asInstanceOf[js.Dynamic].selectDynamic("animations").asInstanceOf[FeaturePackages]

inline def anticipate(p: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("anticipate")(p.asInstanceOf[js.Any]).asInstanceOf[Double]

inline def backIn: EasingFunction = ^.asInstanceOf[js.Dynamic].selectDynamic("backIn").asInstanceOf[EasingFunction]

inline def backInOut: EasingFunction = ^.asInstanceOf[js.Dynamic].selectDynamic("backInOut").asInstanceOf[EasingFunction]

inline def backOut(t: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("backOut")(t.asInstanceOf[js.Any]).asInstanceOf[Double]

/**
  * Build a CSS transform style from individual x/y/scale etc properties.
  *
  * This outputs with a default order of transforms/scales/rotations, this can be customised by
  * providing a transformTemplate function.
  */
inline def buildTransform(transform: ResolvedValues, param1: DOMVisualElementOptions, transformIsDefault: Boolean): String = (^.asInstanceOf[js.Dynamic].applyDynamic("buildTransform")(transform.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], transformIsDefault.asInstanceOf[js.Any])).asInstanceOf[String]
inline def buildTransform(
  transform: ResolvedValues,
  param1: DOMVisualElementOptions,
  transformIsDefault: Boolean,
  transformTemplate: js.UndefOr[
  js.Function2[/* transform */ TransformProperties, /* generatedTransform */ String, String]
]
): String = (^.asInstanceOf[js.Dynamic].applyDynamic("buildTransform")(transform.asInstanceOf[js.Any], param1.asInstanceOf[js.Any], transformIsDefault.asInstanceOf[js.Any], transformTemplate.asInstanceOf[js.Any])).asInstanceOf[String]

inline def calcLength(axis: Axis): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("calcLength")(axis.asInstanceOf[js.Any]).asInstanceOf[Double]

inline def cancelFrame(process: Process): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("cancelFrame")(process.asInstanceOf[js.Any]).asInstanceOf[Unit]

inline def checkTargetForNewValues(
  visualElement: VisualElement[Any, Any, js.Object],
  target: TargetWithKeyframes,
  origin: ResolvedValues
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("checkTargetForNewValues")(visualElement.asInstanceOf[js.Any], target.asInstanceOf[js.Any], origin.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def circIn: EasingFunction = ^.asInstanceOf[js.Dynamic].selectDynamic("circIn").asInstanceOf[EasingFunction]

inline def circInOut: EasingFunction = ^.asInstanceOf[js.Dynamic].selectDynamic("circInOut").asInstanceOf[EasingFunction]

inline def circOut: EasingFunction = ^.asInstanceOf[js.Dynamic].selectDynamic("circOut").asInstanceOf[EasingFunction]

inline def clamp(min: Double, max: Double, v: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("clamp")(min.asInstanceOf[js.Any], max.asInstanceOf[js.Any], v.asInstanceOf[js.Any])).asInstanceOf[Double]

inline def createBox(): Box = ^.asInstanceOf[js.Dynamic].applyDynamic("createBox")().asInstanceOf[Box]

/**
  * Create a DOM `motion` component with the provided string. This is primarily intended
  * as a full alternative to `motion` for consumers who have to support environments that don't
  * support `Proxy`.
  *
  * ```javascript
  * import { createDomMotionComponent } from "framer-motion"
  *
  * const motion = {
  *   div: createDomMotionComponent('div')
  * }
  * ```
  *
  * @public
  */
inline def createDomMotionComponent[T /* <: /* keyof framer-motion.framer-motion.DOMMotionComponents */ String */](key: T): /* import warning: importer.ImportType#apply Failed type conversion: framer-motion.framer-motion.DOMMotionComponents[T] */ js.Any = ^.asInstanceOf[js.Dynamic].applyDynamic("createDomMotionComponent")(key.asInstanceOf[js.Any]).asInstanceOf[/* import warning: importer.ImportType#apply Failed type conversion: framer-motion.framer-motion.DOMMotionComponents[T] */ js.Any]

/**
  * Create a `motion` component.
  *
  * This function accepts a Component argument, which can be either a string (ie "div"
  * for `motion.div`), or an actual React component.
  *
  * Alongside this is a config option which provides a way of rendering the provided
  * component "offline", or outside the React render cycle.
  */
inline def createMotionComponent[Props /* <: js.Object */, Instance, RenderState](param0: MotionComponentConfig[Instance, RenderState]): ForwardRefExoticComponent[(PropsWithoutRef[Props & MotionProps]) & RefAttributes[Instance]] = ^.asInstanceOf[js.Dynamic].applyDynamic("createMotionComponent")(param0.asInstanceOf[js.Any]).asInstanceOf[ForwardRefExoticComponent[(PropsWithoutRef[Props & MotionProps]) & RefAttributes[Instance]]]

inline def createScopedAnimate(): FnCallFromToOptions = ^.asInstanceOf[js.Dynamic].applyDynamic("createScopedAnimate")().asInstanceOf[FnCallFromToOptions]
inline def createScopedAnimate(scope: AnimationScope[Any]): FnCallFromToOptions = ^.asInstanceOf[js.Dynamic].applyDynamic("createScopedAnimate")(scope.asInstanceOf[js.Any]).asInstanceOf[FnCallFromToOptions]

inline def cubicBezier(mX1: Double, mY1: Double, mX2: Double, mY2: Double): js.Function1[/* t */ Double, Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("cubicBezier")(mX1.asInstanceOf[js.Any], mY1.asInstanceOf[js.Any], mX2.asInstanceOf[js.Any], mY2.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Double]]

/**
  * Timeout defined in ms
  */
inline def delay(callback: DelayedFunction, timeout: Double): js.Function0[Unit] = (^.asInstanceOf[js.Dynamic].applyDynamic("delay")(callback.asInstanceOf[js.Any], timeout.asInstanceOf[js.Any])).asInstanceOf[js.Function0[Unit]]

inline def distance(a: Double, b: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("distance")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[Double]

inline def distance2D(a: Point, b: Point): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("distance2D")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[Double]

/**
  * @public
  */
inline def domAnimation: FeatureBundle = ^.asInstanceOf[js.Dynamic].selectDynamic("domAnimation").asInstanceOf[FeatureBundle]

/**
  * @public
  */
inline def domMax: FeatureBundle = ^.asInstanceOf[js.Dynamic].selectDynamic("domMax").asInstanceOf[FeatureBundle]

inline def easeIn(t: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeIn")(t.asInstanceOf[js.Any]).asInstanceOf[Double]

inline def easeInOut(t: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeInOut")(t.asInstanceOf[js.Any]).asInstanceOf[Double]

inline def easeOut(t: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeOut")(t.asInstanceOf[js.Any]).asInstanceOf[Double]

inline def filterProps(props: MotionProps, isDom: Boolean, forwardMotionProps: Boolean): js.Object = (^.asInstanceOf[js.Dynamic].applyDynamic("filterProps")(props.asInstanceOf[js.Any], isDom.asInstanceOf[js.Any], forwardMotionProps.asInstanceOf[js.Any])).asInstanceOf[js.Object]

inline def frame: Frameloop = ^.asInstanceOf[js.Dynamic].selectDynamic("frame").asInstanceOf[Frameloop]

inline def inView(
  elementOrSelector: ElementOrSelector,
  onStart: js.Function1[/* entry */ IntersectionObserverEntry, Unit | ViewChangeHandler]
): VoidFunction = (^.asInstanceOf[js.Dynamic].applyDynamic("inView")(elementOrSelector.asInstanceOf[js.Any], onStart.asInstanceOf[js.Any])).asInstanceOf[VoidFunction]
inline def inView(
  elementOrSelector: ElementOrSelector,
  onStart: js.Function1[/* entry */ IntersectionObserverEntry, Unit | ViewChangeHandler],
  param2: InViewOptions
): VoidFunction = (^.asInstanceOf[js.Dynamic].applyDynamic("inView")(elementOrSelector.asInstanceOf[js.Any], onStart.asInstanceOf[js.Any], param2.asInstanceOf[js.Any])).asInstanceOf[VoidFunction]

/**
  * Create a function that maps from a numerical input array to a generic output array.
  *
  * Accepts:
  *   - Numbers
  *   - Colors (hex, hsl, hsla, rgb, rgba)
  *   - Complex (combinations of one or more numbers or strings)
  *
  * ```jsx
  * const mixColor = interpolate([0, 1], ['#fff', '#000'])
  *
  * mixColor(0.5) // 'rgba(128, 128, 128, 1)'
  * ```
  *
  * TODO Revist this approach once we've moved to data models for values,
  * probably not needed to pregenerate mixer functions.
  *
  * @public
  */
inline def interpolate[T](input: js.Array[Double], output: js.Array[T]): js.Function1[/* v */ Double, T] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(input.asInstanceOf[js.Any], output.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* v */ Double, T]]
inline def interpolate[T](input: js.Array[Double], output: js.Array[T], param2: InterpolateOptions[T]): js.Function1[/* v */ Double, T] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(input.asInstanceOf[js.Any], output.asInstanceOf[js.Any], param2.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* v */ Double, T]]

inline def invariant: DevMessage = ^.asInstanceOf[js.Dynamic].selectDynamic("invariant").asInstanceOf[DevMessage]
inline def invariant_=(x: DevMessage): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("invariant")(x.asInstanceOf[js.Any])

inline def isBrowser: Boolean = ^.asInstanceOf[js.Dynamic].selectDynamic("isBrowser").asInstanceOf[Boolean]

inline def isDragActive(): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isDragActive")().asInstanceOf[Boolean]

inline def isMotionComponent(component: String): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isMotionComponent")(component.asInstanceOf[js.Any]).asInstanceOf[Boolean]
/**
  * Checks if a component is a `motion` component.
  */
inline def isMotionComponent(component: ComponentType[js.Object]): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isMotionComponent")(component.asInstanceOf[js.Any]).asInstanceOf[Boolean]

inline def isMotionValue(value: Any): /* is framer-motion.framer-motion.MotionValue<any> */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isMotionValue")(value.asInstanceOf[js.Any]).asInstanceOf[/* is framer-motion.framer-motion.MotionValue<any> */ Boolean]

/**
  * Check whether a prop name is a valid `MotionProp` key.
  *
  * @param key - Name of the property to check
  * @returns `true` is key is a valid `MotionProp`.
  *
  * @public
  */
inline def isValidMotionProp(key: String): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isValidMotionProp")(key.asInstanceOf[js.Any]).asInstanceOf[Boolean]

/**
  * @public
  */
inline def m: (js.Function2[
/* Component */ String | ComponentType[PropsWithChildren[js.Object]], 
/* customMotionComponentConfig */ js.UndefOr[CustomMotionComponentConfig], 
CustomDomComponent[js.Object]]) & HTMLMotionComponents & SVGMotionComponents = ^.asInstanceOf[js.Dynamic].selectDynamic("m").asInstanceOf[(js.Function2[
/* Component */ String | ComponentType[PropsWithChildren[js.Object]], 
/* customMotionComponentConfig */ js.UndefOr[CustomMotionComponentConfig], 
CustomDomComponent[js.Object]]) & HTMLMotionComponents & SVGMotionComponents]

inline def makeUseVisualState[I, RS](config: UseVisualStateConfig[I, RS]): UseVisualState[I, RS] = ^.asInstanceOf[js.Dynamic].applyDynamic("makeUseVisualState")(config.asInstanceOf[js.Any]).asInstanceOf[UseVisualState[I, RS]]

inline def mirrorEasing: EasingModifier = ^.asInstanceOf[js.Dynamic].selectDynamic("mirrorEasing").asInstanceOf[EasingModifier]

inline def mix(from: Double, to: Double, progress: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("mix")(from.asInstanceOf[js.Any], to.asInstanceOf[js.Any], progress.asInstanceOf[js.Any])).asInstanceOf[Double]

/**
  * HTML & SVG components, optimised for use with gestures and animation. These can be used as
  * drop-in replacements for any HTML & SVG component, all CSS & SVG properties are supported.
  *
  * @public
  */
inline def motion: (js.Function2[
/* Component */ String | ComponentType[PropsWithChildren[js.Object]], 
/* customMotionComponentConfig */ js.UndefOr[CustomMotionComponentConfig], 
CustomDomComponent[js.Object]]) & HTMLMotionComponents & SVGMotionComponents = ^.asInstanceOf[js.Dynamic].selectDynamic("motion").asInstanceOf[(js.Function2[
/* Component */ String | ComponentType[PropsWithChildren[js.Object]], 
/* customMotionComponentConfig */ js.UndefOr[CustomMotionComponentConfig], 
CustomDomComponent[js.Object]]) & HTMLMotionComponents & SVGMotionComponents]

inline def motionValue[V](init: V): MotionValue_[V] = ^.asInstanceOf[js.Dynamic].applyDynamic("motionValue")(init.asInstanceOf[js.Any]).asInstanceOf[MotionValue_[V]]
inline def motionValue[V](init: V, options: MotionValueOptions): MotionValue_[V] = (^.asInstanceOf[js.Dynamic].applyDynamic("motionValue")(init.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[MotionValue_[V]]

inline def optimizedAppearDataAttribute: String = ^.asInstanceOf[js.Dynamic].selectDynamic("optimizedAppearDataAttribute").asInstanceOf[String]

inline def pipe(transformers: js.Function*): js.Function = ^.asInstanceOf[js.Dynamic].applyDynamic("pipe")(transformers.asInstanceOf[Seq[js.Any]]*).asInstanceOf[js.Function]

inline def progress(from: Double, to: Double, value: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("progress")(from.asInstanceOf[js.Any], to.asInstanceOf[js.Any], value.asInstanceOf[js.Any])).asInstanceOf[Double]

/**
  * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself
  *
  * TODO: Remove and move to library
  */
inline def resolveMotionValue(): String | Double = ^.asInstanceOf[js.Dynamic].applyDynamic("resolveMotionValue")().asInstanceOf[String | Double]
inline def resolveMotionValue(value: String): String | Double = ^.asInstanceOf[js.Dynamic].applyDynamic("resolveMotionValue")(value.asInstanceOf[js.Any]).asInstanceOf[String | Double]
inline def resolveMotionValue(value: Double): String | Double = ^.asInstanceOf[js.Dynamic].applyDynamic("resolveMotionValue")(value.asInstanceOf[js.Any]).asInstanceOf[String | Double]
inline def resolveMotionValue(value: CustomValueType): String | Double = ^.asInstanceOf[js.Dynamic].applyDynamic("resolveMotionValue")(value.asInstanceOf[js.Any]).asInstanceOf[String | Double]
inline def resolveMotionValue(value: MotionValue_[Any]): String | Double = ^.asInstanceOf[js.Dynamic].applyDynamic("resolveMotionValue")(value.asInstanceOf[js.Any]).asInstanceOf[String | Double]

inline def reverseEasing: EasingModifier = ^.asInstanceOf[js.Dynamic].selectDynamic("reverseEasing").asInstanceOf[EasingModifier]

inline def scroll(onScroll: OnScroll): js.Function0[Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("scroll")(onScroll.asInstanceOf[js.Any]).asInstanceOf[js.Function0[Unit]]
inline def scroll(onScroll: OnScroll, param1: ScrollOptions): js.Function0[Unit] = (^.asInstanceOf[js.Dynamic].applyDynamic("scroll")(onScroll.asInstanceOf[js.Any], param1.asInstanceOf[js.Any])).asInstanceOf[js.Function0[Unit]]

inline def spring(param0: ValueAnimationOptions[Double]): KeyframeGenerator[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("spring")(param0.asInstanceOf[js.Any]).asInstanceOf[KeyframeGenerator[Double]]

inline def stagger(): DynamicOption[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("stagger")().asInstanceOf[DynamicOption[Double]]
inline def stagger(duration: Double): DynamicOption[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("stagger")(duration.asInstanceOf[js.Any]).asInstanceOf[DynamicOption[Double]]
inline def stagger(duration: Double, param1: StaggerOptions): DynamicOption[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("stagger")(duration.asInstanceOf[js.Any], param1.asInstanceOf[js.Any])).asInstanceOf[DynamicOption[Double]]
inline def stagger(duration: Unit, param1: StaggerOptions): DynamicOption[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("stagger")(duration.asInstanceOf[js.Any], param1.asInstanceOf[js.Any])).asInstanceOf[DynamicOption[Double]]

inline def startOptimizedAppearAnimation(
  element: HTMLElement,
  name: String,
  keyframes: js.Array[Double | String],
  options: NativeAnimationOptions
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("startOptimizedAppearAnimation")(element.asInstanceOf[js.Any], name.asInstanceOf[js.Any], keyframes.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def startOptimizedAppearAnimation(
  element: HTMLElement,
  name: String,
  keyframes: js.Array[Double | String],
  options: NativeAnimationOptions,
  onReady: js.Function1[/* animation */ Animation, Unit]
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("startOptimizedAppearAnimation")(element.asInstanceOf[js.Any], name.asInstanceOf[js.Any], keyframes.asInstanceOf[js.Any], options.asInstanceOf[js.Any], onReady.asInstanceOf[js.Any])).asInstanceOf[Unit]

inline def steps: Steps_ = ^.asInstanceOf[js.Dynamic].selectDynamic("steps").asInstanceOf[Steps_]

inline def stepsOrder: js.Array[StepId] = ^.asInstanceOf[js.Dynamic].selectDynamic("stepsOrder").asInstanceOf[js.Array[StepId]]

/**
  * @deprecated
  *
  * Import as `frame` instead.
  */
inline def sync: Frameloop = ^.asInstanceOf[js.Dynamic].selectDynamic("sync").asInstanceOf[Frameloop]

/**
  *
  * Transforms numbers into other values by mapping them from an input range to an output range.
  *
  * Given an input range of `[0, 200]` and an output range of
  * `[0, 1]`, this function will return a value between `0` and `1`.
  * The input range must be a linear series of numbers. The output range
  * can be any supported value type, such as numbers, colors, shadows, arrays, objects and more.
  * Every value in the output range must be of the same type and in the same format.
  *
  * ```jsx
  * import * as React from "react"
  * import { Frame, transform } from "framer"
  *
  * export function MyComponent() {
  *     const inputRange = [-200, -100, 100, 200]
  *     const outputRange = [0, 1, 1, 0]
  *     const convertRange = transform(inputRange, outputRange)
  *     const output = convertRange(-150)
  *
  *     // Returns 0.5
  *     return <div>{output}</div>
  * }
  *
  * ```
  *
  * @param inputRange - A linear series of numbers (either all increasing or decreasing).
  * @param outputRange - A series of numbers, colors or strings. Must be the same length as `inputRange`.
  * @param options - Clamp: clamp values to within the given range. Defaults to `true`.
  *
  * @public
  */
inline def transform[T](inputRange: js.Array[Double], outputRange: js.Array[T]): js.Function1[/* inputValue */ Double, T] = (^.asInstanceOf[js.Dynamic].applyDynamic("transform")(inputRange.asInstanceOf[js.Any], outputRange.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* inputValue */ Double, T]]
inline def transform[T](inputRange: js.Array[Double], outputRange: js.Array[T], options: TransformOptions[T]): js.Function1[/* inputValue */ Double, T] = (^.asInstanceOf[js.Dynamic].applyDynamic("transform")(inputRange.asInstanceOf[js.Any], outputRange.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* inputValue */ Double, T]]
/**
  * Transforms numbers into other values by mapping them from an input range to an output range.
  * Returns the type of the input provided.
  *
  * @remarks
  *
  * Given an input range of `[0, 200]` and an output range of
  * `[0, 1]`, this function will return a value between `0` and `1`.
  * The input range must be a linear series of numbers. The output range
  * can be any supported value type, such as numbers, colors, shadows, arrays, objects and more.
  * Every value in the output range must be of the same type and in the same format.
  *
  * ```jsx
  * import * as React from "react"
  * import { transform } from "framer-motion"
  *
  * export function MyComponent() {
  *    const inputRange = [0, 200]
  *    const outputRange = [0, 1]
  *    const output = transform(100, inputRange, outputRange)
  *
  *    // Returns 0.5
  *    return <div>{output}</div>
  * }
  * ```
  *
  * @param inputValue - A number to transform between the input and output ranges.
  * @param inputRange - A linear series of numbers (either all increasing or decreasing).
  * @param outputRange - A series of numbers, colors, strings, or arrays/objects of those. Must be the same length as `inputRange`.
  * @param options - Clamp: Clamp values to within the given range. Defaults to `true`.
  *
  * @public
  */
inline def transform[T](inputValue: Double, inputRange: js.Array[Double], outputRange: js.Array[T]): T = (^.asInstanceOf[js.Dynamic].applyDynamic("transform")(inputValue.asInstanceOf[js.Any], inputRange.asInstanceOf[js.Any], outputRange.asInstanceOf[js.Any])).asInstanceOf[T]
inline def transform[T](
  inputValue: Double,
  inputRange: js.Array[Double],
  outputRange: js.Array[T],
  options: TransformOptions[T]
): T = (^.asInstanceOf[js.Dynamic].applyDynamic("transform")(inputValue.asInstanceOf[js.Any], inputRange.asInstanceOf[js.Any], outputRange.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[T]

inline def unwrapMotionComponent(component: String): js.UndefOr[ComponentType[js.Object] | String] = ^.asInstanceOf[js.Dynamic].applyDynamic("unwrapMotionComponent")(component.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[ComponentType[js.Object] | String]]
/**
  * Unwraps a `motion` component and returns either a string for `motion.div` or
  * the React component for `motion(Component)`.
  *
  * If the component is not a `motion` component it returns undefined.
  */
inline def unwrapMotionComponent(component: ComponentType[js.Object]): js.UndefOr[ComponentType[js.Object] | String] = ^.asInstanceOf[js.Dynamic].applyDynamic("unwrapMotionComponent")(component.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[ComponentType[js.Object] | String]]

inline def useAnimate[T /* <: typings.std.Element */](): js.Tuple2[AnimationScope[T], FnCallFromToOptions] = ^.asInstanceOf[js.Dynamic].applyDynamic("useAnimate")().asInstanceOf[js.Tuple2[AnimationScope[T], FnCallFromToOptions]]

/**
  * Creates `AnimationControls`, which can be used to manually start, stop
  * and sequence animations on one or more components.
  *
  * The returned `AnimationControls` should be passed to the `animate` property
  * of the components you want to animate.
  *
  * These components can then be animated with the `start` method.
  *
  * ```jsx
  * import * as React from 'react'
  * import { motion, useAnimation } from 'framer-motion'
  *
  * export function MyComponent(props) {
  *    const controls = useAnimation()
  *
  *    controls.start({
  *        x: 100,
  *        transition: { duration: 0.5 },
  *    })
  *
  *    return <motion.div animate={controls} />
  * }
  * ```
  *
  * @returns Animation controller with `start` and `stop` methods
  *
  * @public
  */
/* was `typeof useAnimationControls` */
inline def useAnimation(): AnimationControls_ = ^.asInstanceOf[js.Dynamic].applyDynamic("useAnimation")().asInstanceOf[AnimationControls_]

/**
  * Creates `AnimationControls`, which can be used to manually start, stop
  * and sequence animations on one or more components.
  *
  * The returned `AnimationControls` should be passed to the `animate` property
  * of the components you want to animate.
  *
  * These components can then be animated with the `start` method.
  *
  * ```jsx
  * import * as React from 'react'
  * import { motion, useAnimation } from 'framer-motion'
  *
  * export function MyComponent(props) {
  *    const controls = useAnimation()
  *
  *    controls.start({
  *        x: 100,
  *        transition: { duration: 0.5 },
  *    })
  *
  *    return <motion.div animate={controls} />
  * }
  * ```
  *
  * @returns Animation controller with `start` and `stop` methods
  *
  * @public
  */
inline def useAnimationControls(): AnimationControls_ = ^.asInstanceOf[js.Dynamic].applyDynamic("useAnimationControls")().asInstanceOf[AnimationControls_]

inline def useAnimationFrame(callback: FrameCallback): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("useAnimationFrame")(callback.asInstanceOf[js.Any]).asInstanceOf[Unit]

/**
  * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.
  *
  * An index value can be passed to the returned `cycle` function to cycle to a specific index.
  *
  * ```jsx
  * import * as React from "react"
  * import { motion, useCycle } from "framer-motion"
  *
  * export const MyComponent = () => {
  *   const [x, cycleX] = useCycle(0, 50, 100)
  *
  *   return (
  *     <motion.div
  *       animate={{ x: x }}
  *       onTap={() => cycleX()}
  *      />
  *    )
  * }
  * ```
  *
  * @param items - items to cycle through
  * @returns [currentState, cycleState]
  *
  * @public
  */
inline def useCycle[T](items: T*): CycleState[T] = ^.asInstanceOf[js.Dynamic].applyDynamic("useCycle")(items.asInstanceOf[Seq[js.Any]]*).asInstanceOf[CycleState[T]]

/**
  * This is not an officially supported API and may be removed
  * on any version.
  */
inline def useDeprecatedAnimatedState(initialState: Any): js.Array[Any] = ^.asInstanceOf[js.Dynamic].applyDynamic("useDeprecatedAnimatedState")(initialState.asInstanceOf[js.Any]).asInstanceOf[js.Array[Any]]

/**
  * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse
  * of their respective parent scales.
  *
  * This is useful for undoing the distortion of content when scaling a parent component.
  *
  * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.
  * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output
  * of those instead.
  *
  * ```jsx
  * const MyComponent = () => {
  *   const { scaleX, scaleY } = useInvertedScale()
  *   return <motion.div style={{ scaleX, scaleY }} />
  * }
  * ```
  *
  * @deprecated
  */
inline def useDeprecatedInvertedScale(): ScaleMotionValues = ^.asInstanceOf[js.Dynamic].applyDynamic("useDeprecatedInvertedScale")().asInstanceOf[ScaleMotionValues]
inline def useDeprecatedInvertedScale(scale: PartialScaleMotionValues): ScaleMotionValues = ^.asInstanceOf[js.Dynamic].applyDynamic("useDeprecatedInvertedScale")(scale.asInstanceOf[js.Any]).asInstanceOf[ScaleMotionValues]

/**
  * Attaches an event listener directly to the provided DOM element.
  *
  * Bypassing React's event system can be desirable, for instance when attaching non-passive
  * event handlers.
  *
  * ```jsx
  * const ref = useRef(null)
  *
  * useDomEvent(ref, 'wheel', onWheel, { passive: false })
  *
  * return <div ref={ref} />
  * ```
  *
  * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.
  * @param eventName - Name of the event you want listen for.
  * @param handler - Function to fire when receiving the event.
  * @param options - Options to pass to `Event.addEventListener`.
  *
  * @public
  */
inline def useDomEvent(ref: typings.react.mod.RefObject[EventTarget], eventName: String): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("useDomEvent")(ref.asInstanceOf[js.Any], eventName.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def useDomEvent(
  ref: typings.react.mod.RefObject[EventTarget],
  eventName: String,
  handler: Unit,
  options: AddEventListenerOptions
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("useDomEvent")(ref.asInstanceOf[js.Any], eventName.asInstanceOf[js.Any], handler.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def useDomEvent(ref: typings.react.mod.RefObject[EventTarget], eventName: String, handler: EventListener): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("useDomEvent")(ref.asInstanceOf[js.Any], eventName.asInstanceOf[js.Any], handler.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def useDomEvent(
  ref: typings.react.mod.RefObject[EventTarget],
  eventName: String,
  handler: EventListener,
  options: AddEventListenerOptions
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("useDomEvent")(ref.asInstanceOf[js.Any], eventName.asInstanceOf[js.Any], handler.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[Unit]

/**
  * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop
  * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we
  * might want to initiate that dragging from a different component than the draggable one.
  *
  * By creating a `dragControls` using the `useDragControls` hook, we can pass this into
  * the draggable component's `dragControls` prop. It exposes a `start` method
  * that can start dragging from pointer events on other components.
  *
  * ```jsx
  * const dragControls = useDragControls()
  *
  * function startDrag(event) {
  *   dragControls.start(event, { snapToCursor: true })
  * }
  *
  * return (
  *   <>
  *     <div onPointerDown={startDrag} />
  *     <motion.div drag="x" dragControls={dragControls} />
  *   </>
  * )
  * ```
  *
  * @public
  */
inline def useDragControls(): DragControls = ^.asInstanceOf[js.Dynamic].applyDynamic("useDragControls")().asInstanceOf[DragControls]

/**
  * @deprecated useElementScroll is deprecated. Convert to useScroll({ container: ref })
  */
inline def useElementScroll(ref: typings.react.mod.RefObject[HTMLElement]): ScrollX = ^.asInstanceOf[js.Dynamic].applyDynamic("useElementScroll")(ref.asInstanceOf[js.Any]).asInstanceOf[ScrollX]

inline def useForceUpdate(): js.Tuple2[VoidFunction, Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("useForceUpdate")().asInstanceOf[js.Tuple2[VoidFunction, Double]]

inline def useInView(ref: typings.react.mod.RefObject[typings.std.Element]): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("useInView")(ref.asInstanceOf[js.Any]).asInstanceOf[Boolean]
inline def useInView(ref: typings.react.mod.RefObject[typings.std.Element], param1: Options): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("useInView")(ref.asInstanceOf[js.Any], param1.asInstanceOf[js.Any])).asInstanceOf[Boolean]

inline def useInstantLayoutTransition(): js.Function1[/* cb */ js.UndefOr[js.Function0[Unit]], Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("useInstantLayoutTransition")().asInstanceOf[js.Function1[/* cb */ js.UndefOr[js.Function0[Unit]], Unit]]

inline def useInstantTransition(): js.Function1[/* callback */ js.Function0[Unit], Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("useInstantTransition")().asInstanceOf[js.Function1[/* callback */ js.Function0[Unit], Unit]]

/**
  * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.
  * There is no `safeToRemove` function.
  *
  * ```jsx
  * import { useIsPresent } from "framer-motion"
  *
  * export const Component = () => {
  *   const isPresent = useIsPresent()
  *
  *   useEffect(() => {
  *     !isPresent && console.log("I've been removed!")
  *   }, [isPresent])
  *
  *   return <div />
  * }
  * ```
  *
  * @public
  */
inline def useIsPresent(): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("useIsPresent")().asInstanceOf[Boolean]

/**
  * Accepts a function that contains imperative, possibly effectful code.
  *
  * @param effect Imperative function that can return a cleanup function
  * @param deps If present, effect will only activate if the values in the list change.
  *
  * @version 16.8.0
  * @see https://react.dev/reference/react/useEffect
  */
/* was `typeof useEffect` */
inline def useIsomorphicLayoutEffect(effect: EffectCallback): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("useIsomorphicLayoutEffect")(effect.asInstanceOf[js.Any]).asInstanceOf[Unit]
/* was `typeof useEffect` */
inline def useIsomorphicLayoutEffect(effect: EffectCallback, deps: DependencyList): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("useIsomorphicLayoutEffect")(effect.asInstanceOf[js.Any], deps.asInstanceOf[js.Any])).asInstanceOf[Unit]

/**
  * Combine multiple motion values into a new one using a string template literal.
  *
  * ```jsx
  * import {
  *   motion,
  *   useSpring,
  *   useMotionValue,
  *   useMotionTemplate
  * } from "framer-motion"
  *
  * function Component() {
  *   const shadowX = useSpring(0)
  *   const shadowY = useMotionValue(0)
  *   const shadow = useMotionTemplate`drop-shadow(${shadowX}px ${shadowY}px 20px rgba(0,0,0,0.3))`
  *
  *   return <motion.div style={{ filter: shadow }} />
  * }
  * ```
  *
  * @public
  */
inline def useMotionTemplate(fragments: TemplateStringsArray, values: (MotionValue_[Any] | Double | String)*): MotionValue_[String] = ^.asInstanceOf[js.Dynamic].applyDynamic("useMotionTemplate")(scala.List(fragments.asInstanceOf[js.Any]).`++`(values.asInstanceOf[Seq[js.Any]])*).asInstanceOf[MotionValue_[String]]

/**
  * Creates a `MotionValue` to track the state and velocity of a value.
  *
  * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.
  *
  * ```jsx
  * export const MyComponent = () => {
  *   const scale = useMotionValue(1)
  *
  *   return <motion.div style={{ scale }} />
  * }
  * ```
  *
  * @param initial - The initial state.
  *
  * @public
  */
inline def useMotionValue[T](initial: T): MotionValue_[T] = ^.asInstanceOf[js.Dynamic].applyDynamic("useMotionValue")(initial.asInstanceOf[js.Any]).asInstanceOf[MotionValue_[T]]

inline def useMotionValueEvent[V, EventName /* <: /* keyof framer-motion.framer-motion.MotionValueEventCallbacks<V> */ animationStart_ | animationComplete_ | animationCancel | change | renderRequest | velocityChange */](
  value: MotionValue_[V],
  event: EventName,
  callback: /* import warning: importer.ImportType#apply Failed type conversion: framer-motion.framer-motion.MotionValueEventCallbacks<V>[EventName] */ js.Any
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("useMotionValueEvent")(value.asInstanceOf[js.Any], event.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[Unit]

/**
  * When a component is the child of `AnimatePresence`, it can use `usePresence`
  * to access information about whether it's still present in the React tree.
  *
  * ```jsx
  * import { usePresence } from "framer-motion"
  *
  * export const Component = () => {
  *   const [isPresent, safeToRemove] = usePresence()
  *
  *   useEffect(() => {
  *     !isPresent && setTimeout(safeToRemove, 1000)
  *   }, [isPresent])
  *
  *   return <div />
  * }
  * ```
  *
  * If `isPresent` is `false`, it means that a component has been removed the tree, but
  * `AnimatePresence` won't really remove it until `safeToRemove` has been called.
  *
  * @public
  */
inline def usePresence(): AlwaysPresent | Present | NotPresent = ^.asInstanceOf[js.Dynamic].applyDynamic("usePresence")().asInstanceOf[AlwaysPresent | Present | NotPresent]

/**
  * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.
  *
  * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing
  * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.
  *
  * It will actively respond to changes and re-render your components with the latest setting.
  *
  * ```jsx
  * export function Sidebar({ isOpen }) {
  *   const shouldReduceMotion = useReducedMotion()
  *   const closedX = shouldReduceMotion ? 0 : "-100%"
  *
  *   return (
  *     <motion.div animate={{
  *       opacity: isOpen ? 1 : 0,
  *       x: isOpen ? 0 : closedX
  *     }} />
  *   )
  * }
  * ```
  *
  * @return boolean
  *
  * @public
  */
inline def useReducedMotion(): Boolean | Null = ^.asInstanceOf[js.Dynamic].applyDynamic("useReducedMotion")().asInstanceOf[Boolean | Null]

inline def useReducedMotionConfig(): Boolean | Null = ^.asInstanceOf[js.Dynamic].applyDynamic("useReducedMotionConfig")().asInstanceOf[Boolean | Null]

inline def useResetProjection(): js.Function0[Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("useResetProjection")().asInstanceOf[js.Function0[Unit]]

inline def useScroll(): ScrollX = ^.asInstanceOf[js.Dynamic].applyDynamic("useScroll")().asInstanceOf[ScrollX]
inline def useScroll(param0: UseScrollOptions): ScrollX = ^.asInstanceOf[js.Dynamic].applyDynamic("useScroll")(param0.asInstanceOf[js.Any]).asInstanceOf[ScrollX]

inline def useSpring(source: Double): MotionValue_[Any] = ^.asInstanceOf[js.Dynamic].applyDynamic("useSpring")(source.asInstanceOf[js.Any]).asInstanceOf[MotionValue_[Any]]
inline def useSpring(source: Double, config: SpringOptions): MotionValue_[Any] = (^.asInstanceOf[js.Dynamic].applyDynamic("useSpring")(source.asInstanceOf[js.Any], config.asInstanceOf[js.Any])).asInstanceOf[MotionValue_[Any]]
/**
  * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.
  *
  * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber
  * to another `MotionValue`.
  *
  * @remarks
  *
  * ```jsx
  * const x = useSpring(0, { stiffness: 300 })
  * const y = useSpring(x, { damping: 10 })
  * ```
  *
  * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.
  * @param springConfig - Configuration options for the spring.
  * @returns `MotionValue`
  *
  * @public
  */
inline def useSpring(source: MotionValue_[Any]): MotionValue_[Any] = ^.asInstanceOf[js.Dynamic].applyDynamic("useSpring")(source.asInstanceOf[js.Any]).asInstanceOf[MotionValue_[Any]]
inline def useSpring(source: MotionValue_[Any], config: SpringOptions): MotionValue_[Any] = (^.asInstanceOf[js.Dynamic].applyDynamic("useSpring")(source.asInstanceOf[js.Any], config.asInstanceOf[js.Any])).asInstanceOf[MotionValue_[Any]]

inline def useTime(): MotionValue_[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("useTime")().asInstanceOf[MotionValue_[Double]]

/**
  * Pass an array of `MotionValue`s and a function to combine them. In this example, `z` will be the `x` multiplied by `y`.
  *
  * ```jsx
  * export const MyComponent = () => {
  *   const x = useMotionValue(0)
  *   const y = useMotionValue(0)
  *   const z = useTransform([x, y], ([latestX, latestY]) => latestX * latestY)
  *
  *   return <motion.div style={{ x, y, z }} />
  * }
  * ```
  *
  * @param input - An array of `MotionValue`s that will pass their latest values through `transform` to update the returned `MotionValue`.
  * @param transform - A function that accepts the latest values from `input` and returns a new value.
  * @returns `MotionValue`
  *
  * @public
  */
inline def useTransform[I, O](input: js.Array[MotionValue_[Double | String]], transformer: MultiTransformer[I, O]): MotionValue_[O] = (^.asInstanceOf[js.Dynamic].applyDynamic("useTransform")(input.asInstanceOf[js.Any], transformer.asInstanceOf[js.Any])).asInstanceOf[MotionValue_[O]]
/**
  * Create a `MotionValue` that transforms the output of another `MotionValue` through a function.
  * In this example, `y` will always be double `x`.
  *
  * ```jsx
  * export const MyComponent = () => {
  *   const x = useMotionValue(10)
  *   const y = useTransform(x, value => value * 2)
  *
  *   return <motion.div style={{ x, y }} />
  * }
  * ```
  *
  * @param input - A `MotionValue` that will pass its latest value through `transform` to update the returned `MotionValue`.
  * @param transform - A function that accepts the latest value from `input` and returns a new value.
  * @returns `MotionValue`
  *
  * @public
  */
inline def useTransform[I, O](input: MotionValue_[I], transformer: SingleTransformer[I, O]): MotionValue_[O] = (^.asInstanceOf[js.Dynamic].applyDynamic("useTransform")(input.asInstanceOf[js.Any], transformer.asInstanceOf[js.Any])).asInstanceOf[MotionValue_[O]]
/**
  * Create a `MotionValue` that transforms the output of another `MotionValue` by mapping it from one range of values into another.
  *
  * @remarks
  *
  * Given an input range of `[-200, -100, 100, 200]` and an output range of
  * `[0, 1, 1, 0]`, the returned `MotionValue` will:
  *
  * - When provided a value between `-200` and `-100`, will return a value between `0` and  `1`.
  * - When provided a value between `-100` and `100`, will return `1`.
  * - When provided a value between `100` and `200`, will return a value between `1` and  `0`
  *
  *
  * The input range must be a linear series of numbers. The output range
  * can be any value type supported by Framer Motion: numbers, colors, shadows, etc.
  *
  * Every value in the output range must be of the same type and in the same format.
  *
  * ```jsx
  * export const MyComponent = () => {
  *   const x = useMotionValue(0)
  *   const xRange = [-200, -100, 100, 200]
  *   const opacityRange = [0, 1, 1, 0]
  *   const opacity = useTransform(x, xRange, opacityRange)
  *
  *   return (
  *     <motion.div
  *       animate={{ x: 200 }}
  *       style={{ opacity, x }}
  *     />
  *   )
  * }
  * ```
  *
  * @param inputValue - `MotionValue`
  * @param inputRange - A linear series of numbers (either all increasing or decreasing)
  * @param outputRange - A series of numbers, colors or strings. Must be the same length as `inputRange`.
  * @param options -
  *
  *  - clamp: boolean. Clamp values to within the given range. Defaults to `true`
  *  - ease: EasingFunction[]. Easing functions to use on the interpolations between each value in the input and output ranges. If provided as an array, the array must be one item shorter than the input and output ranges, as the easings apply to the transition between each.
  *
  * @returns `MotionValue`
  *
  * @public
  */
inline def useTransform[I, O](value: MotionValue_[Double], inputRange: InputRange, outputRange: js.Array[O]): MotionValue_[O] = (^.asInstanceOf[js.Dynamic].applyDynamic("useTransform")(value.asInstanceOf[js.Any], inputRange.asInstanceOf[js.Any], outputRange.asInstanceOf[js.Any])).asInstanceOf[MotionValue_[O]]
inline def useTransform[I, O](
  value: MotionValue_[Double],
  inputRange: InputRange,
  outputRange: js.Array[O],
  options: TransformOptions[O]
): MotionValue_[O] = (^.asInstanceOf[js.Dynamic].applyDynamic("useTransform")(value.asInstanceOf[js.Any], inputRange.asInstanceOf[js.Any], outputRange.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[MotionValue_[O]]

inline def useUnmountEffect(callback: js.Function0[Unit]): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("useUnmountEffect")(callback.asInstanceOf[js.Any]).asInstanceOf[Unit]

/**
  * Creates a `MotionValue` that updates when the velocity of the provided `MotionValue` changes.
  *
  * ```javascript
  * const x = useMotionValue(0)
  * const xVelocity = useVelocity(x)
  * const xAcceleration = useVelocity(xVelocity)
  * ```
  *
  * @public
  */
inline def useVelocity(value: MotionValue_[Double]): MotionValue_[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("useVelocity")(value.asInstanceOf[js.Any]).asInstanceOf[MotionValue_[Double]]

/**
  * @deprecated useViewportScroll is deprecated. Convert to useScroll()
  */
inline def useViewportScroll(): ScrollX = ^.asInstanceOf[js.Dynamic].applyDynamic("useViewportScroll")().asInstanceOf[ScrollX]

inline def useWillChange(): WillChange = ^.asInstanceOf[js.Dynamic].applyDynamic("useWillChange")().asInstanceOf[WillChange]

inline def visualElementStore: WeakMap[Any, VisualElement[Any, Any, js.Object]] = ^.asInstanceOf[js.Dynamic].selectDynamic("visualElementStore").asInstanceOf[WeakMap[Any, VisualElement[Any, Any, js.Object]]]

inline def warning: DevMessage = ^.asInstanceOf[js.Dynamic].selectDynamic("warning").asInstanceOf[DevMessage]
inline def warning_=(x: DevMessage): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("warning")(x.asInstanceOf[js.Any])

inline def wrap(min: Double, max: Double, v: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("wrap")(min.asInstanceOf[js.Any], max.asInstanceOf[js.Any], v.asInstanceOf[js.Any])).asInstanceOf[Double]

type AlwaysPresent = js.Tuple2[`true`, Null]

type AnimationDefinition = VariantLabels | TargetAndTransition | TargetResolver

type AnimationSequence = js.Array[Segment]

type BezierDefinition = js.Tuple4[Double, Double, Double, Double]

type CSSVariableName = /* template literal string: --${string} */ String

type CSSVariableToken = /* template literal string: var(${CSSVariableName}) */ String

type CreateVisualElement[Instance] = js.Function2[
/* Component */ String | ComponentType[PropsWithChildren[Any]], 
/* options */ VisualElementOptions[Instance, Any], 
VisualElement[Instance, Any, js.Object]]

/**
  * I'd rather the return type of `custom` to be implicit but this throws
  * incorrect relative paths in the exported types and API Extractor throws
  * a wobbly.
  */
type CustomDomComponent[Props] = ForwardRefExoticComponent[
(PropsWithoutRef[Props & MotionProps]) & (RefAttributes[SVGElement | HTMLElement])]

type Cycle = js.Function1[/* i */ js.UndefOr[Double], Unit]

type CycleState[T] = js.Tuple2[T, Cycle]

type DOMMotionComponents = HTMLMotionComponents & SVGMotionComponents

type DOMSegment = js.Tuple2[ElementOrSelector, DOMKeyframesDefinition]

type DOMSegmentWithTransition = js.Tuple3[ElementOrSelector, DOMKeyframesDefinition, DynamicAnimationOptions & At]

type DelayedFunction = js.Function1[/* overshoot */ Double, Unit]

type DevMessage = js.Function2[/* check */ Boolean, /* message */ String, Unit]

type DragElastic = Boolean | Double | PartialBoundingBox

type Driver = js.Function1[/* update */ Update, DriverControls]

type DynamicOption[T] = js.Function2[/* i */ Double, /* total */ Double, T]

/**
  * The easing function to use. Set as one of:
  *
  * - The name of an in-built easing function.
  * - An array of four numbers to define a cubic bezier curve.
  * - An easing function, that accepts and returns a progress value between `0` and `1`.
  *
  * @public
  */
type Easing = EasingDefinition | EasingFunction

/* Rewritten from type alias, can be one of: 
  - typings.framerMotion.mod.BezierDefinition
  - typings.framerMotion.framerMotionStrings.linear
  - typings.framerMotion.framerMotionStrings.easeIn
  - typings.framerMotion.framerMotionStrings.easeOut
  - typings.framerMotion.framerMotionStrings.easeInOut
  - typings.framerMotion.framerMotionStrings.circIn
  - typings.framerMotion.framerMotionStrings.circOut
  - typings.framerMotion.framerMotionStrings.circInOut
  - typings.framerMotion.framerMotionStrings.backIn
  - typings.framerMotion.framerMotionStrings.backOut
  - typings.framerMotion.framerMotionStrings.backInOut
  - typings.framerMotion.framerMotionStrings.anticipate
*/
type EasingDefinition = _EasingDefinition | BezierDefinition

type EasingFunction = js.Function1[/* v */ Double, Double]

type EasingModifier = js.Function1[/* easing */ EasingFunction, EasingFunction]

type Edge = EdgeString | Double

type EdgeString = NamedEdges | EdgeUnit | (/* template literal string: ${number} */ String)

type EdgeUnit = /* template literal string: ${number}${SupportedEdgeUnit} */ String

type ElementOrSelector = typings.std.Element | js.Array[typings.std.Element] | NodeListOf[typings.std.Element] | String

type EventListenerWithPointInfo = js.Function2[/* e */ PointerEvent, /* info */ EventInfo, Unit]

/**
  * @public
  */
type ForwardRefComponent[T, P] = ForwardRefExoticComponent[PropsWithoutRef[P] & RefAttributes[T]]

type FrameCallback = js.Function2[/* timestamp */ Double, /* delta */ Double, Unit]

type GenericKeyframesTarget[V] = (Array[Null | V]) | js.Array[V]

/** NOTE: Mapped type definitions are impossible to translate to Scala.
  * See https://www.typescriptlang.org/docs/handbook/2/mapped-types.html for an intro.
  * This translation is imprecise and ignores the effect of the type mapping. 
  * TS definition: {{{
  {[ K in std.Exclude<keyof Attributes, 'style' | 'transformTemplate' | 'transformValues' | 'children'> ]:? Attributes[K]}
  }}}
  */
type HTMLAttributesWithoutMotionProps[Attributes /* <: HTMLAttributes[Element] */, Element /* <: HTMLElement */] = Attributes

type HTMLElements = UnionStringArray[js.Array[Any]]

/**
  * @public
  */
type HTMLMotionProps[TagName /* <: /* import warning: LimitUnionLength.leaveTypeRef Was union type with length 117, starting with typings.framerMotion.framerMotionStrings.a, typings.framerMotion.framerMotionStrings.abbr, typings.framerMotion.framerMotionStrings.address */ Any */] = (HTMLAttributesWithoutMotionProps[
UnwrapFactoryAttributes[
  /* import warning: importer.ImportType#apply Failed type conversion: react.react.ReactHTML[TagName] */ js.Any
], 
UnwrapFactoryElement[
  /* import warning: importer.ImportType#apply Failed type conversion: react.react.ReactHTML[TagName] */ js.Any
]]) & MotionProps

type InheritOption = Boolean | id

type InputRange = js.Array[Double]

type Intersection = /* template literal string: ${Edge} ${Edge} */ String

type IsValidProp = js.Function1[/* key */ String, Boolean]

/**
  * @public
  */
type KeyframesTarget = ResolvedKeyframesTarget | GenericKeyframesTarget[CustomValueType]

type LazyFeatureBundle1 = js.Function0[js.Promise[FeatureBundle]]

type MakeMotion[T] = MakeCustomValueType[
/* import warning: importer.ImportType#apply Failed type conversion: {[ K in keyof T ]: T[K] | framer-motion.framer-motion.MotionValue<number> | framer-motion.framer-motion.MotionValue<string> | framer-motion.framer-motion.MotionValue<any>} */ js.Any]

type Mix_[T] = js.Function1[/* v */ Double, T]

type MixerFactory[T] = js.Function2[/* from */ T, /* to */ T, Mix_[T]]

type MotionValueSegment = js.Tuple2[MotionValue_[Any], UnresolvedValueKeyframe | js.Array[UnresolvedValueKeyframe]]

type MotionValueSegmentWithTransition = js.Tuple3[
MotionValue_[Any], 
UnresolvedValueKeyframe | js.Array[UnresolvedValueKeyframe], 
Transition1 & At]

type MultiTransformer[I, O] = js.Function1[/* input */ js.Array[I], O]

type NotPresent = js.Tuple2[`false`, SafeToRemove]

type Omit1[T, K /* <: /* keyof T */ String */] = Pick[T, Exclude[/* keyof T */ String, K]]

type OnScroll = js.Function1[/* info */ ScrollInfo, Unit]

/**
  * @public
  */
type PassiveEffect[T] = js.Function2[/* v */ T, /* safeSetter */ js.Function1[/* v */ T, Unit], Unit]

/**
  * @public
  */
type PermissiveTransitionDefinition = StringDictionary[Any]

type Present = js.Array[`true`]

type Process = js.Function1[/* data */ FrameData_, Unit]

type ProgressIntersection = js.Tuple2[Double, Double]

type RenderComponent[Instance, RenderState] = js.Function6[
/* Component */ String | ComponentType[PropsWithChildren[Any]], 
/* props */ MotionProps, 
/* ref */ Ref[Instance], 
/* visualState */ VisualState[Instance, RenderState], 
/* isStatic */ Boolean, 
/* visualElement */ js.UndefOr[VisualElement[Instance, Any, js.Object]], 
Any]

/**
  * @public
  */
type ResolveLayoutTransition = js.Function1[/* info */ RelayoutInfo, Transition1 | Boolean]

/**
  * @public
  */
type ResolvedKeyframesTarget = GenericKeyframesTarget[Double | String]

/**
  * @public
  */
type ResolvedSingleTarget = String | Double

/**
  * @public
  */
type ResolvedValueTarget = ResolvedSingleTarget | ResolvedKeyframesTarget

/**
  * A generic set of string/number values
  */
type ResolvedValues = StringDictionary[String | Double]

type ResolvedValues1 = StringDictionary[String | Double]

type SVGElements = UnionStringArray1[js.Array[Any]]

type SafeToRemove = js.Function0[Unit]

type ScaleCorrector = js.Function2[/* latest */ String | Double, /* node */ IProjectionNode[Any], String | Double]

type ScaleCorrectorMap = StringDictionary[ScaleCorrectorDefinition]

type Schedule = js.Function3[
/* process */ Process, 
/* keepAlive */ js.UndefOr[Boolean], 
/* immediate */ js.UndefOr[Boolean], 
Process]

type ScrapeMotionValuesFromProps = js.Function2[
/* props */ MotionProps, 
/* prevProps */ MotionProps, 
StringDictionary[MotionValue_[Any] | String | Double]]

type ScrollOffset = js.Array[Edge | Intersection | ProgressIntersection]

type Segment = MotionValueSegment | MotionValueSegmentWithTransition | DOMSegment | DOMSegmentWithTransition | SequenceLabel | SequenceLabelWithTime

type SequenceLabel = String

type SequenceTime = Double | Lessthansign | (/* template literal string: +${number} */ String)

/**
  * @public
  */
type SingleTarget = ResolvedSingleTarget | CustomValueType

type SingleTransformer[I, O] = js.Function1[/* input */ I, O]

/* Rewritten from type alias, can be one of: 
  - typings.framerMotion.framerMotionStrings.first
  - typings.framerMotion.framerMotionStrings.last
  - typings.framerMotion.framerMotionStrings.center
  - scala.Double
*/
type StaggerOrigin = _StaggerOrigin | Double

/**
  * @public
  */
type Subscriber[T] = js.Function1[/* v */ T, Unit]

type TargetResolver = js.Function3[
/* custom */ Any, 
/* current */ Target, 
/* velocity */ Target, 
TargetAndTransition | String]

type TransformPoint = js.Function1[/* point */ Point, Point]

type Transformer = js.Function1[/* v */ Any, Any]

/**
  * Transition props
  *
  * @public
  */
type Transition1 = (Orchestration & Repeat & TransitionDefinition) | (Orchestration & Repeat & TransitionMap)

/**
  * @public
  */
/* Rewritten from type alias, can be one of: 
  - typings.framerMotion.mod.Tween
  - typings.framerMotion.mod.Spring_
  - typings.framerMotion.mod.Keyframes
  - typings.framerMotion.mod.Inertia
  - typings.framerMotion.mod.Just
  - typings.framerMotion.mod.None
  - typings.framerMotion.mod.PermissiveTransitionDefinition
*/
type TransitionDefinition = _TransitionDefinition | PermissiveTransitionDefinition

type TransitionMap = Orchestration & TransitionDefinition & StringDictionary[TransitionDefinition]

type UnionStringArray[T /* <: ReadonlyArraystring */] = /* import warning: importer.ImportType#apply Failed type conversion: T[number] */ js.Any

type UnionStringArray1[T /* <: ReadonlyArraystring */] = /* import warning: importer.ImportType#apply Failed type conversion: T[number] */ js.Any

type UnresolvedValueKeyframe = ValueKeyframe | Null

/**
  * An update function. It accepts a timestamp used to advance the animation.
  */
type Update = js.Function1[/* timestamp */ Double, Unit]

type UseVisualState[Instance, RenderState] = js.Function2[/* props */ MotionProps, /* isStatic */ Boolean, VisualState[Instance, RenderState]]

type ValueKeyframe = String | Double

type ValueKeyframesDefinition = ValueKeyframe | (js.Array[UnresolvedValueKeyframe | ValueKeyframe])

/**
  * @public
  */
type ValueTarget = SingleTarget | KeyframesTarget

type VariableKeyframesDefinition = StringDictionary[ValueKeyframesDefinition]

type VariableTransitions = StringDictionary[Transition1]

/**
  * @public
  */
type Variant = TargetAndTransition | TargetResolver

/**
  * Either a string, or array of strings, that reference variants defined via the `variants` prop.
  * @public
  */
type VariantLabels = String | js.Array[String]

/**
  * @public
  */
type Variants = StringDictionary[Variant]

type ViewChangeHandler = js.Function1[/* entry */ IntersectionObserverEntry, Unit]

type ViewportEventHandler = js.Function1[/* entry */ IntersectionObserverEntry | Null, Unit]
