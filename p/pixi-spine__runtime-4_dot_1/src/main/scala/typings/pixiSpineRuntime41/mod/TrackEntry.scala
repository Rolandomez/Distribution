package typings.pixiSpineRuntime41.mod

import typings.pixiSpineBase.mod.IAnimationStateListener
import typings.pixiSpineBase.mod.ITrackEntry
import typings.pixiSpineBase.mod.MixBlend
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

@JSImport("@pixi-spine/runtime-4.1", "TrackEntry")
@js.native
open class TrackEntry ()
  extends StObject
     with ITrackEntry {
  
  /* CompleteClass */
  var alpha: Double = js.native
  
  /** The animation to apply for this track entry. */
  var animation: Animation2 | Null = js.native
  
  /* CompleteClass */
  var animationEnd: Double = js.native
  
  /** The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this
    * animation is applied, event timelines will fire all events between the `animationLast` time (exclusive) and
    * `animationTime` (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation
    * is applied. */
  var animationLast: Double = js.native
  
  /** Seconds when this animation starts, both initially and after looping. Defaults to 0.
    *
    * When changing the `animationStart` time, it often makes sense to set {@link #animationLast} to the same
    * value to prevent timeline keys before the start time from triggering. */
  var animationStart: Double = js.native
  
  /** When the mix percentage ({@link #mixtime} / {@link #mixDuration}) is less than the
    * `attachmentThreshold`, attachment timelines are applied while this animation is being mixed out. Defaults to
    * 0, so attachment timelines are not applied while this animation is being mixed out. */
  var attachmentThreshold: Double = js.native
  
  /* CompleteClass */
  var delay: Double = js.native
  
  /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the
    * `drawOrderThreshold`, draw order timelines are applied while this animation is being mixed out. Defaults to 0,
    * so draw order timelines are not applied while this animation is being mixed out. */
  var drawOrderThreshold: Double = js.native
  
  def endTime: Double = js.native
  def endTime_=(value: Double): Unit = js.native
  
  /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the
    * `eventThreshold`, event timelines are applied while this animation is being mixed out. Defaults to 0, so event
    * timelines are not applied while this animation is being mixed out. */
  var eventThreshold: Double = js.native
  
  /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}
    * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the
    * `animationStart` time. */
  def getAnimationTime(): Double = js.native
  
  def getTrackComplete(): Double = js.native
  
  /** If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead
    * of being mixed out.
    *
    * When mixing between animations that key the same property, if a lower track also keys that property then the value will
    * briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%
    * while the second animation mixes from 0% to 100%. Setting `holdPrevious` to true applies the first animation
    * at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which
    * keys the property, only when a higher track also keys the property.
    *
    * Snapping will occur if `holdPrevious` is true and this animation does not key all the same properties as the
    * previous animation. */
  var holdPrevious: Boolean = js.native
  
  /* CompleteClass */
  var interruptAlpha: Double = js.native
  
  /** Returns true if at least one loop has been completed.
    *
    * See {@link AnimationStateListener#complete()}. */
  def isComplete(): Boolean = js.native
  
  /* CompleteClass */
  var listener: IAnimationStateListener = js.native
  /** The listener for events generated by this track entry, or null.
    *
    * A track entry returned from {@link AnimationState#setAnimation()} is already the current animation
    * for the track, so the track entry listener {@link AnimationStateListener#start()} will not be called. */
  @JSName("listener")
  var listener_TrackEntry: AnimationStateListener | Null = js.native
  
  /* CompleteClass */
  var loop: Boolean = js.native
  
  def loopsCount(): Double = js.native
  
  /** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which
    * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to
    * the values from the lower tracks.
    *
    * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first
    * called. */
  var mixBlend: MixBlend = js.native
  
  /* CompleteClass */
  var mixDuration: Double = js.native
  
  /* CompleteClass */
  var mixTime: Double = js.native
  
  /** The track entry for the previous animation when mixing from the previous animation to this animation, or null if no
    * mixing is currently occuring. When mixing from multiple animations, `mixingFrom` makes up a linked list. */
  var mixingFrom: TrackEntry | Null = js.native
  
  /** The track entry for the next animation when mixing from this animation to the next animation, or null if no mixing is
    * currently occuring. When mixing to multiple animations, `mixingTo` makes up a linked list. */
  var mixingTo: TrackEntry | Null = js.native
  
  /** The animation queued to start after this animation, or null. `next` makes up a linked list. */
  var next: TrackEntry | Null = js.native
  
  var nextAnimationLast: Double = js.native
  
  /* CompleteClass */
  var nextTrackLast: Double = js.native
  
  def onComplete(trackIndex: Double, loopCount: Double): Any = js.native
  
  def onEnd(trackIndex: Double): Any = js.native
  
  def onEvent(trackIndex: Double, event: Event2): Any = js.native
  
  def onStart(trackIndex: Double): Any = js.native
  
  var previous: TrackEntry | Null = js.native
  
  def reset(): Unit = js.native
  
  /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the
    * long way around when using {@link #alpha} and starting animations on other tracks.
    *
    * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:
    * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long
    * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the
    * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */
  def resetRotationDirections(): Unit = js.native
  
  var reverse: Boolean = js.native
  
  def setAnimationLast(animationLast: Double): Unit = js.native
  
  var shortestRotation: Boolean = js.native
  
  def time: Double = js.native
  
  /* CompleteClass */
  var timeScale: Double = js.native
  
  def time_=(value: Double): Unit = js.native
  
  var timelineHoldMix: js.Array[TrackEntry] = js.native
  
  var timelineMode: js.Array[Double] = js.native
  
  var timelinesRotation: js.Array[Double] = js.native
  
  /* CompleteClass */
  var totalAlpha: Double = js.native
  
  /* CompleteClass */
  var trackEnd: Double = js.native
  
  /* CompleteClass */
  var trackIndex: Double = js.native
  
  /* CompleteClass */
  var trackLast: Double = js.native
  
  /* CompleteClass */
  var trackTime: Double = js.native
}
/* static members */
object TrackEntry {
  
  @JSImport("@pixi-spine/runtime-4.1", "TrackEntry")
  @js.native
  val ^ : js.Any = js.native
  
  @JSImport("@pixi-spine/runtime-4.1", "TrackEntry.deprecatedWarning1")
  @js.native
  def deprecatedWarning1: Any = js.native
  inline def deprecatedWarning1_=(x: Any): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("deprecatedWarning1")(x.asInstanceOf[js.Any])
  
  @JSImport("@pixi-spine/runtime-4.1", "TrackEntry.deprecatedWarning2")
  @js.native
  def deprecatedWarning2: Any = js.native
  inline def deprecatedWarning2_=(x: Any): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("deprecatedWarning2")(x.asInstanceOf[js.Any])
}
