package typings.plotlyJs.mod

import org.scalablytyped.runtime.Instantiable0
import org.scalablytyped.runtime.Instantiable1
import org.scalablytyped.runtime.NumberDictionary
import org.scalablytyped.runtime.StringDictionary
import typings.d3.mod.FormatSpecifier_
import typings.d3Array.anon.FnCall
import typings.d3Array.mod.Bisector_
import typings.d3Array.mod.HistogramGeneratorDate
import typings.d3Array.mod.HistogramGeneratorNumber
import typings.d3Array.mod.Numeric
import typings.d3Array.mod.Primitive
import typings.d3Axis.mod.AxisDomain
import typings.d3Axis.mod.AxisScale
import typings.d3Brush.mod.BrushBehavior
import typings.d3Brush.mod.BrushSelection_
import typings.d3Chord.mod.ChordLayout
import typings.d3Chord.mod.RibbonGenerator
import typings.d3Chord.mod.RibbonSubgroup
import typings.d3Chord.mod.Ribbon_
import typings.d3Color.mod.ColorCommonInstance
import typings.d3Color.mod.ColorFactory
import typings.d3Color.mod.ColorSpaceObject
import typings.d3Color.mod.CubehelixColor
import typings.d3Color.mod.CubehelixColorFactory
import typings.d3Color.mod.HCLColor
import typings.d3Color.mod.HCLColorFactory
import typings.d3Color.mod.HSLColor
import typings.d3Color.mod.HSLColorFactory
import typings.d3Color.mod.LabColor
import typings.d3Color.mod.LabColorFactory
import typings.d3Color.mod.RGBColor
import typings.d3Color.mod.RGBColorFactory
import typings.d3Contour.mod.ContourDensity_
import typings.d3Contour.mod.Contours_
import typings.d3Dispatch.mod.Dispatch_
import typings.d3Drag.mod.DragBehavior
import typings.d3Drag.mod.DraggedElementBaseType
import typings.d3Drag.mod.SubjectPosition
import typings.d3Dsv.mod.DSV
import typings.d3Dsv.mod.DSVParsedArray
import typings.d3Dsv.mod.DSVRowArray
import typings.d3Dsv.mod.DSVRowString
import typings.d3Ease.mod.BackEasingFactory
import typings.d3Ease.mod.ElasticEasingFactory
import typings.d3Ease.mod.PolynomialEasingFactory
import typings.d3Fetch.anon.PartialHTMLImageElement
import typings.d3Force.mod.ForceCenter_
import typings.d3Force.mod.ForceCollide_
import typings.d3Force.mod.ForceLink_
import typings.d3Force.mod.ForceManyBody_
import typings.d3Force.mod.ForceRadial_
import typings.d3Force.mod.ForceX_
import typings.d3Force.mod.ForceY_
import typings.d3Force.mod.Simulation
import typings.d3Force.mod.SimulationLinkDatum
import typings.d3Force.mod.SimulationNodeDatum
import typings.d3Format.anon.ValueOf
import typings.d3Format.mod.FormatLocaleDefinition
import typings.d3Format.mod.FormatLocaleObject
import typings.d3Format.mod.FormatSpecifierObject
import typings.d3Geo.anon.`0`
import typings.d3Geo.mod.ExtendedFeature
import typings.d3Geo.mod.ExtendedFeatureCollection
import typings.d3Geo.mod.ExtendedGeometryCollection
import typings.d3Geo.mod.GeoCircleGenerator
import typings.d3Geo.mod.GeoConicProjection
import typings.d3Geo.mod.GeoContext
import typings.d3Geo.mod.GeoGeometryObjects
import typings.d3Geo.mod.GeoGraticuleGenerator
import typings.d3Geo.mod.GeoIdentityTransform
import typings.d3Geo.mod.GeoPath_
import typings.d3Geo.mod.GeoPermissibleObjects
import typings.d3Geo.mod.GeoProjection_
import typings.d3Geo.mod.GeoRawProjection
import typings.d3Geo.mod.GeoRotation_
import typings.d3Geo.mod.GeoStreamWrapper
import typings.d3Geo.mod.GeoStream_
import typings.d3Geo.mod.GeoTransformPrototype
import typings.d3Hierarchy.mod.ClusterLayout
import typings.d3Hierarchy.mod.HierarchyNode
import typings.d3Hierarchy.mod.HierarchyRectangularNode
import typings.d3Hierarchy.mod.PackCircle
import typings.d3Hierarchy.mod.PackLayout
import typings.d3Hierarchy.mod.PackRadius
import typings.d3Hierarchy.mod.PartitionLayout
import typings.d3Hierarchy.mod.RatioSquarifyTilingFactory
import typings.d3Hierarchy.mod.StratifyOperator
import typings.d3Hierarchy.mod.TreeLayout
import typings.d3Hierarchy.mod.TreemapLayout
import typings.d3Interpolate.anon.ToString
import typings.d3Interpolate.mod.ArrayInterpolator
import typings.d3Interpolate.mod.ColorGammaInterpolationFactory
import typings.d3Interpolate.mod.NumberArray
import typings.d3Interpolate.mod.ZoomInterpolator
import typings.d3Interpolate.mod.ZoomView
import typings.d3Path.mod.Path_
import typings.d3Quadtree.mod.Quadtree_
import typings.d3Random.mod.RandomBates_
import typings.d3Random.mod.RandomBernoulli_
import typings.d3Random.mod.RandomBeta_
import typings.d3Random.mod.RandomBinomial_
import typings.d3Random.mod.RandomCauchy_
import typings.d3Random.mod.RandomExponential_
import typings.d3Random.mod.RandomGamma_
import typings.d3Random.mod.RandomGeometric_
import typings.d3Random.mod.RandomInt_
import typings.d3Random.mod.RandomIrwinHall_
import typings.d3Random.mod.RandomLogNormal_
import typings.d3Random.mod.RandomLogistic_
import typings.d3Random.mod.RandomNormal_
import typings.d3Random.mod.RandomPareto_
import typings.d3Random.mod.RandomPoisson_
import typings.d3Random.mod.RandomUniform_
import typings.d3Random.mod.RandomWeibull_
import typings.d3Scale.mod.NumberValue
import typings.d3Scale.mod.ScaleBand_
import typings.d3Scale.mod.ScaleDiverging_
import typings.d3Scale.mod.ScaleIdentity_
import typings.d3Scale.mod.ScaleLinear_
import typings.d3Scale.mod.ScaleLogarithmic
import typings.d3Scale.mod.ScaleOrdinal_
import typings.d3Scale.mod.ScalePoint_
import typings.d3Scale.mod.ScalePower
import typings.d3Scale.mod.ScaleQuantile_
import typings.d3Scale.mod.ScaleQuantize_
import typings.d3Scale.mod.ScaleRadial_
import typings.d3Scale.mod.ScaleSequentialQuantile_
import typings.d3Scale.mod.ScaleSequential_
import typings.d3Scale.mod.ScaleSymLog_
import typings.d3Scale.mod.ScaleThreshold_
import typings.d3Scale.mod.ScaleTime_
import typings.d3Selection.mod.BaseType
import typings.d3Selection.mod.EnterElement
import typings.d3Selection.mod.Local_
import typings.d3Selection.mod.NamespaceLocalObject
import typings.d3Selection.mod.NamespaceMap
import typings.d3Selection.mod.Selection_
import typings.d3Shape.mod.Arc_
import typings.d3Shape.mod.AreaRadial_
import typings.d3Shape.mod.Area_
import typings.d3Shape.mod.CurveBundleFactory
import typings.d3Shape.mod.CurveCardinalFactory
import typings.d3Shape.mod.CurveCatmullRomFactory
import typings.d3Shape.mod.CurveGenerator
import typings.d3Shape.mod.DefaultArcObject
import typings.d3Shape.mod.DefaultLinkObject
import typings.d3Shape.mod.LineRadial_
import typings.d3Shape.mod.Line_
import typings.d3Shape.mod.Link
import typings.d3Shape.mod.LinkRadial_
import typings.d3Shape.mod.Pie_
import typings.d3Shape.mod.RadialArea_
import typings.d3Shape.mod.RadialLine_
import typings.d3Shape.mod.Series
import typings.d3Shape.mod.Stack_
import typings.d3Shape.mod.SymbolType
import typings.d3Shape.mod.Symbol_
import typings.d3Time.mod.CountableTimeInterval
import typings.d3Time.mod.TimeInterval_
import typings.d3TimeFormat.mod.TimeLocaleDefinition
import typings.d3TimeFormat.mod.TimeLocaleObject
import typings.d3Timer.mod.Timer_
import typings.d3Transition.mod.Transition_
import typings.d3Zoom.mod.ZoomBehavior
import typings.d3Zoom.mod.ZoomTransform_
import typings.d3Zoom.mod.ZoomedElementBaseType
import typings.geojson.mod.GeoJsonProperties
import typings.geojson.mod.MultiLineString
import typings.plotlyJs.anon.TypeofDelaunay
import typings.plotlyJs.anon.Typeofbisect
import typings.plotlyJs.anon.TypeofscaleImplicit
import typings.plotlyJs.plotlyJsStrings.`object`
import typings.plotlyJs.plotlyJsStrings.`var`
import typings.plotlyJs.plotlyJsStrings.a
import typings.plotlyJs.plotlyJsStrings.abbr
import typings.plotlyJs.plotlyJsStrings.address
import typings.plotlyJs.plotlyJsStrings.applet
import typings.plotlyJs.plotlyJsStrings.area
import typings.plotlyJs.plotlyJsStrings.article
import typings.plotlyJs.plotlyJsStrings.aside
import typings.plotlyJs.plotlyJsStrings.audio
import typings.plotlyJs.plotlyJsStrings.b_
import typings.plotlyJs.plotlyJsStrings.base
import typings.plotlyJs.plotlyJsStrings.basefont
import typings.plotlyJs.plotlyJsStrings.bdi
import typings.plotlyJs.plotlyJsStrings.bdo
import typings.plotlyJs.plotlyJsStrings.blockquote
import typings.plotlyJs.plotlyJsStrings.body
import typings.plotlyJs.plotlyJsStrings.br
import typings.plotlyJs.plotlyJsStrings.button
import typings.plotlyJs.plotlyJsStrings.canvas
import typings.plotlyJs.plotlyJsStrings.caption
import typings.plotlyJs.plotlyJsStrings.circle
import typings.plotlyJs.plotlyJsStrings.cite
import typings.plotlyJs.plotlyJsStrings.clipPath
import typings.plotlyJs.plotlyJsStrings.code
import typings.plotlyJs.plotlyJsStrings.col
import typings.plotlyJs.plotlyJsStrings.colgroup
import typings.plotlyJs.plotlyJsStrings.data
import typings.plotlyJs.plotlyJsStrings.datalist
import typings.plotlyJs.plotlyJsStrings.dd
import typings.plotlyJs.plotlyJsStrings.defs
import typings.plotlyJs.plotlyJsStrings.del
import typings.plotlyJs.plotlyJsStrings.desc
import typings.plotlyJs.plotlyJsStrings.details
import typings.plotlyJs.plotlyJsStrings.dfn
import typings.plotlyJs.plotlyJsStrings.dialog
import typings.plotlyJs.plotlyJsStrings.dir
import typings.plotlyJs.plotlyJsStrings.div
import typings.plotlyJs.plotlyJsStrings.dl
import typings.plotlyJs.plotlyJsStrings.dt
import typings.plotlyJs.plotlyJsStrings.ellipse
import typings.plotlyJs.plotlyJsStrings.em
import typings.plotlyJs.plotlyJsStrings.embed
import typings.plotlyJs.plotlyJsStrings.feBlend
import typings.plotlyJs.plotlyJsStrings.feColorMatrix
import typings.plotlyJs.plotlyJsStrings.feComponentTransfer
import typings.plotlyJs.plotlyJsStrings.feComposite
import typings.plotlyJs.plotlyJsStrings.feConvolveMatrix
import typings.plotlyJs.plotlyJsStrings.feDiffuseLighting
import typings.plotlyJs.plotlyJsStrings.feDisplacementMap
import typings.plotlyJs.plotlyJsStrings.feDistantLight
import typings.plotlyJs.plotlyJsStrings.feFlood
import typings.plotlyJs.plotlyJsStrings.feFuncA
import typings.plotlyJs.plotlyJsStrings.feFuncB
import typings.plotlyJs.plotlyJsStrings.feFuncG
import typings.plotlyJs.plotlyJsStrings.feFuncR
import typings.plotlyJs.plotlyJsStrings.feGaussianBlur
import typings.plotlyJs.plotlyJsStrings.feImage
import typings.plotlyJs.plotlyJsStrings.feMerge
import typings.plotlyJs.plotlyJsStrings.feMergeNode
import typings.plotlyJs.plotlyJsStrings.feMorphology
import typings.plotlyJs.plotlyJsStrings.feOffset
import typings.plotlyJs.plotlyJsStrings.fePointLight
import typings.plotlyJs.plotlyJsStrings.feSpecularLighting
import typings.plotlyJs.plotlyJsStrings.feSpotLight
import typings.plotlyJs.plotlyJsStrings.feTile
import typings.plotlyJs.plotlyJsStrings.feTurbulence
import typings.plotlyJs.plotlyJsStrings.fieldset
import typings.plotlyJs.plotlyJsStrings.figcaption
import typings.plotlyJs.plotlyJsStrings.figure
import typings.plotlyJs.plotlyJsStrings.filter
import typings.plotlyJs.plotlyJsStrings.font
import typings.plotlyJs.plotlyJsStrings.footer
import typings.plotlyJs.plotlyJsStrings.foreignObject
import typings.plotlyJs.plotlyJsStrings.form
import typings.plotlyJs.plotlyJsStrings.frame
import typings.plotlyJs.plotlyJsStrings.frameset
import typings.plotlyJs.plotlyJsStrings.g
import typings.plotlyJs.plotlyJsStrings.h1
import typings.plotlyJs.plotlyJsStrings.h2
import typings.plotlyJs.plotlyJsStrings.h3
import typings.plotlyJs.plotlyJsStrings.h4
import typings.plotlyJs.plotlyJsStrings.h5
import typings.plotlyJs.plotlyJsStrings.h6
import typings.plotlyJs.plotlyJsStrings.head
import typings.plotlyJs.plotlyJsStrings.header
import typings.plotlyJs.plotlyJsStrings.hgroup
import typings.plotlyJs.plotlyJsStrings.hr
import typings.plotlyJs.plotlyJsStrings.html
import typings.plotlyJs.plotlyJsStrings.i
import typings.plotlyJs.plotlyJsStrings.iframe
import typings.plotlyJs.plotlyJsStrings.image
import typings.plotlyJs.plotlyJsStrings.img
import typings.plotlyJs.plotlyJsStrings.input
import typings.plotlyJs.plotlyJsStrings.ins
import typings.plotlyJs.plotlyJsStrings.kbd
import typings.plotlyJs.plotlyJsStrings.label
import typings.plotlyJs.plotlyJsStrings.legend
import typings.plotlyJs.plotlyJsStrings.li
import typings.plotlyJs.plotlyJsStrings.line
import typings.plotlyJs.plotlyJsStrings.linearGradient
import typings.plotlyJs.plotlyJsStrings.link
import typings.plotlyJs.plotlyJsStrings.main
import typings.plotlyJs.plotlyJsStrings.map
import typings.plotlyJs.plotlyJsStrings.mark
import typings.plotlyJs.plotlyJsStrings.marker
import typings.plotlyJs.plotlyJsStrings.marquee
import typings.plotlyJs.plotlyJsStrings.mask
import typings.plotlyJs.plotlyJsStrings.menu
import typings.plotlyJs.plotlyJsStrings.meta
import typings.plotlyJs.plotlyJsStrings.metadata
import typings.plotlyJs.plotlyJsStrings.meter
import typings.plotlyJs.plotlyJsStrings.nav
import typings.plotlyJs.plotlyJsStrings.noscript
import typings.plotlyJs.plotlyJsStrings.ol
import typings.plotlyJs.plotlyJsStrings.optgroup
import typings.plotlyJs.plotlyJsStrings.option
import typings.plotlyJs.plotlyJsStrings.output
import typings.plotlyJs.plotlyJsStrings.p
import typings.plotlyJs.plotlyJsStrings.param
import typings.plotlyJs.plotlyJsStrings.path
import typings.plotlyJs.plotlyJsStrings.pattern
import typings.plotlyJs.plotlyJsStrings.picture
import typings.plotlyJs.plotlyJsStrings.polygon
import typings.plotlyJs.plotlyJsStrings.polyline
import typings.plotlyJs.plotlyJsStrings.pre
import typings.plotlyJs.plotlyJsStrings.progress
import typings.plotlyJs.plotlyJsStrings.q
import typings.plotlyJs.plotlyJsStrings.radialGradient
import typings.plotlyJs.plotlyJsStrings.rect
import typings.plotlyJs.plotlyJsStrings.rp
import typings.plotlyJs.plotlyJsStrings.rt
import typings.plotlyJs.plotlyJsStrings.ruby
import typings.plotlyJs.plotlyJsStrings.s
import typings.plotlyJs.plotlyJsStrings.samp
import typings.plotlyJs.plotlyJsStrings.script
import typings.plotlyJs.plotlyJsStrings.section
import typings.plotlyJs.plotlyJsStrings.select
import typings.plotlyJs.plotlyJsStrings.slot
import typings.plotlyJs.plotlyJsStrings.small
import typings.plotlyJs.plotlyJsStrings.source
import typings.plotlyJs.plotlyJsStrings.span
import typings.plotlyJs.plotlyJsStrings.stop
import typings.plotlyJs.plotlyJsStrings.strong
import typings.plotlyJs.plotlyJsStrings.style
import typings.plotlyJs.plotlyJsStrings.sub
import typings.plotlyJs.plotlyJsStrings.summary
import typings.plotlyJs.plotlyJsStrings.sup
import typings.plotlyJs.plotlyJsStrings.svg
import typings.plotlyJs.plotlyJsStrings.switch
import typings.plotlyJs.plotlyJsStrings.symbol
import typings.plotlyJs.plotlyJsStrings.table
import typings.plotlyJs.plotlyJsStrings.tbody
import typings.plotlyJs.plotlyJsStrings.td
import typings.plotlyJs.plotlyJsStrings.template
import typings.plotlyJs.plotlyJsStrings.text
import typings.plotlyJs.plotlyJsStrings.textPath
import typings.plotlyJs.plotlyJsStrings.textarea
import typings.plotlyJs.plotlyJsStrings.tfoot
import typings.plotlyJs.plotlyJsStrings.th
import typings.plotlyJs.plotlyJsStrings.thead
import typings.plotlyJs.plotlyJsStrings.time
import typings.plotlyJs.plotlyJsStrings.title
import typings.plotlyJs.plotlyJsStrings.tr
import typings.plotlyJs.plotlyJsStrings.track
import typings.plotlyJs.plotlyJsStrings.tspan
import typings.plotlyJs.plotlyJsStrings.u
import typings.plotlyJs.plotlyJsStrings.ul
import typings.plotlyJs.plotlyJsStrings.use
import typings.plotlyJs.plotlyJsStrings.video
import typings.plotlyJs.plotlyJsStrings.view
import typings.plotlyJs.plotlyJsStrings.wbr
import typings.std.ArrayBuffer
import typings.std.ArrayLike
import typings.std.Blob
import typings.std.CanvasRenderingContext2D
import typings.std.DataView
import typings.std.Date
import typings.std.Document
import typings.std.Element
import typings.std.Float32Array
import typings.std.Float64Array
import typings.std.HTMLAnchorElement
import typings.std.HTMLAppletElement
import typings.std.HTMLAreaElement
import typings.std.HTMLAudioElement
import typings.std.HTMLBRElement
import typings.std.HTMLBaseElement
import typings.std.HTMLBaseFontElement
import typings.std.HTMLBodyElement
import typings.std.HTMLButtonElement
import typings.std.HTMLCanvasElement
import typings.std.HTMLDListElement
import typings.std.HTMLDataElement
import typings.std.HTMLDataListElement
import typings.std.HTMLDetailsElement
import typings.std.HTMLDialogElement
import typings.std.HTMLDirectoryElement
import typings.std.HTMLDivElement
import typings.std.HTMLElement
import typings.std.HTMLEmbedElement
import typings.std.HTMLFieldSetElement
import typings.std.HTMLFontElement
import typings.std.HTMLFormElement
import typings.std.HTMLFrameElement
import typings.std.HTMLFrameSetElement
import typings.std.HTMLHRElement
import typings.std.HTMLHeadElement
import typings.std.HTMLHeadingElement
import typings.std.HTMLHtmlElement
import typings.std.HTMLIFrameElement
import typings.std.HTMLImageElement
import typings.std.HTMLInputElement
import typings.std.HTMLLIElement
import typings.std.HTMLLabelElement
import typings.std.HTMLLegendElement
import typings.std.HTMLLinkElement
import typings.std.HTMLMapElement
import typings.std.HTMLMarqueeElement
import typings.std.HTMLMenuElement
import typings.std.HTMLMetaElement
import typings.std.HTMLMeterElement
import typings.std.HTMLModElement
import typings.std.HTMLOListElement
import typings.std.HTMLObjectElement
import typings.std.HTMLOptGroupElement
import typings.std.HTMLOptionElement
import typings.std.HTMLOutputElement
import typings.std.HTMLParagraphElement
import typings.std.HTMLParamElement
import typings.std.HTMLPictureElement
import typings.std.HTMLPreElement
import typings.std.HTMLProgressElement
import typings.std.HTMLQuoteElement
import typings.std.HTMLScriptElement
import typings.std.HTMLSelectElement
import typings.std.HTMLSlotElement
import typings.std.HTMLSourceElement
import typings.std.HTMLSpanElement
import typings.std.HTMLStyleElement
import typings.std.HTMLTableCaptionElement
import typings.std.HTMLTableColElement
import typings.std.HTMLTableDataCellElement
import typings.std.HTMLTableElement
import typings.std.HTMLTableHeaderCellElement
import typings.std.HTMLTableRowElement
import typings.std.HTMLTableSectionElement
import typings.std.HTMLTemplateElement
import typings.std.HTMLTextAreaElement
import typings.std.HTMLTimeElement
import typings.std.HTMLTitleElement
import typings.std.HTMLTrackElement
import typings.std.HTMLUListElement
import typings.std.HTMLVideoElement
import typings.std.Int16Array
import typings.std.Int32Array
import typings.std.Int8Array
import typings.std.Iterable
import typings.std.Map
import typings.std.NodeListOf
import typings.std.RequestInit
import typings.std.SVGCircleElement
import typings.std.SVGClipPathElement
import typings.std.SVGDefsElement
import typings.std.SVGDescElement
import typings.std.SVGEllipseElement
import typings.std.SVGFEBlendElement
import typings.std.SVGFEColorMatrixElement
import typings.std.SVGFEComponentTransferElement
import typings.std.SVGFECompositeElement
import typings.std.SVGFEConvolveMatrixElement
import typings.std.SVGFEDiffuseLightingElement
import typings.std.SVGFEDisplacementMapElement
import typings.std.SVGFEDistantLightElement
import typings.std.SVGFEFloodElement
import typings.std.SVGFEFuncAElement
import typings.std.SVGFEFuncBElement
import typings.std.SVGFEFuncGElement
import typings.std.SVGFEFuncRElement
import typings.std.SVGFEGaussianBlurElement
import typings.std.SVGFEImageElement
import typings.std.SVGFEMergeElement
import typings.std.SVGFEMergeNodeElement
import typings.std.SVGFEMorphologyElement
import typings.std.SVGFEOffsetElement
import typings.std.SVGFEPointLightElement
import typings.std.SVGFESpecularLightingElement
import typings.std.SVGFESpotLightElement
import typings.std.SVGFETileElement
import typings.std.SVGFETurbulenceElement
import typings.std.SVGFilterElement
import typings.std.SVGForeignObjectElement
import typings.std.SVGGElement
import typings.std.SVGImageElement
import typings.std.SVGLineElement
import typings.std.SVGLinearGradientElement
import typings.std.SVGMarkerElement
import typings.std.SVGMaskElement
import typings.std.SVGMetadataElement
import typings.std.SVGPathElement
import typings.std.SVGPatternElement
import typings.std.SVGPolygonElement
import typings.std.SVGPolylineElement
import typings.std.SVGRadialGradientElement
import typings.std.SVGRectElement
import typings.std.SVGSVGElement
import typings.std.SVGStopElement
import typings.std.SVGSwitchElement
import typings.std.SVGSymbolElement
import typings.std.SVGTSpanElement
import typings.std.SVGTextElement
import typings.std.SVGTextPathElement
import typings.std.SVGUseElement
import typings.std.SVGViewElement
import typings.std.Set
import typings.std.Uint16Array
import typings.std.Uint32Array
import typings.std.Uint8Array
import typings.std.Uint8ClampedArray
import typings.std.Window
import typings.std.XMLDocument
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object d3 {
  
  @JSImport("plotly.js", "d3")
  @js.native
  val ^ : js.Any = js.native
  
  /* This class was inferred from a value with a constructor. In rare cases (like HTMLElement in the DOM) it might not work as you expect. */
  @JSImport("plotly.js", "d3.Adder")
  @js.native
  /**
    * Creates a full precision adder for IEEE 754 floating point numbers, setting its initial value to 0.
    */
  class Adder ()
    extends typings.d3.mod.Adder
  @JSImport("plotly.js", "d3.Adder")
  @js.native
  def Adder: Instantiable0[typings.d3.mod.Adder] = js.native
  @scala.inline
  def Adder_=(x: Instantiable0[typings.d3.mod.Adder]): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("Adder")(x.asInstanceOf[js.Any])
  
  /* This class was inferred from a value with a constructor. In rare cases (like HTMLElement in the DOM) it might not work as you expect. */
  @JSImport("plotly.js", "d3.Delaunay")
  @js.native
  class Delaunay[P] protected ()
    extends typings.d3.mod.Delaunay[P] {
    /**
      * Returns the Delaunay triangulation for the given flat array [x0, y0, x1, y1, …] of points.
      */
    def this(points: ArrayLike[Double]) = this()
  }
  @JSImport("plotly.js", "d3.Delaunay")
  @js.native
  def Delaunay: js.Any | TypeofDelaunay = js.native
  @scala.inline
  def Delaunay_=(x: js.Any | TypeofDelaunay): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("Delaunay")(x.asInstanceOf[js.Any])
  
  /* This class was inferred from a value with a constructor. In rare cases (like HTMLElement in the DOM) it might not work as you expect. */
  @JSImport("plotly.js", "d3.FormatSpecifier")
  @js.native
  class FormatSpecifier protected () extends FormatSpecifier_ {
    /**
      * Given the specified specifier object, returning an object with exposed fields that correspond to the format specification mini-language and a toString method that reconstructs the specifier.
      * @param specifier A specifier object.
      */
    def this(specifier: FormatSpecifierObject) = this()
  }
  @JSImport("plotly.js", "d3.FormatSpecifier")
  @js.native
  def FormatSpecifier_ : Instantiable1[/* specifier */ FormatSpecifierObject, typings.d3.mod.FormatSpecifier_] = js.native
  
  @scala.inline
  def FormatSpecifier__=(x: Instantiable1[/* specifier */ FormatSpecifierObject, FormatSpecifier_]): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FormatSpecifier")(x.asInstanceOf[js.Any])
  
  /* This class was inferred from a value with a constructor. In rare cases (like HTMLElement in the DOM) it might not work as you expect. */
  @JSImport("plotly.js", "d3.Voronoi")
  @js.native
  class Voronoi[P] ()
    extends typings.d3.mod.Voronoi[P]
  @JSImport("plotly.js", "d3.Voronoi")
  @js.native
  def Voronoi: Instantiable0[typings.d3.mod.Voronoi[js.Object]] = js.native
  @scala.inline
  def Voronoi_=(x: Instantiable0[typings.d3.mod.Voronoi[js.Object]]): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("Voronoi")(x.asInstanceOf[js.Any])
  
  @JSImport("plotly.js", "d3.active")
  @js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](): (Transition_[Null, Datum, PElement, PDatum]) | Null = js.native
  @JSImport("plotly.js", "d3.active")
  @js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: Null, name: String): (Transition_[Null, Datum, PElement, PDatum]) | Null = js.native
  @JSImport("plotly.js", "d3.active")
  @js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: EnterElement): (Transition_[EnterElement, Datum, PElement, PDatum]) | Null = js.native
  @JSImport("plotly.js", "d3.active")
  @js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: EnterElement, name: String): (Transition_[EnterElement, Datum, PElement, PDatum]) | Null = js.native
  @JSImport("plotly.js", "d3.active")
  @js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: Document): (Transition_[Document, Datum, PElement, PDatum]) | Null = js.native
  @JSImport("plotly.js", "d3.active")
  @js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: Document, name: String): (Transition_[Document, Datum, PElement, PDatum]) | Null = js.native
  @JSImport("plotly.js", "d3.active")
  @js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: Element): (Transition_[Element, Datum, PElement, PDatum]) | Null = js.native
  @JSImport("plotly.js", "d3.active")
  @js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: Element, name: String): (Transition_[Element, Datum, PElement, PDatum]) | Null = js.native
  @JSImport("plotly.js", "d3.active")
  @js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: Window): (Transition_[Window, Datum, PElement, PDatum]) | Null = js.native
  @JSImport("plotly.js", "d3.active")
  @js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: Window, name: String): (Transition_[Window, Datum, PElement, PDatum]) | Null = js.native
  
  @JSImport("plotly.js", "d3.arc")
  @js.native
  def arc(): Arc_[_, DefaultArcObject] = js.native
  @JSImport("plotly.js", "d3.arc")
  @js.native
  def arc_Datum[Datum](): Arc_[_, Datum] = js.native
  @JSImport("plotly.js", "d3.arc")
  @js.native
  def arc_ThisDatum[This, Datum](): Arc_[This, Datum] = js.native
  
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](): Area_[Datum] = js.native
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](
    x: js.UndefOr[scala.Nothing],
    y0: js.UndefOr[scala.Nothing],
    y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
  ): Area_[Datum] = js.native
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](x: js.UndefOr[scala.Nothing], y0: js.UndefOr[scala.Nothing], y1: Double): Area_[Datum] = js.native
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](
    x: js.UndefOr[scala.Nothing],
    y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
  ): Area_[Datum] = js.native
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](
    x: js.UndefOr[scala.Nothing],
    y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
  ): Area_[Datum] = js.native
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](
    x: js.UndefOr[scala.Nothing],
    y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y1: Double
  ): Area_[Datum] = js.native
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](x: js.UndefOr[scala.Nothing], y0: Double): Area_[Datum] = js.native
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](
    x: js.UndefOr[scala.Nothing],
    y0: Double,
    y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
  ): Area_[Datum] = js.native
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](x: js.UndefOr[scala.Nothing], y0: Double, y1: Double): Area_[Datum] = js.native
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]): Area_[Datum] = js.native
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](
    x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y0: js.UndefOr[scala.Nothing],
    y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
  ): Area_[Datum] = js.native
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](
    x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y0: js.UndefOr[scala.Nothing],
    y1: Double
  ): Area_[Datum] = js.native
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](
    x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
  ): Area_[Datum] = js.native
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](
    x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
  ): Area_[Datum] = js.native
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](
    x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y1: Double
  ): Area_[Datum] = js.native
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double], y0: Double): Area_[Datum] = js.native
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](
    x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y0: Double,
    y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
  ): Area_[Datum] = js.native
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](
    x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y0: Double,
    y1: Double
  ): Area_[Datum] = js.native
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](x: Double): Area_[Datum] = js.native
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](
    x: Double,
    y0: js.UndefOr[scala.Nothing],
    y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
  ): Area_[Datum] = js.native
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](x: Double, y0: js.UndefOr[scala.Nothing], y1: Double): Area_[Datum] = js.native
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](x: Double, y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]): Area_[Datum] = js.native
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](
    x: Double,
    y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
  ): Area_[Datum] = js.native
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](
    x: Double,
    y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y1: Double
  ): Area_[Datum] = js.native
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](x: Double, y0: Double): Area_[Datum] = js.native
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](
    x: Double,
    y0: Double,
    y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
  ): Area_[Datum] = js.native
  @JSImport("plotly.js", "d3.area")
  @js.native
  def area[Datum](x: Double, y0: Double, y1: Double): Area_[Datum] = js.native
  
  @JSImport("plotly.js", "d3.areaRadial")
  @js.native
  def areaRadial(): AreaRadial_[js.Tuple2[Double, Double]] = js.native
  @JSImport("plotly.js", "d3.areaRadial")
  @js.native
  def areaRadial_Datum[Datum](): AreaRadial_[Datum] = js.native
  
  @JSImport("plotly.js", "d3.ascending")
  @js.native
  def ascending(): Double = js.native
  @JSImport("plotly.js", "d3.ascending")
  @js.native
  def ascending(a: js.UndefOr[Primitive], b: Primitive): Double = js.native
  @JSImport("plotly.js", "d3.ascending")
  @js.native
  def ascending(a: Primitive): Double = js.native
  
  @JSImport("plotly.js", "d3.autoType")
  @js.native
  def autoType[ParsedRow /* <: js.UndefOr[js.Object | Null] */, Columns /* <: String */](// tslint:disable-next-line:no-unnecessary-generics
  `object`: js.Array[String]): ParsedRow = js.native
  @JSImport("plotly.js", "d3.autoType")
  @js.native
  def autoType[ParsedRow /* <: js.UndefOr[js.Object | Null] */, Columns /* <: String */](// tslint:disable-next-line:no-unnecessary-generics
  `object`: DSVRowString[Columns]): ParsedRow = js.native
  
  @JSImport("plotly.js", "d3.axisBottom")
  @js.native
  def axisBottom[Domain /* <: AxisDomain */](scale: AxisScale[Domain]): typings.d3Axis.mod.Axis[Domain] = js.native
  
  @JSImport("plotly.js", "d3.axisLeft")
  @js.native
  def axisLeft[Domain /* <: AxisDomain */](scale: AxisScale[Domain]): typings.d3Axis.mod.Axis[Domain] = js.native
  
  @JSImport("plotly.js", "d3.axisRight")
  @js.native
  def axisRight[Domain /* <: AxisDomain */](scale: AxisScale[Domain]): typings.d3Axis.mod.Axis[Domain] = js.native
  
  @JSImport("plotly.js", "d3.axisTop")
  @js.native
  def axisTop[Domain /* <: AxisDomain */](scale: AxisScale[Domain]): typings.d3Axis.mod.Axis[Domain] = js.native
  
  @JSImport("plotly.js", "d3.bin")
  @js.native
  def bin(): HistogramGeneratorNumber[Double, Double] = js.native
  
  @JSImport("plotly.js", "d3.bisect")
  @js.native
  val bisect: Typeofbisect = js.native
  
  @JSImport("plotly.js", "d3.bisectCenter")
  @js.native
  def bisectCenter(array: ArrayLike[String], x: String): Double = js.native
  @JSImport("plotly.js", "d3.bisectCenter")
  @js.native
  def bisectCenter(array: ArrayLike[String], x: String, lo: js.UndefOr[scala.Nothing], hi: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectCenter")
  @js.native
  def bisectCenter(array: ArrayLike[String], x: String, lo: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectCenter")
  @js.native
  def bisectCenter(array: ArrayLike[String], x: String, lo: Double, hi: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectCenter")
  @js.native
  def bisectCenter(array: ArrayLike[Double], x: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectCenter")
  @js.native
  def bisectCenter(array: ArrayLike[Double], x: Double, lo: js.UndefOr[scala.Nothing], hi: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectCenter")
  @js.native
  def bisectCenter(array: ArrayLike[Double], x: Double, lo: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectCenter")
  @js.native
  def bisectCenter(array: ArrayLike[Double], x: Double, lo: Double, hi: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectCenter")
  @js.native
  def bisectCenter(array: ArrayLike[Date], x: Date): Double = js.native
  @JSImport("plotly.js", "d3.bisectCenter")
  @js.native
  def bisectCenter(array: ArrayLike[Date], x: Date, lo: js.UndefOr[scala.Nothing], hi: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectCenter")
  @js.native
  def bisectCenter(array: ArrayLike[Date], x: Date, lo: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectCenter")
  @js.native
  def bisectCenter(array: ArrayLike[Date], x: Date, lo: Double, hi: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.bisectLeft")
  @js.native
  def bisectLeft(array: ArrayLike[String], x: String): Double = js.native
  @JSImport("plotly.js", "d3.bisectLeft")
  @js.native
  def bisectLeft(array: ArrayLike[String], x: String, lo: js.UndefOr[scala.Nothing], hi: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectLeft")
  @js.native
  def bisectLeft(array: ArrayLike[String], x: String, lo: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectLeft")
  @js.native
  def bisectLeft(array: ArrayLike[String], x: String, lo: Double, hi: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectLeft")
  @js.native
  def bisectLeft(array: ArrayLike[Double], x: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectLeft")
  @js.native
  def bisectLeft(array: ArrayLike[Double], x: Double, lo: js.UndefOr[scala.Nothing], hi: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectLeft")
  @js.native
  def bisectLeft(array: ArrayLike[Double], x: Double, lo: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectLeft")
  @js.native
  def bisectLeft(array: ArrayLike[Double], x: Double, lo: Double, hi: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectLeft")
  @js.native
  def bisectLeft(array: ArrayLike[Date], x: Date): Double = js.native
  @JSImport("plotly.js", "d3.bisectLeft")
  @js.native
  def bisectLeft(array: ArrayLike[Date], x: Date, lo: js.UndefOr[scala.Nothing], hi: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectLeft")
  @js.native
  def bisectLeft(array: ArrayLike[Date], x: Date, lo: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectLeft")
  @js.native
  def bisectLeft(array: ArrayLike[Date], x: Date, lo: Double, hi: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.bisectRight")
  @js.native
  def bisectRight(array: ArrayLike[String], x: String): Double = js.native
  @JSImport("plotly.js", "d3.bisectRight")
  @js.native
  def bisectRight(array: ArrayLike[String], x: String, lo: js.UndefOr[scala.Nothing], hi: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectRight")
  @js.native
  def bisectRight(array: ArrayLike[String], x: String, lo: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectRight")
  @js.native
  def bisectRight(array: ArrayLike[String], x: String, lo: Double, hi: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectRight")
  @js.native
  def bisectRight(array: ArrayLike[Double], x: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectRight")
  @js.native
  def bisectRight(array: ArrayLike[Double], x: Double, lo: js.UndefOr[scala.Nothing], hi: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectRight")
  @js.native
  def bisectRight(array: ArrayLike[Double], x: Double, lo: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectRight")
  @js.native
  def bisectRight(array: ArrayLike[Double], x: Double, lo: Double, hi: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectRight")
  @js.native
  def bisectRight(array: ArrayLike[Date], x: Date): Double = js.native
  @JSImport("plotly.js", "d3.bisectRight")
  @js.native
  def bisectRight(array: ArrayLike[Date], x: Date, lo: js.UndefOr[scala.Nothing], hi: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectRight")
  @js.native
  def bisectRight(array: ArrayLike[Date], x: Date, lo: Double): Double = js.native
  @JSImport("plotly.js", "d3.bisectRight")
  @js.native
  def bisectRight(array: ArrayLike[Date], x: Date, lo: Double, hi: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.bisector")
  @js.native
  def bisector[T, U](accessor: js.Function1[/* x */ T, U]): Bisector_[T, U] = js.native
  @JSImport("plotly.js", "d3.bisector")
  @js.native
  def bisector[T, U](comparator: js.Function2[/* a */ T, /* b */ U, Double]): Bisector_[T, U] = js.native
  
  @JSImport("plotly.js", "d3.blob")
  @js.native
  def blob(url: String): js.Promise[Blob] = js.native
  @JSImport("plotly.js", "d3.blob")
  @js.native
  def blob(url: String, init: RequestInit): js.Promise[Blob] = js.native
  
  @JSImport("plotly.js", "d3.brush")
  @js.native
  def brush[Datum](): BrushBehavior[Datum] = js.native
  
  @JSImport("plotly.js", "d3.brushSelection")
  @js.native
  def brushSelection(node: SVGGElement): BrushSelection_ | Null = js.native
  
  @JSImport("plotly.js", "d3.brushX")
  @js.native
  def brushX[Datum](): BrushBehavior[Datum] = js.native
  
  @JSImport("plotly.js", "d3.brushY")
  @js.native
  def brushY[Datum](): BrushBehavior[Datum] = js.native
  
  @JSImport("plotly.js", "d3.buffer")
  @js.native
  def buffer(url: String): js.Promise[ArrayBuffer] = js.native
  @JSImport("plotly.js", "d3.buffer")
  @js.native
  def buffer(url: String, init: RequestInit): js.Promise[ArrayBuffer] = js.native
  
  @JSImport("plotly.js", "d3.chord")
  @js.native
  def chord(): ChordLayout = js.native
  
  @JSImport("plotly.js", "d3.chordDirected")
  @js.native
  def chordDirected(): ChordLayout = js.native
  
  @JSImport("plotly.js", "d3.chordTranspose")
  @js.native
  def chordTranspose(): ChordLayout = js.native
  
  @JSImport("plotly.js", "d3.cluster")
  @js.native
  def cluster[Datum](): ClusterLayout[Datum] = js.native
  
  @JSImport("plotly.js", "d3.color")
  @js.native
  val color: ColorFactory = js.native
  @JSImport("plotly.js", "d3.color")
  @js.native
  def color(color: ColorCommonInstance): RGBColor | HSLColor = js.native
  /**
    * Converts the provided color instance and returns an RGB or HSL color.
    *
    * @param color A permissible color space instance.
    */
  @JSImport("plotly.js", "d3.color")
  @js.native
  def color(color: ColorSpaceObject): RGBColor | HSLColor = js.native
  /**
    * Parses the specified CSS Color Module Level 3 specifier string, returning an RGB or HSL color.
    * If the specifier was not valid, null is returned.
    *
    * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
    */
  @JSImport("plotly.js", "d3.color")
  @js.native
  def color(cssColorSpecifier: String): RGBColor | HSLColor | Null = js.native
  
  @JSImport("plotly.js", "d3.contourDensity")
  @js.native
  def contourDensity[Datum](): ContourDensity_[Datum] = js.native
  
  @JSImport("plotly.js", "d3.contours")
  @js.native
  def contours(): Contours_ = js.native
  
  @JSImport("plotly.js", "d3.count")
  @js.native
  def count[TObject](iterable: Iterable[TObject]): Double = js.native
  @JSImport("plotly.js", "d3.count")
  @js.native
  def count[TObject](
    iterable: Iterable[TObject],
    accessor: js.Function2[/* a */ TObject, /* b */ TObject, js.UndefOr[Double | Null]]
  ): Double = js.native
  
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create[NewGElement /* <: Element */](name: String): Selection_[NewGElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_a(name: a): Selection_[HTMLAnchorElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_abbr(name: abbr): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_address(name: address): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_applet(name: applet): Selection_[HTMLAppletElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_area(name: area): Selection_[HTMLAreaElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_article(name: article): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_aside(name: aside): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_audio(name: audio): Selection_[HTMLAudioElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_b(name: b_): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_base(name: base): Selection_[HTMLBaseElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_basefont(name: basefont): Selection_[HTMLBaseFontElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_bdi(name: bdi): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_bdo(name: bdo): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_blockquote(name: blockquote): Selection_[HTMLQuoteElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_body(name: body): Selection_[HTMLBodyElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_br(name: br): Selection_[HTMLBRElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_button(name: button): Selection_[HTMLButtonElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_canvas(name: canvas): Selection_[HTMLCanvasElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_caption(name: caption): Selection_[HTMLTableCaptionElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_circle(name: circle): Selection_[SVGCircleElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_cite(name: cite): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_clipPath(name: clipPath): Selection_[SVGClipPathElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_code(name: code): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_col(name: col): Selection_[HTMLTableColElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_colgroup(name: colgroup): Selection_[HTMLTableColElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_data(name: data): Selection_[HTMLDataElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_datalist(name: datalist): Selection_[HTMLDataListElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_dd(name: dd): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_defs(name: defs): Selection_[SVGDefsElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_del(name: del): Selection_[HTMLModElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_desc(name: desc): Selection_[SVGDescElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_details(name: details): Selection_[HTMLDetailsElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_dfn(name: dfn): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_dialog(name: dialog): Selection_[HTMLDialogElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_dir(name: dir): Selection_[HTMLDirectoryElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_div(name: div): Selection_[HTMLDivElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_dl(name: dl): Selection_[HTMLDListElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_dt(name: dt): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_ellipse(name: ellipse): Selection_[SVGEllipseElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_em(name: em): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_embed(name: embed): Selection_[HTMLEmbedElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_feBlend(name: feBlend): Selection_[SVGFEBlendElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_feColorMatrix(name: feColorMatrix): Selection_[SVGFEColorMatrixElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_feComponentTransfer(name: feComponentTransfer): Selection_[
    SVGFEComponentTransferElement, 
    js.UndefOr[scala.Nothing], 
    Null, 
    js.UndefOr[scala.Nothing]
  ] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_feComposite(name: feComposite): Selection_[SVGFECompositeElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_feConvolveMatrix(name: feConvolveMatrix): Selection_[SVGFEConvolveMatrixElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_feDiffuseLighting(name: feDiffuseLighting): Selection_[
    SVGFEDiffuseLightingElement, 
    js.UndefOr[scala.Nothing], 
    Null, 
    js.UndefOr[scala.Nothing]
  ] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_feDisplacementMap(name: feDisplacementMap): Selection_[
    SVGFEDisplacementMapElement, 
    js.UndefOr[scala.Nothing], 
    Null, 
    js.UndefOr[scala.Nothing]
  ] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_feDistantLight(name: feDistantLight): Selection_[SVGFEDistantLightElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_feFlood(name: feFlood): Selection_[SVGFEFloodElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_feFuncA(name: feFuncA): Selection_[SVGFEFuncAElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_feFuncB(name: feFuncB): Selection_[SVGFEFuncBElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_feFuncG(name: feFuncG): Selection_[SVGFEFuncGElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_feFuncR(name: feFuncR): Selection_[SVGFEFuncRElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_feGaussianBlur(name: feGaussianBlur): Selection_[SVGFEGaussianBlurElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_feImage(name: feImage): Selection_[SVGFEImageElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_feMerge(name: feMerge): Selection_[SVGFEMergeElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_feMergeNode(name: feMergeNode): Selection_[SVGFEMergeNodeElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_feMorphology(name: feMorphology): Selection_[SVGFEMorphologyElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_feOffset(name: feOffset): Selection_[SVGFEOffsetElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_fePointLight(name: fePointLight): Selection_[SVGFEPointLightElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_feSpecularLighting(name: feSpecularLighting): Selection_[
    SVGFESpecularLightingElement, 
    js.UndefOr[scala.Nothing], 
    Null, 
    js.UndefOr[scala.Nothing]
  ] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_feSpotLight(name: feSpotLight): Selection_[SVGFESpotLightElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_feTile(name: feTile): Selection_[SVGFETileElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_feTurbulence(name: feTurbulence): Selection_[SVGFETurbulenceElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_fieldset(name: fieldset): Selection_[HTMLFieldSetElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_figcaption(name: figcaption): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_figure(name: figure): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_filter(name: filter): Selection_[SVGFilterElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_font(name: font): Selection_[HTMLFontElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_footer(name: footer): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_foreignObject(name: foreignObject): Selection_[SVGForeignObjectElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_form(name: form): Selection_[HTMLFormElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_frame(name: frame): Selection_[HTMLFrameElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_frameset(name: frameset): Selection_[HTMLFrameSetElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_g(name: g): Selection_[SVGGElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_h1(name: h1): Selection_[HTMLHeadingElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_h2(name: h2): Selection_[HTMLHeadingElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_h3(name: h3): Selection_[HTMLHeadingElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_h4(name: h4): Selection_[HTMLHeadingElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_h5(name: h5): Selection_[HTMLHeadingElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_h6(name: h6): Selection_[HTMLHeadingElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_head(name: head): Selection_[HTMLHeadElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_header(name: header): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_hgroup(name: hgroup): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_hr(name: hr): Selection_[HTMLHRElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_html(name: html): Selection_[HTMLHtmlElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_i(name: i): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_iframe(name: iframe): Selection_[HTMLIFrameElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_image(name: image): Selection_[SVGImageElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_img(name: img): Selection_[HTMLImageElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_input(name: input): Selection_[HTMLInputElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_ins(name: ins): Selection_[HTMLModElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_kbd(name: kbd): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_label(name: label): Selection_[HTMLLabelElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_legend(name: legend): Selection_[HTMLLegendElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_li(name: li): Selection_[HTMLLIElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_line(name: line): Selection_[SVGLineElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_linearGradient(name: linearGradient): Selection_[SVGLinearGradientElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_link(name: link): Selection_[HTMLLinkElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_main(name: main): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_map(name: map): Selection_[HTMLMapElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_mark(name: mark): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_marker(name: marker): Selection_[SVGMarkerElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_marquee(name: marquee): Selection_[HTMLMarqueeElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_mask(name: mask): Selection_[SVGMaskElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_menu(name: menu): Selection_[HTMLMenuElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_meta(name: meta): Selection_[HTMLMetaElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_metadata(name: metadata): Selection_[SVGMetadataElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_meter(name: meter): Selection_[HTMLMeterElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_nav(name: nav): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_noscript(name: noscript): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_object(name: `object`): Selection_[HTMLObjectElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_ol(name: ol): Selection_[HTMLOListElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_optgroup(name: optgroup): Selection_[HTMLOptGroupElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_option(name: option): Selection_[HTMLOptionElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_output(name: output): Selection_[HTMLOutputElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_p(name: p): Selection_[HTMLParagraphElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_param(name: param): Selection_[HTMLParamElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_path(name: path): Selection_[SVGPathElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_pattern(name: pattern): Selection_[SVGPatternElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_picture(name: picture): Selection_[HTMLPictureElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_polygon(name: polygon): Selection_[SVGPolygonElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_polyline(name: polyline): Selection_[SVGPolylineElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_pre(name: pre): Selection_[HTMLPreElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_progress(name: progress): Selection_[HTMLProgressElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_q(name: q): Selection_[HTMLQuoteElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_radialGradient(name: radialGradient): Selection_[SVGRadialGradientElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_rect(name: rect): Selection_[SVGRectElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_rp(name: rp): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_rt(name: rt): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_ruby(name: ruby): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_s(name: s): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_samp(name: samp): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_script(name: script): Selection_[HTMLScriptElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_section(name: section): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_select(name: select): Selection_[HTMLSelectElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_slot(name: slot): Selection_[HTMLSlotElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_small(name: small): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_source(name: source): Selection_[HTMLSourceElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_span(name: span): Selection_[HTMLSpanElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_stop(name: stop): Selection_[SVGStopElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_strong(name: strong): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_style(name: style): Selection_[HTMLStyleElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_sub(name: sub): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_summary(name: summary): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_sup(name: sup): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_svg(name: svg): Selection_[SVGSVGElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_switch(name: switch): Selection_[SVGSwitchElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_symbol(name: symbol): Selection_[SVGSymbolElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_table(name: table): Selection_[HTMLTableElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_tbody(name: tbody): Selection_[HTMLTableSectionElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_td(name: td): Selection_[HTMLTableDataCellElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_template(name: template): Selection_[HTMLTemplateElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_text(name: text): Selection_[SVGTextElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_textPath(name: textPath): Selection_[SVGTextPathElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_textarea(name: textarea): Selection_[HTMLTextAreaElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_tfoot(name: tfoot): Selection_[HTMLTableSectionElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_th(name: th): Selection_[HTMLTableHeaderCellElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_thead(name: thead): Selection_[HTMLTableSectionElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_time(name: time): Selection_[HTMLTimeElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_title(name: title): Selection_[HTMLTitleElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_tr(name: tr): Selection_[HTMLTableRowElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_track(name: track): Selection_[HTMLTrackElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_tspan(name: tspan): Selection_[SVGTSpanElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_u(name: u): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_ul(name: ul): Selection_[HTMLUListElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_use(name: use): Selection_[SVGUseElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_var(name: `var`): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_video(name: video): Selection_[HTMLVideoElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_view(name: view): Selection_[SVGViewElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.create")
  @js.native
  def create_wbr(name: wbr): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator[NewGElement /* <: Element */](name: String): js.ThisFunction0[/* this */ BaseType, NewGElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_a(name: a): js.ThisFunction0[/* this */ BaseType, HTMLAnchorElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_abbr(name: abbr): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_address(name: address): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_applet(name: applet): js.ThisFunction0[/* this */ BaseType, HTMLAppletElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_area(name: area): js.ThisFunction0[/* this */ BaseType, HTMLAreaElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_article(name: article): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_aside(name: aside): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_audio(name: audio): js.ThisFunction0[/* this */ BaseType, HTMLAudioElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_b(name: b_): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_base(name: base): js.ThisFunction0[/* this */ BaseType, HTMLBaseElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_basefont(name: basefont): js.ThisFunction0[/* this */ BaseType, HTMLBaseFontElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_bdi(name: bdi): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_bdo(name: bdo): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_blockquote(name: blockquote): js.ThisFunction0[/* this */ BaseType, HTMLQuoteElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_body(name: body): js.ThisFunction0[/* this */ BaseType, HTMLBodyElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_br(name: br): js.ThisFunction0[/* this */ BaseType, HTMLBRElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_button(name: button): js.ThisFunction0[/* this */ BaseType, HTMLButtonElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_canvas(name: canvas): js.ThisFunction0[/* this */ BaseType, HTMLCanvasElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_caption(name: caption): js.ThisFunction0[/* this */ BaseType, HTMLTableCaptionElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_circle(name: circle): js.ThisFunction0[/* this */ BaseType, SVGCircleElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_cite(name: cite): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_clipPath(name: clipPath): js.ThisFunction0[/* this */ BaseType, SVGClipPathElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_code(name: code): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_col(name: col): js.ThisFunction0[/* this */ BaseType, HTMLTableColElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_colgroup(name: colgroup): js.ThisFunction0[/* this */ BaseType, HTMLTableColElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_data(name: data): js.ThisFunction0[/* this */ BaseType, HTMLDataElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_datalist(name: datalist): js.ThisFunction0[/* this */ BaseType, HTMLDataListElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_dd(name: dd): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_defs(name: defs): js.ThisFunction0[/* this */ BaseType, SVGDefsElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_del(name: del): js.ThisFunction0[/* this */ BaseType, HTMLModElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_desc(name: desc): js.ThisFunction0[/* this */ BaseType, SVGDescElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_details(name: details): js.ThisFunction0[/* this */ BaseType, HTMLDetailsElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_dfn(name: dfn): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_dialog(name: dialog): js.ThisFunction0[/* this */ BaseType, HTMLDialogElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_dir(name: dir): js.ThisFunction0[/* this */ BaseType, HTMLDirectoryElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_div(name: div): js.ThisFunction0[/* this */ BaseType, HTMLDivElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_dl(name: dl): js.ThisFunction0[/* this */ BaseType, HTMLDListElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_dt(name: dt): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_ellipse(name: ellipse): js.ThisFunction0[/* this */ BaseType, SVGEllipseElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_em(name: em): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_embed(name: embed): js.ThisFunction0[/* this */ BaseType, HTMLEmbedElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_feBlend(name: feBlend): js.ThisFunction0[/* this */ BaseType, SVGFEBlendElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_feColorMatrix(name: feColorMatrix): js.ThisFunction0[/* this */ BaseType, SVGFEColorMatrixElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_feComponentTransfer(name: feComponentTransfer): js.ThisFunction0[/* this */ BaseType, SVGFEComponentTransferElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_feComposite(name: feComposite): js.ThisFunction0[/* this */ BaseType, SVGFECompositeElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_feConvolveMatrix(name: feConvolveMatrix): js.ThisFunction0[/* this */ BaseType, SVGFEConvolveMatrixElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_feDiffuseLighting(name: feDiffuseLighting): js.ThisFunction0[/* this */ BaseType, SVGFEDiffuseLightingElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_feDisplacementMap(name: feDisplacementMap): js.ThisFunction0[/* this */ BaseType, SVGFEDisplacementMapElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_feDistantLight(name: feDistantLight): js.ThisFunction0[/* this */ BaseType, SVGFEDistantLightElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_feFlood(name: feFlood): js.ThisFunction0[/* this */ BaseType, SVGFEFloodElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_feFuncA(name: feFuncA): js.ThisFunction0[/* this */ BaseType, SVGFEFuncAElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_feFuncB(name: feFuncB): js.ThisFunction0[/* this */ BaseType, SVGFEFuncBElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_feFuncG(name: feFuncG): js.ThisFunction0[/* this */ BaseType, SVGFEFuncGElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_feFuncR(name: feFuncR): js.ThisFunction0[/* this */ BaseType, SVGFEFuncRElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_feGaussianBlur(name: feGaussianBlur): js.ThisFunction0[/* this */ BaseType, SVGFEGaussianBlurElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_feImage(name: feImage): js.ThisFunction0[/* this */ BaseType, SVGFEImageElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_feMerge(name: feMerge): js.ThisFunction0[/* this */ BaseType, SVGFEMergeElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_feMergeNode(name: feMergeNode): js.ThisFunction0[/* this */ BaseType, SVGFEMergeNodeElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_feMorphology(name: feMorphology): js.ThisFunction0[/* this */ BaseType, SVGFEMorphologyElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_feOffset(name: feOffset): js.ThisFunction0[/* this */ BaseType, SVGFEOffsetElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_fePointLight(name: fePointLight): js.ThisFunction0[/* this */ BaseType, SVGFEPointLightElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_feSpecularLighting(name: feSpecularLighting): js.ThisFunction0[/* this */ BaseType, SVGFESpecularLightingElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_feSpotLight(name: feSpotLight): js.ThisFunction0[/* this */ BaseType, SVGFESpotLightElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_feTile(name: feTile): js.ThisFunction0[/* this */ BaseType, SVGFETileElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_feTurbulence(name: feTurbulence): js.ThisFunction0[/* this */ BaseType, SVGFETurbulenceElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_fieldset(name: fieldset): js.ThisFunction0[/* this */ BaseType, HTMLFieldSetElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_figcaption(name: figcaption): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_figure(name: figure): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_filter(name: filter): js.ThisFunction0[/* this */ BaseType, SVGFilterElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_font(name: font): js.ThisFunction0[/* this */ BaseType, HTMLFontElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_footer(name: footer): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_foreignObject(name: foreignObject): js.ThisFunction0[/* this */ BaseType, SVGForeignObjectElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_form(name: form): js.ThisFunction0[/* this */ BaseType, HTMLFormElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_frame(name: frame): js.ThisFunction0[/* this */ BaseType, HTMLFrameElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_frameset(name: frameset): js.ThisFunction0[/* this */ BaseType, HTMLFrameSetElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_g(name: g): js.ThisFunction0[/* this */ BaseType, SVGGElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_h1(name: h1): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_h2(name: h2): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_h3(name: h3): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_h4(name: h4): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_h5(name: h5): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_h6(name: h6): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_head(name: head): js.ThisFunction0[/* this */ BaseType, HTMLHeadElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_header(name: header): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_hgroup(name: hgroup): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_hr(name: hr): js.ThisFunction0[/* this */ BaseType, HTMLHRElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_html(name: html): js.ThisFunction0[/* this */ BaseType, HTMLHtmlElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_i(name: i): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_iframe(name: iframe): js.ThisFunction0[/* this */ BaseType, HTMLIFrameElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_image(name: image): js.ThisFunction0[/* this */ BaseType, SVGImageElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_img(name: img): js.ThisFunction0[/* this */ BaseType, HTMLImageElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_input(name: input): js.ThisFunction0[/* this */ BaseType, HTMLInputElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_ins(name: ins): js.ThisFunction0[/* this */ BaseType, HTMLModElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_kbd(name: kbd): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_label(name: label): js.ThisFunction0[/* this */ BaseType, HTMLLabelElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_legend(name: legend): js.ThisFunction0[/* this */ BaseType, HTMLLegendElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_li(name: li): js.ThisFunction0[/* this */ BaseType, HTMLLIElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_line(name: line): js.ThisFunction0[/* this */ BaseType, SVGLineElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_linearGradient(name: linearGradient): js.ThisFunction0[/* this */ BaseType, SVGLinearGradientElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_link(name: link): js.ThisFunction0[/* this */ BaseType, HTMLLinkElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_main(name: main): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_map(name: map): js.ThisFunction0[/* this */ BaseType, HTMLMapElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_mark(name: mark): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_marker(name: marker): js.ThisFunction0[/* this */ BaseType, SVGMarkerElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_marquee(name: marquee): js.ThisFunction0[/* this */ BaseType, HTMLMarqueeElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_mask(name: mask): js.ThisFunction0[/* this */ BaseType, SVGMaskElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_menu(name: menu): js.ThisFunction0[/* this */ BaseType, HTMLMenuElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_meta(name: meta): js.ThisFunction0[/* this */ BaseType, HTMLMetaElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_metadata(name: metadata): js.ThisFunction0[/* this */ BaseType, SVGMetadataElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_meter(name: meter): js.ThisFunction0[/* this */ BaseType, HTMLMeterElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_nav(name: nav): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_noscript(name: noscript): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_object(name: `object`): js.ThisFunction0[/* this */ BaseType, HTMLObjectElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_ol(name: ol): js.ThisFunction0[/* this */ BaseType, HTMLOListElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_optgroup(name: optgroup): js.ThisFunction0[/* this */ BaseType, HTMLOptGroupElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_option(name: option): js.ThisFunction0[/* this */ BaseType, HTMLOptionElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_output(name: output): js.ThisFunction0[/* this */ BaseType, HTMLOutputElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_p(name: p): js.ThisFunction0[/* this */ BaseType, HTMLParagraphElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_param(name: param): js.ThisFunction0[/* this */ BaseType, HTMLParamElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_path(name: path): js.ThisFunction0[/* this */ BaseType, SVGPathElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_pattern(name: pattern): js.ThisFunction0[/* this */ BaseType, SVGPatternElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_picture(name: picture): js.ThisFunction0[/* this */ BaseType, HTMLPictureElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_polygon(name: polygon): js.ThisFunction0[/* this */ BaseType, SVGPolygonElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_polyline(name: polyline): js.ThisFunction0[/* this */ BaseType, SVGPolylineElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_pre(name: pre): js.ThisFunction0[/* this */ BaseType, HTMLPreElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_progress(name: progress): js.ThisFunction0[/* this */ BaseType, HTMLProgressElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_q(name: q): js.ThisFunction0[/* this */ BaseType, HTMLQuoteElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_radialGradient(name: radialGradient): js.ThisFunction0[/* this */ BaseType, SVGRadialGradientElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_rect(name: rect): js.ThisFunction0[/* this */ BaseType, SVGRectElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_rp(name: rp): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_rt(name: rt): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_ruby(name: ruby): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_s(name: s): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_samp(name: samp): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_script(name: script): js.ThisFunction0[/* this */ BaseType, HTMLScriptElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_section(name: section): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_select(name: select): js.ThisFunction0[/* this */ BaseType, HTMLSelectElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_slot(name: slot): js.ThisFunction0[/* this */ BaseType, HTMLSlotElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_small(name: small): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_source(name: source): js.ThisFunction0[/* this */ BaseType, HTMLSourceElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_span(name: span): js.ThisFunction0[/* this */ BaseType, HTMLSpanElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_stop(name: stop): js.ThisFunction0[/* this */ BaseType, SVGStopElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_strong(name: strong): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_style(name: style): js.ThisFunction0[/* this */ BaseType, HTMLStyleElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_sub(name: sub): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_summary(name: summary): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_sup(name: sup): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_svg(name: svg): js.ThisFunction0[/* this */ BaseType, SVGSVGElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_switch(name: switch): js.ThisFunction0[/* this */ BaseType, SVGSwitchElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_symbol(name: symbol): js.ThisFunction0[/* this */ BaseType, SVGSymbolElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_table(name: table): js.ThisFunction0[/* this */ BaseType, HTMLTableElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_tbody(name: tbody): js.ThisFunction0[/* this */ BaseType, HTMLTableSectionElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_td(name: td): js.ThisFunction0[/* this */ BaseType, HTMLTableDataCellElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_template(name: template): js.ThisFunction0[/* this */ BaseType, HTMLTemplateElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_text(name: text): js.ThisFunction0[/* this */ BaseType, SVGTextElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_textPath(name: textPath): js.ThisFunction0[/* this */ BaseType, SVGTextPathElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_textarea(name: textarea): js.ThisFunction0[/* this */ BaseType, HTMLTextAreaElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_tfoot(name: tfoot): js.ThisFunction0[/* this */ BaseType, HTMLTableSectionElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_th(name: th): js.ThisFunction0[/* this */ BaseType, HTMLTableHeaderCellElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_thead(name: thead): js.ThisFunction0[/* this */ BaseType, HTMLTableSectionElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_time(name: time): js.ThisFunction0[/* this */ BaseType, HTMLTimeElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_title(name: title): js.ThisFunction0[/* this */ BaseType, HTMLTitleElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_tr(name: tr): js.ThisFunction0[/* this */ BaseType, HTMLTableRowElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_track(name: track): js.ThisFunction0[/* this */ BaseType, HTMLTrackElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_tspan(name: tspan): js.ThisFunction0[/* this */ BaseType, SVGTSpanElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_u(name: u): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_ul(name: ul): js.ThisFunction0[/* this */ BaseType, HTMLUListElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_use(name: use): js.ThisFunction0[/* this */ BaseType, SVGUseElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_var(name: `var`): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_video(name: video): js.ThisFunction0[/* this */ BaseType, HTMLVideoElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_view(name: view): js.ThisFunction0[/* this */ BaseType, SVGViewElement] = js.native
  @JSImport("plotly.js", "d3.creator")
  @js.native
  def creator_wbr(name: wbr): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  
  @JSImport("plotly.js", "d3.cross")
  @js.native
  def cross[S, T](a: Iterable[S], b: Iterable[T]): js.Array[js.Tuple2[S, T]] = js.native
  @JSImport("plotly.js", "d3.cross")
  @js.native
  def cross[S, T, U](a: Iterable[S], b: Iterable[T], reducer: js.Function2[/* a */ S, /* b */ T, U]): js.Array[U] = js.native
  
  @JSImport("plotly.js", "d3.csv")
  @js.native
  def csv[Columns /* <: String */](url: String): js.Promise[DSVRowArray[Columns]] = js.native
  @JSImport("plotly.js", "d3.csv")
  @js.native
  def csv[Columns /* <: String */](url: String, init: RequestInit): js.Promise[DSVRowArray[Columns]] = js.native
  @JSImport("plotly.js", "d3.csv")
  @js.native
  def csv[ParsedRow /* <: js.Object */, Columns /* <: String */](
    url: String,
    init: RequestInit,
    row: js.Function3[
      /* rawRow */ DSVRowString[Columns], 
      /* index */ Double, 
      /* columns */ js.Array[Columns], 
      js.UndefOr[ParsedRow | Null]
    ]
  ): js.Promise[DSVParsedArray[ParsedRow]] = js.native
  @JSImport("plotly.js", "d3.csv")
  @js.native
  def csv[ParsedRow /* <: js.Object */, Columns /* <: String */](
    url: String,
    row: js.Function3[
      /* rawRow */ DSVRowString[Columns], 
      /* index */ Double, 
      /* columns */ js.Array[Columns], 
      js.UndefOr[ParsedRow | Null]
    ]
  ): js.Promise[DSVParsedArray[ParsedRow]] = js.native
  
  @JSImport("plotly.js", "d3.csvFormat")
  @js.native
  def csvFormat[T /* <: js.Object */](rows: js.Array[T]): String = js.native
  @JSImport("plotly.js", "d3.csvFormat")
  @js.native
  def csvFormat[T /* <: js.Object */](rows: js.Array[T], columns: js.Array[/* keyof T */ String]): String = js.native
  
  @JSImport("plotly.js", "d3.csvFormatBody")
  @js.native
  def csvFormatBody[T /* <: js.Object */](rows: js.Array[T]): String = js.native
  @JSImport("plotly.js", "d3.csvFormatBody")
  @js.native
  def csvFormatBody[T /* <: js.Object */](rows: js.Array[T], columns: js.Array[/* keyof T */ String]): String = js.native
  
  @JSImport("plotly.js", "d3.csvFormatRow")
  @js.native
  def csvFormatRow(row: js.Array[String]): String = js.native
  
  @JSImport("plotly.js", "d3.csvFormatRows")
  @js.native
  def csvFormatRows(rows: js.Array[js.Array[String]]): String = js.native
  
  @JSImport("plotly.js", "d3.csvFormatValue")
  @js.native
  def csvFormatValue(value: String): String = js.native
  
  @JSImport("plotly.js", "d3.csvParse")
  @js.native
  def csvParse[Columns /* <: String */](csvString: String): DSVRowArray[Columns] = js.native
  @JSImport("plotly.js", "d3.csvParse")
  @js.native
  def csvParse[ParsedRow /* <: js.Object */, Columns /* <: String */](
    csvString: String,
    row: js.Function3[
      /* rawRow */ DSVRowString[Columns], 
      /* index */ Double, 
      /* columns */ js.Array[Columns], 
      js.UndefOr[ParsedRow | Null]
    ]
  ): DSVParsedArray[ParsedRow] = js.native
  
  @JSImport("plotly.js", "d3.csvParseRows")
  @js.native
  def csvParseRows(csvString: String): js.Array[js.Array[String]] = js.native
  @JSImport("plotly.js", "d3.csvParseRows")
  @js.native
  def csvParseRows[ParsedRow /* <: js.Object */](
    csvString: String,
    row: js.Function2[/* rawRow */ js.Array[String], /* index */ Double, js.UndefOr[ParsedRow | Null]]
  ): js.Array[ParsedRow] = js.native
  
  @JSImport("plotly.js", "d3.cubehelix")
  @js.native
  val cubehelix: CubehelixColorFactory = js.native
  @JSImport("plotly.js", "d3.cubehelix")
  @js.native
  def cubehelix(color: ColorCommonInstance): CubehelixColor = js.native
  /**
    * Converts the provided color instance and returns a Cubehelix color.
    * The color instance is specified, it is converted to the RGB color space using color.rgb and then converted to Cubehelix.
    * (Colors already in the Cubehelix color space skip the conversion to RGB.)
    *
    * @param color A permissible color space instance.
    */
  @JSImport("plotly.js", "d3.cubehelix")
  @js.native
  def cubehelix(color: ColorSpaceObject): CubehelixColor = js.native
  /**
    * Parses the specified CSS Color Module Level 3 specifier string, returning an Cubehelix color.
    * If the specifier was not valid, null is returned.
    *
    * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
    */
  @JSImport("plotly.js", "d3.cubehelix")
  @js.native
  def cubehelix(cssColorSpecifier: String): CubehelixColor = js.native
  /**
    * Constructs a new Cubehelix color based on the specified channel values and opacity.
    *
    * @param h Hue channel value.
    * @param s Saturation channel value.
    * @param l Lightness channel value.
    * @param opacity Optional opacity value, defaults to 1.
    */
  @JSImport("plotly.js", "d3.cubehelix")
  @js.native
  def cubehelix(h: Double, s: Double, l: Double): CubehelixColor = js.native
  @JSImport("plotly.js", "d3.cubehelix")
  @js.native
  def cubehelix(h: Double, s: Double, l: Double, opacity: Double): CubehelixColor = js.native
  
  @JSImport("plotly.js", "d3.cumsum")
  @js.native
  def cumsum[T /* <: Numeric */](iterable: Iterable[js.UndefOr[T | Null]]): Float64Array = js.native
  @JSImport("plotly.js", "d3.cumsum")
  @js.native
  def cumsum[T](
    iterable: Iterable[T],
    accessor: js.Function3[/* element */ T, /* i */ Double, /* array */ Iterable[T], js.UndefOr[Double | Null]]
  ): Float64Array = js.native
  
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  @JSImport("plotly.js", "d3.curveBasis")
  @js.native
  def curveBasis(context: Path_): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  @JSImport("plotly.js", "d3.curveBasis")
  @js.native
  def curveBasis(context: CanvasRenderingContext2D): CurveGenerator = js.native
  
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  @JSImport("plotly.js", "d3.curveBasisClosed")
  @js.native
  def curveBasisClosed(context: Path_): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  @JSImport("plotly.js", "d3.curveBasisClosed")
  @js.native
  def curveBasisClosed(context: CanvasRenderingContext2D): CurveGenerator = js.native
  
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  @JSImport("plotly.js", "d3.curveBasisOpen")
  @js.native
  def curveBasisOpen(context: Path_): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  @JSImport("plotly.js", "d3.curveBasisOpen")
  @js.native
  def curveBasisOpen(context: CanvasRenderingContext2D): CurveGenerator = js.native
  
  @JSImport("plotly.js", "d3.curveBundle")
  @js.native
  val curveBundle: CurveBundleFactory = js.native
  
  @JSImport("plotly.js", "d3.curveCardinal")
  @js.native
  val curveCardinal: CurveCardinalFactory = js.native
  
  @JSImport("plotly.js", "d3.curveCardinalClosed")
  @js.native
  val curveCardinalClosed: CurveCardinalFactory = js.native
  
  @JSImport("plotly.js", "d3.curveCardinalOpen")
  @js.native
  val curveCardinalOpen: CurveCardinalFactory = js.native
  
  @JSImport("plotly.js", "d3.curveCatmullRom")
  @js.native
  val curveCatmullRom: CurveCatmullRomFactory = js.native
  
  @JSImport("plotly.js", "d3.curveCatmullRomClosed")
  @js.native
  val curveCatmullRomClosed: CurveCatmullRomFactory = js.native
  
  @JSImport("plotly.js", "d3.curveCatmullRomOpen")
  @js.native
  val curveCatmullRomOpen: CurveCatmullRomFactory = js.native
  
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  @JSImport("plotly.js", "d3.curveLinear")
  @js.native
  def curveLinear(context: Path_): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  @JSImport("plotly.js", "d3.curveLinear")
  @js.native
  def curveLinear(context: CanvasRenderingContext2D): CurveGenerator = js.native
  
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  @JSImport("plotly.js", "d3.curveLinearClosed")
  @js.native
  def curveLinearClosed(context: Path_): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  @JSImport("plotly.js", "d3.curveLinearClosed")
  @js.native
  def curveLinearClosed(context: CanvasRenderingContext2D): CurveGenerator = js.native
  
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  @JSImport("plotly.js", "d3.curveMonotoneX")
  @js.native
  def curveMonotoneX(context: Path_): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  @JSImport("plotly.js", "d3.curveMonotoneX")
  @js.native
  def curveMonotoneX(context: CanvasRenderingContext2D): CurveGenerator = js.native
  
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  @JSImport("plotly.js", "d3.curveMonotoneY")
  @js.native
  def curveMonotoneY(context: Path_): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  @JSImport("plotly.js", "d3.curveMonotoneY")
  @js.native
  def curveMonotoneY(context: CanvasRenderingContext2D): CurveGenerator = js.native
  
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  @JSImport("plotly.js", "d3.curveNatural")
  @js.native
  def curveNatural(context: Path_): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  @JSImport("plotly.js", "d3.curveNatural")
  @js.native
  def curveNatural(context: CanvasRenderingContext2D): CurveGenerator = js.native
  
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  @JSImport("plotly.js", "d3.curveStep")
  @js.native
  def curveStep(context: Path_): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  @JSImport("plotly.js", "d3.curveStep")
  @js.native
  def curveStep(context: CanvasRenderingContext2D): CurveGenerator = js.native
  
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  @JSImport("plotly.js", "d3.curveStepAfter")
  @js.native
  def curveStepAfter(context: Path_): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  @JSImport("plotly.js", "d3.curveStepAfter")
  @js.native
  def curveStepAfter(context: CanvasRenderingContext2D): CurveGenerator = js.native
  
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  @JSImport("plotly.js", "d3.curveStepBefore")
  @js.native
  def curveStepBefore(context: Path_): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  @JSImport("plotly.js", "d3.curveStepBefore")
  @js.native
  def curveStepBefore(context: CanvasRenderingContext2D): CurveGenerator = js.native
  
  @JSImport("plotly.js", "d3.descending")
  @js.native
  def descending(): Double = js.native
  @JSImport("plotly.js", "d3.descending")
  @js.native
  def descending(a: js.UndefOr[Primitive], b: Primitive): Double = js.native
  @JSImport("plotly.js", "d3.descending")
  @js.native
  def descending(a: Primitive): Double = js.native
  
  @JSImport("plotly.js", "d3.deviation")
  @js.native
  def deviation[T /* <: Numeric */](iterable: Iterable[js.UndefOr[T | Null]]): js.UndefOr[Double] = js.native
  @JSImport("plotly.js", "d3.deviation")
  @js.native
  def deviation[T](
    iterable: Iterable[T],
    accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[Double | Null]]
  ): js.UndefOr[Double] = js.native
  
  @JSImport("plotly.js", "d3.difference")
  @js.native
  def difference[T](iterable: Iterable[T], others: Iterable[T]*): Set[T] = js.native
  
  @JSImport("plotly.js", "d3.disjoint")
  @js.native
  def disjoint[T](a: Iterable[T], b: Iterable[T]): Boolean = js.native
  
  @JSImport("plotly.js", "d3.dispatch")
  @js.native
  def dispatch[T /* <: js.Object */](types: String*): Dispatch_[T] = js.native
  
  @JSImport("plotly.js", "d3.drag")
  @js.native
  def drag[GElement /* <: DraggedElementBaseType */, Datum](): DragBehavior[GElement, Datum, Datum | SubjectPosition] = js.native
  
  @JSImport("plotly.js", "d3.dragDisable")
  @js.native
  def dragDisable(window: Window): Unit = js.native
  
  @JSImport("plotly.js", "d3.dragEnable")
  @js.native
  def dragEnable(window: Window): Unit = js.native
  @JSImport("plotly.js", "d3.dragEnable")
  @js.native
  def dragEnable(window: Window, noClick: Boolean): Unit = js.native
  
  @JSImport("plotly.js", "d3.drag")
  @js.native
  def drag_GElement_DraggedElementBaseTypeDatumSubject[GElement /* <: DraggedElementBaseType */, Datum, Subject](): DragBehavior[GElement, Datum, Subject] = js.native
  
  @JSImport("plotly.js", "d3.dsv")
  @js.native
  def dsv[Columns /* <: String */](delimiter: String, url: String): js.Promise[DSVRowArray[Columns]] = js.native
  @JSImport("plotly.js", "d3.dsv")
  @js.native
  def dsv[Columns /* <: String */](delimiter: String, url: String, init: RequestInit): js.Promise[DSVRowArray[Columns]] = js.native
  @JSImport("plotly.js", "d3.dsv")
  @js.native
  def dsv[ParsedRow /* <: js.Object */, Columns /* <: String */](
    delimiter: String,
    url: String,
    init: RequestInit,
    row: js.Function3[
      /* rawRow */ DSVRowString[Columns], 
      /* index */ Double, 
      /* columns */ js.Array[Columns], 
      js.UndefOr[ParsedRow | Null]
    ]
  ): js.Promise[DSVParsedArray[ParsedRow]] = js.native
  @JSImport("plotly.js", "d3.dsv")
  @js.native
  def dsv[ParsedRow /* <: js.Object */, Columns /* <: String */](
    delimiter: String,
    url: String,
    row: js.Function3[
      /* rawRow */ DSVRowString[Columns], 
      /* index */ Double, 
      /* columns */ js.Array[Columns], 
      js.UndefOr[ParsedRow | Null]
    ]
  ): js.Promise[DSVParsedArray[ParsedRow]] = js.native
  
  @JSImport("plotly.js", "d3.dsvFormat")
  @js.native
  def dsvFormat(delimiter: String): DSV = js.native
  
  @JSImport("plotly.js", "d3.easeBack")
  @js.native
  val easeBack: BackEasingFactory = js.native
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  @JSImport("plotly.js", "d3.easeBack")
  @js.native
  def easeBack(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeBackIn")
  @js.native
  val easeBackIn: BackEasingFactory = js.native
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  @JSImport("plotly.js", "d3.easeBackIn")
  @js.native
  def easeBackIn(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeBackInOut")
  @js.native
  val easeBackInOut: BackEasingFactory = js.native
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  @JSImport("plotly.js", "d3.easeBackInOut")
  @js.native
  def easeBackInOut(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeBackOut")
  @js.native
  val easeBackOut: BackEasingFactory = js.native
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  @JSImport("plotly.js", "d3.easeBackOut")
  @js.native
  def easeBackOut(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeBounce")
  @js.native
  def easeBounce(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeBounceIn")
  @js.native
  def easeBounceIn(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeBounceInOut")
  @js.native
  def easeBounceInOut(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeBounceOut")
  @js.native
  def easeBounceOut(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeCircle")
  @js.native
  def easeCircle(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeCircleIn")
  @js.native
  def easeCircleIn(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeCircleInOut")
  @js.native
  def easeCircleInOut(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeCircleOut")
  @js.native
  def easeCircleOut(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeCubic")
  @js.native
  def easeCubic(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeCubicIn")
  @js.native
  def easeCubicIn(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeCubicInOut")
  @js.native
  def easeCubicInOut(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeCubicOut")
  @js.native
  def easeCubicOut(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeElastic")
  @js.native
  val easeElastic: ElasticEasingFactory = js.native
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  @JSImport("plotly.js", "d3.easeElastic")
  @js.native
  def easeElastic(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeElasticIn")
  @js.native
  val easeElasticIn: ElasticEasingFactory = js.native
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  @JSImport("plotly.js", "d3.easeElasticIn")
  @js.native
  def easeElasticIn(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeElasticInOut")
  @js.native
  val easeElasticInOut: ElasticEasingFactory = js.native
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  @JSImport("plotly.js", "d3.easeElasticInOut")
  @js.native
  def easeElasticInOut(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeElasticOut")
  @js.native
  val easeElasticOut: ElasticEasingFactory = js.native
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  @JSImport("plotly.js", "d3.easeElasticOut")
  @js.native
  def easeElasticOut(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeExp")
  @js.native
  def easeExp(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeExpIn")
  @js.native
  def easeExpIn(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeExpInOut")
  @js.native
  def easeExpInOut(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeExpOut")
  @js.native
  def easeExpOut(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeLinear")
  @js.native
  def easeLinear(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easePoly")
  @js.native
  val easePoly: PolynomialEasingFactory = js.native
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  @JSImport("plotly.js", "d3.easePoly")
  @js.native
  def easePoly(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easePolyIn")
  @js.native
  val easePolyIn: PolynomialEasingFactory = js.native
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  @JSImport("plotly.js", "d3.easePolyIn")
  @js.native
  def easePolyIn(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easePolyInOut")
  @js.native
  val easePolyInOut: PolynomialEasingFactory = js.native
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  @JSImport("plotly.js", "d3.easePolyInOut")
  @js.native
  def easePolyInOut(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easePolyOut")
  @js.native
  val easePolyOut: PolynomialEasingFactory = js.native
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  @JSImport("plotly.js", "d3.easePolyOut")
  @js.native
  def easePolyOut(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeQuad")
  @js.native
  def easeQuad(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeQuadIn")
  @js.native
  def easeQuadIn(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeQuadInOut")
  @js.native
  def easeQuadInOut(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeQuadOut")
  @js.native
  def easeQuadOut(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeSin")
  @js.native
  def easeSin(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeSinIn")
  @js.native
  def easeSinIn(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeSinInOut")
  @js.native
  def easeSinInOut(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.easeSinOut")
  @js.native
  def easeSinOut(normalizedTime: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.every")
  @js.native
  def every[T](
    iterable: Iterable[T],
    test: js.Function3[/* value */ T, /* index */ Double, /* iterable */ Iterable[T], _]
  ): Boolean = js.native
  
  @JSImport("plotly.js", "d3.extent")
  @js.native
  def extent(iterable: Iterable[String]): js.Tuple2[js.UndefOr[String], js.UndefOr[String]] = js.native
  @JSImport("plotly.js", "d3.extent")
  @js.native
  def extent[T](
    iterable: Iterable[T],
    accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[String | Null]]
  ): js.Tuple2[js.UndefOr[String], js.UndefOr[String]] = js.native
  @JSImport("plotly.js", "d3.extent")
  @js.native
  def extent_TU_Numeric[T, U /* <: Numeric */](
    iterable: Iterable[T],
    accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[U | Null]]
  ): js.Tuple2[js.UndefOr[U], js.UndefOr[U]] = js.native
  @JSImport("plotly.js", "d3.extent")
  @js.native
  def extent_T_Numeric[T /* <: Numeric */](iterable: Iterable[T]): js.Tuple2[js.UndefOr[T], js.UndefOr[T]] = js.native
  
  @JSImport("plotly.js", "d3.filter")
  @js.native
  def filter[T](
    iterable: Iterable[T],
    test: js.Function3[/* value */ T, /* index */ Double, /* iterable */ Iterable[T], _]
  ): js.Array[T] = js.native
  
  @JSImport("plotly.js", "d3.forceCenter")
  @js.native
  def forceCenter[NodeDatum /* <: SimulationNodeDatum */](): ForceCenter_[NodeDatum] = js.native
  @JSImport("plotly.js", "d3.forceCenter")
  @js.native
  def forceCenter[NodeDatum /* <: SimulationNodeDatum */](x: js.UndefOr[scala.Nothing], y: Double): ForceCenter_[NodeDatum] = js.native
  @JSImport("plotly.js", "d3.forceCenter")
  @js.native
  def forceCenter[NodeDatum /* <: SimulationNodeDatum */](x: Double): ForceCenter_[NodeDatum] = js.native
  @JSImport("plotly.js", "d3.forceCenter")
  @js.native
  def forceCenter[NodeDatum /* <: SimulationNodeDatum */](x: Double, y: Double): ForceCenter_[NodeDatum] = js.native
  
  @JSImport("plotly.js", "d3.forceCollide")
  @js.native
  def forceCollide[NodeDatum /* <: SimulationNodeDatum */](): ForceCollide_[NodeDatum] = js.native
  @JSImport("plotly.js", "d3.forceCollide")
  @js.native
  def forceCollide[NodeDatum /* <: SimulationNodeDatum */](
    radius: js.Function3[/* node */ NodeDatum, /* i */ Double, /* nodes */ js.Array[NodeDatum], Double]
  ): ForceCollide_[NodeDatum] = js.native
  @JSImport("plotly.js", "d3.forceCollide")
  @js.native
  def forceCollide[NodeDatum /* <: SimulationNodeDatum */](radius: Double): ForceCollide_[NodeDatum] = js.native
  
  @JSImport("plotly.js", "d3.forceLink")
  @js.native
  def forceLink[NodeDatum /* <: SimulationNodeDatum */, LinksDatum /* <: SimulationLinkDatum[NodeDatum] */](): ForceLink_[NodeDatum, LinksDatum] = js.native
  @JSImport("plotly.js", "d3.forceLink")
  @js.native
  def forceLink[NodeDatum /* <: SimulationNodeDatum */, LinksDatum /* <: SimulationLinkDatum[NodeDatum] */](links: js.Array[LinksDatum]): ForceLink_[NodeDatum, LinksDatum] = js.native
  
  @JSImport("plotly.js", "d3.forceManyBody")
  @js.native
  def forceManyBody[NodeDatum /* <: SimulationNodeDatum */](): ForceManyBody_[NodeDatum] = js.native
  
  @JSImport("plotly.js", "d3.forceRadial")
  @js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]): ForceRadial_[NodeDatum] = js.native
  @JSImport("plotly.js", "d3.forceRadial")
  @js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    x: js.UndefOr[scala.Nothing],
    y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
  ): ForceRadial_[NodeDatum] = js.native
  @JSImport("plotly.js", "d3.forceRadial")
  @js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    x: js.UndefOr[scala.Nothing],
    y: Double
  ): ForceRadial_[NodeDatum] = js.native
  @JSImport("plotly.js", "d3.forceRadial")
  @js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
  ): ForceRadial_[NodeDatum] = js.native
  @JSImport("plotly.js", "d3.forceRadial")
  @js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
  ): ForceRadial_[NodeDatum] = js.native
  @JSImport("plotly.js", "d3.forceRadial")
  @js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    y: Double
  ): ForceRadial_[NodeDatum] = js.native
  @JSImport("plotly.js", "d3.forceRadial")
  @js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    x: Double
  ): ForceRadial_[NodeDatum] = js.native
  @JSImport("plotly.js", "d3.forceRadial")
  @js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    x: Double,
    y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
  ): ForceRadial_[NodeDatum] = js.native
  @JSImport("plotly.js", "d3.forceRadial")
  @js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    x: Double,
    y: Double
  ): ForceRadial_[NodeDatum] = js.native
  @JSImport("plotly.js", "d3.forceRadial")
  @js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](radius: Double): ForceRadial_[NodeDatum] = js.native
  @JSImport("plotly.js", "d3.forceRadial")
  @js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: Double,
    x: js.UndefOr[scala.Nothing],
    y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
  ): ForceRadial_[NodeDatum] = js.native
  @JSImport("plotly.js", "d3.forceRadial")
  @js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](radius: Double, x: js.UndefOr[scala.Nothing], y: Double): ForceRadial_[NodeDatum] = js.native
  @JSImport("plotly.js", "d3.forceRadial")
  @js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: Double,
    x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
  ): ForceRadial_[NodeDatum] = js.native
  @JSImport("plotly.js", "d3.forceRadial")
  @js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: Double,
    x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
  ): ForceRadial_[NodeDatum] = js.native
  @JSImport("plotly.js", "d3.forceRadial")
  @js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: Double,
    x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    y: Double
  ): ForceRadial_[NodeDatum] = js.native
  @JSImport("plotly.js", "d3.forceRadial")
  @js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](radius: Double, x: Double): ForceRadial_[NodeDatum] = js.native
  @JSImport("plotly.js", "d3.forceRadial")
  @js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: Double,
    x: Double,
    y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
  ): ForceRadial_[NodeDatum] = js.native
  @JSImport("plotly.js", "d3.forceRadial")
  @js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](radius: Double, x: Double, y: Double): ForceRadial_[NodeDatum] = js.native
  
  @JSImport("plotly.js", "d3.forceSimulation")
  @js.native
  def forceSimulation[NodeDatum /* <: SimulationNodeDatum */](): Simulation[NodeDatum, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.forceSimulation")
  @js.native
  def forceSimulation[NodeDatum /* <: SimulationNodeDatum */](nodesData: js.Array[NodeDatum]): Simulation[NodeDatum, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.forceSimulation")
  @js.native
  def forceSimulation_NodeDatum_SimulationNodeDatumLinkDatum_SimulationLinkDatumNodeDatum[NodeDatum /* <: SimulationNodeDatum */, LinkDatum /* <: SimulationLinkDatum[NodeDatum] */](): Simulation[NodeDatum, LinkDatum] = js.native
  @JSImport("plotly.js", "d3.forceSimulation")
  @js.native
  def forceSimulation_NodeDatum_SimulationNodeDatumLinkDatum_SimulationLinkDatumNodeDatum[NodeDatum /* <: SimulationNodeDatum */, LinkDatum /* <: SimulationLinkDatum[NodeDatum] */](nodesData: js.Array[NodeDatum]): Simulation[NodeDatum, LinkDatum] = js.native
  
  @JSImport("plotly.js", "d3.forceX")
  @js.native
  def forceX[NodeDatum /* <: SimulationNodeDatum */](): ForceX_[NodeDatum] = js.native
  @JSImport("plotly.js", "d3.forceX")
  @js.native
  def forceX[NodeDatum /* <: SimulationNodeDatum */](x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]): ForceX_[NodeDatum] = js.native
  @JSImport("plotly.js", "d3.forceX")
  @js.native
  def forceX[NodeDatum /* <: SimulationNodeDatum */](x: Double): ForceX_[NodeDatum] = js.native
  
  @JSImport("plotly.js", "d3.forceY")
  @js.native
  def forceY[NodeDatum /* <: SimulationNodeDatum */](): ForceY_[NodeDatum] = js.native
  @JSImport("plotly.js", "d3.forceY")
  @js.native
  def forceY[NodeDatum /* <: SimulationNodeDatum */](y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]): ForceY_[NodeDatum] = js.native
  @JSImport("plotly.js", "d3.forceY")
  @js.native
  def forceY[NodeDatum /* <: SimulationNodeDatum */](y: Double): ForceY_[NodeDatum] = js.native
  
  @JSImport("plotly.js", "d3.format")
  @js.native
  def format(specifier: String): js.Function1[/* n */ Double | ValueOf, String] = js.native
  
  @JSImport("plotly.js", "d3.formatDefaultLocale")
  @js.native
  def formatDefaultLocale(defaultLocale: FormatLocaleDefinition): FormatLocaleObject = js.native
  
  @JSImport("plotly.js", "d3.formatLocale")
  @js.native
  def formatLocale(locale: FormatLocaleDefinition): FormatLocaleObject = js.native
  
  @JSImport("plotly.js", "d3.formatPrefix")
  @js.native
  def formatPrefix(specifier: String, value: Double): js.Function1[/* n */ Double | ValueOf, String] = js.native
  
  @JSImport("plotly.js", "d3.formatSpecifier")
  @js.native
  def formatSpecifier(specifier: String): typings.d3Format.mod.FormatSpecifier_ = js.native
  
  @JSImport("plotly.js", "d3.fsum")
  @js.native
  def fsum[T /* <: Numeric */](values: Iterable[js.UndefOr[T | Null]]): Double = js.native
  @JSImport("plotly.js", "d3.fsum")
  @js.native
  def fsum[T](
    values: Iterable[T],
    accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[Double | Null]]
  ): Double = js.native
  
  @JSImport("plotly.js", "d3.geoAlbers")
  @js.native
  def geoAlbers(): GeoConicProjection = js.native
  
  @JSImport("plotly.js", "d3.geoAlbersUsa")
  @js.native
  def geoAlbersUsa(): GeoProjection_ = js.native
  
  @JSImport("plotly.js", "d3.geoArea")
  @js.native
  def geoArea(`object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]): Double = js.native
  @JSImport("plotly.js", "d3.geoArea")
  @js.native
  def geoArea(`object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]]): Double = js.native
  @JSImport("plotly.js", "d3.geoArea")
  @js.native
  def geoArea(`object`: ExtendedGeometryCollection[GeoGeometryObjects]): Double = js.native
  @JSImport("plotly.js", "d3.geoArea")
  @js.native
  def geoArea(`object`: GeoGeometryObjects): Double = js.native
  
  @JSImport("plotly.js", "d3.geoAzimuthalEqualArea")
  @js.native
  def geoAzimuthalEqualArea(): GeoProjection_ = js.native
  
  @JSImport("plotly.js", "d3.geoAzimuthalEqualAreaRaw")
  @js.native
  def geoAzimuthalEqualAreaRaw(): GeoRawProjection = js.native
  
  @JSImport("plotly.js", "d3.geoAzimuthalEquidistant")
  @js.native
  def geoAzimuthalEquidistant(): GeoProjection_ = js.native
  
  @JSImport("plotly.js", "d3.geoAzimuthalEquidistantRaw")
  @js.native
  def geoAzimuthalEquidistantRaw(): GeoRawProjection = js.native
  
  @JSImport("plotly.js", "d3.geoBounds")
  @js.native
  def geoBounds(`object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]): js.Tuple2[js.Tuple2[Double, Double], js.Tuple2[Double, Double]] = js.native
  @JSImport("plotly.js", "d3.geoBounds")
  @js.native
  def geoBounds(`object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]]): js.Tuple2[js.Tuple2[Double, Double], js.Tuple2[Double, Double]] = js.native
  @JSImport("plotly.js", "d3.geoBounds")
  @js.native
  def geoBounds(`object`: ExtendedGeometryCollection[GeoGeometryObjects]): js.Tuple2[js.Tuple2[Double, Double], js.Tuple2[Double, Double]] = js.native
  @JSImport("plotly.js", "d3.geoBounds")
  @js.native
  def geoBounds(`object`: GeoGeometryObjects): js.Tuple2[js.Tuple2[Double, Double], js.Tuple2[Double, Double]] = js.native
  
  @JSImport("plotly.js", "d3.geoCentroid")
  @js.native
  def geoCentroid(`object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]): js.Tuple2[Double, Double] = js.native
  @JSImport("plotly.js", "d3.geoCentroid")
  @js.native
  def geoCentroid(`object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]]): js.Tuple2[Double, Double] = js.native
  @JSImport("plotly.js", "d3.geoCentroid")
  @js.native
  def geoCentroid(`object`: ExtendedGeometryCollection[GeoGeometryObjects]): js.Tuple2[Double, Double] = js.native
  @JSImport("plotly.js", "d3.geoCentroid")
  @js.native
  def geoCentroid(`object`: GeoGeometryObjects): js.Tuple2[Double, Double] = js.native
  
  @JSImport("plotly.js", "d3.geoCircle")
  @js.native
  def geoCircle(): GeoCircleGenerator[_, _] = js.native
  @JSImport("plotly.js", "d3.geoCircle")
  @js.native
  def geoCircle_Datum[Datum](): GeoCircleGenerator[_, Datum] = js.native
  @JSImport("plotly.js", "d3.geoCircle")
  @js.native
  def geoCircle_ThisDatum[This, Datum](): GeoCircleGenerator[This, Datum] = js.native
  
  @JSImport("plotly.js", "d3.geoClipAntimeridian")
  @js.native
  def geoClipAntimeridian(stream: GeoStream_): GeoStream_ = js.native
  
  @JSImport("plotly.js", "d3.geoClipCircle")
  @js.native
  def geoClipCircle(angle: Double): js.Function1[/* stream */ GeoStream_, GeoStream_] = js.native
  
  @JSImport("plotly.js", "d3.geoClipRectangle")
  @js.native
  def geoClipRectangle(x0: Double, y0: Double, x1: Double, y1: Double): js.Function1[/* stream */ GeoStream_, GeoStream_] = js.native
  
  @JSImport("plotly.js", "d3.geoConicConformal")
  @js.native
  def geoConicConformal(): GeoConicProjection = js.native
  
  @JSImport("plotly.js", "d3.geoConicConformalRaw")
  @js.native
  def geoConicConformalRaw(phi0: Double, phi1: Double): GeoRawProjection = js.native
  
  @JSImport("plotly.js", "d3.geoConicEqualArea")
  @js.native
  def geoConicEqualArea(): GeoConicProjection = js.native
  
  @JSImport("plotly.js", "d3.geoConicEqualAreaRaw")
  @js.native
  def geoConicEqualAreaRaw(phi0: Double, phi1: Double): GeoRawProjection = js.native
  
  @JSImport("plotly.js", "d3.geoConicEquidistant")
  @js.native
  def geoConicEquidistant(): GeoConicProjection = js.native
  
  @JSImport("plotly.js", "d3.geoConicEquidistantRaw")
  @js.native
  def geoConicEquidistantRaw(phi0: Double, phi1: Double): GeoRawProjection = js.native
  
  @JSImport("plotly.js", "d3.geoContains")
  @js.native
  def geoContains(
    `object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]],
    point: js.Tuple2[Double, Double]
  ): Boolean = js.native
  @JSImport("plotly.js", "d3.geoContains")
  @js.native
  def geoContains(
    `object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties],
    point: js.Tuple2[Double, Double]
  ): Boolean = js.native
  @JSImport("plotly.js", "d3.geoContains")
  @js.native
  def geoContains(`object`: ExtendedGeometryCollection[GeoGeometryObjects], point: js.Tuple2[Double, Double]): Boolean = js.native
  @JSImport("plotly.js", "d3.geoContains")
  @js.native
  def geoContains(`object`: GeoGeometryObjects, point: js.Tuple2[Double, Double]): Boolean = js.native
  
  @JSImport("plotly.js", "d3.geoDistance")
  @js.native
  def geoDistance(a: js.Tuple2[Double, Double], b: js.Tuple2[Double, Double]): Double = js.native
  
  @JSImport("plotly.js", "d3.geoEqualEarth")
  @js.native
  def geoEqualEarth(): GeoProjection_ = js.native
  
  @JSImport("plotly.js", "d3.geoEqualEarthRaw")
  @js.native
  def geoEqualEarthRaw(): GeoRawProjection = js.native
  
  @JSImport("plotly.js", "d3.geoEquirectangular")
  @js.native
  def geoEquirectangular(): GeoProjection_ = js.native
  
  @JSImport("plotly.js", "d3.geoEquirectangularRaw")
  @js.native
  def geoEquirectangularRaw(): GeoRawProjection = js.native
  
  @JSImport("plotly.js", "d3.geoGnomonic")
  @js.native
  def geoGnomonic(): GeoProjection_ = js.native
  
  @JSImport("plotly.js", "d3.geoGnomonicRaw")
  @js.native
  def geoGnomonicRaw(): GeoRawProjection = js.native
  
  @JSImport("plotly.js", "d3.geoGraticule")
  @js.native
  def geoGraticule(): GeoGraticuleGenerator = js.native
  
  @JSImport("plotly.js", "d3.geoGraticule10")
  @js.native
  def geoGraticule10(): MultiLineString = js.native
  
  @JSImport("plotly.js", "d3.geoIdentity")
  @js.native
  def geoIdentity(): GeoIdentityTransform = js.native
  
  @JSImport("plotly.js", "d3.geoInterpolate")
  @js.native
  def geoInterpolate(a: js.Tuple2[Double, Double], b: js.Tuple2[Double, Double]): js.Function1[/* t */ Double, js.Tuple2[Double, Double]] = js.native
  
  @JSImport("plotly.js", "d3.geoLength")
  @js.native
  def geoLength(`object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]): Double = js.native
  @JSImport("plotly.js", "d3.geoLength")
  @js.native
  def geoLength(`object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]]): Double = js.native
  @JSImport("plotly.js", "d3.geoLength")
  @js.native
  def geoLength(`object`: ExtendedGeometryCollection[GeoGeometryObjects]): Double = js.native
  @JSImport("plotly.js", "d3.geoLength")
  @js.native
  def geoLength(`object`: GeoGeometryObjects): Double = js.native
  
  @JSImport("plotly.js", "d3.geoMercator")
  @js.native
  def geoMercator(): GeoProjection_ = js.native
  
  @JSImport("plotly.js", "d3.geoMercatorRaw")
  @js.native
  def geoMercatorRaw(): GeoRawProjection = js.native
  
  @JSImport("plotly.js", "d3.geoNaturalEarth1")
  @js.native
  def geoNaturalEarth1(): GeoProjection_ = js.native
  
  @JSImport("plotly.js", "d3.geoNaturalEarth1Raw")
  @js.native
  def geoNaturalEarth1Raw(): GeoRawProjection = js.native
  
  @JSImport("plotly.js", "d3.geoOrthographic")
  @js.native
  def geoOrthographic(): GeoProjection_ = js.native
  
  @JSImport("plotly.js", "d3.geoOrthographicRaw")
  @js.native
  def geoOrthographicRaw(): GeoRawProjection = js.native
  
  @JSImport("plotly.js", "d3.geoPath")
  @js.native
  def geoPath(): GeoPath_[_, GeoPermissibleObjects] = js.native
  @JSImport("plotly.js", "d3.geoPath")
  @js.native
  def geoPath(projection: js.UndefOr[scala.Nothing], context: GeoContext): GeoPath_[_, GeoPermissibleObjects] = js.native
  @JSImport("plotly.js", "d3.geoPath")
  @js.native
  def geoPath(projection: Null, context: GeoContext): GeoPath_[_, GeoPermissibleObjects] = js.native
  @JSImport("plotly.js", "d3.geoPath")
  @js.native
  def geoPath(projection: GeoProjection_): GeoPath_[_, GeoPermissibleObjects] = js.native
  @JSImport("plotly.js", "d3.geoPath")
  @js.native
  def geoPath(projection: GeoProjection_, context: GeoContext): GeoPath_[_, GeoPermissibleObjects] = js.native
  @JSImport("plotly.js", "d3.geoPath")
  @js.native
  def geoPath(projection: GeoStreamWrapper): GeoPath_[_, GeoPermissibleObjects] = js.native
  @JSImport("plotly.js", "d3.geoPath")
  @js.native
  def geoPath(projection: GeoStreamWrapper, context: GeoContext): GeoPath_[_, GeoPermissibleObjects] = js.native
  @JSImport("plotly.js", "d3.geoPath")
  @js.native
  def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](): GeoPath_[_, DatumObject] = js.native
  @JSImport("plotly.js", "d3.geoPath")
  @js.native
  def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: js.UndefOr[scala.Nothing], context: GeoContext): GeoPath_[_, DatumObject] = js.native
  @JSImport("plotly.js", "d3.geoPath")
  @js.native
  def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: Null, context: GeoContext): GeoPath_[_, DatumObject] = js.native
  @JSImport("plotly.js", "d3.geoPath")
  @js.native
  def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: GeoProjection_): GeoPath_[_, DatumObject] = js.native
  @JSImport("plotly.js", "d3.geoPath")
  @js.native
  def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: GeoProjection_, context: GeoContext): GeoPath_[_, DatumObject] = js.native
  @JSImport("plotly.js", "d3.geoPath")
  @js.native
  def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: GeoStreamWrapper): GeoPath_[_, DatumObject] = js.native
  @JSImport("plotly.js", "d3.geoPath")
  @js.native
  def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: GeoStreamWrapper, context: GeoContext): GeoPath_[_, DatumObject] = js.native
  @JSImport("plotly.js", "d3.geoPath")
  @js.native
  def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](): GeoPath_[This, DatumObject] = js.native
  @JSImport("plotly.js", "d3.geoPath")
  @js.native
  def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: js.UndefOr[scala.Nothing], context: GeoContext): GeoPath_[This, DatumObject] = js.native
  @JSImport("plotly.js", "d3.geoPath")
  @js.native
  def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: Null, context: GeoContext): GeoPath_[This, DatumObject] = js.native
  @JSImport("plotly.js", "d3.geoPath")
  @js.native
  def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: GeoProjection_): GeoPath_[This, DatumObject] = js.native
  @JSImport("plotly.js", "d3.geoPath")
  @js.native
  def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: GeoProjection_, context: GeoContext): GeoPath_[This, DatumObject] = js.native
  @JSImport("plotly.js", "d3.geoPath")
  @js.native
  def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: GeoStreamWrapper): GeoPath_[This, DatumObject] = js.native
  @JSImport("plotly.js", "d3.geoPath")
  @js.native
  def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: GeoStreamWrapper, context: GeoContext): GeoPath_[This, DatumObject] = js.native
  
  @JSImport("plotly.js", "d3.geoProjection")
  @js.native
  def geoProjection(project: GeoRawProjection): GeoProjection_ = js.native
  
  @JSImport("plotly.js", "d3.geoProjectionMutator")
  @js.native
  def geoProjectionMutator(factory: js.Function1[/* repeated */ js.Any, GeoRawProjection]): js.Function0[GeoProjection_] = js.native
  
  @JSImport("plotly.js", "d3.geoRotation")
  @js.native
  def geoRotation(angles: js.Tuple2[Double, Double]): GeoRotation_ = js.native
  @JSImport("plotly.js", "d3.geoRotation")
  @js.native
  def geoRotation(angles: js.Tuple3[Double, Double, Double]): GeoRotation_ = js.native
  
  @JSImport("plotly.js", "d3.geoStereographic")
  @js.native
  def geoStereographic(): GeoProjection_ = js.native
  
  @JSImport("plotly.js", "d3.geoStereographicRaw")
  @js.native
  def geoStereographicRaw(): GeoRawProjection = js.native
  
  @JSImport("plotly.js", "d3.geoStream")
  @js.native
  def geoStream(
    `object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]],
    stream: GeoStream_
  ): Unit = js.native
  @JSImport("plotly.js", "d3.geoStream")
  @js.native
  def geoStream(`object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties], stream: GeoStream_): Unit = js.native
  @JSImport("plotly.js", "d3.geoStream")
  @js.native
  def geoStream(`object`: ExtendedGeometryCollection[GeoGeometryObjects], stream: GeoStream_): Unit = js.native
  @JSImport("plotly.js", "d3.geoStream")
  @js.native
  def geoStream(`object`: GeoGeometryObjects, stream: GeoStream_): Unit = js.native
  
  @JSImport("plotly.js", "d3.geoTransform")
  @js.native
  def geoTransform[T /* <: GeoTransformPrototype */](methods: T): `0`[T] = js.native
  
  @JSImport("plotly.js", "d3.geoTransverseMercator")
  @js.native
  def geoTransverseMercator(): GeoProjection_ = js.native
  
  @JSImport("plotly.js", "d3.geoTransverseMercatorRaw")
  @js.native
  def geoTransverseMercatorRaw(): GeoRawProjection = js.native
  
  /**
    * Constructs a new CIELAB color with the specified l value and a = b = 0.
    *
    * @param l Lightness typically in the range [0, 100].
    * @param opacity Optional opacity value, defaults to 1.
    */
  @JSImport("plotly.js", "d3.gray")
  @js.native
  def gray(l: Double): LabColor = js.native
  /**
    * Constructs a new CIELAB color with the specified l value and a = b = 0.
    *
    * @param l Lightness typically in the range [0, 100].
    * @param opacity Optional opacity value, defaults to 1.
    */
  @JSImport("plotly.js", "d3.gray")
  @js.native
  def gray(l: Double, opacity: Double): LabColor = js.native
  
  @JSImport("plotly.js", "d3.greatest")
  @js.native
  def greatest[T](iterable: Iterable[T]): js.UndefOr[T] = js.native
  @JSImport("plotly.js", "d3.greatest")
  @js.native
  def greatest[T](iterable: Iterable[T], comparator: js.Function2[/* a */ T, /* b */ T, Double]): js.UndefOr[T] = js.native
  @JSImport("plotly.js", "d3.greatest")
  @js.native
  def greatest[T, U](iterable: Iterable[T], accessor: js.Function1[/* a */ T, U]): js.UndefOr[T] = js.native
  
  @JSImport("plotly.js", "d3.greatestIndex")
  @js.native
  def greatestIndex[T](iterable: Iterable[T]): js.UndefOr[Double] = js.native
  @JSImport("plotly.js", "d3.greatestIndex")
  @js.native
  def greatestIndex[T](iterable: Iterable[T], comparator: js.Function2[/* a */ T, /* b */ T, Double]): js.UndefOr[Double] = js.native
  @JSImport("plotly.js", "d3.greatestIndex")
  @js.native
  def greatestIndex[T, U](iterable: Iterable[T], accessor: js.Function1[/* a */ T, U]): js.UndefOr[Double] = js.native
  
  @JSImport("plotly.js", "d3.group")
  @js.native
  def group[TObject, TKey](iterable: Iterable[TObject], key: js.Function1[/* value */ TObject, TKey]): Map[TKey, js.Array[TObject]] = js.native
  @JSImport("plotly.js", "d3.group")
  @js.native
  def group[TObject, TKey1, TKey2](
    iterable: Iterable[TObject],
    key1: js.Function1[/* value */ TObject, TKey1],
    key2: js.Function1[/* value */ TObject, TKey2]
  ): Map[TKey1, Map[TKey2, js.Array[TObject]]] = js.native
  @JSImport("plotly.js", "d3.group")
  @js.native
  def group[TObject, TKey1, TKey2, TKey3](
    iterable: Iterable[TObject],
    key1: js.Function1[/* value */ TObject, TKey1],
    key2: js.Function1[/* value */ TObject, TKey2],
    key3: js.Function1[/* value */ TObject, TKey3]
  ): Map[TKey1, Map[TKey2, Map[TKey3, js.Array[TObject]]]] = js.native
  
  @JSImport("plotly.js", "d3.groups")
  @js.native
  def groups[TObject, TKey](iterable: Iterable[TObject], key: js.Function1[/* value */ TObject, TKey]): js.Array[js.Tuple2[TKey, js.Array[TObject]]] = js.native
  @JSImport("plotly.js", "d3.groups")
  @js.native
  def groups[TObject, TKey1, TKey2](
    iterable: Iterable[TObject],
    key1: js.Function1[/* value */ TObject, TKey1],
    key2: js.Function1[/* value */ TObject, TKey2]
  ): js.Array[js.Tuple2[TKey1, js.Array[js.Tuple2[TKey2, js.Array[TObject]]]]] = js.native
  @JSImport("plotly.js", "d3.groups")
  @js.native
  def groups[TObject, TKey1, TKey2, TKey3](
    iterable: Iterable[TObject],
    key1: js.Function1[/* value */ TObject, TKey1],
    key2: js.Function1[/* value */ TObject, TKey2],
    key3: js.Function1[/* value */ TObject, TKey3]
  ): js.Array[
    js.Tuple2[TKey1, js.Array[js.Tuple2[TKey2, js.Array[js.Tuple2[TKey3, js.Array[TObject]]]]]]
  ] = js.native
  
  @JSImport("plotly.js", "d3.hcl")
  @js.native
  val hcl: HCLColorFactory = js.native
  @JSImport("plotly.js", "d3.hcl")
  @js.native
  def hcl(color: ColorCommonInstance): HCLColor = js.native
  /**
    * Converts the provided color instance and returns an HCL color.
    * The color instance is converted to the RGB color space using color.rgb and then converted to HCL.
    * (Colors already in the HCL color space skip the conversion to RGB,
    * and colors in the Lab color space are converted directly to HCL.)
    *
    * @param color A permissible color space instance.
    */
  @JSImport("plotly.js", "d3.hcl")
  @js.native
  def hcl(color: ColorSpaceObject): HCLColor = js.native
  /**
    * Parses the specified CSS Color Module Level 3 specifier string, returning an HCL color.
    * If the specifier was not valid, null is returned.
    *
    * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
    */
  @JSImport("plotly.js", "d3.hcl")
  @js.native
  def hcl(cssColorSpecifier: String): HCLColor = js.native
  /**
    * Constructs a new HCL color based on the specified channel values and opacity.
    *
    * @param h Hue channel value typically in [0, 360).
    * @param c Chroma channel value typically in [0, 230].
    * @param l Luminance channel value typically in the range [0, 100].
    * @param opacity Optional opacity value, defaults to 1.
    */
  @JSImport("plotly.js", "d3.hcl")
  @js.native
  def hcl(h: Double, c: Double, l: Double): HCLColor = js.native
  @JSImport("plotly.js", "d3.hcl")
  @js.native
  def hcl(h: Double, c: Double, l: Double, opacity: Double): HCLColor = js.native
  
  @JSImport("plotly.js", "d3.hierarchy")
  @js.native
  def hierarchy[Datum](data: Datum): HierarchyNode[Datum] = js.native
  @JSImport("plotly.js", "d3.hierarchy")
  @js.native
  def hierarchy[Datum](data: Datum, children: js.Function1[/* d */ Datum, js.UndefOr[Iterable[Datum] | Null]]): HierarchyNode[Datum] = js.native
  
  @JSImport("plotly.js", "d3.histogram")
  @js.native
  def histogram(): HistogramGeneratorNumber[Double, Double] = js.native
  
  @JSImport("plotly.js", "d3.hsl")
  @js.native
  val hsl: HSLColorFactory = js.native
  @JSImport("plotly.js", "d3.hsl")
  @js.native
  def hsl(color: ColorCommonInstance): HSLColor = js.native
  /**
    * Converts the provided color instance and returns an HSL color.
    * The color instance is converted to the RGB color space using color.rgb and then converted to HSL.
    * (Colors already in the HSL color space skip the conversion to RGB.)
    *
    * @param color A permissible color space instance.
    */
  @JSImport("plotly.js", "d3.hsl")
  @js.native
  def hsl(color: ColorSpaceObject): HSLColor = js.native
  /**
    * Parses the specified CSS Color Module Level 3 specifier string, returning an HSL color.
    * If the specifier was not valid, null is returned.
    *
    * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
    */
  @JSImport("plotly.js", "d3.hsl")
  @js.native
  def hsl(cssColorSpecifier: String): HSLColor = js.native
  /**
    * Constructs a new HSL color based on the specified channel values and opacity.
    *
    * @param h Hue channel value.
    * @param s Saturation channel value.
    * @param l Lightness channel value.
    * @param opacity Optional opacity value, defaults to 1.
    */
  @JSImport("plotly.js", "d3.hsl")
  @js.native
  def hsl(h: Double, s: Double, l: Double): HSLColor = js.native
  @JSImport("plotly.js", "d3.hsl")
  @js.native
  def hsl(h: Double, s: Double, l: Double, opacity: Double): HSLColor = js.native
  
  @JSImport("plotly.js", "d3.html")
  @js.native
  def html(url: String): js.Promise[Document] = js.native
  @JSImport("plotly.js", "d3.html")
  @js.native
  def html(url: String, init: RequestInit): js.Promise[Document] = js.native
  
  @JSImport("plotly.js", "d3.image")
  @js.native
  def image(url: String): js.Promise[HTMLImageElement] = js.native
  @JSImport("plotly.js", "d3.image")
  @js.native
  def image(url: String, init: PartialHTMLImageElement): js.Promise[HTMLImageElement] = js.native
  
  @JSImport("plotly.js", "d3.index")
  @js.native
  def index[TObject, TKey](iterable: Iterable[TObject], key: js.Function1[/* value */ TObject, TKey]): Map[TKey, TObject] = js.native
  @JSImport("plotly.js", "d3.index")
  @js.native
  def index[TObject, TKey1, TKey2](
    iterable: Iterable[TObject],
    key1: js.Function1[/* value */ TObject, TKey1],
    key2: js.Function1[/* value */ TObject, TKey2]
  ): Map[TKey1, Map[TKey2, TObject]] = js.native
  @JSImport("plotly.js", "d3.index")
  @js.native
  def index[TObject, TKey1, TKey2, TKey3](
    iterable: Iterable[TObject],
    key1: js.Function1[/* value */ TObject, TKey1],
    key2: js.Function1[/* value */ TObject, TKey2],
    key3: js.Function1[/* value */ TObject, TKey3]
  ): Map[TKey1, Map[TKey2, Map[TKey3, TObject]]] = js.native
  
  @JSImport("plotly.js", "d3.indexes")
  @js.native
  def indexes[TObject, TKey](iterable: Iterable[TObject], key: js.Function1[/* value */ TObject, TKey]): js.Array[js.Tuple2[TKey, TObject]] = js.native
  @JSImport("plotly.js", "d3.indexes")
  @js.native
  def indexes[TObject, TKey1, TKey2](
    iterable: Iterable[TObject],
    key1: js.Function1[/* value */ TObject, TKey1],
    key2: js.Function1[/* value */ TObject, TKey2]
  ): js.Array[js.Tuple2[TKey1, js.Array[js.Tuple2[TKey2, TObject]]]] = js.native
  @JSImport("plotly.js", "d3.indexes")
  @js.native
  def indexes[TObject, TKey1, TKey2, TKey3](
    iterable: Iterable[TObject],
    key1: js.Function1[/* value */ TObject, TKey1],
    key2: js.Function1[/* value */ TObject, TKey2],
    key3: js.Function1[/* value */ TObject, TKey3]
  ): js.Array[
    js.Tuple2[TKey1, js.Array[js.Tuple2[TKey2, js.Array[js.Tuple2[TKey3, TObject]]]]]
  ] = js.native
  
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: js.Any, b: Boolean): js.Function1[/* t */ Double, Boolean] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: js.Any, b: Null): js.Function1[/* t */ Double, Null] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: js.Array[Double], b: DataView): js.Function1[/* t */ Double, DataView] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: js.Array[Double], b: Float32Array): js.Function1[/* t */ Double, Float32Array] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: js.Array[Double], b: Float64Array): js.Function1[/* t */ Double, Float64Array] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: js.Array[Double], b: Int16Array): js.Function1[/* t */ Double, Int16Array] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: js.Array[Double], b: Int32Array): js.Function1[/* t */ Double, Int32Array] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: js.Array[Double], b: Int8Array): js.Function1[/* t */ Double, Int8Array] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: js.Array[Double], b: Uint16Array): js.Function1[/* t */ Double, Uint16Array] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: js.Array[Double], b: Uint32Array): js.Function1[/* t */ Double, Uint32Array] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: js.Array[Double], b: Uint8Array): js.Function1[/* t */ Double, Uint8Array] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: js.Array[Double], b: Uint8ClampedArray): js.Function1[/* t */ Double, Uint8ClampedArray] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: Double, b: Double): js.Function1[/* t */ Double, Double] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: Double, b: typings.d3Interpolate.anon.ValueOf): js.Function1[/* t */ Double, Double] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: ToString, b: String): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: typings.d3Interpolate.anon.ValueOf, b: Double): js.Function1[/* t */ Double, Double] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: typings.d3Interpolate.anon.ValueOf, b: typings.d3Interpolate.anon.ValueOf): js.Function1[/* t */ Double, Double] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: NumberArray, b: DataView): js.Function1[/* t */ Double, DataView] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: NumberArray, b: Float32Array): js.Function1[/* t */ Double, Float32Array] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: NumberArray, b: Float64Array): js.Function1[/* t */ Double, Float64Array] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: NumberArray, b: Int16Array): js.Function1[/* t */ Double, Int16Array] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: NumberArray, b: Int32Array): js.Function1[/* t */ Double, Int32Array] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: NumberArray, b: Int8Array): js.Function1[/* t */ Double, Int8Array] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: NumberArray, b: Uint16Array): js.Function1[/* t */ Double, Uint16Array] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: NumberArray, b: Uint32Array): js.Function1[/* t */ Double, Uint32Array] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: NumberArray, b: Uint8Array): js.Function1[/* t */ Double, Uint8Array] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: NumberArray, b: Uint8ClampedArray): js.Function1[/* t */ Double, Uint8ClampedArray] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate(a: Date, b: Date): js.Function1[/* t */ Double, Date] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate[U /* <: js.Object */](a: js.Any, b: U): js.Function1[/* t */ Double, U] = js.native
  @JSImport("plotly.js", "d3.interpolate")
  @js.native
  def interpolate[U /* <: js.Array[_] */](a: js.Array[_], b: U): js.Function1[/* t */ Double, U] = js.native
  
  @JSImport("plotly.js", "d3.interpolateArray")
  @js.native
  def interpolateArray(a: js.Array[Double], b: DataView): js.Function1[/* t */ Double, DataView] = js.native
  @JSImport("plotly.js", "d3.interpolateArray")
  @js.native
  def interpolateArray(a: js.Array[Double], b: Float32Array): js.Function1[/* t */ Double, Float32Array] = js.native
  @JSImport("plotly.js", "d3.interpolateArray")
  @js.native
  def interpolateArray(a: js.Array[Double], b: Float64Array): js.Function1[/* t */ Double, Float64Array] = js.native
  @JSImport("plotly.js", "d3.interpolateArray")
  @js.native
  def interpolateArray(a: js.Array[Double], b: Int16Array): js.Function1[/* t */ Double, Int16Array] = js.native
  @JSImport("plotly.js", "d3.interpolateArray")
  @js.native
  def interpolateArray(a: js.Array[Double], b: Int32Array): js.Function1[/* t */ Double, Int32Array] = js.native
  @JSImport("plotly.js", "d3.interpolateArray")
  @js.native
  def interpolateArray(a: js.Array[Double], b: Int8Array): js.Function1[/* t */ Double, Int8Array] = js.native
  @JSImport("plotly.js", "d3.interpolateArray")
  @js.native
  def interpolateArray(a: js.Array[Double], b: Uint16Array): js.Function1[/* t */ Double, Uint16Array] = js.native
  @JSImport("plotly.js", "d3.interpolateArray")
  @js.native
  def interpolateArray(a: js.Array[Double], b: Uint32Array): js.Function1[/* t */ Double, Uint32Array] = js.native
  @JSImport("plotly.js", "d3.interpolateArray")
  @js.native
  def interpolateArray(a: js.Array[Double], b: Uint8Array): js.Function1[/* t */ Double, Uint8Array] = js.native
  @JSImport("plotly.js", "d3.interpolateArray")
  @js.native
  def interpolateArray(a: js.Array[Double], b: Uint8ClampedArray): js.Function1[/* t */ Double, Uint8ClampedArray] = js.native
  @JSImport("plotly.js", "d3.interpolateArray")
  @js.native
  def interpolateArray(a: NumberArray, b: DataView): js.Function1[/* t */ Double, DataView] = js.native
  @JSImport("plotly.js", "d3.interpolateArray")
  @js.native
  def interpolateArray(a: NumberArray, b: Float32Array): js.Function1[/* t */ Double, Float32Array] = js.native
  @JSImport("plotly.js", "d3.interpolateArray")
  @js.native
  def interpolateArray(a: NumberArray, b: Float64Array): js.Function1[/* t */ Double, Float64Array] = js.native
  @JSImport("plotly.js", "d3.interpolateArray")
  @js.native
  def interpolateArray(a: NumberArray, b: Int16Array): js.Function1[/* t */ Double, Int16Array] = js.native
  @JSImport("plotly.js", "d3.interpolateArray")
  @js.native
  def interpolateArray(a: NumberArray, b: Int32Array): js.Function1[/* t */ Double, Int32Array] = js.native
  @JSImport("plotly.js", "d3.interpolateArray")
  @js.native
  def interpolateArray(a: NumberArray, b: Int8Array): js.Function1[/* t */ Double, Int8Array] = js.native
  @JSImport("plotly.js", "d3.interpolateArray")
  @js.native
  def interpolateArray(a: NumberArray, b: Uint16Array): js.Function1[/* t */ Double, Uint16Array] = js.native
  @JSImport("plotly.js", "d3.interpolateArray")
  @js.native
  def interpolateArray(a: NumberArray, b: Uint32Array): js.Function1[/* t */ Double, Uint32Array] = js.native
  @JSImport("plotly.js", "d3.interpolateArray")
  @js.native
  def interpolateArray(a: NumberArray, b: Uint8Array): js.Function1[/* t */ Double, Uint8Array] = js.native
  @JSImport("plotly.js", "d3.interpolateArray")
  @js.native
  def interpolateArray(a: NumberArray, b: Uint8ClampedArray): js.Function1[/* t */ Double, Uint8ClampedArray] = js.native
  @JSImport("plotly.js", "d3.interpolateArray")
  @js.native
  def interpolateArray[A /* <: js.Array[_] */](a: js.Array[_], b: A): ArrayInterpolator[A] = js.native
  
  @JSImport("plotly.js", "d3.interpolateBasis")
  @js.native
  def interpolateBasis(splineNodes: js.Array[Double]): js.Function1[/* t */ Double, Double] = js.native
  
  @JSImport("plotly.js", "d3.interpolateBasisClosed")
  @js.native
  def interpolateBasisClosed(splineNodes: js.Array[Double]): js.Function1[/* t */ Double, Double] = js.native
  
  @JSImport("plotly.js", "d3.interpolateBlues")
  @js.native
  def interpolateBlues(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateBrBG")
  @js.native
  def interpolateBrBG(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateBuGn")
  @js.native
  def interpolateBuGn(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateBuPu")
  @js.native
  def interpolateBuPu(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateCividis")
  @js.native
  def interpolateCividis(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateCool")
  @js.native
  def interpolateCool(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateCubehelix")
  @js.native
  val interpolateCubehelix: ColorGammaInterpolationFactory = js.native
  @JSImport("plotly.js", "d3.interpolateCubehelix")
  @js.native
  def interpolateCubehelix(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateCubehelix")
  @js.native
  def interpolateCubehelix(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateCubehelix")
  @js.native
  def interpolateCubehelix(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateCubehelix")
  @js.native
  def interpolateCubehelix(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  
  @JSImport("plotly.js", "d3.interpolateCubehelixDefault")
  @js.native
  def interpolateCubehelixDefault(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateCubehelixLong")
  @js.native
  val interpolateCubehelixLong: ColorGammaInterpolationFactory = js.native
  @JSImport("plotly.js", "d3.interpolateCubehelixLong")
  @js.native
  def interpolateCubehelixLong(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateCubehelixLong")
  @js.native
  def interpolateCubehelixLong(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateCubehelixLong")
  @js.native
  def interpolateCubehelixLong(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateCubehelixLong")
  @js.native
  def interpolateCubehelixLong(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  
  @JSImport("plotly.js", "d3.interpolateDate")
  @js.native
  def interpolateDate(a: Date, b: Date): js.Function1[/* t */ Double, Date] = js.native
  
  @JSImport("plotly.js", "d3.interpolateDiscrete")
  @js.native
  def interpolateDiscrete[T](values: js.Array[T]): js.Function1[/* t */ Double, T] = js.native
  
  @JSImport("plotly.js", "d3.interpolateGnBu")
  @js.native
  def interpolateGnBu(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateGreens")
  @js.native
  def interpolateGreens(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateGreys")
  @js.native
  def interpolateGreys(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateHcl")
  @js.native
  def interpolateHcl(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateHcl")
  @js.native
  def interpolateHcl(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateHcl")
  @js.native
  def interpolateHcl(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateHcl")
  @js.native
  def interpolateHcl(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  
  @JSImport("plotly.js", "d3.interpolateHclLong")
  @js.native
  def interpolateHclLong(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateHclLong")
  @js.native
  def interpolateHclLong(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateHclLong")
  @js.native
  def interpolateHclLong(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateHclLong")
  @js.native
  def interpolateHclLong(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  
  @JSImport("plotly.js", "d3.interpolateHsl")
  @js.native
  def interpolateHsl(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateHsl")
  @js.native
  def interpolateHsl(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateHsl")
  @js.native
  def interpolateHsl(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateHsl")
  @js.native
  def interpolateHsl(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  
  @JSImport("plotly.js", "d3.interpolateHslLong")
  @js.native
  def interpolateHslLong(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateHslLong")
  @js.native
  def interpolateHslLong(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateHslLong")
  @js.native
  def interpolateHslLong(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateHslLong")
  @js.native
  def interpolateHslLong(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  
  @JSImport("plotly.js", "d3.interpolateHue")
  @js.native
  def interpolateHue(a: Double, b: Double): js.Function1[/* t */ Double, Double] = js.native
  
  @JSImport("plotly.js", "d3.interpolateInferno")
  @js.native
  def interpolateInferno(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateLab")
  @js.native
  def interpolateLab(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateLab")
  @js.native
  def interpolateLab(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateLab")
  @js.native
  def interpolateLab(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateLab")
  @js.native
  def interpolateLab(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  
  @JSImport("plotly.js", "d3.interpolateMagma")
  @js.native
  def interpolateMagma(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateNumber")
  @js.native
  def interpolateNumber(a: Double, b: Double): js.Function1[/* t */ Double, Double] = js.native
  @JSImport("plotly.js", "d3.interpolateNumber")
  @js.native
  def interpolateNumber(a: Double, b: typings.d3Interpolate.anon.ValueOf): js.Function1[/* t */ Double, Double] = js.native
  @JSImport("plotly.js", "d3.interpolateNumber")
  @js.native
  def interpolateNumber(a: typings.d3Interpolate.anon.ValueOf, b: Double): js.Function1[/* t */ Double, Double] = js.native
  @JSImport("plotly.js", "d3.interpolateNumber")
  @js.native
  def interpolateNumber(a: typings.d3Interpolate.anon.ValueOf, b: typings.d3Interpolate.anon.ValueOf): js.Function1[/* t */ Double, Double] = js.native
  
  @JSImport("plotly.js", "d3.interpolateNumberArray")
  @js.native
  def interpolateNumberArray(a: js.Array[Double], b: js.Array[Double]): js.Function1[/* t */ Double, js.Array[Double]] = js.native
  @JSImport("plotly.js", "d3.interpolateNumberArray")
  @js.native
  def interpolateNumberArray(a: js.Array[Double], b: DataView): js.Function1[/* t */ Double, DataView] = js.native
  @JSImport("plotly.js", "d3.interpolateNumberArray")
  @js.native
  def interpolateNumberArray(a: js.Array[Double], b: Float32Array): js.Function1[/* t */ Double, Float32Array] = js.native
  @JSImport("plotly.js", "d3.interpolateNumberArray")
  @js.native
  def interpolateNumberArray(a: js.Array[Double], b: Float64Array): js.Function1[/* t */ Double, Float64Array] = js.native
  @JSImport("plotly.js", "d3.interpolateNumberArray")
  @js.native
  def interpolateNumberArray(a: js.Array[Double], b: Int16Array): js.Function1[/* t */ Double, Int16Array] = js.native
  @JSImport("plotly.js", "d3.interpolateNumberArray")
  @js.native
  def interpolateNumberArray(a: js.Array[Double], b: Int32Array): js.Function1[/* t */ Double, Int32Array] = js.native
  @JSImport("plotly.js", "d3.interpolateNumberArray")
  @js.native
  def interpolateNumberArray(a: js.Array[Double], b: Int8Array): js.Function1[/* t */ Double, Int8Array] = js.native
  @JSImport("plotly.js", "d3.interpolateNumberArray")
  @js.native
  def interpolateNumberArray(a: js.Array[Double], b: Uint16Array): js.Function1[/* t */ Double, Uint16Array] = js.native
  @JSImport("plotly.js", "d3.interpolateNumberArray")
  @js.native
  def interpolateNumberArray(a: js.Array[Double], b: Uint32Array): js.Function1[/* t */ Double, Uint32Array] = js.native
  @JSImport("plotly.js", "d3.interpolateNumberArray")
  @js.native
  def interpolateNumberArray(a: js.Array[Double], b: Uint8Array): js.Function1[/* t */ Double, Uint8Array] = js.native
  @JSImport("plotly.js", "d3.interpolateNumberArray")
  @js.native
  def interpolateNumberArray(a: js.Array[Double], b: Uint8ClampedArray): js.Function1[/* t */ Double, Uint8ClampedArray] = js.native
  @JSImport("plotly.js", "d3.interpolateNumberArray")
  @js.native
  def interpolateNumberArray(a: NumberArray, b: js.Array[Double]): js.Function1[/* t */ Double, js.Array[Double]] = js.native
  @JSImport("plotly.js", "d3.interpolateNumberArray")
  @js.native
  def interpolateNumberArray(a: NumberArray, b: DataView): js.Function1[/* t */ Double, DataView] = js.native
  @JSImport("plotly.js", "d3.interpolateNumberArray")
  @js.native
  def interpolateNumberArray(a: NumberArray, b: Float32Array): js.Function1[/* t */ Double, Float32Array] = js.native
  @JSImport("plotly.js", "d3.interpolateNumberArray")
  @js.native
  def interpolateNumberArray(a: NumberArray, b: Float64Array): js.Function1[/* t */ Double, Float64Array] = js.native
  @JSImport("plotly.js", "d3.interpolateNumberArray")
  @js.native
  def interpolateNumberArray(a: NumberArray, b: Int16Array): js.Function1[/* t */ Double, Int16Array] = js.native
  @JSImport("plotly.js", "d3.interpolateNumberArray")
  @js.native
  def interpolateNumberArray(a: NumberArray, b: Int32Array): js.Function1[/* t */ Double, Int32Array] = js.native
  @JSImport("plotly.js", "d3.interpolateNumberArray")
  @js.native
  def interpolateNumberArray(a: NumberArray, b: Int8Array): js.Function1[/* t */ Double, Int8Array] = js.native
  @JSImport("plotly.js", "d3.interpolateNumberArray")
  @js.native
  def interpolateNumberArray(a: NumberArray, b: Uint16Array): js.Function1[/* t */ Double, Uint16Array] = js.native
  @JSImport("plotly.js", "d3.interpolateNumberArray")
  @js.native
  def interpolateNumberArray(a: NumberArray, b: Uint32Array): js.Function1[/* t */ Double, Uint32Array] = js.native
  @JSImport("plotly.js", "d3.interpolateNumberArray")
  @js.native
  def interpolateNumberArray(a: NumberArray, b: Uint8Array): js.Function1[/* t */ Double, Uint8Array] = js.native
  @JSImport("plotly.js", "d3.interpolateNumberArray")
  @js.native
  def interpolateNumberArray(a: NumberArray, b: Uint8ClampedArray): js.Function1[/* t */ Double, Uint8ClampedArray] = js.native
  
  @JSImport("plotly.js", "d3.interpolateObject")
  @js.native
  def interpolateObject[U /* <: js.Object */](a: js.Any, b: U): js.Function1[/* t */ Double, U] = js.native
  
  @JSImport("plotly.js", "d3.interpolateOrRd")
  @js.native
  def interpolateOrRd(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateOranges")
  @js.native
  def interpolateOranges(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolatePRGn")
  @js.native
  def interpolatePRGn(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolatePiYG")
  @js.native
  def interpolatePiYG(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolatePlasma")
  @js.native
  def interpolatePlasma(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolatePuBu")
  @js.native
  def interpolatePuBu(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolatePuBuGn")
  @js.native
  def interpolatePuBuGn(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolatePuOr")
  @js.native
  def interpolatePuOr(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolatePuRd")
  @js.native
  def interpolatePuRd(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolatePurples")
  @js.native
  def interpolatePurples(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateRainbow")
  @js.native
  def interpolateRainbow(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateRdBu")
  @js.native
  def interpolateRdBu(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateRdGy")
  @js.native
  def interpolateRdGy(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateRdPu")
  @js.native
  def interpolateRdPu(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateRdYlBu")
  @js.native
  def interpolateRdYlBu(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateRdYlGn")
  @js.native
  def interpolateRdYlGn(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateReds")
  @js.native
  def interpolateReds(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateRgb")
  @js.native
  val interpolateRgb: ColorGammaInterpolationFactory = js.native
  @JSImport("plotly.js", "d3.interpolateRgb")
  @js.native
  def interpolateRgb(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateRgb")
  @js.native
  def interpolateRgb(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateRgb")
  @js.native
  def interpolateRgb(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateRgb")
  @js.native
  def interpolateRgb(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  
  @JSImport("plotly.js", "d3.interpolateRgbBasis")
  @js.native
  def interpolateRgbBasis(colors: js.Array[String | ColorCommonInstance]): js.Function1[/* t */ Double, String] = js.native
  
  @JSImport("plotly.js", "d3.interpolateRgbBasisClosed")
  @js.native
  def interpolateRgbBasisClosed(colors: js.Array[String | ColorCommonInstance]): js.Function1[/* t */ Double, String] = js.native
  
  @JSImport("plotly.js", "d3.interpolateRound")
  @js.native
  def interpolateRound(a: Double, b: Double): js.Function1[/* t */ Double, Double] = js.native
  @JSImport("plotly.js", "d3.interpolateRound")
  @js.native
  def interpolateRound(a: Double, b: typings.d3Interpolate.anon.ValueOf): js.Function1[/* t */ Double, Double] = js.native
  @JSImport("plotly.js", "d3.interpolateRound")
  @js.native
  def interpolateRound(a: typings.d3Interpolate.anon.ValueOf, b: Double): js.Function1[/* t */ Double, Double] = js.native
  @JSImport("plotly.js", "d3.interpolateRound")
  @js.native
  def interpolateRound(a: typings.d3Interpolate.anon.ValueOf, b: typings.d3Interpolate.anon.ValueOf): js.Function1[/* t */ Double, Double] = js.native
  
  @JSImport("plotly.js", "d3.interpolateSinebow")
  @js.native
  def interpolateSinebow(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateSpectral")
  @js.native
  def interpolateSpectral(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateString")
  @js.native
  def interpolateString(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateString")
  @js.native
  def interpolateString(a: String, b: ToString): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateString")
  @js.native
  def interpolateString(a: ToString, b: String): js.Function1[/* t */ Double, String] = js.native
  @JSImport("plotly.js", "d3.interpolateString")
  @js.native
  def interpolateString(a: ToString, b: ToString): js.Function1[/* t */ Double, String] = js.native
  
  @JSImport("plotly.js", "d3.interpolateTransformCss")
  @js.native
  def interpolateTransformCss(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  
  @JSImport("plotly.js", "d3.interpolateTransformSvg")
  @js.native
  def interpolateTransformSvg(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  
  @JSImport("plotly.js", "d3.interpolateTurbo")
  @js.native
  def interpolateTurbo(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateViridis")
  @js.native
  def interpolateViridis(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateWarm")
  @js.native
  def interpolateWarm(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateYlGn")
  @js.native
  def interpolateYlGn(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateYlGnBu")
  @js.native
  def interpolateYlGnBu(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateYlOrBr")
  @js.native
  def interpolateYlOrBr(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateYlOrRd")
  @js.native
  def interpolateYlOrRd(t: Double): String = js.native
  
  @JSImport("plotly.js", "d3.interpolateZoom")
  @js.native
  def interpolateZoom(a: ZoomView, b: ZoomView): ZoomInterpolator = js.native
  
  @JSImport("plotly.js", "d3.interrupt")
  @js.native
  def interrupt(node: BaseType): Unit = js.native
  @JSImport("plotly.js", "d3.interrupt")
  @js.native
  def interrupt(node: BaseType, name: String): Unit = js.native
  
  @JSImport("plotly.js", "d3.intersection")
  @js.native
  def intersection[T](iterables: Iterable[T]*): Set[T] = js.native
  
  @JSImport("plotly.js", "d3.interval")
  @js.native
  def interval(callback: js.Function1[/* elapsed */ Double, Unit]): Timer_ = js.native
  @JSImport("plotly.js", "d3.interval")
  @js.native
  def interval(callback: js.Function1[/* elapsed */ Double, Unit], delay: js.UndefOr[scala.Nothing], time: Double): Timer_ = js.native
  @JSImport("plotly.js", "d3.interval")
  @js.native
  def interval(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double): Timer_ = js.native
  @JSImport("plotly.js", "d3.interval")
  @js.native
  def interval(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double, time: Double): Timer_ = js.native
  
  @JSImport("plotly.js", "d3.isoFormat")
  @js.native
  def isoFormat(date: Date): String = js.native
  
  @JSImport("plotly.js", "d3.isoParse")
  @js.native
  def isoParse(dateString: String): Date | Null = js.native
  
  @JSImport("plotly.js", "d3.json")
  @js.native
  def json[ParsedJSONObject /* <: js.Any */](url: String): js.Promise[js.UndefOr[ParsedJSONObject]] = js.native
  @JSImport("plotly.js", "d3.json")
  @js.native
  def json[ParsedJSONObject /* <: js.Any */](url: String, init: RequestInit): js.Promise[js.UndefOr[ParsedJSONObject]] = js.native
  
  @JSImport("plotly.js", "d3.lab")
  @js.native
  val lab: LabColorFactory = js.native
  @JSImport("plotly.js", "d3.lab")
  @js.native
  def lab(color: ColorCommonInstance): LabColor = js.native
  /**
    * Converts the provided color instance and returns a Lab color.
    * The color instance is converted to the RGB color space using color.rgb and then converted to CIELAB.
    * (Colors already in the Lab color space skip the conversion to RGB,
    * and colors in the HCL color space are converted directly to CIELAB.)
    *
    * @param color A permissible color space instance.
    */
  @JSImport("plotly.js", "d3.lab")
  @js.native
  def lab(color: ColorSpaceObject): LabColor = js.native
  /**
    * Parses the specified CSS Color Module Level 3 specifier string, returning a Lab color.
    * If the specifier was not valid, null is returned.
    *
    * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
    */
  @JSImport("plotly.js", "d3.lab")
  @js.native
  def lab(cssColorSpecifier: String): LabColor = js.native
  /**
    * Constructs a new CIELAB color based on the specified channel values and opacity.
    *
    * @param l Lightness typically in the range [0, 100].
    * @param a Position between red/magenta and green typically in [-160, +160].
    * @param b Position between yellow and blue typically in [-160, +160].
    * @param opacity Optional opacity value, defaults to 1.
    */
  @JSImport("plotly.js", "d3.lab")
  @js.native
  def lab(l: Double, a: Double, b: Double): LabColor = js.native
  @JSImport("plotly.js", "d3.lab")
  @js.native
  def lab(l: Double, a: Double, b: Double, opacity: Double): LabColor = js.native
  
  @JSImport("plotly.js", "d3.lch")
  @js.native
  def lch(color: ColorCommonInstance): HCLColor = js.native
  /**
    * Converts the provided color instance and returns an HCL color.
    * The color instance is converted to the RGB color space using color.rgb and then converted to HCL.
    * (Colors already in the HCL color space skip the conversion to RGB,
    * and colors in the Lab color space are converted directly to HCL.)
    *
    * @param color A permissible color space instance.
    */
  @JSImport("plotly.js", "d3.lch")
  @js.native
  def lch(color: ColorSpaceObject): HCLColor = js.native
  /**
    * Parses the specified CSS Color Module Level 3 specifier string, returning an HCL color.
    * If the specifier was not valid, null is returned.
    *
    * @param cssColorSpecifier A CSS color Module Level 3 specifier string.
    */
  @JSImport("plotly.js", "d3.lch")
  @js.native
  def lch(cssColorSpecifier: String): HCLColor = js.native
  /**
    * Constructs a new HCL color based on the specified channel values and opacity.
    *
    * @param l Luminance channel value typically in the range [0, 100].
    * @param c Chroma channel value typically in [0, 230].
    * @param h Hue channel value typically in [0, 360).
    * @param opacity Optional opacity value, defaults to 1.
    */
  @JSImport("plotly.js", "d3.lch")
  @js.native
  def lch(l: Double, c: Double, h: Double): HCLColor = js.native
  @JSImport("plotly.js", "d3.lch")
  @js.native
  def lch(l: Double, c: Double, h: Double, opacity: Double): HCLColor = js.native
  
  @JSImport("plotly.js", "d3.least")
  @js.native
  def least[T](iterable: Iterable[T]): js.UndefOr[T] = js.native
  @JSImport("plotly.js", "d3.least")
  @js.native
  def least[T](iterable: Iterable[T], comparator: js.Function2[/* a */ T, /* b */ T, Double]): js.UndefOr[T] = js.native
  @JSImport("plotly.js", "d3.least")
  @js.native
  def least[T, U](iterable: Iterable[T], accessor: js.Function1[/* a */ T, U]): js.UndefOr[T] = js.native
  
  @JSImport("plotly.js", "d3.leastIndex")
  @js.native
  def leastIndex[T](iterable: Iterable[T]): js.UndefOr[Double] = js.native
  @JSImport("plotly.js", "d3.leastIndex")
  @js.native
  def leastIndex[T](iterable: Iterable[T], comparator: js.Function2[/* a */ T, /* b */ T, Double]): js.UndefOr[Double] = js.native
  @JSImport("plotly.js", "d3.leastIndex")
  @js.native
  def leastIndex[T, U](iterable: Iterable[T], accessor: js.Function1[/* a */ T, U]): js.UndefOr[Double] = js.native
  
  @JSImport("plotly.js", "d3.line")
  @js.native
  def line[Datum](): Line_[Datum] = js.native
  @JSImport("plotly.js", "d3.line")
  @js.native
  def line[Datum](
    x: js.UndefOr[scala.Nothing],
    y: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
  ): Line_[Datum] = js.native
  @JSImport("plotly.js", "d3.line")
  @js.native
  def line[Datum](x: js.UndefOr[scala.Nothing], y: Double): Line_[Datum] = js.native
  @JSImport("plotly.js", "d3.line")
  @js.native
  def line[Datum](x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]): Line_[Datum] = js.native
  @JSImport("plotly.js", "d3.line")
  @js.native
  def line[Datum](
    x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
  ): Line_[Datum] = js.native
  @JSImport("plotly.js", "d3.line")
  @js.native
  def line[Datum](x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double], y: Double): Line_[Datum] = js.native
  @JSImport("plotly.js", "d3.line")
  @js.native
  def line[Datum](x: Double): Line_[Datum] = js.native
  @JSImport("plotly.js", "d3.line")
  @js.native
  def line[Datum](x: Double, y: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]): Line_[Datum] = js.native
  @JSImport("plotly.js", "d3.line")
  @js.native
  def line[Datum](x: Double, y: Double): Line_[Datum] = js.native
  
  @JSImport("plotly.js", "d3.lineRadial")
  @js.native
  def lineRadial(): LineRadial_[js.Tuple2[Double, Double]] = js.native
  @JSImport("plotly.js", "d3.lineRadial")
  @js.native
  def lineRadial_Datum[Datum](): LineRadial_[Datum] = js.native
  
  @JSImport("plotly.js", "d3.linkHorizontal")
  @js.native
  def linkHorizontal(): Link[_, DefaultLinkObject, js.Tuple2[Double, Double]] = js.native
  @JSImport("plotly.js", "d3.linkHorizontal")
  @js.native
  def linkHorizontal_LinkDatumNodeDatum[LinkDatum, NodeDatum](): Link[_, LinkDatum, NodeDatum] = js.native
  @JSImport("plotly.js", "d3.linkHorizontal")
  @js.native
  def linkHorizontal_ThisLinkDatumNodeDatum[This, LinkDatum, NodeDatum](): Link[This, LinkDatum, NodeDatum] = js.native
  
  @JSImport("plotly.js", "d3.linkRadial")
  @js.native
  def linkRadial(): LinkRadial_[_, DefaultLinkObject, js.Tuple2[Double, Double]] = js.native
  @JSImport("plotly.js", "d3.linkRadial")
  @js.native
  def linkRadial_LinkDatumNodeDatum[LinkDatum, NodeDatum](): LinkRadial_[_, LinkDatum, NodeDatum] = js.native
  @JSImport("plotly.js", "d3.linkRadial")
  @js.native
  def linkRadial_ThisLinkDatumNodeDatum[This, LinkDatum, NodeDatum](): LinkRadial_[This, LinkDatum, NodeDatum] = js.native
  
  @JSImport("plotly.js", "d3.linkVertical")
  @js.native
  def linkVertical(): Link[_, DefaultLinkObject, js.Tuple2[Double, Double]] = js.native
  @JSImport("plotly.js", "d3.linkVertical")
  @js.native
  def linkVertical_LinkDatumNodeDatum[LinkDatum, NodeDatum](): Link[_, LinkDatum, NodeDatum] = js.native
  @JSImport("plotly.js", "d3.linkVertical")
  @js.native
  def linkVertical_ThisLinkDatumNodeDatum[This, LinkDatum, NodeDatum](): Link[This, LinkDatum, NodeDatum] = js.native
  
  @JSImport("plotly.js", "d3.local")
  @js.native
  def local[T](): Local_[T] = js.native
  
  @JSImport("plotly.js", "d3.map")
  @js.native
  def map[T, U](
    iterable: Iterable[T],
    mapper: js.Function3[/* value */ T, /* index */ Double, /* iterable */ Iterable[T], U]
  ): js.Array[U] = js.native
  
  @JSImport("plotly.js", "d3.matcher")
  @js.native
  def matcher(selector: String): js.ThisFunction0[/* this */ BaseType, Boolean] = js.native
  
  @JSImport("plotly.js", "d3.max")
  @js.native
  def max(iterable: Iterable[String]): js.UndefOr[String] = js.native
  @JSImport("plotly.js", "d3.max")
  @js.native
  def max[T](
    iterable: Iterable[T],
    accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[String | Null]]
  ): js.UndefOr[String] = js.native
  
  @JSImport("plotly.js", "d3.maxIndex")
  @js.native
  def maxIndex[T](iterable: Iterable[T]): Double = js.native
  @JSImport("plotly.js", "d3.maxIndex")
  @js.native
  def maxIndex[TDatum, U](
    iterable: Iterable[TDatum],
    accessor: js.Function3[
      /* datum */ TDatum, 
      /* index */ Double, 
      /* array */ Iterable[TDatum], 
      js.UndefOr[U | Null]
    ]
  ): Double = js.native
  
  @JSImport("plotly.js", "d3.max")
  @js.native
  def max_TU_Numeric[T, U /* <: Numeric */](
    iterable: Iterable[T],
    accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[U | Null]]
  ): js.UndefOr[U] = js.native
  @JSImport("plotly.js", "d3.max")
  @js.native
  def max_T_Numeric[T /* <: Numeric */](iterable: Iterable[T]): js.UndefOr[T] = js.native
  
  @JSImport("plotly.js", "d3.mean")
  @js.native
  def mean[T /* <: Numeric */](iterable: Iterable[js.UndefOr[T | Null]]): js.UndefOr[Double] = js.native
  @JSImport("plotly.js", "d3.mean")
  @js.native
  def mean[T](
    iterable: Iterable[T],
    accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[Double | Null]]
  ): js.UndefOr[Double] = js.native
  
  @JSImport("plotly.js", "d3.median")
  @js.native
  def median[T /* <: Numeric */](iterable: Iterable[js.UndefOr[T | Null]]): js.UndefOr[Double] = js.native
  @JSImport("plotly.js", "d3.median")
  @js.native
  def median[T](
    iterable: Iterable[T],
    accessor: js.Function3[/* element */ T, /* i */ Double, /* array */ Iterable[T], js.UndefOr[Double | Null]]
  ): js.UndefOr[Double] = js.native
  
  @JSImport("plotly.js", "d3.merge")
  @js.native
  def merge[T](iterables: Iterable[Iterable[T]]): js.Array[T] = js.native
  
  @JSImport("plotly.js", "d3.min")
  @js.native
  def min(iterable: Iterable[String]): js.UndefOr[String] = js.native
  @JSImport("plotly.js", "d3.min")
  @js.native
  def min[T](
    iterable: Iterable[T],
    accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[String | Null]]
  ): js.UndefOr[String] = js.native
  
  @JSImport("plotly.js", "d3.minIndex")
  @js.native
  def minIndex[T](iterable: Iterable[T]): Double = js.native
  @JSImport("plotly.js", "d3.minIndex")
  @js.native
  def minIndex[TDatum, U](
    iterable: Iterable[TDatum],
    accessor: js.Function3[
      /* datum */ TDatum, 
      /* index */ Double, 
      /* array */ Iterable[TDatum], 
      js.UndefOr[U | Null]
    ]
  ): Double = js.native
  
  @JSImport("plotly.js", "d3.min")
  @js.native
  def min_TU_Numeric[T, U /* <: Numeric */](
    iterable: Iterable[T],
    accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[U | Null]]
  ): js.UndefOr[U] = js.native
  @JSImport("plotly.js", "d3.min")
  @js.native
  def min_T_Numeric[T /* <: Numeric */](iterable: Iterable[T]): js.UndefOr[T] = js.native
  
  @JSImport("plotly.js", "d3.namespace")
  @js.native
  def namespace(prefixedLocal: String): NamespaceLocalObject | String = js.native
  
  @JSImport("plotly.js", "d3.namespaces")
  @js.native
  val namespaces: NamespaceMap = js.native
  
  @JSImport("plotly.js", "d3.nice")
  @js.native
  def nice(start: Double, stop: Double, count: Double): js.Tuple2[Double, Double] = js.native
  
  @JSImport("plotly.js", "d3.now")
  @js.native
  def now(): Double = js.native
  
  @JSImport("plotly.js", "d3.pack")
  @js.native
  def pack[Datum](): PackLayout[Datum] = js.native
  
  @JSImport("plotly.js", "d3.packEnclose")
  @js.native
  def packEnclose[Datum /* <: PackCircle */](circles: js.Array[Datum]): PackCircle = js.native
  
  @JSImport("plotly.js", "d3.packSiblings")
  @js.native
  def packSiblings[Datum /* <: PackRadius */](circles: js.Array[Datum]): js.Array[Datum with PackCircle] = js.native
  
  @JSImport("plotly.js", "d3.pairs")
  @js.native
  def pairs[T](iterable: Iterable[T]): js.Array[js.Tuple2[T, T]] = js.native
  @JSImport("plotly.js", "d3.pairs")
  @js.native
  def pairs[T, U](iterable: Iterable[T], reducer: js.Function2[/* a */ T, /* b */ T, U]): js.Array[U] = js.native
  
  @JSImport("plotly.js", "d3.partition")
  @js.native
  def partition[Datum](): PartitionLayout[Datum] = js.native
  
  @JSImport("plotly.js", "d3.path")
  @js.native
  def path(): Path_ = js.native
  
  @JSImport("plotly.js", "d3.permute")
  @js.native
  def permute[T](source: NumberDictionary[T], keys: Iterable[Double]): js.Array[T] = js.native
  @JSImport("plotly.js", "d3.permute")
  @js.native
  def permute[T, K /* <: /* keyof T */ String */](source: T, keys: Iterable[K]): js.Array[
    /* import warning: importer.ImportType#apply Failed type conversion: T[K] */ js.Any
  ] = js.native
  
  @JSImport("plotly.js", "d3.pie")
  @js.native
  def pie(): Pie_[_, Double | typings.d3Shape.anon.ValueOf] = js.native
  @JSImport("plotly.js", "d3.pie")
  @js.native
  def pie_Datum[Datum](): Pie_[_, Datum] = js.native
  @JSImport("plotly.js", "d3.pie")
  @js.native
  def pie_ThisDatum[This, Datum](): Pie_[This, Datum] = js.native
  
  @JSImport("plotly.js", "d3.piecewise")
  @js.native
  def piecewise(
    interpolate: js.Function2[/* a */ ZoomView, /* b */ ZoomView, ZoomInterpolator],
    values: js.Array[ZoomView]
  ): ZoomInterpolator = js.native
  @JSImport("plotly.js", "d3.piecewise")
  @js.native
  def piecewise(values: js.Array[ZoomView]): ZoomInterpolator = js.native
  @JSImport("plotly.js", "d3.piecewise")
  @js.native
  def piecewise_A_ArrayWildcard_ArrayInterpolator[A /* <: js.Array[_] */](
    interpolate: js.Function2[/* a */ js.Array[_], /* b */ A, ArrayInterpolator[A]],
    values: js.Array[A]
  ): ArrayInterpolator[A] = js.native
  @JSImport("plotly.js", "d3.piecewise")
  @js.native
  def piecewise_A_ArrayWildcard_ArrayInterpolator[A /* <: js.Array[_] */](values: js.Array[A]): ArrayInterpolator[A] = js.native
  @JSImport("plotly.js", "d3.piecewise")
  @js.native
  def piecewise_TDataInterpolator_Function1[TData, Interpolator](interpolate: js.Function2[/* a */ TData, /* b */ TData, Interpolator], values: js.Array[TData]): js.Function1[/* t */ Double, _] = js.native
  @JSImport("plotly.js", "d3.piecewise")
  @js.native
  def piecewise_TData_Function1[TData](values: js.Array[TData]): js.Function1[/* t */ Double, _] = js.native
  
  @JSImport("plotly.js", "d3.pointRadial")
  @js.native
  def pointRadial(angle: Double, radius: Double): js.Tuple2[Double, Double] = js.native
  
  @JSImport("plotly.js", "d3.pointer")
  @js.native
  def pointer(event: js.Any): js.Tuple2[Double, Double] = js.native
  @JSImport("plotly.js", "d3.pointer")
  @js.native
  def pointer(event: js.Any, target: js.Any): js.Tuple2[Double, Double] = js.native
  
  @JSImport("plotly.js", "d3.pointers")
  @js.native
  def pointers(event: js.Any): js.Array[js.Tuple2[Double, Double]] = js.native
  @JSImport("plotly.js", "d3.pointers")
  @js.native
  def pointers(event: js.Any, target: js.Any): js.Array[js.Tuple2[Double, Double]] = js.native
  
  @JSImport("plotly.js", "d3.polygonArea")
  @js.native
  def polygonArea(polygon: js.Array[js.Tuple2[Double, Double]]): Double = js.native
  
  @JSImport("plotly.js", "d3.polygonCentroid")
  @js.native
  def polygonCentroid(polygon: js.Array[js.Tuple2[Double, Double]]): js.Tuple2[Double, Double] = js.native
  
  @JSImport("plotly.js", "d3.polygonContains")
  @js.native
  def polygonContains(polygon: js.Array[js.Tuple2[Double, Double]], point: js.Tuple2[Double, Double]): Boolean = js.native
  
  @JSImport("plotly.js", "d3.polygonHull")
  @js.native
  def polygonHull(points: js.Array[js.Tuple2[Double, Double]]): (js.Array[js.Tuple2[Double, Double]]) | Null = js.native
  
  @JSImport("plotly.js", "d3.polygonLength")
  @js.native
  def polygonLength(polygon: js.Array[js.Tuple2[Double, Double]]): Double = js.native
  
  @JSImport("plotly.js", "d3.precisionFixed")
  @js.native
  def precisionFixed(step: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.precisionPrefix")
  @js.native
  def precisionPrefix(step: Double, value: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.precisionRound")
  @js.native
  def precisionRound(step: Double, max: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.quadtree")
  @js.native
  def quadtree[T](): Quadtree_[T] = js.native
  @JSImport("plotly.js", "d3.quadtree")
  @js.native
  def quadtree[T](data: js.Array[T]): Quadtree_[T] = js.native
  @JSImport("plotly.js", "d3.quadtree")
  @js.native
  def quadtree[T](data: js.Array[T], x: js.UndefOr[scala.Nothing], y: js.Function1[/* d */ T, Double]): Quadtree_[T] = js.native
  @JSImport("plotly.js", "d3.quadtree")
  @js.native
  def quadtree[T](data: js.Array[T], x: js.Function1[/* d */ T, Double]): Quadtree_[T] = js.native
  @JSImport("plotly.js", "d3.quadtree")
  @js.native
  def quadtree[T](data: js.Array[T], x: js.Function1[/* d */ T, Double], y: js.Function1[/* d */ T, Double]): Quadtree_[T] = js.native
  
  @JSImport("plotly.js", "d3.quantile")
  @js.native
  def quantile[T /* <: Numeric */](iterable: Iterable[js.UndefOr[T | Null]], p: Double): js.UndefOr[Double] = js.native
  @JSImport("plotly.js", "d3.quantile")
  @js.native
  def quantile[T](
    iterable: Iterable[T],
    p: Double,
    accessor: js.Function3[/* element */ T, /* i */ Double, /* array */ Iterable[T], js.UndefOr[Double | Null]]
  ): js.UndefOr[Double] = js.native
  
  @JSImport("plotly.js", "d3.quantileSorted")
  @js.native
  def quantileSorted[T /* <: Numeric */](array: js.Array[js.UndefOr[T | Null]], p: Double): js.UndefOr[Double] = js.native
  @JSImport("plotly.js", "d3.quantileSorted")
  @js.native
  def quantileSorted[T](
    array: js.Array[T],
    p: Double,
    accessor: js.Function3[/* element */ T, /* i */ Double, /* array */ js.Array[T], js.UndefOr[Double | Null]]
  ): js.UndefOr[Double] = js.native
  
  @JSImport("plotly.js", "d3.quantize")
  @js.native
  def quantize[T](interpolator: js.Function1[/* t */ Double, T], n: Double): js.Array[T] = js.native
  
  @JSImport("plotly.js", "d3.quickselect")
  @js.native
  def quickselect[T](array: ArrayLike[T], k: Double): js.Array[T] = js.native
  @JSImport("plotly.js", "d3.quickselect")
  @js.native
  def quickselect[T](array: ArrayLike[T], k: Double, left: Double): js.Array[T] = js.native
  @JSImport("plotly.js", "d3.quickselect")
  @js.native
  def quickselect[T](array: ArrayLike[T], k: Double, left: Double, right: Double): js.Array[T] = js.native
  @JSImport("plotly.js", "d3.quickselect")
  @js.native
  def quickselect[T](
    array: ArrayLike[T],
    k: Double,
    left: Double,
    right: Double,
    compare: js.Function2[/* a */ js.UndefOr[Primitive], /* b */ js.UndefOr[Primitive], Double]
  ): js.Array[T] = js.native
  
  @JSImport("plotly.js", "d3.radialArea")
  @js.native
  def radialArea(): RadialArea_[js.Tuple2[Double, Double]] = js.native
  @JSImport("plotly.js", "d3.radialArea")
  @js.native
  def radialArea_Datum[Datum](): RadialArea_[Datum] = js.native
  
  @JSImport("plotly.js", "d3.radialLine")
  @js.native
  def radialLine(): RadialLine_[js.Tuple2[Double, Double]] = js.native
  @JSImport("plotly.js", "d3.radialLine")
  @js.native
  def radialLine_Datum[Datum](): RadialLine_[Datum] = js.native
  
  @JSImport("plotly.js", "d3.randomBates")
  @js.native
  val randomBates: RandomBates_ = js.native
  /**
    * Returns a function for generating random numbers with a Bates distribution with n independent variables.
    * The case of fractional n is handled as with d3.randomIrwinHall, and d3.randomBates(0) is equivalent to d3.randomUniform().
    *
    * @param n Number of independent random variables to use.
    */
  @JSImport("plotly.js", "d3.randomBates")
  @js.native
  def randomBates(n: Double): js.Function0[Double] = js.native
  
  @JSImport("plotly.js", "d3.randomBernoulli")
  @js.native
  val randomBernoulli: RandomBernoulli_ = js.native
  /**
    * Returns a function for generating either 1 or 0 according to a Bernoulli distribution with 1 being returned with success probability p and 0 with failure probability q = 1 - p.
    * The value p is in the range [0, 1].
    *
    * @param p p
    */
  @JSImport("plotly.js", "d3.randomBernoulli")
  @js.native
  def randomBernoulli(p: Double): js.Function0[Double] = js.native
  
  @JSImport("plotly.js", "d3.randomBeta")
  @js.native
  val randomBeta: RandomBeta_ = js.native
  /**
    * Returns a function for generating random numbers with a beta distribution with alpha and beta shape parameters, which must both be positive.
    *
    * @param alpha Shape parameter
    * @param beta Shape paramter
    */
  @JSImport("plotly.js", "d3.randomBeta")
  @js.native
  def randomBeta(alpha: Double, beta: Double): js.Function0[Double] = js.native
  
  @JSImport("plotly.js", "d3.randomBinomial")
  @js.native
  val randomBinomial: RandomBinomial_ = js.native
  /**
    * Returns a function for generating numbers with a geometric distribution with success probability p.
    * The value p is in the range (0, 1].
    *
    * @param p Success probability
    */
  @JSImport("plotly.js", "d3.randomBinomial")
  @js.native
  def randomBinomial(p: Double): js.Function0[Double] = js.native
  
  /**
    * Returns a function for generating random numbers with a Cauchy distribution.
    * a and b have the same meanings and default values as in d3.randomWeibull.
    *
    * @param a Location parameter
    * @param b Scale parameter
    */
  @JSImport("plotly.js", "d3.randomCauchy")
  @js.native
  def randomCauchy(): js.Function0[Double] = js.native
  @JSImport("plotly.js", "d3.randomCauchy")
  @js.native
  def randomCauchy(a: js.UndefOr[scala.Nothing], b: Double): js.Function0[Double] = js.native
  @JSImport("plotly.js", "d3.randomCauchy")
  @js.native
  def randomCauchy(a: Double): js.Function0[Double] = js.native
  @JSImport("plotly.js", "d3.randomCauchy")
  @js.native
  def randomCauchy(a: Double, b: Double): js.Function0[Double] = js.native
  @JSImport("plotly.js", "d3.randomCauchy")
  @js.native
  val randomCauchy_Fd3: RandomCauchy_ = js.native
  
  @JSImport("plotly.js", "d3.randomExponential")
  @js.native
  val randomExponential: RandomExponential_ = js.native
  /**
    * Returns a function for generating random numbers with an exponential distribution with the rate lambda;
    * equivalent to time between events in a Poisson process with a mean of 1 / lambda.
    *
    * @param lambda Expected time between events.
    */
  @JSImport("plotly.js", "d3.randomExponential")
  @js.native
  def randomExponential(lambda: Double): js.Function0[Double] = js.native
  
  @JSImport("plotly.js", "d3.randomGamma")
  @js.native
  val randomGamma: RandomGamma_ = js.native
  /**
    * Returns a function for generating random numbers with a gamma distribution with k the shape parameter and theta the scale parameter.
    * The value k must be a positive value; if theta is not specified, it defaults to 1.
    *
    * @param k Shape parameter
    * @param theta Scale paramter
    */
  @JSImport("plotly.js", "d3.randomGamma")
  @js.native
  def randomGamma(k: Double): js.Function0[Double] = js.native
  @JSImport("plotly.js", "d3.randomGamma")
  @js.native
  def randomGamma(k: Double, theta: Double): js.Function0[Double] = js.native
  
  @JSImport("plotly.js", "d3.randomGeometric")
  @js.native
  val randomGeometric: RandomGeometric_ = js.native
  /**
    * Returns a function for generating numbers with a geometric distribution with success probability p.
    * The value p is in the range [0, 1].
    *
    * @param p Success probability
    */
  @JSImport("plotly.js", "d3.randomGeometric")
  @js.native
  def randomGeometric(p: Double): js.Function0[Double] = js.native
  
  @JSImport("plotly.js", "d3.randomInt")
  @js.native
  val randomInt: RandomInt_ = js.native
  /**
    * Returns a function for generating random integers with a uniform distribution.
    * The minimum allowed value of a returned number is ⌊min⌋ (inclusive), and the maximum is ⌊max - 1⌋ (inclusive)
    * Min defaults to 0.
    *
    * @param max The maximum allowed value of a returned number.
    */
  @JSImport("plotly.js", "d3.randomInt")
  @js.native
  def randomInt(max: Double): js.Function0[Double] = js.native
  /**
    * Returns a function for generating random integers with a uniform distribution.
    * The minimum allowed value of a returned number is ⌊min⌋ (inclusive), and the maximum is ⌊max - 1⌋ (inclusive)
    *
    * @param min The minimum allowed value of a returned number.
    * @param max The maximum allowed value of a returned number.
    */
  // tslint:disable-next-line:unified-signatures
  @JSImport("plotly.js", "d3.randomInt")
  @js.native
  def randomInt(min: Double, max: Double): js.Function0[Double] = js.native
  
  @JSImport("plotly.js", "d3.randomIrwinHall")
  @js.native
  val randomIrwinHall: RandomIrwinHall_ = js.native
  /**
    * Returns a function for generating random numbers with an Irwin–Hall distribution with n independent variables.
    * If the fractional part of n is non-zero, this is treated as adding d3.randomUniform() times that fractional part to the integral part.
    *
    * @param n Number of independent random variables to use.
    */
  @JSImport("plotly.js", "d3.randomIrwinHall")
  @js.native
  def randomIrwinHall(n: Double): js.Function0[Double] = js.native
  
  @JSImport("plotly.js", "d3.randomLcg")
  @js.native
  def randomLcg(): js.Function0[Double] = js.native
  @JSImport("plotly.js", "d3.randomLcg")
  @js.native
  def randomLcg(seed: Double): js.Function0[Double] = js.native
  
  /**
    * Returns a function for generating random numbers with a log-normal distribution. The expected value of the random variable’s natural logarithm is mu,
    * with the given standard deviation sigma. If mu is not specified, it defaults to 0; if sigma is not specified, it defaults to 1.
    *
    * @param mu Expected value, defaults to 0.
    * @param sigma Standard deviation, defaults to 1.
    */
  @JSImport("plotly.js", "d3.randomLogNormal")
  @js.native
  def randomLogNormal(): js.Function0[Double] = js.native
  @JSImport("plotly.js", "d3.randomLogNormal")
  @js.native
  def randomLogNormal(mu: js.UndefOr[scala.Nothing], sigma: Double): js.Function0[Double] = js.native
  @JSImport("plotly.js", "d3.randomLogNormal")
  @js.native
  def randomLogNormal(mu: Double): js.Function0[Double] = js.native
  @JSImport("plotly.js", "d3.randomLogNormal")
  @js.native
  def randomLogNormal(mu: Double, sigma: Double): js.Function0[Double] = js.native
  @JSImport("plotly.js", "d3.randomLogNormal")
  @js.native
  val randomLogNormal_Fd3: RandomLogNormal_ = js.native
  
  /**
    * Returns a function for generating random numbers with a logistic distribution.
    * a and b have the same meanings and default values as in d3.randomWeibull.
    *
    * @param a Location parameter
    * @param b Scale parameter
    */
  @JSImport("plotly.js", "d3.randomLogistic")
  @js.native
  def randomLogistic(): js.Function0[Double] = js.native
  @JSImport("plotly.js", "d3.randomLogistic")
  @js.native
  def randomLogistic(a: js.UndefOr[scala.Nothing], b: Double): js.Function0[Double] = js.native
  @JSImport("plotly.js", "d3.randomLogistic")
  @js.native
  def randomLogistic(a: Double): js.Function0[Double] = js.native
  @JSImport("plotly.js", "d3.randomLogistic")
  @js.native
  def randomLogistic(a: Double, b: Double): js.Function0[Double] = js.native
  @JSImport("plotly.js", "d3.randomLogistic")
  @js.native
  val randomLogistic_Fd3: RandomLogistic_ = js.native
  
  /**
    * Returns a function for generating random numbers with a normal (Gaussian) distribution.
    * The expected value of the generated numbers is mu, with the given standard deviation sigma.
    * If mu is not specified, it defaults to 0; if sigma is not specified, it defaults to 1.
    *
    * @param mu Expected value, defaults to 0.
    * @param sigma Standard deviation, defaults to 1.
    */
  @JSImport("plotly.js", "d3.randomNormal")
  @js.native
  def randomNormal(): js.Function0[Double] = js.native
  @JSImport("plotly.js", "d3.randomNormal")
  @js.native
  def randomNormal(mu: js.UndefOr[scala.Nothing], sigma: Double): js.Function0[Double] = js.native
  @JSImport("plotly.js", "d3.randomNormal")
  @js.native
  def randomNormal(mu: Double): js.Function0[Double] = js.native
  @JSImport("plotly.js", "d3.randomNormal")
  @js.native
  def randomNormal(mu: Double, sigma: Double): js.Function0[Double] = js.native
  @JSImport("plotly.js", "d3.randomNormal")
  @js.native
  val randomNormal_Fd3: RandomNormal_ = js.native
  
  @JSImport("plotly.js", "d3.randomPareto")
  @js.native
  val randomPareto: RandomPareto_ = js.native
  /**
    * Returns a function for generating random numbers with a Pareto distribution with the shape alpha.
    * The value alpha must be a positive value.
    *
    * @param alpha alpha
    */
  @JSImport("plotly.js", "d3.randomPareto")
  @js.native
  def randomPareto(alpha: Double): js.Function0[Double] = js.native
  
  @JSImport("plotly.js", "d3.randomPoisson")
  @js.native
  val randomPoisson: RandomPoisson_ = js.native
  /**
    * Returns a function for generating random numbers with a Poisson distribution with mean lambda.
    *
    * @param lambda Mean
    */
  @JSImport("plotly.js", "d3.randomPoisson")
  @js.native
  def randomPoisson(lambda: Double): js.Function0[Double] = js.native
  
  /**
    * Returns a function for generating random numbers with a uniform distribution.
    * The minimum allowed value of a returned number is min (inclusive), and the maximum is max (exclusive).
    * Min defaults to 0; if max is not specified, it defaults to 1.
    *
    * @param max The maximum allowed value of a returned number, defaults to 1.
    */
  @JSImport("plotly.js", "d3.randomUniform")
  @js.native
  def randomUniform(): js.Function0[Double] = js.native
  @JSImport("plotly.js", "d3.randomUniform")
  @js.native
  def randomUniform(max: Double): js.Function0[Double] = js.native
  /**
    * Returns a function for generating random numbers with a uniform distribution.
    * The minimum allowed value of a returned number is min (inclusive), and the maximum is max (exclusive).
    *
    * @param min The minimum allowed value of a returned number.
    * @param max The maximum allowed value of a returned number.
    */
  // tslint:disable-next-line:unified-signatures
  @JSImport("plotly.js", "d3.randomUniform")
  @js.native
  def randomUniform(min: Double, max: Double): js.Function0[Double] = js.native
  @JSImport("plotly.js", "d3.randomUniform")
  @js.native
  val randomUniform_Fd3: RandomUniform_ = js.native
  
  @JSImport("plotly.js", "d3.randomWeibull")
  @js.native
  val randomWeibull: RandomWeibull_ = js.native
  /**
    * Returns a function for generating random numbers with one of the generalized extreme value distributions, depending on k:
    * If k is positive, the Weibull distribution with shape parameter k
    * If k is zero, the Gumbel distribution
    * If k is negative, the Fréchet distribution with shape parameter −k
    * In all three cases, a is the location parameter and b is the scale parameter.
    * If a is not specified, it defaults to 0; if b is not specified, it defaults to 1.
    *
    * @param k Shape parameter
    * @param a Location parameter
    * @param b Scale parameter
    */
  @JSImport("plotly.js", "d3.randomWeibull")
  @js.native
  def randomWeibull(k: Double): js.Function0[Double] = js.native
  @JSImport("plotly.js", "d3.randomWeibull")
  @js.native
  def randomWeibull(k: Double, a: js.UndefOr[scala.Nothing], b: Double): js.Function0[Double] = js.native
  @JSImport("plotly.js", "d3.randomWeibull")
  @js.native
  def randomWeibull(k: Double, a: Double): js.Function0[Double] = js.native
  @JSImport("plotly.js", "d3.randomWeibull")
  @js.native
  def randomWeibull(k: Double, a: Double, b: Double): js.Function0[Double] = js.native
  
  @JSImport("plotly.js", "d3.range")
  @js.native
  def range(start: Double, stop: Double): js.Array[Double] = js.native
  @JSImport("plotly.js", "d3.range")
  @js.native
  def range(start: Double, stop: Double, step: Double): js.Array[Double] = js.native
  @JSImport("plotly.js", "d3.range")
  @js.native
  def range(stop: Double): js.Array[Double] = js.native
  
  @JSImport("plotly.js", "d3.reduce")
  @js.native
  def reduce[T](
    iterable: Iterable[T],
    reducer: js.Function4[
      /* previousValue */ T, 
      /* currentValue */ T, 
      /* currentIndex */ Double, 
      /* iterable */ Iterable[T], 
      T
    ]
  ): T = js.native
  @JSImport("plotly.js", "d3.reduce")
  @js.native
  def reduce[T](
    iterable: Iterable[T],
    reducer: js.Function4[
      /* previousValue */ T, 
      /* currentValue */ T, 
      /* currentIndex */ Double, 
      /* iterable */ Iterable[T], 
      T
    ],
    initialValue: T
  ): T = js.native
  @JSImport("plotly.js", "d3.reduce")
  @js.native
  def reduce_TU_U[T, U](
    iterable: Iterable[T],
    reducer: js.Function4[
      /* previousValue */ U, 
      /* currentValue */ T, 
      /* currentIndex */ Double, 
      /* iterable */ Iterable[T], 
      U
    ],
    initialValue: U
  ): U = js.native
  
  @JSImport("plotly.js", "d3.reverse")
  @js.native
  def reverse[T](iterable: Iterable[T]): js.Array[T] = js.native
  
  @JSImport("plotly.js", "d3.rgb")
  @js.native
  val rgb: RGBColorFactory = js.native
  @JSImport("plotly.js", "d3.rgb")
  @js.native
  def rgb(color: ColorCommonInstance): RGBColor = js.native
  /**
    * Converts the provided color instance and returns an RGB color. The color instance is converted to the RGB color space using color.rgb.
    * Note that unlike color.rgb this method always returns a new instance, even if color is already an RGB color.
    *
    * @param color A permissible color space instance.
    */
  @JSImport("plotly.js", "d3.rgb")
  @js.native
  def rgb(color: ColorSpaceObject): RGBColor = js.native
  /**
    * Parses the specified CSS Color Module Level 3 specifier string, returning an RGB color.
    * If the specifier was not valid, null is returned.
    *
    * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
    */
  @JSImport("plotly.js", "d3.rgb")
  @js.native
  def rgb(cssColorSpecifier: String): RGBColor = js.native
  /**
    * Constructs a new RGB color based on the specified channel values and opacity.
    *
    * @param r Red channel value.
    * @param g Green channel value.
    * @param b Blue channel value.
    * @param opacity Optional opacity value, defaults to 1.
    */
  @JSImport("plotly.js", "d3.rgb")
  @js.native
  def rgb(r: Double, g: Double, b: Double): RGBColor = js.native
  @JSImport("plotly.js", "d3.rgb")
  @js.native
  def rgb(r: Double, g: Double, b: Double, opacity: Double): RGBColor = js.native
  
  @JSImport("plotly.js", "d3.ribbon")
  @js.native
  def ribbon(): RibbonGenerator[_, Ribbon_, RibbonSubgroup] = js.native
  @JSImport("plotly.js", "d3.ribbon")
  @js.native
  def ribbon_DatumSubgroupDatum[Datum, SubgroupDatum](): RibbonGenerator[_, Datum, SubgroupDatum] = js.native
  @JSImport("plotly.js", "d3.ribbon")
  @js.native
  def ribbon_ThisDatumSubgroupDatum[This, Datum, SubgroupDatum](): RibbonGenerator[This, Datum, SubgroupDatum] = js.native
  
  @JSImport("plotly.js", "d3.rollup")
  @js.native
  def rollup[TObject, TReduce, TKey](
    iterable: Iterable[TObject],
    reduce: js.Function1[/* value */ js.Array[TObject], TReduce],
    key: js.Function1[/* value */ TObject, TKey]
  ): Map[TKey, TReduce] = js.native
  @JSImport("plotly.js", "d3.rollup")
  @js.native
  def rollup[TObject, TReduce, TKey1, TKey2](
    iterable: Iterable[TObject],
    reduce: js.Function1[/* value */ js.Array[TObject], TReduce],
    key1: js.Function1[/* value */ TObject, TKey1],
    key2: js.Function1[/* value */ TObject, TKey2]
  ): Map[TKey1, Map[TKey2, TReduce]] = js.native
  @JSImport("plotly.js", "d3.rollup")
  @js.native
  def rollup[TObject, TReduce, TKey1, TKey2, TKey3](
    iterable: Iterable[TObject],
    reduce: js.Function1[/* value */ js.Array[TObject], TReduce],
    key1: js.Function1[/* value */ TObject, TKey1],
    key2: js.Function1[/* value */ TObject, TKey2],
    key3: js.Function1[/* value */ TObject, TKey3]
  ): Map[TKey1, Map[TKey2, Map[TKey3, TReduce]]] = js.native
  
  @JSImport("plotly.js", "d3.rollups")
  @js.native
  def rollups[TObject, TReduce, TKey](
    iterable: Iterable[TObject],
    reduce: js.Function1[/* value */ js.Array[TObject], TReduce],
    key: js.Function1[/* value */ TObject, TKey]
  ): js.Array[js.Tuple2[TKey, TReduce]] = js.native
  @JSImport("plotly.js", "d3.rollups")
  @js.native
  def rollups[TObject, TReduce, TKey1, TKey2](
    iterable: Iterable[TObject],
    reduce: js.Function1[/* value */ js.Array[TObject], TReduce],
    key1: js.Function1[/* value */ TObject, TKey1],
    key2: js.Function1[/* value */ TObject, TKey2]
  ): js.Array[js.Tuple2[TKey1, js.Array[js.Tuple2[TKey2, TReduce]]]] = js.native
  @JSImport("plotly.js", "d3.rollups")
  @js.native
  def rollups[TObject, TReduce, TKey1, TKey2, TKey3](
    iterable: Iterable[TObject],
    reduce: js.Function1[/* value */ js.Array[TObject], TReduce],
    key1: js.Function1[/* value */ TObject, TKey1],
    key2: js.Function1[/* value */ TObject, TKey2],
    key3: js.Function1[/* value */ TObject, TKey3]
  ): js.Array[
    js.Tuple2[TKey1, js.Array[js.Tuple2[TKey2, js.Array[js.Tuple2[TKey3, TReduce]]]]]
  ] = js.native
  
  @JSImport("plotly.js", "d3.scaleBand")
  @js.native
  def scaleBand[Domain /* <: typings.d3Scale.anon.ToString */](): ScaleBand_[Domain] = js.native
  @JSImport("plotly.js", "d3.scaleBand")
  @js.native
  def scaleBand[Domain /* <: typings.d3Scale.anon.ToString */](domain: Iterable[Domain], range: Iterable[NumberValue]): ScaleBand_[Domain] = js.native
  @JSImport("plotly.js", "d3.scaleBand")
  @js.native
  def scaleBand[Domain /* <: typings.d3Scale.anon.ToString */](range: Iterable[NumberValue]): ScaleBand_[Domain] = js.native
  
  @JSImport("plotly.js", "d3.scaleDiverging")
  @js.native
  def scaleDiverging[Output, Unknown](): ScaleDiverging_[Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleDiverging")
  @js.native
  def scaleDiverging[Output, Unknown](domain: Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleDiverging")
  @js.native
  def scaleDiverging[Output, Unknown](domain: Iterable[NumberValue], interpolator: Iterable[Output]): ScaleDiverging_[Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleDiverging")
  @js.native
  def scaleDiverging[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleDiverging")
  @js.native
  def scaleDiverging[Output, Unknown](interpolator: Iterable[Output]): ScaleDiverging_[Output, Unknown] = js.native
  
  @JSImport("plotly.js", "d3.scaleDivergingLog")
  @js.native
  def scaleDivergingLog[Output, Unknown](): ScaleDiverging_[Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleDivergingLog")
  @js.native
  def scaleDivergingLog[Output, Unknown](domain: Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleDivergingLog")
  @js.native
  def scaleDivergingLog[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = js.native
  
  @JSImport("plotly.js", "d3.scaleDivergingPow")
  @js.native
  def scaleDivergingPow[Output, Unknown](): ScaleDiverging_[Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleDivergingPow")
  @js.native
  def scaleDivergingPow[Output, Unknown](domain: Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleDivergingPow")
  @js.native
  def scaleDivergingPow[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = js.native
  
  @JSImport("plotly.js", "d3.scaleDivergingSqrt")
  @js.native
  def scaleDivergingSqrt[Output, Unknown](): ScaleDiverging_[Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleDivergingSqrt")
  @js.native
  def scaleDivergingSqrt[Output, Unknown](domain: Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleDivergingSqrt")
  @js.native
  def scaleDivergingSqrt[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = js.native
  
  @JSImport("plotly.js", "d3.scaleDivergingSymlog")
  @js.native
  def scaleDivergingSymlog[Output, Unknown](): ScaleDiverging_[Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleDivergingSymlog")
  @js.native
  def scaleDivergingSymlog[Output, Unknown](domain: Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleDivergingSymlog")
  @js.native
  def scaleDivergingSymlog[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = js.native
  
  @JSImport("plotly.js", "d3.scaleIdentity")
  @js.native
  def scaleIdentity[Unknown](): ScaleIdentity_[Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleIdentity")
  @js.native
  def scaleIdentity[Unknown](range: Iterable[NumberValue]): ScaleIdentity_[Unknown] = js.native
  
  @JSImport("plotly.js", "d3.scaleImplicit")
  @js.native
  val scaleImplicit: TypeofscaleImplicit = js.native
  
  @JSImport("plotly.js", "d3.scaleLinear")
  @js.native
  def scaleLinear[Range, Output, Unknown](): ScaleLinear_[Range, Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleLinear")
  @js.native
  def scaleLinear[Range, Output, Unknown](domain: Iterable[NumberValue], range: Iterable[Range]): ScaleLinear_[Range, Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleLinear")
  @js.native
  def scaleLinear[Range, Output, Unknown](range: Iterable[Range]): ScaleLinear_[Range, Output, Unknown] = js.native
  
  @JSImport("plotly.js", "d3.scaleLog")
  @js.native
  def scaleLog[Range, Output, Unknown](): ScaleLogarithmic[Range, Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleLog")
  @js.native
  def scaleLog[Range, Output, Unknown](domain: Iterable[NumberValue], range: Iterable[Range]): ScaleLogarithmic[Range, Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleLog")
  @js.native
  def scaleLog[Range, Output, Unknown](range: Iterable[Range]): ScaleLogarithmic[Range, Output, Unknown] = js.native
  
  @JSImport("plotly.js", "d3.scaleOrdinal")
  @js.native
  def scaleOrdinal[Range](): ScaleOrdinal_[String, Range, scala.Nothing] = js.native
  @JSImport("plotly.js", "d3.scaleOrdinal")
  @js.native
  def scaleOrdinal[Range](range: Iterable[Range]): ScaleOrdinal_[String, Range, scala.Nothing] = js.native
  @JSImport("plotly.js", "d3.scaleOrdinal")
  @js.native
  def scaleOrdinal[Domain /* <: typings.d3Scale.anon.ToString */, Range, Unknown](domain: Iterable[Domain], range: Iterable[Range]): ScaleOrdinal_[Domain, Range, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleOrdinal")
  @js.native
  def scaleOrdinal_Domain_ToStringRangeUnknown[Domain /* <: typings.d3Scale.anon.ToString */, Range, Unknown](): ScaleOrdinal_[Domain, Range, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleOrdinal")
  @js.native
  def scaleOrdinal_Domain_ToStringRangeUnknown[Domain /* <: typings.d3Scale.anon.ToString */, Range, Unknown](range: Iterable[Range]): ScaleOrdinal_[Domain, Range, Unknown] = js.native
  
  @JSImport("plotly.js", "d3.scalePoint")
  @js.native
  def scalePoint[Domain /* <: typings.d3Scale.anon.ToString */](): ScalePoint_[Domain] = js.native
  @JSImport("plotly.js", "d3.scalePoint")
  @js.native
  def scalePoint[Domain /* <: typings.d3Scale.anon.ToString */](domain: Iterable[Domain], range: Iterable[NumberValue]): ScalePoint_[Domain] = js.native
  @JSImport("plotly.js", "d3.scalePoint")
  @js.native
  def scalePoint[Domain /* <: typings.d3Scale.anon.ToString */](range: Iterable[NumberValue]): ScalePoint_[Domain] = js.native
  
  @JSImport("plotly.js", "d3.scalePow")
  @js.native
  def scalePow[Range, Output, Unknown](): ScalePower[Range, Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scalePow")
  @js.native
  def scalePow[Range, Output, Unknown](domain: Iterable[NumberValue], range: Iterable[Range]): ScalePower[Range, Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scalePow")
  @js.native
  def scalePow[Range, Output, Unknown](range: Iterable[Range]): ScalePower[Range, Output, Unknown] = js.native
  
  @JSImport("plotly.js", "d3.scaleQuantile")
  @js.native
  def scaleQuantile[Range, Unknown](): ScaleQuantile_[Range, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleQuantile")
  @js.native
  def scaleQuantile[Range, Unknown](domain: Iterable[js.UndefOr[NumberValue | Null]], range: Iterable[Range]): ScaleQuantile_[Range, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleQuantile")
  @js.native
  def scaleQuantile[Range, Unknown](range: Iterable[Range]): ScaleQuantile_[Range, Unknown] = js.native
  
  @JSImport("plotly.js", "d3.scaleQuantize")
  @js.native
  def scaleQuantize[Range, Unknown](): ScaleQuantize_[Range, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleQuantize")
  @js.native
  def scaleQuantize[Range, Unknown](domain: Iterable[NumberValue], range: Iterable[Range]): ScaleQuantize_[Range, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleQuantize")
  @js.native
  def scaleQuantize[Range, Unknown](range: Iterable[Range]): ScaleQuantize_[Range, Unknown] = js.native
  
  @JSImport("plotly.js", "d3.scaleRadial")
  @js.native
  def scaleRadial[Range, Unknown](): ScaleRadial_[Range, Range, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleRadial")
  @js.native
  def scaleRadial[Range, Unknown](domain: Iterable[NumberValue], range: Iterable[Range]): ScaleRadial_[Range, Range, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleRadial")
  @js.native
  def scaleRadial[Range, Unknown](range: Iterable[Range]): ScaleRadial_[Range, Range, Unknown] = js.native
  
  @JSImport("plotly.js", "d3.scaleSequential")
  @js.native
  def scaleSequential[Output, Unknown](): ScaleSequential_[Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleSequential")
  @js.native
  def scaleSequential[Output, Unknown](domain: Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleSequential")
  @js.native
  def scaleSequential[Output, Unknown](domain: Iterable[NumberValue], interpolator: Iterable[Output]): ScaleSequential_[Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleSequential")
  @js.native
  def scaleSequential[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleSequential")
  @js.native
  def scaleSequential[Output, Unknown](interpolator: Iterable[Output]): ScaleSequential_[Output, Unknown] = js.native
  
  @JSImport("plotly.js", "d3.scaleSequentialLog")
  @js.native
  def scaleSequentialLog[Output, Unknown](): ScaleSequential_[Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleSequentialLog")
  @js.native
  def scaleSequentialLog[Output, Unknown](domain: Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleSequentialLog")
  @js.native
  def scaleSequentialLog[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = js.native
  
  @JSImport("plotly.js", "d3.scaleSequentialPow")
  @js.native
  def scaleSequentialPow[Output, Unknown](): ScaleSequential_[Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleSequentialPow")
  @js.native
  def scaleSequentialPow[Output, Unknown](domain: Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleSequentialPow")
  @js.native
  def scaleSequentialPow[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = js.native
  
  @JSImport("plotly.js", "d3.scaleSequentialQuantile")
  @js.native
  def scaleSequentialQuantile[Output, Unknown](): ScaleSequentialQuantile_[Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleSequentialQuantile")
  @js.native
  def scaleSequentialQuantile[Output, Unknown](domain: Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleSequentialQuantile_[Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleSequentialQuantile")
  @js.native
  def scaleSequentialQuantile[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleSequentialQuantile_[Output, Unknown] = js.native
  
  @JSImport("plotly.js", "d3.scaleSequentialSqrt")
  @js.native
  def scaleSequentialSqrt[Output, Unknown](): ScaleSequential_[Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleSequentialSqrt")
  @js.native
  def scaleSequentialSqrt[Output, Unknown](domain: Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleSequentialSqrt")
  @js.native
  def scaleSequentialSqrt[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = js.native
  
  @JSImport("plotly.js", "d3.scaleSequentialSymlog")
  @js.native
  def scaleSequentialSymlog[Output, Unknown](): ScaleSequential_[Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleSequentialSymlog")
  @js.native
  def scaleSequentialSymlog[Output, Unknown](domain: Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleSequentialSymlog")
  @js.native
  def scaleSequentialSymlog[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = js.native
  
  @JSImport("plotly.js", "d3.scaleSqrt")
  @js.native
  def scaleSqrt[Range, Output, Unknown](): ScalePower[Range, Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleSqrt")
  @js.native
  def scaleSqrt[Range, Output, Unknown](domain: Iterable[NumberValue], range: Iterable[Range]): ScalePower[Range, Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleSqrt")
  @js.native
  def scaleSqrt[Range, Output, Unknown](range: Iterable[Range]): ScalePower[Range, Output, Unknown] = js.native
  
  @JSImport("plotly.js", "d3.scaleSymlog")
  @js.native
  def scaleSymlog[Range, Output, Unknown](): ScaleSymLog_[Range, Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleSymlog")
  @js.native
  def scaleSymlog[Range, Output, Unknown](domain: Iterable[NumberValue], range: Iterable[Range]): ScaleSymLog_[Range, Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleSymlog")
  @js.native
  def scaleSymlog[Range, Output, Unknown](range: Iterable[Range]): ScaleSymLog_[Range, Output, Unknown] = js.native
  
  @JSImport("plotly.js", "d3.scaleThreshold")
  @js.native
  def scaleThreshold[Domain /* <: Double | String | Date */, Range, Unknown](): ScaleThreshold_[Domain, Range, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleThreshold")
  @js.native
  def scaleThreshold[Domain /* <: Double | String | Date */, Range, Unknown](domain: Iterable[Domain], range: Iterable[Range]): ScaleThreshold_[Domain, Range, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleThreshold")
  @js.native
  def scaleThreshold[Domain /* <: Double | String | Date */, Range, Unknown](range: Iterable[Range]): ScaleThreshold_[Domain, Range, Unknown] = js.native
  
  @JSImport("plotly.js", "d3.scaleTime")
  @js.native
  def scaleTime[Range, Output, Unknown](): ScaleTime_[Range, Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleTime")
  @js.native
  def scaleTime[Range, Output, Unknown](domain: Iterable[Date | NumberValue], range: Iterable[Range]): ScaleTime_[Range, Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleTime")
  @js.native
  def scaleTime[Range, Output, Unknown](range: Iterable[Range]): ScaleTime_[Range, Output, Unknown] = js.native
  
  @JSImport("plotly.js", "d3.scaleUtc")
  @js.native
  def scaleUtc[Range, Output, Unknown](): ScaleTime_[Range, Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleUtc")
  @js.native
  def scaleUtc[Range, Output, Unknown](domain: Iterable[NumberValue], range: Iterable[Range]): ScaleTime_[Range, Output, Unknown] = js.native
  @JSImport("plotly.js", "d3.scaleUtc")
  @js.native
  def scaleUtc[Range, Output, Unknown](range: Iterable[Range]): ScaleTime_[Range, Output, Unknown] = js.native
  
  @JSImport("plotly.js", "d3.schemeAccent")
  @js.native
  val schemeAccent: js.Array[String] = js.native
  
  @JSImport("plotly.js", "d3.schemeBlues")
  @js.native
  val schemeBlues: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.schemeBrBG")
  @js.native
  val schemeBrBG: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.schemeBuGn")
  @js.native
  val schemeBuGn: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.schemeBuPu")
  @js.native
  val schemeBuPu: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.schemeCategory10")
  @js.native
  val schemeCategory10: js.Array[String] = js.native
  
  @JSImport("plotly.js", "d3.schemeDark2")
  @js.native
  val schemeDark2: js.Array[String] = js.native
  
  @JSImport("plotly.js", "d3.schemeGnBu")
  @js.native
  val schemeGnBu: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.schemeGreens")
  @js.native
  val schemeGreens: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.schemeGreys")
  @js.native
  val schemeGreys: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.schemeOrRd")
  @js.native
  val schemeOrRd: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.schemeOranges")
  @js.native
  val schemeOranges: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.schemePRGn")
  @js.native
  val schemePRGn: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.schemePaired")
  @js.native
  val schemePaired: js.Array[String] = js.native
  
  @JSImport("plotly.js", "d3.schemePastel1")
  @js.native
  val schemePastel1: js.Array[String] = js.native
  
  @JSImport("plotly.js", "d3.schemePastel2")
  @js.native
  val schemePastel2: js.Array[String] = js.native
  
  @JSImport("plotly.js", "d3.schemePiYG")
  @js.native
  val schemePiYG: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.schemePuBu")
  @js.native
  val schemePuBu: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.schemePuBuGn")
  @js.native
  val schemePuBuGn: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.schemePuOr")
  @js.native
  val schemePuOr: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.schemePuRd")
  @js.native
  val schemePuRd: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.schemePurples")
  @js.native
  val schemePurples: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.schemeRdBu")
  @js.native
  val schemeRdBu: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.schemeRdGy")
  @js.native
  val schemeRdGy: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.schemeRdPu")
  @js.native
  val schemeRdPu: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.schemeRdYlBu")
  @js.native
  val schemeRdYlBu: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.schemeRdYlGn")
  @js.native
  val schemeRdYlGn: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.schemeReds")
  @js.native
  val schemeReds: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.schemeSet1")
  @js.native
  val schemeSet1: js.Array[String] = js.native
  
  @JSImport("plotly.js", "d3.schemeSet2")
  @js.native
  val schemeSet2: js.Array[String] = js.native
  
  @JSImport("plotly.js", "d3.schemeSet3")
  @js.native
  val schemeSet3: js.Array[String] = js.native
  
  @JSImport("plotly.js", "d3.schemeSpectral")
  @js.native
  val schemeSpectral: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.schemeTableau10")
  @js.native
  val schemeTableau10: js.Array[String] = js.native
  
  @JSImport("plotly.js", "d3.schemeYlGn")
  @js.native
  val schemeYlGn: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.schemeYlGnBu")
  @js.native
  val schemeYlGnBu: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.schemeYlOrBr")
  @js.native
  val schemeYlOrBr: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.schemeYlOrRd")
  @js.native
  val schemeYlOrRd: js.Array[js.Array[String]] = js.native
  
  @JSImport("plotly.js", "d3.select")
  @js.native
  def select[OldDatum](node: Null): Selection_[Null, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.select")
  @js.native
  def select[OldDatum](node: EnterElement): Selection_[EnterElement, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.select")
  @js.native
  def select[OldDatum](node: Document): Selection_[Document, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.select")
  @js.native
  def select[OldDatum](node: Element): Selection_[Element, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.select")
  @js.native
  def select[OldDatum](node: Window): Selection_[Window, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.select")
  @js.native
  def select[GElement /* <: BaseType */, OldDatum](selector: String): Selection_[GElement, OldDatum, HTMLElement, _] = js.native
  
  @JSImport("plotly.js", "d3.selectAll")
  @js.native
  def selectAll(): Selection_[Null, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.selectAll")
  @js.native
  def selectAll(selector: js.UndefOr[scala.Nothing]): Selection_[Null, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.selectAll")
  @js.native
  def selectAll(selector: Null): Selection_[Null, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.selectAll")
  @js.native
  def selectAll[GElement /* <: BaseType */, OldDatum](nodes: js.Array[GElement]): Selection_[GElement, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.selectAll")
  @js.native
  def selectAll[GElement /* <: BaseType */, OldDatum](nodes: typings.d3Selection.mod.ArrayLike[GElement]): Selection_[GElement, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.selectAll")
  @js.native
  def selectAll[GElement /* <: BaseType */, OldDatum](nodes: Iterable[GElement]): Selection_[GElement, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.selectAll")
  @js.native
  def selectAll[GElement /* <: BaseType */, OldDatum](selector: String): Selection_[GElement, OldDatum, HTMLElement, _] = js.native
  
  @JSImport("plotly.js", "d3.selection")
  @js.native
  def selection(): Selection_[HTMLElement, _, Null, js.UndefOr[scala.Nothing]] = js.native
  
  @JSImport("plotly.js", "d3.selector")
  @js.native
  def selector[DescElement /* <: Element */](selector: String): js.ThisFunction0[/* this */ BaseType, DescElement] = js.native
  
  @JSImport("plotly.js", "d3.selectorAll")
  @js.native
  def selectorAll[DescElement /* <: Element */](selector: String): js.ThisFunction0[/* this */ BaseType, NodeListOf[DescElement]] = js.native
  
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Float32Array): Float32Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Float32Array, lo: js.UndefOr[scala.Nothing], hi: Double): Float32Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Float32Array, lo: Double): Float32Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Float32Array, lo: Double, hi: Double): Float32Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Float64Array): Float64Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Float64Array, lo: js.UndefOr[scala.Nothing], hi: Double): Float64Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Float64Array, lo: Double): Float64Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Float64Array, lo: Double, hi: Double): Float64Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Int16Array): Int16Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Int16Array, lo: js.UndefOr[scala.Nothing], hi: Double): Int16Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Int16Array, lo: Double): Int16Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Int16Array, lo: Double, hi: Double): Int16Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Int32Array): Int32Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Int32Array, lo: js.UndefOr[scala.Nothing], hi: Double): Int32Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Int32Array, lo: Double): Int32Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Int32Array, lo: Double, hi: Double): Int32Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Int8Array): Int8Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Int8Array, lo: js.UndefOr[scala.Nothing], hi: Double): Int8Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Int8Array, lo: Double): Int8Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Int8Array, lo: Double, hi: Double): Int8Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Uint16Array): Uint16Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Uint16Array, lo: js.UndefOr[scala.Nothing], hi: Double): Uint16Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Uint16Array, lo: Double): Uint16Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Uint16Array, lo: Double, hi: Double): Uint16Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Uint32Array): Uint32Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Uint32Array, lo: js.UndefOr[scala.Nothing], hi: Double): Uint32Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Uint32Array, lo: Double): Uint32Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Uint32Array, lo: Double, hi: Double): Uint32Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Uint8Array): Uint8Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Uint8Array, lo: js.UndefOr[scala.Nothing], hi: Double): Uint8Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Uint8Array, lo: Double): Uint8Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Uint8Array, lo: Double, hi: Double): Uint8Array = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Uint8ClampedArray): Uint8ClampedArray = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Uint8ClampedArray, lo: js.UndefOr[scala.Nothing], hi: Double): Uint8ClampedArray = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Uint8ClampedArray, lo: Double): Uint8ClampedArray = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle(array: Uint8ClampedArray, lo: Double, hi: Double): Uint8ClampedArray = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle[T](array: js.Array[T]): js.Array[T] = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle[T](array: js.Array[T], lo: js.UndefOr[scala.Nothing], hi: Double): js.Array[T] = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle[T](array: js.Array[T], lo: Double): js.Array[T] = js.native
  @JSImport("plotly.js", "d3.shuffle")
  @js.native
  def shuffle[T](array: js.Array[T], lo: Double, hi: Double): js.Array[T] = js.native
  
  @JSImport("plotly.js", "d3.shuffler")
  @js.native
  def shuffler(random: js.Function0[Double]): FnCall = js.native
  
  @JSImport("plotly.js", "d3.some")
  @js.native
  def some[T](
    iterable: Iterable[T],
    test: js.Function3[/* value */ T, /* index */ Double, /* iterable */ Iterable[T], _]
  ): Boolean = js.native
  
  @JSImport("plotly.js", "d3.sort")
  @js.native
  def sort[T](iterable: Iterable[T]): js.Array[T] = js.native
  @JSImport("plotly.js", "d3.sort")
  @js.native
  def sort[T](iterable: Iterable[T], comparator: js.Function2[/* a */ T, /* b */ T, Double]): js.Array[T] = js.native
  
  @JSImport("plotly.js", "d3.stack")
  @js.native
  def stack(): Stack_[_, StringDictionary[Double], String] = js.native
  
  @JSImport("plotly.js", "d3.stackOffsetDiverging")
  @js.native
  def stackOffsetDiverging(series: Series[_, _], order: Iterable[Double]): Unit = js.native
  
  @JSImport("plotly.js", "d3.stackOffsetExpand")
  @js.native
  def stackOffsetExpand(series: Series[_, _], order: Iterable[Double]): Unit = js.native
  
  @JSImport("plotly.js", "d3.stackOffsetNone")
  @js.native
  def stackOffsetNone(series: Series[_, _], order: Iterable[Double]): Unit = js.native
  
  @JSImport("plotly.js", "d3.stackOffsetSilhouette")
  @js.native
  def stackOffsetSilhouette(series: Series[_, _], order: Iterable[Double]): Unit = js.native
  
  @JSImport("plotly.js", "d3.stackOffsetWiggle")
  @js.native
  def stackOffsetWiggle(series: Series[_, _], order: Iterable[Double]): Unit = js.native
  
  @JSImport("plotly.js", "d3.stackOrderAppearance")
  @js.native
  def stackOrderAppearance(series: Series[_, _]): js.Array[Double] = js.native
  
  @JSImport("plotly.js", "d3.stackOrderAscending")
  @js.native
  def stackOrderAscending(series: Series[_, _]): js.Array[Double] = js.native
  
  @JSImport("plotly.js", "d3.stackOrderDescending")
  @js.native
  def stackOrderDescending(series: Series[_, _]): js.Array[Double] = js.native
  
  @JSImport("plotly.js", "d3.stackOrderInsideOut")
  @js.native
  def stackOrderInsideOut(series: Series[_, _]): js.Array[Double] = js.native
  
  @JSImport("plotly.js", "d3.stackOrderNone")
  @js.native
  def stackOrderNone(series: Series[_, _]): js.Array[Double] = js.native
  
  @JSImport("plotly.js", "d3.stackOrderReverse")
  @js.native
  def stackOrderReverse(series: Series[_, _]): js.Array[Double] = js.native
  
  @JSImport("plotly.js", "d3.stack")
  @js.native
  def stack_Datum[Datum](): Stack_[_, Datum, String] = js.native
  @JSImport("plotly.js", "d3.stack")
  @js.native
  def stack_DatumKey[Datum, Key](): Stack_[_, Datum, Key] = js.native
  @JSImport("plotly.js", "d3.stack")
  @js.native
  def stack_ThisDatumKey[This, Datum, Key](): Stack_[This, Datum, Key] = js.native
  
  @JSImport("plotly.js", "d3.stratify")
  @js.native
  def stratify[Datum](): StratifyOperator[Datum] = js.native
  
  @JSImport("plotly.js", "d3.style")
  @js.native
  def style(node: Element, name: String): String = js.native
  
  @JSImport("plotly.js", "d3.subset")
  @js.native
  def subset[T](a: Iterable[T], b: Iterable[T]): Boolean = js.native
  
  @JSImport("plotly.js", "d3.sum")
  @js.native
  def sum[T /* <: Numeric */](iterable: Iterable[js.UndefOr[T | Null]]): Double = js.native
  @JSImport("plotly.js", "d3.sum")
  @js.native
  def sum[T](
    iterable: Iterable[T],
    accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[Double | Null]]
  ): Double = js.native
  
  @JSImport("plotly.js", "d3.superset")
  @js.native
  def superset[T](a: Iterable[T], b: Iterable[T]): Boolean = js.native
  
  @JSImport("plotly.js", "d3.svg")
  @js.native
  def svg(url: String): js.Promise[Document] = js.native
  @JSImport("plotly.js", "d3.svg")
  @js.native
  def svg(url: String, init: RequestInit): js.Promise[Document] = js.native
  
  @JSImport("plotly.js", "d3.symbol")
  @js.native
  def symbol[Datum](): Symbol_[_, Datum] = js.native
  @JSImport("plotly.js", "d3.symbol")
  @js.native
  def symbol[Datum](
    `type`: js.UndefOr[scala.Nothing],
    size: js.ThisFunction2[/* this */ js.Any, /* d */ Datum, /* repeated */ js.Any, Double]
  ): Symbol_[_, Datum] = js.native
  @JSImport("plotly.js", "d3.symbol")
  @js.native
  def symbol[Datum](`type`: js.UndefOr[scala.Nothing], size: Double): Symbol_[_, Datum] = js.native
  @JSImport("plotly.js", "d3.symbol")
  @js.native
  def symbol[Datum](`type`: js.ThisFunction2[/* this */ js.Any, /* d */ Datum, /* repeated */ js.Any, SymbolType]): Symbol_[_, Datum] = js.native
  @JSImport("plotly.js", "d3.symbol")
  @js.native
  def symbol[Datum](
    `type`: js.ThisFunction2[/* this */ js.Any, /* d */ Datum, /* repeated */ js.Any, SymbolType],
    size: js.ThisFunction2[/* this */ js.Any, /* d */ Datum, /* repeated */ js.Any, Double]
  ): Symbol_[_, Datum] = js.native
  @JSImport("plotly.js", "d3.symbol")
  @js.native
  def symbol[Datum](
    `type`: js.ThisFunction2[/* this */ js.Any, /* d */ Datum, /* repeated */ js.Any, SymbolType],
    size: Double
  ): Symbol_[_, Datum] = js.native
  @JSImport("plotly.js", "d3.symbol")
  @js.native
  def symbol[Datum](`type`: SymbolType): Symbol_[_, Datum] = js.native
  @JSImport("plotly.js", "d3.symbol")
  @js.native
  def symbol[Datum](
    `type`: SymbolType,
    size: js.ThisFunction2[/* this */ js.Any, /* d */ Datum, /* repeated */ js.Any, Double]
  ): Symbol_[_, Datum] = js.native
  @JSImport("plotly.js", "d3.symbol")
  @js.native
  def symbol[Datum](`type`: SymbolType, size: Double): Symbol_[_, Datum] = js.native
  
  @JSImport("plotly.js", "d3.symbolCircle")
  @js.native
  val symbolCircle: SymbolType = js.native
  
  @JSImport("plotly.js", "d3.symbolCross")
  @js.native
  val symbolCross: SymbolType = js.native
  
  @JSImport("plotly.js", "d3.symbolDiamond")
  @js.native
  val symbolDiamond: SymbolType = js.native
  
  @JSImport("plotly.js", "d3.symbolSquare")
  @js.native
  val symbolSquare: SymbolType = js.native
  
  @JSImport("plotly.js", "d3.symbolStar")
  @js.native
  val symbolStar: SymbolType = js.native
  
  @JSImport("plotly.js", "d3.symbolTriangle")
  @js.native
  val symbolTriangle: SymbolType = js.native
  
  @JSImport("plotly.js", "d3.symbolWye")
  @js.native
  val symbolWye: SymbolType = js.native
  
  @JSImport("plotly.js", "d3.symbol")
  @js.native
  def symbol_ThisDatum[This, Datum](): Symbol_[This, Datum] = js.native
  @JSImport("plotly.js", "d3.symbol")
  @js.native
  def symbol_ThisDatum[This, Datum](
    `type`: js.UndefOr[scala.Nothing],
    size: js.ThisFunction2[/* this */ This, /* d */ Datum, /* repeated */ js.Any, Double]
  ): Symbol_[This, Datum] = js.native
  @JSImport("plotly.js", "d3.symbol")
  @js.native
  def symbol_ThisDatum[This, Datum](`type`: js.UndefOr[scala.Nothing], size: Double): Symbol_[This, Datum] = js.native
  @JSImport("plotly.js", "d3.symbol")
  @js.native
  def symbol_ThisDatum[This, Datum](`type`: js.ThisFunction2[/* this */ This, /* d */ Datum, /* repeated */ js.Any, SymbolType]): Symbol_[This, Datum] = js.native
  @JSImport("plotly.js", "d3.symbol")
  @js.native
  def symbol_ThisDatum[This, Datum](
    `type`: js.ThisFunction2[/* this */ This, /* d */ Datum, /* repeated */ js.Any, SymbolType],
    size: js.ThisFunction2[/* this */ This, /* d */ Datum, /* repeated */ js.Any, Double]
  ): Symbol_[This, Datum] = js.native
  @JSImport("plotly.js", "d3.symbol")
  @js.native
  def symbol_ThisDatum[This, Datum](
    `type`: js.ThisFunction2[/* this */ This, /* d */ Datum, /* repeated */ js.Any, SymbolType],
    size: Double
  ): Symbol_[This, Datum] = js.native
  @JSImport("plotly.js", "d3.symbol")
  @js.native
  def symbol_ThisDatum[This, Datum](`type`: SymbolType): Symbol_[This, Datum] = js.native
  @JSImport("plotly.js", "d3.symbol")
  @js.native
  def symbol_ThisDatum[This, Datum](
    `type`: SymbolType,
    size: js.ThisFunction2[/* this */ This, /* d */ Datum, /* repeated */ js.Any, Double]
  ): Symbol_[This, Datum] = js.native
  @JSImport("plotly.js", "d3.symbol")
  @js.native
  def symbol_ThisDatum[This, Datum](`type`: SymbolType, size: Double): Symbol_[This, Datum] = js.native
  
  @JSImport("plotly.js", "d3.symbols")
  @js.native
  val symbols: js.Array[SymbolType] = js.native
  
  @JSImport("plotly.js", "d3.text")
  @js.native
  def text(url: String): js.Promise[String] = js.native
  @JSImport("plotly.js", "d3.text")
  @js.native
  def text(url: String, init: RequestInit): js.Promise[String] = js.native
  
  @JSImport("plotly.js", "d3.thresholdFreedmanDiaconis")
  @js.native
  def thresholdFreedmanDiaconis(values: ArrayLike[js.UndefOr[Double]], min: Double, max: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.thresholdScott")
  @js.native
  def thresholdScott(values: ArrayLike[js.UndefOr[Double]], min: Double, max: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.thresholdSturges")
  @js.native
  def thresholdSturges(values: ArrayLike[js.UndefOr[Double]]): Double = js.native
  
  @JSImport("plotly.js", "d3.tickFormat")
  @js.native
  def tickFormat(start: Double, stop: Double, count: Double): js.Function1[/* d */ NumberValue, String] = js.native
  @JSImport("plotly.js", "d3.tickFormat")
  @js.native
  def tickFormat(start: Double, stop: Double, count: Double, specifier: String): js.Function1[/* d */ NumberValue, String] = js.native
  
  @JSImport("plotly.js", "d3.tickIncrement")
  @js.native
  def tickIncrement(start: Double, stop: Double, count: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.tickStep")
  @js.native
  def tickStep(start: Double, stop: Double, count: Double): Double = js.native
  
  @JSImport("plotly.js", "d3.ticks")
  @js.native
  def ticks(start: Double, stop: Double, count: Double): js.Array[Double] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.timeDay")
  @js.native
  def timeDay(): Date = js.native
  @JSImport("plotly.js", "d3.timeDay")
  @js.native
  def timeDay(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.timeDay")
  @js.native
  val timeDay_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.timeDays")
  @js.native
  def timeDays(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.timeDays")
  @js.native
  def timeDays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  @JSImport("plotly.js", "d3.timeFormat")
  @js.native
  def timeFormat(specifier: String): js.Function1[/* date */ Date, String] = js.native
  
  @JSImport("plotly.js", "d3.timeFormatDefaultLocale")
  @js.native
  def timeFormatDefaultLocale(definition: TimeLocaleDefinition): TimeLocaleObject = js.native
  
  @JSImport("plotly.js", "d3.timeFormatLocale")
  @js.native
  def timeFormatLocale(definition: TimeLocaleDefinition): TimeLocaleObject = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.timeFriday")
  @js.native
  def timeFriday(): Date = js.native
  @JSImport("plotly.js", "d3.timeFriday")
  @js.native
  def timeFriday(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.timeFriday")
  @js.native
  val timeFriday_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.timeFridays")
  @js.native
  def timeFridays(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.timeFridays")
  @js.native
  def timeFridays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.timeHour")
  @js.native
  def timeHour(): Date = js.native
  @JSImport("plotly.js", "d3.timeHour")
  @js.native
  def timeHour(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.timeHour")
  @js.native
  val timeHour_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.timeHours")
  @js.native
  def timeHours(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.timeHours")
  @js.native
  def timeHours(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  @JSImport("plotly.js", "d3.timeInterval")
  @js.native
  def timeInterval(
    floor: js.Function1[/* date */ Date, Unit],
    offset: js.Function2[/* date */ Date, /* step */ Double, Unit]
  ): TimeInterval_ = js.native
  @JSImport("plotly.js", "d3.timeInterval")
  @js.native
  def timeInterval(
    floor: js.Function1[/* date */ Date, Unit],
    offset: js.Function2[/* date */ Date, /* step */ Double, Unit],
    count: js.Function2[/* start */ Date, /* end */ Date, Double]
  ): CountableTimeInterval = js.native
  @JSImport("plotly.js", "d3.timeInterval")
  @js.native
  def timeInterval(
    floor: js.Function1[/* date */ Date, Unit],
    offset: js.Function2[/* date */ Date, /* step */ Double, Unit],
    count: js.Function2[/* start */ Date, /* end */ Date, Double],
    field: js.Function1[/* date */ Date, Double]
  ): CountableTimeInterval = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.timeMillisecond")
  @js.native
  def timeMillisecond(): Date = js.native
  @JSImport("plotly.js", "d3.timeMillisecond")
  @js.native
  def timeMillisecond(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.timeMillisecond")
  @js.native
  val timeMillisecond_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.timeMilliseconds")
  @js.native
  def timeMilliseconds(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.timeMilliseconds")
  @js.native
  def timeMilliseconds(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.timeMinute")
  @js.native
  def timeMinute(): Date = js.native
  @JSImport("plotly.js", "d3.timeMinute")
  @js.native
  def timeMinute(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.timeMinute")
  @js.native
  val timeMinute_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.timeMinutes")
  @js.native
  def timeMinutes(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.timeMinutes")
  @js.native
  def timeMinutes(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.timeMonday")
  @js.native
  def timeMonday(): Date = js.native
  @JSImport("plotly.js", "d3.timeMonday")
  @js.native
  def timeMonday(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.timeMonday")
  @js.native
  val timeMonday_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.timeMondays")
  @js.native
  def timeMondays(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.timeMondays")
  @js.native
  def timeMondays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.timeMonth")
  @js.native
  def timeMonth(): Date = js.native
  @JSImport("plotly.js", "d3.timeMonth")
  @js.native
  def timeMonth(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.timeMonth")
  @js.native
  val timeMonth_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.timeMonths")
  @js.native
  def timeMonths(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.timeMonths")
  @js.native
  def timeMonths(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  @JSImport("plotly.js", "d3.timeParse")
  @js.native
  def timeParse(specifier: String): js.Function1[/* dateString */ String, Date | Null] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.timeSaturday")
  @js.native
  def timeSaturday(): Date = js.native
  @JSImport("plotly.js", "d3.timeSaturday")
  @js.native
  def timeSaturday(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.timeSaturday")
  @js.native
  val timeSaturday_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.timeSaturdays")
  @js.native
  def timeSaturdays(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.timeSaturdays")
  @js.native
  def timeSaturdays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.timeSecond")
  @js.native
  def timeSecond(): Date = js.native
  @JSImport("plotly.js", "d3.timeSecond")
  @js.native
  def timeSecond(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.timeSecond")
  @js.native
  val timeSecond_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.timeSeconds")
  @js.native
  def timeSeconds(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.timeSeconds")
  @js.native
  def timeSeconds(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.timeSunday")
  @js.native
  def timeSunday(): Date = js.native
  @JSImport("plotly.js", "d3.timeSunday")
  @js.native
  def timeSunday(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.timeSunday")
  @js.native
  val timeSunday_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.timeSundays")
  @js.native
  def timeSundays(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.timeSundays")
  @js.native
  def timeSundays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.timeThursday")
  @js.native
  def timeThursday(): Date = js.native
  @JSImport("plotly.js", "d3.timeThursday")
  @js.native
  def timeThursday(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.timeThursday")
  @js.native
  val timeThursday_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.timeThursdays")
  @js.native
  def timeThursdays(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.timeThursdays")
  @js.native
  def timeThursdays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.timeTuesday")
  @js.native
  def timeTuesday(): Date = js.native
  @JSImport("plotly.js", "d3.timeTuesday")
  @js.native
  def timeTuesday(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.timeTuesday")
  @js.native
  val timeTuesday_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.timeTuesdays")
  @js.native
  def timeTuesdays(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.timeTuesdays")
  @js.native
  def timeTuesdays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.timeWednesday")
  @js.native
  def timeWednesday(): Date = js.native
  @JSImport("plotly.js", "d3.timeWednesday")
  @js.native
  def timeWednesday(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.timeWednesday")
  @js.native
  val timeWednesday_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.timeWednesdays")
  @js.native
  def timeWednesdays(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.timeWednesdays")
  @js.native
  def timeWednesdays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.timeWeek")
  @js.native
  def timeWeek(): Date = js.native
  @JSImport("plotly.js", "d3.timeWeek")
  @js.native
  def timeWeek(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.timeWeek")
  @js.native
  val timeWeek_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.timeWeeks")
  @js.native
  def timeWeeks(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.timeWeeks")
  @js.native
  def timeWeeks(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.timeYear")
  @js.native
  def timeYear(): Date = js.native
  @JSImport("plotly.js", "d3.timeYear")
  @js.native
  def timeYear(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.timeYear")
  @js.native
  val timeYear_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.timeYears")
  @js.native
  def timeYears(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.timeYears")
  @js.native
  def timeYears(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  @JSImport("plotly.js", "d3.timeout")
  @js.native
  def timeout(callback: js.Function1[/* elapsed */ Double, Unit]): Timer_ = js.native
  @JSImport("plotly.js", "d3.timeout")
  @js.native
  def timeout(callback: js.Function1[/* elapsed */ Double, Unit], delay: js.UndefOr[scala.Nothing], time: Double): Timer_ = js.native
  @JSImport("plotly.js", "d3.timeout")
  @js.native
  def timeout(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double): Timer_ = js.native
  @JSImport("plotly.js", "d3.timeout")
  @js.native
  def timeout(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double, time: Double): Timer_ = js.native
  
  @JSImport("plotly.js", "d3.timer")
  @js.native
  def timer(callback: js.Function1[/* elapsed */ Double, Unit]): Timer_ = js.native
  @JSImport("plotly.js", "d3.timer")
  @js.native
  def timer(callback: js.Function1[/* elapsed */ Double, Unit], delay: js.UndefOr[scala.Nothing], time: Double): Timer_ = js.native
  @JSImport("plotly.js", "d3.timer")
  @js.native
  def timer(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double): Timer_ = js.native
  @JSImport("plotly.js", "d3.timer")
  @js.native
  def timer(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double, time: Double): Timer_ = js.native
  
  @JSImport("plotly.js", "d3.timerFlush")
  @js.native
  def timerFlush(): Unit = js.native
  
  @JSImport("plotly.js", "d3.transition")
  @js.native
  def transition[OldDatum](): Transition_[HTMLElement, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.transition")
  @js.native
  def transition[OldDatum](name: String): Transition_[HTMLElement, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  @JSImport("plotly.js", "d3.transition")
  @js.native
  def transition[OldDatum](transition: Transition_[BaseType, _, BaseType, _]): Transition_[HTMLElement, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  
  @JSImport("plotly.js", "d3.transpose")
  @js.native
  def transpose[T](matrix: ArrayLike[ArrayLike[T]]): js.Array[js.Array[T]] = js.native
  
  @JSImport("plotly.js", "d3.tree")
  @js.native
  def tree[Datum](): TreeLayout[Datum] = js.native
  
  @JSImport("plotly.js", "d3.treemap")
  @js.native
  def treemap[Datum](): TreemapLayout[Datum] = js.native
  
  @JSImport("plotly.js", "d3.treemapBinary")
  @js.native
  def treemapBinary(node: HierarchyRectangularNode[_], x0: Double, y0: Double, x1: Double, y1: Double): Unit = js.native
  
  @JSImport("plotly.js", "d3.treemapDice")
  @js.native
  def treemapDice(node: HierarchyRectangularNode[_], x0: Double, y0: Double, x1: Double, y1: Double): Unit = js.native
  
  @JSImport("plotly.js", "d3.treemapResquarify")
  @js.native
  val treemapResquarify: RatioSquarifyTilingFactory = js.native
  @JSImport("plotly.js", "d3.treemapResquarify")
  @js.native
  def treemapResquarify(node: HierarchyRectangularNode[_], x0: Double, y0: Double, x1: Double, y1: Double): Unit = js.native
  
  @JSImport("plotly.js", "d3.treemapSlice")
  @js.native
  def treemapSlice(node: HierarchyRectangularNode[_], x0: Double, y0: Double, x1: Double, y1: Double): Unit = js.native
  
  @JSImport("plotly.js", "d3.treemapSliceDice")
  @js.native
  def treemapSliceDice(node: HierarchyRectangularNode[_], x0: Double, y0: Double, x1: Double, y1: Double): Unit = js.native
  
  @JSImport("plotly.js", "d3.treemapSquarify")
  @js.native
  val treemapSquarify: RatioSquarifyTilingFactory = js.native
  @JSImport("plotly.js", "d3.treemapSquarify")
  @js.native
  def treemapSquarify(node: HierarchyRectangularNode[_], x0: Double, y0: Double, x1: Double, y1: Double): Unit = js.native
  
  @JSImport("plotly.js", "d3.tsv")
  @js.native
  def tsv[Columns /* <: String */](url: String): js.Promise[DSVRowArray[Columns]] = js.native
  @JSImport("plotly.js", "d3.tsv")
  @js.native
  def tsv[Columns /* <: String */](url: String, init: RequestInit): js.Promise[DSVRowArray[Columns]] = js.native
  @JSImport("plotly.js", "d3.tsv")
  @js.native
  def tsv[ParsedRow /* <: js.Object */, Columns /* <: String */](
    url: String,
    init: RequestInit,
    row: js.Function3[
      /* rawRow */ DSVRowString[Columns], 
      /* index */ Double, 
      /* columns */ js.Array[Columns], 
      js.UndefOr[ParsedRow | Null]
    ]
  ): js.Promise[DSVParsedArray[ParsedRow]] = js.native
  @JSImport("plotly.js", "d3.tsv")
  @js.native
  def tsv[ParsedRow /* <: js.Object */, Columns /* <: String */](
    url: String,
    row: js.Function3[
      /* rawRow */ DSVRowString[Columns], 
      /* index */ Double, 
      /* columns */ js.Array[Columns], 
      js.UndefOr[ParsedRow | Null]
    ]
  ): js.Promise[DSVParsedArray[ParsedRow]] = js.native
  
  @JSImport("plotly.js", "d3.tsvFormat")
  @js.native
  def tsvFormat[T /* <: js.Object */](rows: js.Array[T]): String = js.native
  @JSImport("plotly.js", "d3.tsvFormat")
  @js.native
  def tsvFormat[T /* <: js.Object */](rows: js.Array[T], columns: js.Array[/* keyof T */ String]): String = js.native
  
  @JSImport("plotly.js", "d3.tsvFormatBody")
  @js.native
  def tsvFormatBody[T /* <: js.Object */](rows: js.Array[T]): String = js.native
  @JSImport("plotly.js", "d3.tsvFormatBody")
  @js.native
  def tsvFormatBody[T /* <: js.Object */](rows: js.Array[T], columns: js.Array[/* keyof T */ String]): String = js.native
  
  @JSImport("plotly.js", "d3.tsvFormatRow")
  @js.native
  def tsvFormatRow(row: js.Array[String]): String = js.native
  
  @JSImport("plotly.js", "d3.tsvFormatRows")
  @js.native
  def tsvFormatRows(rows: js.Array[js.Array[String]]): String = js.native
  
  @JSImport("plotly.js", "d3.tsvFormatValue")
  @js.native
  def tsvFormatValue(value: String): String = js.native
  
  @JSImport("plotly.js", "d3.tsvParse")
  @js.native
  def tsvParse[Columns /* <: String */](tsvString: String): DSVRowArray[Columns] = js.native
  @JSImport("plotly.js", "d3.tsvParse")
  @js.native
  def tsvParse[ParsedRow /* <: js.Object */, Columns /* <: String */](
    tsvString: String,
    row: js.Function3[
      /* rawRow */ DSVRowString[Columns], 
      /* index */ Double, 
      /* columns */ js.Array[Columns], 
      js.UndefOr[ParsedRow | Null]
    ]
  ): DSVParsedArray[ParsedRow] = js.native
  
  @JSImport("plotly.js", "d3.tsvParseRows")
  @js.native
  def tsvParseRows(tsvString: String): js.Array[js.Array[String]] = js.native
  @JSImport("plotly.js", "d3.tsvParseRows")
  @js.native
  def tsvParseRows[ParsedRow /* <: js.Object */](
    tsvString: String,
    row: js.Function2[/* rawRow */ js.Array[String], /* index */ Double, js.UndefOr[ParsedRow | Null]]
  ): js.Array[ParsedRow] = js.native
  
  @JSImport("plotly.js", "d3.union")
  @js.native
  def union[T](iterables: Iterable[T]*): Set[T] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.utcDay")
  @js.native
  def utcDay(): Date = js.native
  @JSImport("plotly.js", "d3.utcDay")
  @js.native
  def utcDay(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.utcDay")
  @js.native
  val utcDay_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.utcDays")
  @js.native
  def utcDays(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.utcDays")
  @js.native
  def utcDays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  @JSImport("plotly.js", "d3.utcFormat")
  @js.native
  def utcFormat(specifier: String): js.Function1[/* date */ Date, String] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.utcFriday")
  @js.native
  def utcFriday(): Date = js.native
  @JSImport("plotly.js", "d3.utcFriday")
  @js.native
  def utcFriday(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.utcFriday")
  @js.native
  val utcFriday_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.utcFridays")
  @js.native
  def utcFridays(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.utcFridays")
  @js.native
  def utcFridays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.utcHour")
  @js.native
  def utcHour(): Date = js.native
  @JSImport("plotly.js", "d3.utcHour")
  @js.native
  def utcHour(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.utcHour")
  @js.native
  val utcHour_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.utcHours")
  @js.native
  def utcHours(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.utcHours")
  @js.native
  def utcHours(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.utcMillisecond")
  @js.native
  def utcMillisecond(): Date = js.native
  @JSImport("plotly.js", "d3.utcMillisecond")
  @js.native
  def utcMillisecond(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.utcMillisecond")
  @js.native
  val utcMillisecond_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.utcMilliseconds")
  @js.native
  def utcMilliseconds(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.utcMilliseconds")
  @js.native
  def utcMilliseconds(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.utcMinute")
  @js.native
  def utcMinute(): Date = js.native
  @JSImport("plotly.js", "d3.utcMinute")
  @js.native
  def utcMinute(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.utcMinute")
  @js.native
  val utcMinute_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.utcMinutes")
  @js.native
  def utcMinutes(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.utcMinutes")
  @js.native
  def utcMinutes(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.utcMonday")
  @js.native
  def utcMonday(): Date = js.native
  @JSImport("plotly.js", "d3.utcMonday")
  @js.native
  def utcMonday(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.utcMonday")
  @js.native
  val utcMonday_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.utcMondays")
  @js.native
  def utcMondays(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.utcMondays")
  @js.native
  def utcMondays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.utcMonth")
  @js.native
  def utcMonth(): Date = js.native
  @JSImport("plotly.js", "d3.utcMonth")
  @js.native
  def utcMonth(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.utcMonth")
  @js.native
  val utcMonth_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.utcMonths")
  @js.native
  def utcMonths(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.utcMonths")
  @js.native
  def utcMonths(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  @JSImport("plotly.js", "d3.utcParse")
  @js.native
  def utcParse(specifier: String): js.Function1[/* dateString */ String, Date | Null] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.utcSaturday")
  @js.native
  def utcSaturday(): Date = js.native
  @JSImport("plotly.js", "d3.utcSaturday")
  @js.native
  def utcSaturday(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.utcSaturday")
  @js.native
  val utcSaturday_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.utcSaturdays")
  @js.native
  def utcSaturdays(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.utcSaturdays")
  @js.native
  def utcSaturdays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.utcSecond")
  @js.native
  def utcSecond(): Date = js.native
  @JSImport("plotly.js", "d3.utcSecond")
  @js.native
  def utcSecond(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.utcSecond")
  @js.native
  val utcSecond_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.utcSeconds")
  @js.native
  def utcSeconds(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.utcSeconds")
  @js.native
  def utcSeconds(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.utcSunday")
  @js.native
  def utcSunday(): Date = js.native
  @JSImport("plotly.js", "d3.utcSunday")
  @js.native
  def utcSunday(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.utcSunday")
  @js.native
  val utcSunday_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.utcSundays")
  @js.native
  def utcSundays(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.utcSundays")
  @js.native
  def utcSundays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.utcThursday")
  @js.native
  def utcThursday(): Date = js.native
  @JSImport("plotly.js", "d3.utcThursday")
  @js.native
  def utcThursday(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.utcThursday")
  @js.native
  val utcThursday_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.utcThursdays")
  @js.native
  def utcThursdays(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.utcThursdays")
  @js.native
  def utcThursdays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.utcTuesday")
  @js.native
  def utcTuesday(): Date = js.native
  @JSImport("plotly.js", "d3.utcTuesday")
  @js.native
  def utcTuesday(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.utcTuesday")
  @js.native
  val utcTuesday_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.utcTuesdays")
  @js.native
  def utcTuesdays(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.utcTuesdays")
  @js.native
  def utcTuesdays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.utcWednesday")
  @js.native
  def utcWednesday(): Date = js.native
  @JSImport("plotly.js", "d3.utcWednesday")
  @js.native
  def utcWednesday(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.utcWednesday")
  @js.native
  val utcWednesday_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.utcWednesdays")
  @js.native
  def utcWednesdays(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.utcWednesdays")
  @js.native
  def utcWednesdays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.utcWeek")
  @js.native
  def utcWeek(): Date = js.native
  @JSImport("plotly.js", "d3.utcWeek")
  @js.native
  def utcWeek(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.utcWeek")
  @js.native
  val utcWeek_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.utcWeeks")
  @js.native
  def utcWeeks(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.utcWeeks")
  @js.native
  def utcWeeks(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  @JSImport("plotly.js", "d3.utcYear")
  @js.native
  def utcYear(): Date = js.native
  @JSImport("plotly.js", "d3.utcYear")
  @js.native
  def utcYear(date: Date): Date = js.native
  @JSImport("plotly.js", "d3.utcYear")
  @js.native
  val utcYear_Fd3: CountableTimeInterval = js.native
  
  @JSImport("plotly.js", "d3.utcYears")
  @js.native
  def utcYears(start: Date, stop: Date): js.Array[Date] = js.native
  @JSImport("plotly.js", "d3.utcYears")
  @js.native
  def utcYears(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  
  @JSImport("plotly.js", "d3.variance")
  @js.native
  def variance[T /* <: Numeric */](iterable: Iterable[js.UndefOr[T | Null]]): js.UndefOr[Double] = js.native
  @JSImport("plotly.js", "d3.variance")
  @js.native
  def variance[T](
    iterable: Iterable[T],
    accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[Double | Null]]
  ): js.UndefOr[Double] = js.native
  
  @JSImport("plotly.js", "d3.version")
  @js.native
  val version: String = js.native
  
  @JSImport("plotly.js", "d3.window")
  @js.native
  def window(DOMNode: Document): Window = js.native
  @JSImport("plotly.js", "d3.window")
  @js.native
  def window(DOMNode: Element): Window = js.native
  @JSImport("plotly.js", "d3.window")
  @js.native
  def window(DOMNode: Window): Window = js.native
  
  @JSImport("plotly.js", "d3.xml")
  @js.native
  def xml(url: String): js.Promise[XMLDocument] = js.native
  @JSImport("plotly.js", "d3.xml")
  @js.native
  def xml(url: String, init: RequestInit): js.Promise[XMLDocument] = js.native
  
  @JSImport("plotly.js", "d3.zip")
  @js.native
  def zip[T](arrays: ArrayLike[T]*): js.Array[js.Array[T]] = js.native
  
  @JSImport("plotly.js", "d3.zoom")
  @js.native
  def zoom[ZoomRefElement /* <: ZoomedElementBaseType */, Datum](): ZoomBehavior[ZoomRefElement, Datum] = js.native
  
  @JSImport("plotly.js", "d3.zoomIdentity")
  @js.native
  val zoomIdentity: ZoomTransform_ = js.native
  
  @JSImport("plotly.js", "d3.zoomTransform")
  @js.native
  def zoomTransform(node: ZoomedElementBaseType): ZoomTransform_ = js.native
  
  @JSImport("plotly.js", "d3.bin")
  @js.native
  def `bin_DatumValue_UnionDate<undefined>_HistogramGeneratorDate`[Datum, Value /* <: js.UndefOr[Date] */](): HistogramGeneratorDate[Datum, Value] = js.native
  @JSImport("plotly.js", "d3.bin")
  @js.native
  def `bin_DatumValue_UnionDouble<undefined>`[Datum, Value /* <: js.UndefOr[Double] */](): HistogramGeneratorNumber[Datum, Value] = js.native
  
  @JSImport("plotly.js", "d3.histogram")
  @js.native
  def `histogram_DatumValue_UnionDate<undefined>_HistogramGeneratorDate`[Datum, Value /* <: js.UndefOr[Date] */](): HistogramGeneratorDate[Datum, Value] = js.native
  @JSImport("plotly.js", "d3.histogram")
  @js.native
  def `histogram_DatumValue_UnionDouble<undefined>`[Datum, Value /* <: js.UndefOr[Double] */](): HistogramGeneratorNumber[Datum, Value] = js.native
}
