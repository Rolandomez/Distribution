package typings.plotlyJs

import org.scalablytyped.runtime.Instantiable0
import org.scalablytyped.runtime.Instantiable1
import org.scalablytyped.runtime.NumberDictionary
import org.scalablytyped.runtime.StringDictionary
import typings.d3.mod.FormatSpecifier_
import typings.d3Array.anon.FnCall
import typings.d3Array.mod.Bisector_
import typings.d3Array.mod.HistogramGeneratorDate
import typings.d3Array.mod.HistogramGeneratorNumber
import typings.d3Array.mod.Numeric
import typings.d3Array.mod.Primitive
import typings.d3Axis.mod.Axis
import typings.d3Axis.mod.AxisDomain
import typings.d3Axis.mod.AxisScale
import typings.d3Brush.mod.BrushBehavior
import typings.d3Brush.mod.BrushSelection_
import typings.d3Chord.mod.ChordLayout
import typings.d3Chord.mod.RibbonGenerator
import typings.d3Chord.mod.RibbonSubgroup
import typings.d3Chord.mod.Ribbon_
import typings.d3Color.mod.ColorCommonInstance
import typings.d3Color.mod.ColorFactory
import typings.d3Color.mod.ColorSpaceObject
import typings.d3Color.mod.CubehelixColor
import typings.d3Color.mod.CubehelixColorFactory
import typings.d3Color.mod.HCLColor
import typings.d3Color.mod.HCLColorFactory
import typings.d3Color.mod.HSLColor
import typings.d3Color.mod.HSLColorFactory
import typings.d3Color.mod.LabColor
import typings.d3Color.mod.LabColorFactory
import typings.d3Color.mod.RGBColor
import typings.d3Color.mod.RGBColorFactory
import typings.d3Contour.mod.ContourDensity_
import typings.d3Contour.mod.Contours_
import typings.d3Dispatch.mod.Dispatch_
import typings.d3Drag.mod.DragBehavior
import typings.d3Drag.mod.DraggedElementBaseType
import typings.d3Drag.mod.SubjectPosition
import typings.d3Dsv.mod.DSV
import typings.d3Dsv.mod.DSVParsedArray
import typings.d3Dsv.mod.DSVRowArray
import typings.d3Dsv.mod.DSVRowString
import typings.d3Ease.mod.BackEasingFactory
import typings.d3Ease.mod.ElasticEasingFactory
import typings.d3Ease.mod.PolynomialEasingFactory
import typings.d3Fetch.anon.PartialHTMLImageElement
import typings.d3Force.mod.ForceCenter_
import typings.d3Force.mod.ForceCollide_
import typings.d3Force.mod.ForceLink_
import typings.d3Force.mod.ForceManyBody_
import typings.d3Force.mod.ForceRadial_
import typings.d3Force.mod.ForceX_
import typings.d3Force.mod.ForceY_
import typings.d3Force.mod.Simulation
import typings.d3Force.mod.SimulationLinkDatum
import typings.d3Force.mod.SimulationNodeDatum
import typings.d3Format.anon.ValueOf
import typings.d3Format.mod.FormatLocaleDefinition
import typings.d3Format.mod.FormatLocaleObject
import typings.d3Format.mod.FormatSpecifierObject
import typings.d3Geo.anon.`0`
import typings.d3Geo.mod.ExtendedFeature
import typings.d3Geo.mod.ExtendedFeatureCollection
import typings.d3Geo.mod.ExtendedGeometryCollection
import typings.d3Geo.mod.GeoCircleGenerator
import typings.d3Geo.mod.GeoConicProjection
import typings.d3Geo.mod.GeoContext
import typings.d3Geo.mod.GeoGeometryObjects
import typings.d3Geo.mod.GeoGraticuleGenerator
import typings.d3Geo.mod.GeoIdentityTransform
import typings.d3Geo.mod.GeoPath_
import typings.d3Geo.mod.GeoPermissibleObjects
import typings.d3Geo.mod.GeoProjection_
import typings.d3Geo.mod.GeoRawProjection
import typings.d3Geo.mod.GeoRotation_
import typings.d3Geo.mod.GeoStreamWrapper
import typings.d3Geo.mod.GeoStream_
import typings.d3Geo.mod.GeoTransformPrototype
import typings.d3Hierarchy.mod.ClusterLayout
import typings.d3Hierarchy.mod.HierarchyNode
import typings.d3Hierarchy.mod.HierarchyRectangularNode
import typings.d3Hierarchy.mod.PackCircle
import typings.d3Hierarchy.mod.PackLayout
import typings.d3Hierarchy.mod.PackRadius
import typings.d3Hierarchy.mod.PartitionLayout
import typings.d3Hierarchy.mod.RatioSquarifyTilingFactory
import typings.d3Hierarchy.mod.StratifyOperator
import typings.d3Hierarchy.mod.TreeLayout
import typings.d3Hierarchy.mod.TreemapLayout
import typings.d3Interpolate.anon.ToString
import typings.d3Interpolate.mod.ArrayInterpolator
import typings.d3Interpolate.mod.ColorGammaInterpolationFactory
import typings.d3Interpolate.mod.NumberArray
import typings.d3Interpolate.mod.ZoomInterpolator
import typings.d3Interpolate.mod.ZoomView
import typings.d3Path.mod.Path_
import typings.d3Quadtree.mod.Quadtree_
import typings.d3Random.mod.RandomBates_
import typings.d3Random.mod.RandomBernoulli_
import typings.d3Random.mod.RandomBeta_
import typings.d3Random.mod.RandomBinomial_
import typings.d3Random.mod.RandomCauchy_
import typings.d3Random.mod.RandomExponential_
import typings.d3Random.mod.RandomGamma_
import typings.d3Random.mod.RandomGeometric_
import typings.d3Random.mod.RandomInt_
import typings.d3Random.mod.RandomIrwinHall_
import typings.d3Random.mod.RandomLogNormal_
import typings.d3Random.mod.RandomLogistic_
import typings.d3Random.mod.RandomNormal_
import typings.d3Random.mod.RandomPareto_
import typings.d3Random.mod.RandomPoisson_
import typings.d3Random.mod.RandomUniform_
import typings.d3Random.mod.RandomWeibull_
import typings.d3Scale.mod.NumberValue
import typings.d3Scale.mod.ScaleBand_
import typings.d3Scale.mod.ScaleDiverging_
import typings.d3Scale.mod.ScaleIdentity_
import typings.d3Scale.mod.ScaleLinear_
import typings.d3Scale.mod.ScaleLogarithmic
import typings.d3Scale.mod.ScaleOrdinal_
import typings.d3Scale.mod.ScalePoint_
import typings.d3Scale.mod.ScalePower
import typings.d3Scale.mod.ScaleQuantile_
import typings.d3Scale.mod.ScaleQuantize_
import typings.d3Scale.mod.ScaleRadial_
import typings.d3Scale.mod.ScaleSequentialQuantile_
import typings.d3Scale.mod.ScaleSequential_
import typings.d3Scale.mod.ScaleSymLog_
import typings.d3Scale.mod.ScaleThreshold_
import typings.d3Scale.mod.ScaleTime_
import typings.d3Selection.mod.BaseType
import typings.d3Selection.mod.EnterElement
import typings.d3Selection.mod.Local_
import typings.d3Selection.mod.NamespaceLocalObject
import typings.d3Selection.mod.NamespaceMap
import typings.d3Selection.mod.Selection_
import typings.d3Shape.mod.Arc_
import typings.d3Shape.mod.AreaRadial_
import typings.d3Shape.mod.Area_
import typings.d3Shape.mod.CurveBundleFactory
import typings.d3Shape.mod.CurveCardinalFactory
import typings.d3Shape.mod.CurveCatmullRomFactory
import typings.d3Shape.mod.CurveGenerator
import typings.d3Shape.mod.DefaultArcObject
import typings.d3Shape.mod.DefaultLinkObject
import typings.d3Shape.mod.LineRadial_
import typings.d3Shape.mod.Line_
import typings.d3Shape.mod.Link
import typings.d3Shape.mod.LinkRadial_
import typings.d3Shape.mod.Pie_
import typings.d3Shape.mod.RadialArea_
import typings.d3Shape.mod.RadialLine_
import typings.d3Shape.mod.Series
import typings.d3Shape.mod.Stack_
import typings.d3Shape.mod.SymbolType
import typings.d3Shape.mod.Symbol_
import typings.d3Time.mod.CountableTimeInterval
import typings.d3Time.mod.TimeInterval_
import typings.d3TimeFormat.mod.TimeLocaleDefinition
import typings.d3TimeFormat.mod.TimeLocaleObject
import typings.d3Timer.mod.Timer_
import typings.d3Transition.mod.Transition_
import typings.d3Zoom.mod.ZoomBehavior
import typings.d3Zoom.mod.ZoomTransform_
import typings.d3Zoom.mod.ZoomedElementBaseType
import typings.geojson.mod.GeoJsonProperties
import typings.geojson.mod.MultiLineString
import typings.plotlyJs.anon.PartialConfig
import typings.plotlyJs.anon.PartialFrame
import typings.plotlyJs.anon.PartialLayout
import typings.plotlyJs.anon.TypeofDelaunay
import typings.plotlyJs.anon.Typeofbisect
import typings.plotlyJs.anon.TypeofscaleImplicit
import typings.plotlyJs.mod.Data
import typings.plotlyJs.mod.DownloadImgopts
import typings.plotlyJs.mod.PlotlyHTMLElement
import typings.plotlyJs.mod.Root
import typings.plotlyJs.mod.StaticPlots
import typings.plotlyJs.mod.ToImgopts
import typings.plotlyJs.plotlyJsStrings.`object`
import typings.plotlyJs.plotlyJsStrings.`var`
import typings.plotlyJs.plotlyJsStrings.a
import typings.plotlyJs.plotlyJsStrings.abbr
import typings.plotlyJs.plotlyJsStrings.address
import typings.plotlyJs.plotlyJsStrings.applet
import typings.plotlyJs.plotlyJsStrings.area
import typings.plotlyJs.plotlyJsStrings.article
import typings.plotlyJs.plotlyJsStrings.aside
import typings.plotlyJs.plotlyJsStrings.audio
import typings.plotlyJs.plotlyJsStrings.b_
import typings.plotlyJs.plotlyJsStrings.base
import typings.plotlyJs.plotlyJsStrings.basefont
import typings.plotlyJs.plotlyJsStrings.bdi
import typings.plotlyJs.plotlyJsStrings.bdo
import typings.plotlyJs.plotlyJsStrings.blockquote
import typings.plotlyJs.plotlyJsStrings.body
import typings.plotlyJs.plotlyJsStrings.br
import typings.plotlyJs.plotlyJsStrings.button
import typings.plotlyJs.plotlyJsStrings.canvas
import typings.plotlyJs.plotlyJsStrings.caption
import typings.plotlyJs.plotlyJsStrings.circle
import typings.plotlyJs.plotlyJsStrings.cite
import typings.plotlyJs.plotlyJsStrings.clipPath
import typings.plotlyJs.plotlyJsStrings.code
import typings.plotlyJs.plotlyJsStrings.col
import typings.plotlyJs.plotlyJsStrings.colgroup
import typings.plotlyJs.plotlyJsStrings.data
import typings.plotlyJs.plotlyJsStrings.datalist
import typings.plotlyJs.plotlyJsStrings.dd
import typings.plotlyJs.plotlyJsStrings.defs
import typings.plotlyJs.plotlyJsStrings.del
import typings.plotlyJs.plotlyJsStrings.desc
import typings.plotlyJs.plotlyJsStrings.details
import typings.plotlyJs.plotlyJsStrings.dfn
import typings.plotlyJs.plotlyJsStrings.dialog
import typings.plotlyJs.plotlyJsStrings.dir
import typings.plotlyJs.plotlyJsStrings.div
import typings.plotlyJs.plotlyJsStrings.dl
import typings.plotlyJs.plotlyJsStrings.dt
import typings.plotlyJs.plotlyJsStrings.ellipse
import typings.plotlyJs.plotlyJsStrings.em
import typings.plotlyJs.plotlyJsStrings.embed
import typings.plotlyJs.plotlyJsStrings.feBlend
import typings.plotlyJs.plotlyJsStrings.feColorMatrix
import typings.plotlyJs.plotlyJsStrings.feComponentTransfer
import typings.plotlyJs.plotlyJsStrings.feComposite
import typings.plotlyJs.plotlyJsStrings.feConvolveMatrix
import typings.plotlyJs.plotlyJsStrings.feDiffuseLighting
import typings.plotlyJs.plotlyJsStrings.feDisplacementMap
import typings.plotlyJs.plotlyJsStrings.feDistantLight
import typings.plotlyJs.plotlyJsStrings.feFlood
import typings.plotlyJs.plotlyJsStrings.feFuncA
import typings.plotlyJs.plotlyJsStrings.feFuncB
import typings.plotlyJs.plotlyJsStrings.feFuncG
import typings.plotlyJs.plotlyJsStrings.feFuncR
import typings.plotlyJs.plotlyJsStrings.feGaussianBlur
import typings.plotlyJs.plotlyJsStrings.feImage
import typings.plotlyJs.plotlyJsStrings.feMerge
import typings.plotlyJs.plotlyJsStrings.feMergeNode
import typings.plotlyJs.plotlyJsStrings.feMorphology
import typings.plotlyJs.plotlyJsStrings.feOffset
import typings.plotlyJs.plotlyJsStrings.fePointLight
import typings.plotlyJs.plotlyJsStrings.feSpecularLighting
import typings.plotlyJs.plotlyJsStrings.feSpotLight
import typings.plotlyJs.plotlyJsStrings.feTile
import typings.plotlyJs.plotlyJsStrings.feTurbulence
import typings.plotlyJs.plotlyJsStrings.fieldset
import typings.plotlyJs.plotlyJsStrings.figcaption
import typings.plotlyJs.plotlyJsStrings.figure
import typings.plotlyJs.plotlyJsStrings.filter
import typings.plotlyJs.plotlyJsStrings.font
import typings.plotlyJs.plotlyJsStrings.footer
import typings.plotlyJs.plotlyJsStrings.foreignObject
import typings.plotlyJs.plotlyJsStrings.form
import typings.plotlyJs.plotlyJsStrings.frame
import typings.plotlyJs.plotlyJsStrings.frameset
import typings.plotlyJs.plotlyJsStrings.g
import typings.plotlyJs.plotlyJsStrings.h1
import typings.plotlyJs.plotlyJsStrings.h2
import typings.plotlyJs.plotlyJsStrings.h3
import typings.plotlyJs.plotlyJsStrings.h4
import typings.plotlyJs.plotlyJsStrings.h5
import typings.plotlyJs.plotlyJsStrings.h6
import typings.plotlyJs.plotlyJsStrings.head
import typings.plotlyJs.plotlyJsStrings.header
import typings.plotlyJs.plotlyJsStrings.hgroup
import typings.plotlyJs.plotlyJsStrings.hr
import typings.plotlyJs.plotlyJsStrings.html
import typings.plotlyJs.plotlyJsStrings.i
import typings.plotlyJs.plotlyJsStrings.iframe
import typings.plotlyJs.plotlyJsStrings.image
import typings.plotlyJs.plotlyJsStrings.img
import typings.plotlyJs.plotlyJsStrings.input
import typings.plotlyJs.plotlyJsStrings.ins
import typings.plotlyJs.plotlyJsStrings.kbd
import typings.plotlyJs.plotlyJsStrings.label
import typings.plotlyJs.plotlyJsStrings.legend
import typings.plotlyJs.plotlyJsStrings.li
import typings.plotlyJs.plotlyJsStrings.line
import typings.plotlyJs.plotlyJsStrings.linearGradient
import typings.plotlyJs.plotlyJsStrings.link
import typings.plotlyJs.plotlyJsStrings.main
import typings.plotlyJs.plotlyJsStrings.map
import typings.plotlyJs.plotlyJsStrings.mark
import typings.plotlyJs.plotlyJsStrings.marker
import typings.plotlyJs.plotlyJsStrings.marquee
import typings.plotlyJs.plotlyJsStrings.mask
import typings.plotlyJs.plotlyJsStrings.menu
import typings.plotlyJs.plotlyJsStrings.meta
import typings.plotlyJs.plotlyJsStrings.metadata
import typings.plotlyJs.plotlyJsStrings.meter
import typings.plotlyJs.plotlyJsStrings.nav
import typings.plotlyJs.plotlyJsStrings.noscript
import typings.plotlyJs.plotlyJsStrings.ol
import typings.plotlyJs.plotlyJsStrings.optgroup
import typings.plotlyJs.plotlyJsStrings.option
import typings.plotlyJs.plotlyJsStrings.output
import typings.plotlyJs.plotlyJsStrings.p
import typings.plotlyJs.plotlyJsStrings.param
import typings.plotlyJs.plotlyJsStrings.path
import typings.plotlyJs.plotlyJsStrings.pattern
import typings.plotlyJs.plotlyJsStrings.picture
import typings.plotlyJs.plotlyJsStrings.polygon
import typings.plotlyJs.plotlyJsStrings.polyline
import typings.plotlyJs.plotlyJsStrings.pre
import typings.plotlyJs.plotlyJsStrings.progress
import typings.plotlyJs.plotlyJsStrings.q
import typings.plotlyJs.plotlyJsStrings.radialGradient
import typings.plotlyJs.plotlyJsStrings.rect
import typings.plotlyJs.plotlyJsStrings.rp
import typings.plotlyJs.plotlyJsStrings.rt
import typings.plotlyJs.plotlyJsStrings.ruby
import typings.plotlyJs.plotlyJsStrings.s
import typings.plotlyJs.plotlyJsStrings.samp
import typings.plotlyJs.plotlyJsStrings.script
import typings.plotlyJs.plotlyJsStrings.section
import typings.plotlyJs.plotlyJsStrings.select
import typings.plotlyJs.plotlyJsStrings.slot
import typings.plotlyJs.plotlyJsStrings.small
import typings.plotlyJs.plotlyJsStrings.source
import typings.plotlyJs.plotlyJsStrings.span
import typings.plotlyJs.plotlyJsStrings.stop
import typings.plotlyJs.plotlyJsStrings.strong
import typings.plotlyJs.plotlyJsStrings.style
import typings.plotlyJs.plotlyJsStrings.sub
import typings.plotlyJs.plotlyJsStrings.summary
import typings.plotlyJs.plotlyJsStrings.sup
import typings.plotlyJs.plotlyJsStrings.svg
import typings.plotlyJs.plotlyJsStrings.switch
import typings.plotlyJs.plotlyJsStrings.symbol
import typings.plotlyJs.plotlyJsStrings.table
import typings.plotlyJs.plotlyJsStrings.tbody
import typings.plotlyJs.plotlyJsStrings.td
import typings.plotlyJs.plotlyJsStrings.template
import typings.plotlyJs.plotlyJsStrings.text
import typings.plotlyJs.plotlyJsStrings.textPath
import typings.plotlyJs.plotlyJsStrings.textarea
import typings.plotlyJs.plotlyJsStrings.tfoot
import typings.plotlyJs.plotlyJsStrings.th
import typings.plotlyJs.plotlyJsStrings.thead
import typings.plotlyJs.plotlyJsStrings.time
import typings.plotlyJs.plotlyJsStrings.title
import typings.plotlyJs.plotlyJsStrings.tr
import typings.plotlyJs.plotlyJsStrings.track
import typings.plotlyJs.plotlyJsStrings.tspan
import typings.plotlyJs.plotlyJsStrings.u
import typings.plotlyJs.plotlyJsStrings.ul
import typings.plotlyJs.plotlyJsStrings.use
import typings.plotlyJs.plotlyJsStrings.video
import typings.plotlyJs.plotlyJsStrings.view
import typings.plotlyJs.plotlyJsStrings.wbr
import typings.std.ArrayBuffer
import typings.std.ArrayLike
import typings.std.Blob
import typings.std.CanvasRenderingContext2D
import typings.std.DataView
import typings.std.Date
import typings.std.Document
import typings.std.Element
import typings.std.Float32Array
import typings.std.Float64Array
import typings.std.HTMLAnchorElement
import typings.std.HTMLAppletElement
import typings.std.HTMLAreaElement
import typings.std.HTMLAudioElement
import typings.std.HTMLBRElement
import typings.std.HTMLBaseElement
import typings.std.HTMLBaseFontElement
import typings.std.HTMLBodyElement
import typings.std.HTMLButtonElement
import typings.std.HTMLCanvasElement
import typings.std.HTMLDListElement
import typings.std.HTMLDataElement
import typings.std.HTMLDataListElement
import typings.std.HTMLDetailsElement
import typings.std.HTMLDialogElement
import typings.std.HTMLDirectoryElement
import typings.std.HTMLDivElement
import typings.std.HTMLElement
import typings.std.HTMLEmbedElement
import typings.std.HTMLFieldSetElement
import typings.std.HTMLFontElement
import typings.std.HTMLFormElement
import typings.std.HTMLFrameElement
import typings.std.HTMLFrameSetElement
import typings.std.HTMLHRElement
import typings.std.HTMLHeadElement
import typings.std.HTMLHeadingElement
import typings.std.HTMLHtmlElement
import typings.std.HTMLIFrameElement
import typings.std.HTMLImageElement
import typings.std.HTMLInputElement
import typings.std.HTMLLIElement
import typings.std.HTMLLabelElement
import typings.std.HTMLLegendElement
import typings.std.HTMLLinkElement
import typings.std.HTMLMapElement
import typings.std.HTMLMarqueeElement
import typings.std.HTMLMenuElement
import typings.std.HTMLMetaElement
import typings.std.HTMLMeterElement
import typings.std.HTMLModElement
import typings.std.HTMLOListElement
import typings.std.HTMLObjectElement
import typings.std.HTMLOptGroupElement
import typings.std.HTMLOptionElement
import typings.std.HTMLOutputElement
import typings.std.HTMLParagraphElement
import typings.std.HTMLParamElement
import typings.std.HTMLPictureElement
import typings.std.HTMLPreElement
import typings.std.HTMLProgressElement
import typings.std.HTMLQuoteElement
import typings.std.HTMLScriptElement
import typings.std.HTMLSelectElement
import typings.std.HTMLSlotElement
import typings.std.HTMLSourceElement
import typings.std.HTMLSpanElement
import typings.std.HTMLStyleElement
import typings.std.HTMLTableCaptionElement
import typings.std.HTMLTableColElement
import typings.std.HTMLTableDataCellElement
import typings.std.HTMLTableElement
import typings.std.HTMLTableHeaderCellElement
import typings.std.HTMLTableRowElement
import typings.std.HTMLTableSectionElement
import typings.std.HTMLTemplateElement
import typings.std.HTMLTextAreaElement
import typings.std.HTMLTimeElement
import typings.std.HTMLTitleElement
import typings.std.HTMLTrackElement
import typings.std.HTMLUListElement
import typings.std.HTMLVideoElement
import typings.std.Int16Array
import typings.std.Int32Array
import typings.std.Int8Array
import typings.std.Iterable
import typings.std.Map
import typings.std.NodeListOf
import typings.std.RequestInit
import typings.std.SVGCircleElement
import typings.std.SVGClipPathElement
import typings.std.SVGDefsElement
import typings.std.SVGDescElement
import typings.std.SVGEllipseElement
import typings.std.SVGFEBlendElement
import typings.std.SVGFEColorMatrixElement
import typings.std.SVGFEComponentTransferElement
import typings.std.SVGFECompositeElement
import typings.std.SVGFEConvolveMatrixElement
import typings.std.SVGFEDiffuseLightingElement
import typings.std.SVGFEDisplacementMapElement
import typings.std.SVGFEDistantLightElement
import typings.std.SVGFEFloodElement
import typings.std.SVGFEFuncAElement
import typings.std.SVGFEFuncBElement
import typings.std.SVGFEFuncGElement
import typings.std.SVGFEFuncRElement
import typings.std.SVGFEGaussianBlurElement
import typings.std.SVGFEImageElement
import typings.std.SVGFEMergeElement
import typings.std.SVGFEMergeNodeElement
import typings.std.SVGFEMorphologyElement
import typings.std.SVGFEOffsetElement
import typings.std.SVGFEPointLightElement
import typings.std.SVGFESpecularLightingElement
import typings.std.SVGFESpotLightElement
import typings.std.SVGFETileElement
import typings.std.SVGFETurbulenceElement
import typings.std.SVGFilterElement
import typings.std.SVGForeignObjectElement
import typings.std.SVGGElement
import typings.std.SVGImageElement
import typings.std.SVGLineElement
import typings.std.SVGLinearGradientElement
import typings.std.SVGMarkerElement
import typings.std.SVGMaskElement
import typings.std.SVGMetadataElement
import typings.std.SVGPathElement
import typings.std.SVGPatternElement
import typings.std.SVGPolygonElement
import typings.std.SVGPolylineElement
import typings.std.SVGRadialGradientElement
import typings.std.SVGRectElement
import typings.std.SVGSVGElement
import typings.std.SVGStopElement
import typings.std.SVGSwitchElement
import typings.std.SVGSymbolElement
import typings.std.SVGTSpanElement
import typings.std.SVGTextElement
import typings.std.SVGTextPathElement
import typings.std.SVGUseElement
import typings.std.SVGViewElement
import typings.std.Set
import typings.std.Uint16Array
import typings.std.Uint32Array
import typings.std.Uint8Array
import typings.std.Uint8ClampedArray
import typings.std.Window
import typings.std.XMLDocument
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object coreMod {
  
  @JSImport("plotly.js/lib/core", JSImport.Namespace)
  @js.native
  val ^ : js.Any = js.native
  
  @JSImport("plotly.js/lib/core", "Plots")
  @js.native
  val Plots: StaticPlots = js.native
  
  @scala.inline
  def addFrames(root: Root, frames: js.Array[PartialFrame]): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("addFrames")(root.asInstanceOf[js.Any], frames.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  
  @scala.inline
  def addTraces(root: Root, traces: js.Array[Data]): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("addTraces")(root.asInstanceOf[js.Any], traces.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def addTraces(root: Root, traces: js.Array[Data], newIndices: js.Array[Double]): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("addTraces")(root.asInstanceOf[js.Any], traces.asInstanceOf[js.Any], newIndices.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def addTraces(root: Root, traces: js.Array[Data], newIndices: Double): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("addTraces")(root.asInstanceOf[js.Any], traces.asInstanceOf[js.Any], newIndices.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def addTraces(root: Root, traces: Data): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("addTraces")(root.asInstanceOf[js.Any], traces.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def addTraces(root: Root, traces: Data, newIndices: js.Array[Double]): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("addTraces")(root.asInstanceOf[js.Any], traces.asInstanceOf[js.Any], newIndices.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def addTraces(root: Root, traces: Data, newIndices: Double): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("addTraces")(root.asInstanceOf[js.Any], traces.asInstanceOf[js.Any], newIndices.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  
  object d3 {
    
    @JSImport("plotly.js/lib/core", "d3")
    @js.native
    val ^ : js.Any = js.native
    
    /* This class was inferred from a value with a constructor. In rare cases (like HTMLElement in the DOM) it might not work as you expect. */
    @JSImport("plotly.js/lib/core", "d3.Adder")
    @js.native
    /**
      * Creates a full precision adder for IEEE 754 floating point numbers, setting its initial value to 0.
      */
    class Adder ()
      extends typings.d3.mod.Adder
    @JSImport("plotly.js/lib/core", "d3.Adder")
    @js.native
    def Adder: Instantiable0[typings.d3.mod.Adder] = js.native
    @scala.inline
    def Adder_=(x: Instantiable0[typings.d3.mod.Adder]): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("Adder")(x.asInstanceOf[js.Any])
    
    /* This class was inferred from a value with a constructor. In rare cases (like HTMLElement in the DOM) it might not work as you expect. */
    @JSImport("plotly.js/lib/core", "d3.Delaunay")
    @js.native
    class Delaunay[P] protected ()
      extends typings.d3.mod.Delaunay[P] {
      /**
        * Returns the Delaunay triangulation for the given flat array [x0, y0, x1, y1, …] of points.
        */
      def this(points: ArrayLike[Double]) = this()
    }
    @JSImport("plotly.js/lib/core", "d3.Delaunay")
    @js.native
    def Delaunay: js.Any | TypeofDelaunay = js.native
    @scala.inline
    def Delaunay_=(x: js.Any | TypeofDelaunay): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("Delaunay")(x.asInstanceOf[js.Any])
    
    /* This class was inferred from a value with a constructor. In rare cases (like HTMLElement in the DOM) it might not work as you expect. */
    @JSImport("plotly.js/lib/core", "d3.FormatSpecifier")
    @js.native
    class FormatSpecifier protected () extends FormatSpecifier_ {
      /**
        * Given the specified specifier object, returning an object with exposed fields that correspond to the format specification mini-language and a toString method that reconstructs the specifier.
        * @param specifier A specifier object.
        */
      def this(specifier: FormatSpecifierObject) = this()
    }
    @JSImport("plotly.js/lib/core", "d3.FormatSpecifier")
    @js.native
    def FormatSpecifier_ : Instantiable1[/* specifier */ FormatSpecifierObject, typings.d3.mod.FormatSpecifier_] = js.native
    
    @scala.inline
    def FormatSpecifier__=(x: Instantiable1[/* specifier */ FormatSpecifierObject, FormatSpecifier_]): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FormatSpecifier")(x.asInstanceOf[js.Any])
    
    /* This class was inferred from a value with a constructor. In rare cases (like HTMLElement in the DOM) it might not work as you expect. */
    @JSImport("plotly.js/lib/core", "d3.Voronoi")
    @js.native
    class Voronoi[P] ()
      extends typings.d3.mod.Voronoi[P]
    @JSImport("plotly.js/lib/core", "d3.Voronoi")
    @js.native
    def Voronoi: Instantiable0[typings.d3.mod.Voronoi[js.Object]] = js.native
    @scala.inline
    def Voronoi_=(x: Instantiable0[typings.d3.mod.Voronoi[js.Object]]): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("Voronoi")(x.asInstanceOf[js.Any])
    
    @scala.inline
    def active[Datum, PElement /* <: BaseType */, PDatum](): (Transition_[Null, Datum, PElement, PDatum]) | Null = ^.asInstanceOf[js.Dynamic].applyDynamic("active")().asInstanceOf[(Transition_[Null, Datum, PElement, PDatum]) | Null]
    @scala.inline
    def active[Datum, PElement /* <: BaseType */, PDatum](node: Null, name: String): (Transition_[Null, Datum, PElement, PDatum]) | Null = (^.asInstanceOf[js.Dynamic].applyDynamic("active")(node.asInstanceOf[js.Any], name.asInstanceOf[js.Any])).asInstanceOf[(Transition_[Null, Datum, PElement, PDatum]) | Null]
    @scala.inline
    def active[Datum, PElement /* <: BaseType */, PDatum](node: EnterElement): (Transition_[EnterElement, Datum, PElement, PDatum]) | Null = ^.asInstanceOf[js.Dynamic].applyDynamic("active")(node.asInstanceOf[js.Any]).asInstanceOf[(Transition_[EnterElement, Datum, PElement, PDatum]) | Null]
    @scala.inline
    def active[Datum, PElement /* <: BaseType */, PDatum](node: EnterElement, name: String): (Transition_[EnterElement, Datum, PElement, PDatum]) | Null = (^.asInstanceOf[js.Dynamic].applyDynamic("active")(node.asInstanceOf[js.Any], name.asInstanceOf[js.Any])).asInstanceOf[(Transition_[EnterElement, Datum, PElement, PDatum]) | Null]
    @scala.inline
    def active[Datum, PElement /* <: BaseType */, PDatum](node: Document): (Transition_[Document, Datum, PElement, PDatum]) | Null = ^.asInstanceOf[js.Dynamic].applyDynamic("active")(node.asInstanceOf[js.Any]).asInstanceOf[(Transition_[Document, Datum, PElement, PDatum]) | Null]
    @scala.inline
    def active[Datum, PElement /* <: BaseType */, PDatum](node: Document, name: String): (Transition_[Document, Datum, PElement, PDatum]) | Null = (^.asInstanceOf[js.Dynamic].applyDynamic("active")(node.asInstanceOf[js.Any], name.asInstanceOf[js.Any])).asInstanceOf[(Transition_[Document, Datum, PElement, PDatum]) | Null]
    @scala.inline
    def active[Datum, PElement /* <: BaseType */, PDatum](node: Element): (Transition_[Element, Datum, PElement, PDatum]) | Null = ^.asInstanceOf[js.Dynamic].applyDynamic("active")(node.asInstanceOf[js.Any]).asInstanceOf[(Transition_[Element, Datum, PElement, PDatum]) | Null]
    @scala.inline
    def active[Datum, PElement /* <: BaseType */, PDatum](node: Element, name: String): (Transition_[Element, Datum, PElement, PDatum]) | Null = (^.asInstanceOf[js.Dynamic].applyDynamic("active")(node.asInstanceOf[js.Any], name.asInstanceOf[js.Any])).asInstanceOf[(Transition_[Element, Datum, PElement, PDatum]) | Null]
    @scala.inline
    def active[Datum, PElement /* <: BaseType */, PDatum](node: Window): (Transition_[Window, Datum, PElement, PDatum]) | Null = ^.asInstanceOf[js.Dynamic].applyDynamic("active")(node.asInstanceOf[js.Any]).asInstanceOf[(Transition_[Window, Datum, PElement, PDatum]) | Null]
    @scala.inline
    def active[Datum, PElement /* <: BaseType */, PDatum](node: Window, name: String): (Transition_[Window, Datum, PElement, PDatum]) | Null = (^.asInstanceOf[js.Dynamic].applyDynamic("active")(node.asInstanceOf[js.Any], name.asInstanceOf[js.Any])).asInstanceOf[(Transition_[Window, Datum, PElement, PDatum]) | Null]
    
    @scala.inline
    def arc(): Arc_[js.Any, DefaultArcObject] = ^.asInstanceOf[js.Dynamic].applyDynamic("arc")().asInstanceOf[Arc_[js.Any, DefaultArcObject]]
    
    @scala.inline
    def arc_Datum[Datum](): Arc_[js.Any, Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("arc")().asInstanceOf[Arc_[js.Any, Datum]]
    
    @scala.inline
    def arc_ThisDatum[This, Datum](): Arc_[This, Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("arc")().asInstanceOf[Arc_[This, Datum]]
    
    @scala.inline
    def area[Datum](): Area_[Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("area")().asInstanceOf[Area_[Datum]]
    @scala.inline
    def area[Datum](x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]): Area_[Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("area")(x.asInstanceOf[js.Any]).asInstanceOf[Area_[Datum]]
    @scala.inline
    def area[Datum](
      x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
      y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
    ): Area_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("area")(x.asInstanceOf[js.Any], y0.asInstanceOf[js.Any])).asInstanceOf[Area_[Datum]]
    @scala.inline
    def area[Datum](
      x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
      y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
      y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
    ): Area_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("area")(x.asInstanceOf[js.Any], y0.asInstanceOf[js.Any], y1.asInstanceOf[js.Any])).asInstanceOf[Area_[Datum]]
    @scala.inline
    def area[Datum](
      x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
      y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
      y1: Double
    ): Area_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("area")(x.asInstanceOf[js.Any], y0.asInstanceOf[js.Any], y1.asInstanceOf[js.Any])).asInstanceOf[Area_[Datum]]
    @scala.inline
    def area[Datum](x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double], y0: Double): Area_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("area")(x.asInstanceOf[js.Any], y0.asInstanceOf[js.Any])).asInstanceOf[Area_[Datum]]
    @scala.inline
    def area[Datum](
      x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
      y0: Double,
      y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
    ): Area_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("area")(x.asInstanceOf[js.Any], y0.asInstanceOf[js.Any], y1.asInstanceOf[js.Any])).asInstanceOf[Area_[Datum]]
    @scala.inline
    def area[Datum](
      x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
      y0: Double,
      y1: Double
    ): Area_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("area")(x.asInstanceOf[js.Any], y0.asInstanceOf[js.Any], y1.asInstanceOf[js.Any])).asInstanceOf[Area_[Datum]]
    @scala.inline
    def area[Datum](
      x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
      y0: Unit,
      y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
    ): Area_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("area")(x.asInstanceOf[js.Any], y0.asInstanceOf[js.Any], y1.asInstanceOf[js.Any])).asInstanceOf[Area_[Datum]]
    @scala.inline
    def area[Datum](
      x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
      y0: Unit,
      y1: Double
    ): Area_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("area")(x.asInstanceOf[js.Any], y0.asInstanceOf[js.Any], y1.asInstanceOf[js.Any])).asInstanceOf[Area_[Datum]]
    @scala.inline
    def area[Datum](x: Double): Area_[Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("area")(x.asInstanceOf[js.Any]).asInstanceOf[Area_[Datum]]
    @scala.inline
    def area[Datum](x: Double, y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]): Area_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("area")(x.asInstanceOf[js.Any], y0.asInstanceOf[js.Any])).asInstanceOf[Area_[Datum]]
    @scala.inline
    def area[Datum](
      x: Double,
      y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
      y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
    ): Area_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("area")(x.asInstanceOf[js.Any], y0.asInstanceOf[js.Any], y1.asInstanceOf[js.Any])).asInstanceOf[Area_[Datum]]
    @scala.inline
    def area[Datum](
      x: Double,
      y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
      y1: Double
    ): Area_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("area")(x.asInstanceOf[js.Any], y0.asInstanceOf[js.Any], y1.asInstanceOf[js.Any])).asInstanceOf[Area_[Datum]]
    @scala.inline
    def area[Datum](x: Double, y0: Double): Area_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("area")(x.asInstanceOf[js.Any], y0.asInstanceOf[js.Any])).asInstanceOf[Area_[Datum]]
    @scala.inline
    def area[Datum](
      x: Double,
      y0: Double,
      y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
    ): Area_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("area")(x.asInstanceOf[js.Any], y0.asInstanceOf[js.Any], y1.asInstanceOf[js.Any])).asInstanceOf[Area_[Datum]]
    @scala.inline
    def area[Datum](x: Double, y0: Double, y1: Double): Area_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("area")(x.asInstanceOf[js.Any], y0.asInstanceOf[js.Any], y1.asInstanceOf[js.Any])).asInstanceOf[Area_[Datum]]
    @scala.inline
    def area[Datum](
      x: Double,
      y0: Unit,
      y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
    ): Area_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("area")(x.asInstanceOf[js.Any], y0.asInstanceOf[js.Any], y1.asInstanceOf[js.Any])).asInstanceOf[Area_[Datum]]
    @scala.inline
    def area[Datum](x: Double, y0: Unit, y1: Double): Area_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("area")(x.asInstanceOf[js.Any], y0.asInstanceOf[js.Any], y1.asInstanceOf[js.Any])).asInstanceOf[Area_[Datum]]
    @scala.inline
    def area[Datum](x: Unit, y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]): Area_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("area")(x.asInstanceOf[js.Any], y0.asInstanceOf[js.Any])).asInstanceOf[Area_[Datum]]
    @scala.inline
    def area[Datum](
      x: Unit,
      y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
      y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
    ): Area_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("area")(x.asInstanceOf[js.Any], y0.asInstanceOf[js.Any], y1.asInstanceOf[js.Any])).asInstanceOf[Area_[Datum]]
    @scala.inline
    def area[Datum](
      x: Unit,
      y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
      y1: Double
    ): Area_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("area")(x.asInstanceOf[js.Any], y0.asInstanceOf[js.Any], y1.asInstanceOf[js.Any])).asInstanceOf[Area_[Datum]]
    @scala.inline
    def area[Datum](x: Unit, y0: Double): Area_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("area")(x.asInstanceOf[js.Any], y0.asInstanceOf[js.Any])).asInstanceOf[Area_[Datum]]
    @scala.inline
    def area[Datum](
      x: Unit,
      y0: Double,
      y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
    ): Area_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("area")(x.asInstanceOf[js.Any], y0.asInstanceOf[js.Any], y1.asInstanceOf[js.Any])).asInstanceOf[Area_[Datum]]
    @scala.inline
    def area[Datum](x: Unit, y0: Double, y1: Double): Area_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("area")(x.asInstanceOf[js.Any], y0.asInstanceOf[js.Any], y1.asInstanceOf[js.Any])).asInstanceOf[Area_[Datum]]
    @scala.inline
    def area[Datum](
      x: Unit,
      y0: Unit,
      y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
    ): Area_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("area")(x.asInstanceOf[js.Any], y0.asInstanceOf[js.Any], y1.asInstanceOf[js.Any])).asInstanceOf[Area_[Datum]]
    @scala.inline
    def area[Datum](x: Unit, y0: Unit, y1: Double): Area_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("area")(x.asInstanceOf[js.Any], y0.asInstanceOf[js.Any], y1.asInstanceOf[js.Any])).asInstanceOf[Area_[Datum]]
    
    @scala.inline
    def areaRadial(): AreaRadial_[js.Tuple2[Double, Double]] = ^.asInstanceOf[js.Dynamic].applyDynamic("areaRadial")().asInstanceOf[AreaRadial_[js.Tuple2[Double, Double]]]
    
    @scala.inline
    def areaRadial_Datum[Datum](): AreaRadial_[Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("areaRadial")().asInstanceOf[AreaRadial_[Datum]]
    
    @scala.inline
    def ascending(): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("ascending")().asInstanceOf[Double]
    @scala.inline
    def ascending(a: Unit, b: Primitive): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("ascending")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def ascending(a: Primitive): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("ascending")(a.asInstanceOf[js.Any]).asInstanceOf[Double]
    @scala.inline
    def ascending(a: Primitive, b: Primitive): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("ascending")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    @scala.inline
    def autoType[ParsedRow /* <: js.UndefOr[js.Object | Null] */, Columns /* <: String */](// tslint:disable-next-line:no-unnecessary-generics
    `object`: js.Array[String]): ParsedRow = ^.asInstanceOf[js.Dynamic].applyDynamic("autoType")(`object`.asInstanceOf[js.Any]).asInstanceOf[ParsedRow]
    @scala.inline
    def autoType[ParsedRow /* <: js.UndefOr[js.Object | Null] */, Columns /* <: String */](// tslint:disable-next-line:no-unnecessary-generics
    `object`: DSVRowString[Columns]): ParsedRow = ^.asInstanceOf[js.Dynamic].applyDynamic("autoType")(`object`.asInstanceOf[js.Any]).asInstanceOf[ParsedRow]
    
    @scala.inline
    def axisBottom[Domain /* <: AxisDomain */](scale: AxisScale[Domain]): Axis[Domain] = ^.asInstanceOf[js.Dynamic].applyDynamic("axisBottom")(scale.asInstanceOf[js.Any]).asInstanceOf[Axis[Domain]]
    
    @scala.inline
    def axisLeft[Domain /* <: AxisDomain */](scale: AxisScale[Domain]): Axis[Domain] = ^.asInstanceOf[js.Dynamic].applyDynamic("axisLeft")(scale.asInstanceOf[js.Any]).asInstanceOf[Axis[Domain]]
    
    @scala.inline
    def axisRight[Domain /* <: AxisDomain */](scale: AxisScale[Domain]): Axis[Domain] = ^.asInstanceOf[js.Dynamic].applyDynamic("axisRight")(scale.asInstanceOf[js.Any]).asInstanceOf[Axis[Domain]]
    
    @scala.inline
    def axisTop[Domain /* <: AxisDomain */](scale: AxisScale[Domain]): Axis[Domain] = ^.asInstanceOf[js.Dynamic].applyDynamic("axisTop")(scale.asInstanceOf[js.Any]).asInstanceOf[Axis[Domain]]
    
    @scala.inline
    def bin(): HistogramGeneratorNumber[Double, Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("bin")().asInstanceOf[HistogramGeneratorNumber[Double, Double]]
    
    @scala.inline
    def `bin_DatumValue_UnionDate<undefined>_HistogramGeneratorDate`[Datum, Value /* <: js.UndefOr[Date] */](): HistogramGeneratorDate[Datum, Value] = ^.asInstanceOf[js.Dynamic].applyDynamic("bin")().asInstanceOf[HistogramGeneratorDate[Datum, Value]]
    
    @scala.inline
    def `bin_DatumValue_UnionDouble<undefined>`[Datum, Value /* <: js.UndefOr[Double] */](): HistogramGeneratorNumber[Datum, Value] = ^.asInstanceOf[js.Dynamic].applyDynamic("bin")().asInstanceOf[HistogramGeneratorNumber[Datum, Value]]
    
    @JSImport("plotly.js/lib/core", "d3.bisect")
    @js.native
    val bisect: Typeofbisect = js.native
    
    @scala.inline
    def bisectCenter(array: ArrayLike[String], x: String): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectCenter")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectCenter(array: ArrayLike[String], x: String, lo: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectCenter")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectCenter(array: ArrayLike[String], x: String, lo: Double, hi: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectCenter")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectCenter(array: ArrayLike[String], x: String, lo: Unit, hi: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectCenter")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectCenter(array: ArrayLike[Double], x: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectCenter")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectCenter(array: ArrayLike[Double], x: Double, lo: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectCenter")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectCenter(array: ArrayLike[Double], x: Double, lo: Double, hi: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectCenter")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectCenter(array: ArrayLike[Double], x: Double, lo: Unit, hi: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectCenter")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectCenter(array: ArrayLike[Date], x: Date): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectCenter")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectCenter(array: ArrayLike[Date], x: Date, lo: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectCenter")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectCenter(array: ArrayLike[Date], x: Date, lo: Double, hi: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectCenter")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectCenter(array: ArrayLike[Date], x: Date, lo: Unit, hi: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectCenter")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    @scala.inline
    def bisectLeft(array: ArrayLike[String], x: String): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectLeft")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectLeft(array: ArrayLike[String], x: String, lo: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectLeft")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectLeft(array: ArrayLike[String], x: String, lo: Double, hi: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectLeft")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectLeft(array: ArrayLike[String], x: String, lo: Unit, hi: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectLeft")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectLeft(array: ArrayLike[Double], x: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectLeft")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectLeft(array: ArrayLike[Double], x: Double, lo: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectLeft")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectLeft(array: ArrayLike[Double], x: Double, lo: Double, hi: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectLeft")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectLeft(array: ArrayLike[Double], x: Double, lo: Unit, hi: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectLeft")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectLeft(array: ArrayLike[Date], x: Date): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectLeft")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectLeft(array: ArrayLike[Date], x: Date, lo: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectLeft")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectLeft(array: ArrayLike[Date], x: Date, lo: Double, hi: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectLeft")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectLeft(array: ArrayLike[Date], x: Date, lo: Unit, hi: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectLeft")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    @scala.inline
    def bisectRight(array: ArrayLike[String], x: String): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectRight")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectRight(array: ArrayLike[String], x: String, lo: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectRight")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectRight(array: ArrayLike[String], x: String, lo: Double, hi: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectRight")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectRight(array: ArrayLike[String], x: String, lo: Unit, hi: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectRight")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectRight(array: ArrayLike[Double], x: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectRight")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectRight(array: ArrayLike[Double], x: Double, lo: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectRight")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectRight(array: ArrayLike[Double], x: Double, lo: Double, hi: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectRight")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectRight(array: ArrayLike[Double], x: Double, lo: Unit, hi: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectRight")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectRight(array: ArrayLike[Date], x: Date): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectRight")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectRight(array: ArrayLike[Date], x: Date, lo: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectRight")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectRight(array: ArrayLike[Date], x: Date, lo: Double, hi: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectRight")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def bisectRight(array: ArrayLike[Date], x: Date, lo: Unit, hi: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("bisectRight")(array.asInstanceOf[js.Any], x.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    @scala.inline
    def bisector[T, U](accessor: js.Function1[/* x */ T, U]): Bisector_[T, U] = ^.asInstanceOf[js.Dynamic].applyDynamic("bisector")(accessor.asInstanceOf[js.Any]).asInstanceOf[Bisector_[T, U]]
    @scala.inline
    def bisector[T, U](comparator: js.Function2[/* a */ T, /* b */ U, Double]): Bisector_[T, U] = ^.asInstanceOf[js.Dynamic].applyDynamic("bisector")(comparator.asInstanceOf[js.Any]).asInstanceOf[Bisector_[T, U]]
    
    @scala.inline
    def blob(url: String): js.Promise[Blob] = ^.asInstanceOf[js.Dynamic].applyDynamic("blob")(url.asInstanceOf[js.Any]).asInstanceOf[js.Promise[Blob]]
    @scala.inline
    def blob(url: String, init: RequestInit): js.Promise[Blob] = (^.asInstanceOf[js.Dynamic].applyDynamic("blob")(url.asInstanceOf[js.Any], init.asInstanceOf[js.Any])).asInstanceOf[js.Promise[Blob]]
    
    @scala.inline
    def brush[Datum](): BrushBehavior[Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("brush")().asInstanceOf[BrushBehavior[Datum]]
    
    @scala.inline
    def brushSelection(node: SVGGElement): BrushSelection_ | Null = ^.asInstanceOf[js.Dynamic].applyDynamic("brushSelection")(node.asInstanceOf[js.Any]).asInstanceOf[BrushSelection_ | Null]
    
    @scala.inline
    def brushX[Datum](): BrushBehavior[Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("brushX")().asInstanceOf[BrushBehavior[Datum]]
    
    @scala.inline
    def brushY[Datum](): BrushBehavior[Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("brushY")().asInstanceOf[BrushBehavior[Datum]]
    
    @scala.inline
    def buffer(url: String): js.Promise[ArrayBuffer] = ^.asInstanceOf[js.Dynamic].applyDynamic("buffer")(url.asInstanceOf[js.Any]).asInstanceOf[js.Promise[ArrayBuffer]]
    @scala.inline
    def buffer(url: String, init: RequestInit): js.Promise[ArrayBuffer] = (^.asInstanceOf[js.Dynamic].applyDynamic("buffer")(url.asInstanceOf[js.Any], init.asInstanceOf[js.Any])).asInstanceOf[js.Promise[ArrayBuffer]]
    
    @scala.inline
    def chord(): ChordLayout = ^.asInstanceOf[js.Dynamic].applyDynamic("chord")().asInstanceOf[ChordLayout]
    
    @scala.inline
    def chordDirected(): ChordLayout = ^.asInstanceOf[js.Dynamic].applyDynamic("chordDirected")().asInstanceOf[ChordLayout]
    
    @scala.inline
    def chordTranspose(): ChordLayout = ^.asInstanceOf[js.Dynamic].applyDynamic("chordTranspose")().asInstanceOf[ChordLayout]
    
    @scala.inline
    def cluster[Datum](): ClusterLayout[Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("cluster")().asInstanceOf[ClusterLayout[Datum]]
    
    @JSImport("plotly.js/lib/core", "d3.color")
    @js.native
    val color: ColorFactory = js.native
    @scala.inline
    def color(color: ColorCommonInstance): RGBColor | HSLColor = ^.asInstanceOf[js.Dynamic].applyDynamic("color")(color.asInstanceOf[js.Any]).asInstanceOf[RGBColor | HSLColor]
    /**
      * Converts the provided color instance and returns an RGB or HSL color.
      *
      * @param color A permissible color space instance.
      */
    @scala.inline
    def color(color: ColorSpaceObject): RGBColor | HSLColor = ^.asInstanceOf[js.Dynamic].applyDynamic("color")(color.asInstanceOf[js.Any]).asInstanceOf[RGBColor | HSLColor]
    /**
      * Parses the specified CSS Color Module Level 3 specifier string, returning an RGB or HSL color.
      * If the specifier was not valid, null is returned.
      *
      * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
      */
    @scala.inline
    def color(cssColorSpecifier: String): RGBColor | HSLColor | Null = ^.asInstanceOf[js.Dynamic].applyDynamic("color")(cssColorSpecifier.asInstanceOf[js.Any]).asInstanceOf[RGBColor | HSLColor | Null]
    
    @scala.inline
    def contourDensity[Datum](): ContourDensity_[Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("contourDensity")().asInstanceOf[ContourDensity_[Datum]]
    
    @scala.inline
    def contours(): Contours_ = ^.asInstanceOf[js.Dynamic].applyDynamic("contours")().asInstanceOf[Contours_]
    
    @scala.inline
    def count[TObject](iterable: Iterable[TObject]): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("count")(iterable.asInstanceOf[js.Any]).asInstanceOf[Double]
    @scala.inline
    def count[TObject](
      iterable: Iterable[TObject],
      accessor: js.Function2[/* a */ TObject, /* b */ TObject, js.UndefOr[Double | Null]]
    ): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("count")(iterable.asInstanceOf[js.Any], accessor.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    @scala.inline
    def create[NewGElement /* <: Element */](name: String): Selection_[NewGElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[NewGElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_a(name: a): Selection_[HTMLAnchorElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLAnchorElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_abbr(name: abbr): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_address(name: address): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_applet(name: applet): Selection_[HTMLAppletElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLAppletElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_area(name: area): Selection_[HTMLAreaElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLAreaElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_article(name: article): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_aside(name: aside): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_audio(name: audio): Selection_[HTMLAudioElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLAudioElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_b(name: b_): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_base(name: base): Selection_[HTMLBaseElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLBaseElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_basefont(name: basefont): Selection_[HTMLBaseFontElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLBaseFontElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_bdi(name: bdi): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_bdo(name: bdo): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_blockquote(name: blockquote): Selection_[HTMLQuoteElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLQuoteElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_body(name: body): Selection_[HTMLBodyElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLBodyElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_br(name: br): Selection_[HTMLBRElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLBRElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_button(name: button): Selection_[HTMLButtonElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLButtonElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_canvas(name: canvas): Selection_[HTMLCanvasElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLCanvasElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_caption(name: caption): Selection_[HTMLTableCaptionElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLTableCaptionElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_circle(name: circle): Selection_[SVGCircleElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGCircleElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_cite(name: cite): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_clipPath(name: clipPath): Selection_[SVGClipPathElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGClipPathElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_code(name: code): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_col(name: col): Selection_[HTMLTableColElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLTableColElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_colgroup(name: colgroup): Selection_[HTMLTableColElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLTableColElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_data(name: data): Selection_[HTMLDataElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLDataElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_datalist(name: datalist): Selection_[HTMLDataListElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLDataListElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_dd(name: dd): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_defs(name: defs): Selection_[SVGDefsElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGDefsElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_del(name: del): Selection_[HTMLModElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLModElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_desc(name: desc): Selection_[SVGDescElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGDescElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_details(name: details): Selection_[HTMLDetailsElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLDetailsElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_dfn(name: dfn): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_dialog(name: dialog): Selection_[HTMLDialogElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLDialogElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_dir(name: dir): Selection_[HTMLDirectoryElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLDirectoryElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_div(name: div): Selection_[HTMLDivElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLDivElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_dl(name: dl): Selection_[HTMLDListElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLDListElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_dt(name: dt): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_ellipse(name: ellipse): Selection_[SVGEllipseElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGEllipseElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_em(name: em): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_embed(name: embed): Selection_[HTMLEmbedElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLEmbedElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_feBlend(name: feBlend): Selection_[SVGFEBlendElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGFEBlendElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_feColorMatrix(name: feColorMatrix): Selection_[SVGFEColorMatrixElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGFEColorMatrixElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_feComponentTransfer(name: feComponentTransfer): Selection_[SVGFEComponentTransferElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGFEComponentTransferElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_feComposite(name: feComposite): Selection_[SVGFECompositeElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGFECompositeElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_feConvolveMatrix(name: feConvolveMatrix): Selection_[SVGFEConvolveMatrixElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGFEConvolveMatrixElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_feDiffuseLighting(name: feDiffuseLighting): Selection_[SVGFEDiffuseLightingElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGFEDiffuseLightingElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_feDisplacementMap(name: feDisplacementMap): Selection_[SVGFEDisplacementMapElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGFEDisplacementMapElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_feDistantLight(name: feDistantLight): Selection_[SVGFEDistantLightElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGFEDistantLightElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_feFlood(name: feFlood): Selection_[SVGFEFloodElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGFEFloodElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_feFuncA(name: feFuncA): Selection_[SVGFEFuncAElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGFEFuncAElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_feFuncB(name: feFuncB): Selection_[SVGFEFuncBElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGFEFuncBElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_feFuncG(name: feFuncG): Selection_[SVGFEFuncGElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGFEFuncGElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_feFuncR(name: feFuncR): Selection_[SVGFEFuncRElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGFEFuncRElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_feGaussianBlur(name: feGaussianBlur): Selection_[SVGFEGaussianBlurElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGFEGaussianBlurElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_feImage(name: feImage): Selection_[SVGFEImageElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGFEImageElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_feMerge(name: feMerge): Selection_[SVGFEMergeElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGFEMergeElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_feMergeNode(name: feMergeNode): Selection_[SVGFEMergeNodeElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGFEMergeNodeElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_feMorphology(name: feMorphology): Selection_[SVGFEMorphologyElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGFEMorphologyElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_feOffset(name: feOffset): Selection_[SVGFEOffsetElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGFEOffsetElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_fePointLight(name: fePointLight): Selection_[SVGFEPointLightElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGFEPointLightElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_feSpecularLighting(name: feSpecularLighting): Selection_[SVGFESpecularLightingElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGFESpecularLightingElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_feSpotLight(name: feSpotLight): Selection_[SVGFESpotLightElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGFESpotLightElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_feTile(name: feTile): Selection_[SVGFETileElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGFETileElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_feTurbulence(name: feTurbulence): Selection_[SVGFETurbulenceElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGFETurbulenceElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_fieldset(name: fieldset): Selection_[HTMLFieldSetElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLFieldSetElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_figcaption(name: figcaption): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_figure(name: figure): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_filter(name: filter): Selection_[SVGFilterElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGFilterElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_font(name: font): Selection_[HTMLFontElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLFontElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_footer(name: footer): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_foreignObject(name: foreignObject): Selection_[SVGForeignObjectElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGForeignObjectElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_form(name: form): Selection_[HTMLFormElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLFormElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_frame(name: frame): Selection_[HTMLFrameElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLFrameElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_frameset(name: frameset): Selection_[HTMLFrameSetElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLFrameSetElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_g(name: g): Selection_[SVGGElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGGElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_h1(name: h1): Selection_[HTMLHeadingElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLHeadingElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_h2(name: h2): Selection_[HTMLHeadingElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLHeadingElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_h3(name: h3): Selection_[HTMLHeadingElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLHeadingElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_h4(name: h4): Selection_[HTMLHeadingElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLHeadingElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_h5(name: h5): Selection_[HTMLHeadingElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLHeadingElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_h6(name: h6): Selection_[HTMLHeadingElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLHeadingElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_head(name: head): Selection_[HTMLHeadElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLHeadElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_header(name: header): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_hgroup(name: hgroup): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_hr(name: hr): Selection_[HTMLHRElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLHRElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_html(name: html): Selection_[HTMLHtmlElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLHtmlElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_i(name: i): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_iframe(name: iframe): Selection_[HTMLIFrameElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLIFrameElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_image(name: image): Selection_[SVGImageElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGImageElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_img(name: img): Selection_[HTMLImageElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLImageElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_input(name: input): Selection_[HTMLInputElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLInputElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_ins(name: ins): Selection_[HTMLModElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLModElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_kbd(name: kbd): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_label(name: label): Selection_[HTMLLabelElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLLabelElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_legend(name: legend): Selection_[HTMLLegendElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLLegendElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_li(name: li): Selection_[HTMLLIElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLLIElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_line(name: line): Selection_[SVGLineElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGLineElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_linearGradient(name: linearGradient): Selection_[SVGLinearGradientElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGLinearGradientElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_link(name: link): Selection_[HTMLLinkElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLLinkElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_main(name: main): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_map(name: map): Selection_[HTMLMapElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLMapElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_mark(name: mark): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_marker(name: marker): Selection_[SVGMarkerElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGMarkerElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_marquee(name: marquee): Selection_[HTMLMarqueeElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLMarqueeElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_mask(name: mask): Selection_[SVGMaskElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGMaskElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_menu(name: menu): Selection_[HTMLMenuElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLMenuElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_meta(name: meta): Selection_[HTMLMetaElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLMetaElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_metadata(name: metadata): Selection_[SVGMetadataElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGMetadataElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_meter(name: meter): Selection_[HTMLMeterElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLMeterElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_nav(name: nav): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_noscript(name: noscript): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_object(name: `object`): Selection_[HTMLObjectElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLObjectElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_ol(name: ol): Selection_[HTMLOListElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLOListElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_optgroup(name: optgroup): Selection_[HTMLOptGroupElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLOptGroupElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_option(name: option): Selection_[HTMLOptionElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLOptionElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_output(name: output): Selection_[HTMLOutputElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLOutputElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_p(name: p): Selection_[HTMLParagraphElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLParagraphElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_param(name: param): Selection_[HTMLParamElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLParamElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_path(name: path): Selection_[SVGPathElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGPathElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_pattern(name: pattern): Selection_[SVGPatternElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGPatternElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_picture(name: picture): Selection_[HTMLPictureElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLPictureElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_polygon(name: polygon): Selection_[SVGPolygonElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGPolygonElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_polyline(name: polyline): Selection_[SVGPolylineElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGPolylineElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_pre(name: pre): Selection_[HTMLPreElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLPreElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_progress(name: progress): Selection_[HTMLProgressElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLProgressElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_q(name: q): Selection_[HTMLQuoteElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLQuoteElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_radialGradient(name: radialGradient): Selection_[SVGRadialGradientElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGRadialGradientElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_rect(name: rect): Selection_[SVGRectElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGRectElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_rp(name: rp): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_rt(name: rt): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_ruby(name: ruby): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_s(name: s): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_samp(name: samp): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_script(name: script): Selection_[HTMLScriptElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLScriptElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_section(name: section): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_select(name: select): Selection_[HTMLSelectElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLSelectElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_slot(name: slot): Selection_[HTMLSlotElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLSlotElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_small(name: small): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_source(name: source): Selection_[HTMLSourceElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLSourceElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_span(name: span): Selection_[HTMLSpanElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLSpanElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_stop(name: stop): Selection_[SVGStopElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGStopElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_strong(name: strong): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_style(name: style): Selection_[HTMLStyleElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLStyleElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_sub(name: sub): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_summary(name: summary): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_sup(name: sup): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_svg(name: svg): Selection_[SVGSVGElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGSVGElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_switch(name: switch): Selection_[SVGSwitchElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGSwitchElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_symbol(name: symbol): Selection_[SVGSymbolElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGSymbolElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_table(name: table): Selection_[HTMLTableElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLTableElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_tbody(name: tbody): Selection_[HTMLTableSectionElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLTableSectionElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_td(name: td): Selection_[HTMLTableDataCellElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLTableDataCellElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_template(name: template): Selection_[HTMLTemplateElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLTemplateElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_text(name: text): Selection_[SVGTextElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGTextElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_textPath(name: textPath): Selection_[SVGTextPathElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGTextPathElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_textarea(name: textarea): Selection_[HTMLTextAreaElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLTextAreaElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_tfoot(name: tfoot): Selection_[HTMLTableSectionElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLTableSectionElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_th(name: th): Selection_[HTMLTableHeaderCellElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLTableHeaderCellElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_thead(name: thead): Selection_[HTMLTableSectionElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLTableSectionElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_time(name: time): Selection_[HTMLTimeElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLTimeElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_title(name: title): Selection_[HTMLTitleElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLTitleElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_tr(name: tr): Selection_[HTMLTableRowElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLTableRowElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_track(name: track): Selection_[HTMLTrackElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLTrackElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_tspan(name: tspan): Selection_[SVGTSpanElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGTSpanElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_u(name: u): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_ul(name: ul): Selection_[HTMLUListElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLUListElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_use(name: use): Selection_[SVGUseElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGUseElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_var(name: `var`): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_video(name: video): Selection_[HTMLVideoElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLVideoElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_view(name: view): Selection_[SVGViewElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[SVGViewElement, Unit, Null, Unit]]
    
    @scala.inline
    def create_wbr(name: wbr): Selection_[HTMLElement, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("create")(name.asInstanceOf[js.Any]).asInstanceOf[Selection_[HTMLElement, Unit, Null, Unit]]
    
    @scala.inline
    def creator[NewGElement /* <: Element */](name: String): js.ThisFunction0[/* this */ BaseType, NewGElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, NewGElement]]
    
    @scala.inline
    def creator_a(name: a): js.ThisFunction0[/* this */ BaseType, HTMLAnchorElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLAnchorElement]]
    
    @scala.inline
    def creator_abbr(name: abbr): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_address(name: address): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_applet(name: applet): js.ThisFunction0[/* this */ BaseType, HTMLAppletElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLAppletElement]]
    
    @scala.inline
    def creator_area(name: area): js.ThisFunction0[/* this */ BaseType, HTMLAreaElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLAreaElement]]
    
    @scala.inline
    def creator_article(name: article): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_aside(name: aside): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_audio(name: audio): js.ThisFunction0[/* this */ BaseType, HTMLAudioElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLAudioElement]]
    
    @scala.inline
    def creator_b(name: b_): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_base(name: base): js.ThisFunction0[/* this */ BaseType, HTMLBaseElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLBaseElement]]
    
    @scala.inline
    def creator_basefont(name: basefont): js.ThisFunction0[/* this */ BaseType, HTMLBaseFontElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLBaseFontElement]]
    
    @scala.inline
    def creator_bdi(name: bdi): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_bdo(name: bdo): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_blockquote(name: blockquote): js.ThisFunction0[/* this */ BaseType, HTMLQuoteElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLQuoteElement]]
    
    @scala.inline
    def creator_body(name: body): js.ThisFunction0[/* this */ BaseType, HTMLBodyElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLBodyElement]]
    
    @scala.inline
    def creator_br(name: br): js.ThisFunction0[/* this */ BaseType, HTMLBRElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLBRElement]]
    
    @scala.inline
    def creator_button(name: button): js.ThisFunction0[/* this */ BaseType, HTMLButtonElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLButtonElement]]
    
    @scala.inline
    def creator_canvas(name: canvas): js.ThisFunction0[/* this */ BaseType, HTMLCanvasElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLCanvasElement]]
    
    @scala.inline
    def creator_caption(name: caption): js.ThisFunction0[/* this */ BaseType, HTMLTableCaptionElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLTableCaptionElement]]
    
    @scala.inline
    def creator_circle(name: circle): js.ThisFunction0[/* this */ BaseType, SVGCircleElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGCircleElement]]
    
    @scala.inline
    def creator_cite(name: cite): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_clipPath(name: clipPath): js.ThisFunction0[/* this */ BaseType, SVGClipPathElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGClipPathElement]]
    
    @scala.inline
    def creator_code(name: code): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_col(name: col): js.ThisFunction0[/* this */ BaseType, HTMLTableColElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLTableColElement]]
    
    @scala.inline
    def creator_colgroup(name: colgroup): js.ThisFunction0[/* this */ BaseType, HTMLTableColElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLTableColElement]]
    
    @scala.inline
    def creator_data(name: data): js.ThisFunction0[/* this */ BaseType, HTMLDataElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLDataElement]]
    
    @scala.inline
    def creator_datalist(name: datalist): js.ThisFunction0[/* this */ BaseType, HTMLDataListElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLDataListElement]]
    
    @scala.inline
    def creator_dd(name: dd): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_defs(name: defs): js.ThisFunction0[/* this */ BaseType, SVGDefsElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGDefsElement]]
    
    @scala.inline
    def creator_del(name: del): js.ThisFunction0[/* this */ BaseType, HTMLModElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLModElement]]
    
    @scala.inline
    def creator_desc(name: desc): js.ThisFunction0[/* this */ BaseType, SVGDescElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGDescElement]]
    
    @scala.inline
    def creator_details(name: details): js.ThisFunction0[/* this */ BaseType, HTMLDetailsElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLDetailsElement]]
    
    @scala.inline
    def creator_dfn(name: dfn): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_dialog(name: dialog): js.ThisFunction0[/* this */ BaseType, HTMLDialogElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLDialogElement]]
    
    @scala.inline
    def creator_dir(name: dir): js.ThisFunction0[/* this */ BaseType, HTMLDirectoryElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLDirectoryElement]]
    
    @scala.inline
    def creator_div(name: div): js.ThisFunction0[/* this */ BaseType, HTMLDivElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLDivElement]]
    
    @scala.inline
    def creator_dl(name: dl): js.ThisFunction0[/* this */ BaseType, HTMLDListElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLDListElement]]
    
    @scala.inline
    def creator_dt(name: dt): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_ellipse(name: ellipse): js.ThisFunction0[/* this */ BaseType, SVGEllipseElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGEllipseElement]]
    
    @scala.inline
    def creator_em(name: em): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_embed(name: embed): js.ThisFunction0[/* this */ BaseType, HTMLEmbedElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLEmbedElement]]
    
    @scala.inline
    def creator_feBlend(name: feBlend): js.ThisFunction0[/* this */ BaseType, SVGFEBlendElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGFEBlendElement]]
    
    @scala.inline
    def creator_feColorMatrix(name: feColorMatrix): js.ThisFunction0[/* this */ BaseType, SVGFEColorMatrixElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGFEColorMatrixElement]]
    
    @scala.inline
    def creator_feComponentTransfer(name: feComponentTransfer): js.ThisFunction0[/* this */ BaseType, SVGFEComponentTransferElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGFEComponentTransferElement]]
    
    @scala.inline
    def creator_feComposite(name: feComposite): js.ThisFunction0[/* this */ BaseType, SVGFECompositeElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGFECompositeElement]]
    
    @scala.inline
    def creator_feConvolveMatrix(name: feConvolveMatrix): js.ThisFunction0[/* this */ BaseType, SVGFEConvolveMatrixElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGFEConvolveMatrixElement]]
    
    @scala.inline
    def creator_feDiffuseLighting(name: feDiffuseLighting): js.ThisFunction0[/* this */ BaseType, SVGFEDiffuseLightingElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGFEDiffuseLightingElement]]
    
    @scala.inline
    def creator_feDisplacementMap(name: feDisplacementMap): js.ThisFunction0[/* this */ BaseType, SVGFEDisplacementMapElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGFEDisplacementMapElement]]
    
    @scala.inline
    def creator_feDistantLight(name: feDistantLight): js.ThisFunction0[/* this */ BaseType, SVGFEDistantLightElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGFEDistantLightElement]]
    
    @scala.inline
    def creator_feFlood(name: feFlood): js.ThisFunction0[/* this */ BaseType, SVGFEFloodElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGFEFloodElement]]
    
    @scala.inline
    def creator_feFuncA(name: feFuncA): js.ThisFunction0[/* this */ BaseType, SVGFEFuncAElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGFEFuncAElement]]
    
    @scala.inline
    def creator_feFuncB(name: feFuncB): js.ThisFunction0[/* this */ BaseType, SVGFEFuncBElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGFEFuncBElement]]
    
    @scala.inline
    def creator_feFuncG(name: feFuncG): js.ThisFunction0[/* this */ BaseType, SVGFEFuncGElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGFEFuncGElement]]
    
    @scala.inline
    def creator_feFuncR(name: feFuncR): js.ThisFunction0[/* this */ BaseType, SVGFEFuncRElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGFEFuncRElement]]
    
    @scala.inline
    def creator_feGaussianBlur(name: feGaussianBlur): js.ThisFunction0[/* this */ BaseType, SVGFEGaussianBlurElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGFEGaussianBlurElement]]
    
    @scala.inline
    def creator_feImage(name: feImage): js.ThisFunction0[/* this */ BaseType, SVGFEImageElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGFEImageElement]]
    
    @scala.inline
    def creator_feMerge(name: feMerge): js.ThisFunction0[/* this */ BaseType, SVGFEMergeElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGFEMergeElement]]
    
    @scala.inline
    def creator_feMergeNode(name: feMergeNode): js.ThisFunction0[/* this */ BaseType, SVGFEMergeNodeElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGFEMergeNodeElement]]
    
    @scala.inline
    def creator_feMorphology(name: feMorphology): js.ThisFunction0[/* this */ BaseType, SVGFEMorphologyElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGFEMorphologyElement]]
    
    @scala.inline
    def creator_feOffset(name: feOffset): js.ThisFunction0[/* this */ BaseType, SVGFEOffsetElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGFEOffsetElement]]
    
    @scala.inline
    def creator_fePointLight(name: fePointLight): js.ThisFunction0[/* this */ BaseType, SVGFEPointLightElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGFEPointLightElement]]
    
    @scala.inline
    def creator_feSpecularLighting(name: feSpecularLighting): js.ThisFunction0[/* this */ BaseType, SVGFESpecularLightingElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGFESpecularLightingElement]]
    
    @scala.inline
    def creator_feSpotLight(name: feSpotLight): js.ThisFunction0[/* this */ BaseType, SVGFESpotLightElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGFESpotLightElement]]
    
    @scala.inline
    def creator_feTile(name: feTile): js.ThisFunction0[/* this */ BaseType, SVGFETileElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGFETileElement]]
    
    @scala.inline
    def creator_feTurbulence(name: feTurbulence): js.ThisFunction0[/* this */ BaseType, SVGFETurbulenceElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGFETurbulenceElement]]
    
    @scala.inline
    def creator_fieldset(name: fieldset): js.ThisFunction0[/* this */ BaseType, HTMLFieldSetElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLFieldSetElement]]
    
    @scala.inline
    def creator_figcaption(name: figcaption): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_figure(name: figure): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_filter(name: filter): js.ThisFunction0[/* this */ BaseType, SVGFilterElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGFilterElement]]
    
    @scala.inline
    def creator_font(name: font): js.ThisFunction0[/* this */ BaseType, HTMLFontElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLFontElement]]
    
    @scala.inline
    def creator_footer(name: footer): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_foreignObject(name: foreignObject): js.ThisFunction0[/* this */ BaseType, SVGForeignObjectElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGForeignObjectElement]]
    
    @scala.inline
    def creator_form(name: form): js.ThisFunction0[/* this */ BaseType, HTMLFormElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLFormElement]]
    
    @scala.inline
    def creator_frame(name: frame): js.ThisFunction0[/* this */ BaseType, HTMLFrameElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLFrameElement]]
    
    @scala.inline
    def creator_frameset(name: frameset): js.ThisFunction0[/* this */ BaseType, HTMLFrameSetElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLFrameSetElement]]
    
    @scala.inline
    def creator_g(name: g): js.ThisFunction0[/* this */ BaseType, SVGGElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGGElement]]
    
    @scala.inline
    def creator_h1(name: h1): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement]]
    
    @scala.inline
    def creator_h2(name: h2): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement]]
    
    @scala.inline
    def creator_h3(name: h3): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement]]
    
    @scala.inline
    def creator_h4(name: h4): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement]]
    
    @scala.inline
    def creator_h5(name: h5): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement]]
    
    @scala.inline
    def creator_h6(name: h6): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement]]
    
    @scala.inline
    def creator_head(name: head): js.ThisFunction0[/* this */ BaseType, HTMLHeadElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLHeadElement]]
    
    @scala.inline
    def creator_header(name: header): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_hgroup(name: hgroup): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_hr(name: hr): js.ThisFunction0[/* this */ BaseType, HTMLHRElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLHRElement]]
    
    @scala.inline
    def creator_html(name: html): js.ThisFunction0[/* this */ BaseType, HTMLHtmlElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLHtmlElement]]
    
    @scala.inline
    def creator_i(name: i): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_iframe(name: iframe): js.ThisFunction0[/* this */ BaseType, HTMLIFrameElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLIFrameElement]]
    
    @scala.inline
    def creator_image(name: image): js.ThisFunction0[/* this */ BaseType, SVGImageElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGImageElement]]
    
    @scala.inline
    def creator_img(name: img): js.ThisFunction0[/* this */ BaseType, HTMLImageElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLImageElement]]
    
    @scala.inline
    def creator_input(name: input): js.ThisFunction0[/* this */ BaseType, HTMLInputElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLInputElement]]
    
    @scala.inline
    def creator_ins(name: ins): js.ThisFunction0[/* this */ BaseType, HTMLModElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLModElement]]
    
    @scala.inline
    def creator_kbd(name: kbd): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_label(name: label): js.ThisFunction0[/* this */ BaseType, HTMLLabelElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLLabelElement]]
    
    @scala.inline
    def creator_legend(name: legend): js.ThisFunction0[/* this */ BaseType, HTMLLegendElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLLegendElement]]
    
    @scala.inline
    def creator_li(name: li): js.ThisFunction0[/* this */ BaseType, HTMLLIElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLLIElement]]
    
    @scala.inline
    def creator_line(name: line): js.ThisFunction0[/* this */ BaseType, SVGLineElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGLineElement]]
    
    @scala.inline
    def creator_linearGradient(name: linearGradient): js.ThisFunction0[/* this */ BaseType, SVGLinearGradientElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGLinearGradientElement]]
    
    @scala.inline
    def creator_link(name: link): js.ThisFunction0[/* this */ BaseType, HTMLLinkElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLLinkElement]]
    
    @scala.inline
    def creator_main(name: main): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_map(name: map): js.ThisFunction0[/* this */ BaseType, HTMLMapElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLMapElement]]
    
    @scala.inline
    def creator_mark(name: mark): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_marker(name: marker): js.ThisFunction0[/* this */ BaseType, SVGMarkerElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGMarkerElement]]
    
    @scala.inline
    def creator_marquee(name: marquee): js.ThisFunction0[/* this */ BaseType, HTMLMarqueeElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLMarqueeElement]]
    
    @scala.inline
    def creator_mask(name: mask): js.ThisFunction0[/* this */ BaseType, SVGMaskElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGMaskElement]]
    
    @scala.inline
    def creator_menu(name: menu): js.ThisFunction0[/* this */ BaseType, HTMLMenuElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLMenuElement]]
    
    @scala.inline
    def creator_meta(name: meta): js.ThisFunction0[/* this */ BaseType, HTMLMetaElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLMetaElement]]
    
    @scala.inline
    def creator_metadata(name: metadata): js.ThisFunction0[/* this */ BaseType, SVGMetadataElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGMetadataElement]]
    
    @scala.inline
    def creator_meter(name: meter): js.ThisFunction0[/* this */ BaseType, HTMLMeterElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLMeterElement]]
    
    @scala.inline
    def creator_nav(name: nav): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_noscript(name: noscript): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_object(name: `object`): js.ThisFunction0[/* this */ BaseType, HTMLObjectElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLObjectElement]]
    
    @scala.inline
    def creator_ol(name: ol): js.ThisFunction0[/* this */ BaseType, HTMLOListElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLOListElement]]
    
    @scala.inline
    def creator_optgroup(name: optgroup): js.ThisFunction0[/* this */ BaseType, HTMLOptGroupElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLOptGroupElement]]
    
    @scala.inline
    def creator_option(name: option): js.ThisFunction0[/* this */ BaseType, HTMLOptionElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLOptionElement]]
    
    @scala.inline
    def creator_output(name: output): js.ThisFunction0[/* this */ BaseType, HTMLOutputElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLOutputElement]]
    
    @scala.inline
    def creator_p(name: p): js.ThisFunction0[/* this */ BaseType, HTMLParagraphElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLParagraphElement]]
    
    @scala.inline
    def creator_param(name: param): js.ThisFunction0[/* this */ BaseType, HTMLParamElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLParamElement]]
    
    @scala.inline
    def creator_path(name: path): js.ThisFunction0[/* this */ BaseType, SVGPathElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGPathElement]]
    
    @scala.inline
    def creator_pattern(name: pattern): js.ThisFunction0[/* this */ BaseType, SVGPatternElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGPatternElement]]
    
    @scala.inline
    def creator_picture(name: picture): js.ThisFunction0[/* this */ BaseType, HTMLPictureElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLPictureElement]]
    
    @scala.inline
    def creator_polygon(name: polygon): js.ThisFunction0[/* this */ BaseType, SVGPolygonElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGPolygonElement]]
    
    @scala.inline
    def creator_polyline(name: polyline): js.ThisFunction0[/* this */ BaseType, SVGPolylineElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGPolylineElement]]
    
    @scala.inline
    def creator_pre(name: pre): js.ThisFunction0[/* this */ BaseType, HTMLPreElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLPreElement]]
    
    @scala.inline
    def creator_progress(name: progress): js.ThisFunction0[/* this */ BaseType, HTMLProgressElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLProgressElement]]
    
    @scala.inline
    def creator_q(name: q): js.ThisFunction0[/* this */ BaseType, HTMLQuoteElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLQuoteElement]]
    
    @scala.inline
    def creator_radialGradient(name: radialGradient): js.ThisFunction0[/* this */ BaseType, SVGRadialGradientElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGRadialGradientElement]]
    
    @scala.inline
    def creator_rect(name: rect): js.ThisFunction0[/* this */ BaseType, SVGRectElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGRectElement]]
    
    @scala.inline
    def creator_rp(name: rp): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_rt(name: rt): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_ruby(name: ruby): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_s(name: s): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_samp(name: samp): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_script(name: script): js.ThisFunction0[/* this */ BaseType, HTMLScriptElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLScriptElement]]
    
    @scala.inline
    def creator_section(name: section): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_select(name: select): js.ThisFunction0[/* this */ BaseType, HTMLSelectElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLSelectElement]]
    
    @scala.inline
    def creator_slot(name: slot): js.ThisFunction0[/* this */ BaseType, HTMLSlotElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLSlotElement]]
    
    @scala.inline
    def creator_small(name: small): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_source(name: source): js.ThisFunction0[/* this */ BaseType, HTMLSourceElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLSourceElement]]
    
    @scala.inline
    def creator_span(name: span): js.ThisFunction0[/* this */ BaseType, HTMLSpanElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLSpanElement]]
    
    @scala.inline
    def creator_stop(name: stop): js.ThisFunction0[/* this */ BaseType, SVGStopElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGStopElement]]
    
    @scala.inline
    def creator_strong(name: strong): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_style(name: style): js.ThisFunction0[/* this */ BaseType, HTMLStyleElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLStyleElement]]
    
    @scala.inline
    def creator_sub(name: sub): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_summary(name: summary): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_sup(name: sup): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_svg(name: svg): js.ThisFunction0[/* this */ BaseType, SVGSVGElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGSVGElement]]
    
    @scala.inline
    def creator_switch(name: switch): js.ThisFunction0[/* this */ BaseType, SVGSwitchElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGSwitchElement]]
    
    @scala.inline
    def creator_symbol(name: symbol): js.ThisFunction0[/* this */ BaseType, SVGSymbolElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGSymbolElement]]
    
    @scala.inline
    def creator_table(name: table): js.ThisFunction0[/* this */ BaseType, HTMLTableElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLTableElement]]
    
    @scala.inline
    def creator_tbody(name: tbody): js.ThisFunction0[/* this */ BaseType, HTMLTableSectionElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLTableSectionElement]]
    
    @scala.inline
    def creator_td(name: td): js.ThisFunction0[/* this */ BaseType, HTMLTableDataCellElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLTableDataCellElement]]
    
    @scala.inline
    def creator_template(name: template): js.ThisFunction0[/* this */ BaseType, HTMLTemplateElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLTemplateElement]]
    
    @scala.inline
    def creator_text(name: text): js.ThisFunction0[/* this */ BaseType, SVGTextElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGTextElement]]
    
    @scala.inline
    def creator_textPath(name: textPath): js.ThisFunction0[/* this */ BaseType, SVGTextPathElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGTextPathElement]]
    
    @scala.inline
    def creator_textarea(name: textarea): js.ThisFunction0[/* this */ BaseType, HTMLTextAreaElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLTextAreaElement]]
    
    @scala.inline
    def creator_tfoot(name: tfoot): js.ThisFunction0[/* this */ BaseType, HTMLTableSectionElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLTableSectionElement]]
    
    @scala.inline
    def creator_th(name: th): js.ThisFunction0[/* this */ BaseType, HTMLTableHeaderCellElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLTableHeaderCellElement]]
    
    @scala.inline
    def creator_thead(name: thead): js.ThisFunction0[/* this */ BaseType, HTMLTableSectionElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLTableSectionElement]]
    
    @scala.inline
    def creator_time(name: time): js.ThisFunction0[/* this */ BaseType, HTMLTimeElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLTimeElement]]
    
    @scala.inline
    def creator_title(name: title): js.ThisFunction0[/* this */ BaseType, HTMLTitleElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLTitleElement]]
    
    @scala.inline
    def creator_tr(name: tr): js.ThisFunction0[/* this */ BaseType, HTMLTableRowElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLTableRowElement]]
    
    @scala.inline
    def creator_track(name: track): js.ThisFunction0[/* this */ BaseType, HTMLTrackElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLTrackElement]]
    
    @scala.inline
    def creator_tspan(name: tspan): js.ThisFunction0[/* this */ BaseType, SVGTSpanElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGTSpanElement]]
    
    @scala.inline
    def creator_u(name: u): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_ul(name: ul): js.ThisFunction0[/* this */ BaseType, HTMLUListElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLUListElement]]
    
    @scala.inline
    def creator_use(name: use): js.ThisFunction0[/* this */ BaseType, SVGUseElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGUseElement]]
    
    @scala.inline
    def creator_var(name: `var`): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def creator_video(name: video): js.ThisFunction0[/* this */ BaseType, HTMLVideoElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLVideoElement]]
    
    @scala.inline
    def creator_view(name: view): js.ThisFunction0[/* this */ BaseType, SVGViewElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, SVGViewElement]]
    
    @scala.inline
    def creator_wbr(name: wbr): js.ThisFunction0[/* this */ BaseType, HTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("creator")(name.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, HTMLElement]]
    
    @scala.inline
    def cross[S, T](a: Iterable[S], b: Iterable[T]): js.Array[js.Tuple2[S, T]] = (^.asInstanceOf[js.Dynamic].applyDynamic("cross")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Array[js.Tuple2[S, T]]]
    @scala.inline
    def cross[S, T, U](a: Iterable[S], b: Iterable[T], reducer: js.Function2[/* a */ S, /* b */ T, U]): js.Array[U] = (^.asInstanceOf[js.Dynamic].applyDynamic("cross")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any], reducer.asInstanceOf[js.Any])).asInstanceOf[js.Array[U]]
    
    @scala.inline
    def csv[Columns /* <: String */](url: String): js.Promise[DSVRowArray[Columns]] = ^.asInstanceOf[js.Dynamic].applyDynamic("csv")(url.asInstanceOf[js.Any]).asInstanceOf[js.Promise[DSVRowArray[Columns]]]
    @scala.inline
    def csv[Columns /* <: String */](url: String, init: RequestInit): js.Promise[DSVRowArray[Columns]] = (^.asInstanceOf[js.Dynamic].applyDynamic("csv")(url.asInstanceOf[js.Any], init.asInstanceOf[js.Any])).asInstanceOf[js.Promise[DSVRowArray[Columns]]]
    @scala.inline
    def csv[ParsedRow /* <: js.Object */, Columns /* <: String */](
      url: String,
      init: RequestInit,
      row: js.Function3[
          /* rawRow */ DSVRowString[Columns], 
          /* index */ Double, 
          /* columns */ js.Array[Columns], 
          js.UndefOr[ParsedRow | Null]
        ]
    ): js.Promise[DSVParsedArray[ParsedRow]] = (^.asInstanceOf[js.Dynamic].applyDynamic("csv")(url.asInstanceOf[js.Any], init.asInstanceOf[js.Any], row.asInstanceOf[js.Any])).asInstanceOf[js.Promise[DSVParsedArray[ParsedRow]]]
    @scala.inline
    def csv[ParsedRow /* <: js.Object */, Columns /* <: String */](
      url: String,
      row: js.Function3[
          /* rawRow */ DSVRowString[Columns], 
          /* index */ Double, 
          /* columns */ js.Array[Columns], 
          js.UndefOr[ParsedRow | Null]
        ]
    ): js.Promise[DSVParsedArray[ParsedRow]] = (^.asInstanceOf[js.Dynamic].applyDynamic("csv")(url.asInstanceOf[js.Any], row.asInstanceOf[js.Any])).asInstanceOf[js.Promise[DSVParsedArray[ParsedRow]]]
    
    @scala.inline
    def csvFormat[T /* <: js.Object */](rows: js.Array[T]): String = ^.asInstanceOf[js.Dynamic].applyDynamic("csvFormat")(rows.asInstanceOf[js.Any]).asInstanceOf[String]
    @scala.inline
    def csvFormat[T /* <: js.Object */](rows: js.Array[T], columns: js.Array[/* keyof T */ String]): String = (^.asInstanceOf[js.Dynamic].applyDynamic("csvFormat")(rows.asInstanceOf[js.Any], columns.asInstanceOf[js.Any])).asInstanceOf[String]
    
    @scala.inline
    def csvFormatBody[T /* <: js.Object */](rows: js.Array[T]): String = ^.asInstanceOf[js.Dynamic].applyDynamic("csvFormatBody")(rows.asInstanceOf[js.Any]).asInstanceOf[String]
    @scala.inline
    def csvFormatBody[T /* <: js.Object */](rows: js.Array[T], columns: js.Array[/* keyof T */ String]): String = (^.asInstanceOf[js.Dynamic].applyDynamic("csvFormatBody")(rows.asInstanceOf[js.Any], columns.asInstanceOf[js.Any])).asInstanceOf[String]
    
    @scala.inline
    def csvFormatRow(row: js.Array[String]): String = ^.asInstanceOf[js.Dynamic].applyDynamic("csvFormatRow")(row.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def csvFormatRows(rows: js.Array[js.Array[String]]): String = ^.asInstanceOf[js.Dynamic].applyDynamic("csvFormatRows")(rows.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def csvFormatValue(value: String): String = ^.asInstanceOf[js.Dynamic].applyDynamic("csvFormatValue")(value.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def csvParse[Columns /* <: String */](csvString: String): DSVRowArray[Columns] = ^.asInstanceOf[js.Dynamic].applyDynamic("csvParse")(csvString.asInstanceOf[js.Any]).asInstanceOf[DSVRowArray[Columns]]
    @scala.inline
    def csvParse[ParsedRow /* <: js.Object */, Columns /* <: String */](
      csvString: String,
      row: js.Function3[
          /* rawRow */ DSVRowString[Columns], 
          /* index */ Double, 
          /* columns */ js.Array[Columns], 
          js.UndefOr[ParsedRow | Null]
        ]
    ): DSVParsedArray[ParsedRow] = (^.asInstanceOf[js.Dynamic].applyDynamic("csvParse")(csvString.asInstanceOf[js.Any], row.asInstanceOf[js.Any])).asInstanceOf[DSVParsedArray[ParsedRow]]
    
    @scala.inline
    def csvParseRows(csvString: String): js.Array[js.Array[String]] = ^.asInstanceOf[js.Dynamic].applyDynamic("csvParseRows")(csvString.asInstanceOf[js.Any]).asInstanceOf[js.Array[js.Array[String]]]
    @scala.inline
    def csvParseRows[ParsedRow /* <: js.Object */](
      csvString: String,
      row: js.Function2[/* rawRow */ js.Array[String], /* index */ Double, js.UndefOr[ParsedRow | Null]]
    ): js.Array[ParsedRow] = (^.asInstanceOf[js.Dynamic].applyDynamic("csvParseRows")(csvString.asInstanceOf[js.Any], row.asInstanceOf[js.Any])).asInstanceOf[js.Array[ParsedRow]]
    
    @JSImport("plotly.js/lib/core", "d3.cubehelix")
    @js.native
    val cubehelix: CubehelixColorFactory = js.native
    @scala.inline
    def cubehelix(color: ColorCommonInstance): CubehelixColor = ^.asInstanceOf[js.Dynamic].applyDynamic("cubehelix")(color.asInstanceOf[js.Any]).asInstanceOf[CubehelixColor]
    /**
      * Converts the provided color instance and returns a Cubehelix color.
      * The color instance is specified, it is converted to the RGB color space using color.rgb and then converted to Cubehelix.
      * (Colors already in the Cubehelix color space skip the conversion to RGB.)
      *
      * @param color A permissible color space instance.
      */
    @scala.inline
    def cubehelix(color: ColorSpaceObject): CubehelixColor = ^.asInstanceOf[js.Dynamic].applyDynamic("cubehelix")(color.asInstanceOf[js.Any]).asInstanceOf[CubehelixColor]
    /**
      * Parses the specified CSS Color Module Level 3 specifier string, returning an Cubehelix color.
      * If the specifier was not valid, null is returned.
      *
      * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
      */
    @scala.inline
    def cubehelix(cssColorSpecifier: String): CubehelixColor = ^.asInstanceOf[js.Dynamic].applyDynamic("cubehelix")(cssColorSpecifier.asInstanceOf[js.Any]).asInstanceOf[CubehelixColor]
    /**
      * Constructs a new Cubehelix color based on the specified channel values and opacity.
      *
      * @param h Hue channel value.
      * @param s Saturation channel value.
      * @param l Lightness channel value.
      * @param opacity Optional opacity value, defaults to 1.
      */
    @scala.inline
    def cubehelix(h: Double, s: Double, l: Double): CubehelixColor = (^.asInstanceOf[js.Dynamic].applyDynamic("cubehelix")(h.asInstanceOf[js.Any], s.asInstanceOf[js.Any], l.asInstanceOf[js.Any])).asInstanceOf[CubehelixColor]
    @scala.inline
    def cubehelix(h: Double, s: Double, l: Double, opacity: Double): CubehelixColor = (^.asInstanceOf[js.Dynamic].applyDynamic("cubehelix")(h.asInstanceOf[js.Any], s.asInstanceOf[js.Any], l.asInstanceOf[js.Any], opacity.asInstanceOf[js.Any])).asInstanceOf[CubehelixColor]
    
    @scala.inline
    def cumsum[T /* <: Numeric */](iterable: Iterable[js.UndefOr[T | Null]]): Float64Array = ^.asInstanceOf[js.Dynamic].applyDynamic("cumsum")(iterable.asInstanceOf[js.Any]).asInstanceOf[Float64Array]
    @scala.inline
    def cumsum[T](
      iterable: Iterable[T],
      accessor: js.Function3[/* element */ T, /* i */ Double, /* array */ Iterable[T], js.UndefOr[Double | Null]]
    ): Float64Array = (^.asInstanceOf[js.Dynamic].applyDynamic("cumsum")(iterable.asInstanceOf[js.Any], accessor.asInstanceOf[js.Any])).asInstanceOf[Float64Array]
    
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    @scala.inline
    def curveBasis(context: Path_): CurveGenerator = ^.asInstanceOf[js.Dynamic].applyDynamic("curveBasis")(context.asInstanceOf[js.Any]).asInstanceOf[CurveGenerator]
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    @scala.inline
    def curveBasis(context: CanvasRenderingContext2D): CurveGenerator = ^.asInstanceOf[js.Dynamic].applyDynamic("curveBasis")(context.asInstanceOf[js.Any]).asInstanceOf[CurveGenerator]
    
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    @scala.inline
    def curveBasisClosed(context: Path_): CurveGenerator = ^.asInstanceOf[js.Dynamic].applyDynamic("curveBasisClosed")(context.asInstanceOf[js.Any]).asInstanceOf[CurveGenerator]
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    @scala.inline
    def curveBasisClosed(context: CanvasRenderingContext2D): CurveGenerator = ^.asInstanceOf[js.Dynamic].applyDynamic("curveBasisClosed")(context.asInstanceOf[js.Any]).asInstanceOf[CurveGenerator]
    
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    @scala.inline
    def curveBasisOpen(context: Path_): CurveGenerator = ^.asInstanceOf[js.Dynamic].applyDynamic("curveBasisOpen")(context.asInstanceOf[js.Any]).asInstanceOf[CurveGenerator]
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    @scala.inline
    def curveBasisOpen(context: CanvasRenderingContext2D): CurveGenerator = ^.asInstanceOf[js.Dynamic].applyDynamic("curveBasisOpen")(context.asInstanceOf[js.Any]).asInstanceOf[CurveGenerator]
    
    @JSImport("plotly.js/lib/core", "d3.curveBundle")
    @js.native
    val curveBundle: CurveBundleFactory = js.native
    
    @JSImport("plotly.js/lib/core", "d3.curveCardinal")
    @js.native
    val curveCardinal: CurveCardinalFactory = js.native
    
    @JSImport("plotly.js/lib/core", "d3.curveCardinalClosed")
    @js.native
    val curveCardinalClosed: CurveCardinalFactory = js.native
    
    @JSImport("plotly.js/lib/core", "d3.curveCardinalOpen")
    @js.native
    val curveCardinalOpen: CurveCardinalFactory = js.native
    
    @JSImport("plotly.js/lib/core", "d3.curveCatmullRom")
    @js.native
    val curveCatmullRom: CurveCatmullRomFactory = js.native
    
    @JSImport("plotly.js/lib/core", "d3.curveCatmullRomClosed")
    @js.native
    val curveCatmullRomClosed: CurveCatmullRomFactory = js.native
    
    @JSImport("plotly.js/lib/core", "d3.curveCatmullRomOpen")
    @js.native
    val curveCatmullRomOpen: CurveCatmullRomFactory = js.native
    
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    @scala.inline
    def curveLinear(context: Path_): CurveGenerator = ^.asInstanceOf[js.Dynamic].applyDynamic("curveLinear")(context.asInstanceOf[js.Any]).asInstanceOf[CurveGenerator]
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    @scala.inline
    def curveLinear(context: CanvasRenderingContext2D): CurveGenerator = ^.asInstanceOf[js.Dynamic].applyDynamic("curveLinear")(context.asInstanceOf[js.Any]).asInstanceOf[CurveGenerator]
    
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    @scala.inline
    def curveLinearClosed(context: Path_): CurveGenerator = ^.asInstanceOf[js.Dynamic].applyDynamic("curveLinearClosed")(context.asInstanceOf[js.Any]).asInstanceOf[CurveGenerator]
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    @scala.inline
    def curveLinearClosed(context: CanvasRenderingContext2D): CurveGenerator = ^.asInstanceOf[js.Dynamic].applyDynamic("curveLinearClosed")(context.asInstanceOf[js.Any]).asInstanceOf[CurveGenerator]
    
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    @scala.inline
    def curveMonotoneX(context: Path_): CurveGenerator = ^.asInstanceOf[js.Dynamic].applyDynamic("curveMonotoneX")(context.asInstanceOf[js.Any]).asInstanceOf[CurveGenerator]
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    @scala.inline
    def curveMonotoneX(context: CanvasRenderingContext2D): CurveGenerator = ^.asInstanceOf[js.Dynamic].applyDynamic("curveMonotoneX")(context.asInstanceOf[js.Any]).asInstanceOf[CurveGenerator]
    
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    @scala.inline
    def curveMonotoneY(context: Path_): CurveGenerator = ^.asInstanceOf[js.Dynamic].applyDynamic("curveMonotoneY")(context.asInstanceOf[js.Any]).asInstanceOf[CurveGenerator]
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    @scala.inline
    def curveMonotoneY(context: CanvasRenderingContext2D): CurveGenerator = ^.asInstanceOf[js.Dynamic].applyDynamic("curveMonotoneY")(context.asInstanceOf[js.Any]).asInstanceOf[CurveGenerator]
    
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    @scala.inline
    def curveNatural(context: Path_): CurveGenerator = ^.asInstanceOf[js.Dynamic].applyDynamic("curveNatural")(context.asInstanceOf[js.Any]).asInstanceOf[CurveGenerator]
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    @scala.inline
    def curveNatural(context: CanvasRenderingContext2D): CurveGenerator = ^.asInstanceOf[js.Dynamic].applyDynamic("curveNatural")(context.asInstanceOf[js.Any]).asInstanceOf[CurveGenerator]
    
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    @scala.inline
    def curveStep(context: Path_): CurveGenerator = ^.asInstanceOf[js.Dynamic].applyDynamic("curveStep")(context.asInstanceOf[js.Any]).asInstanceOf[CurveGenerator]
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    @scala.inline
    def curveStep(context: CanvasRenderingContext2D): CurveGenerator = ^.asInstanceOf[js.Dynamic].applyDynamic("curveStep")(context.asInstanceOf[js.Any]).asInstanceOf[CurveGenerator]
    
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    @scala.inline
    def curveStepAfter(context: Path_): CurveGenerator = ^.asInstanceOf[js.Dynamic].applyDynamic("curveStepAfter")(context.asInstanceOf[js.Any]).asInstanceOf[CurveGenerator]
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    @scala.inline
    def curveStepAfter(context: CanvasRenderingContext2D): CurveGenerator = ^.asInstanceOf[js.Dynamic].applyDynamic("curveStepAfter")(context.asInstanceOf[js.Any]).asInstanceOf[CurveGenerator]
    
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    @scala.inline
    def curveStepBefore(context: Path_): CurveGenerator = ^.asInstanceOf[js.Dynamic].applyDynamic("curveStepBefore")(context.asInstanceOf[js.Any]).asInstanceOf[CurveGenerator]
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    @scala.inline
    def curveStepBefore(context: CanvasRenderingContext2D): CurveGenerator = ^.asInstanceOf[js.Dynamic].applyDynamic("curveStepBefore")(context.asInstanceOf[js.Any]).asInstanceOf[CurveGenerator]
    
    @scala.inline
    def descending(): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("descending")().asInstanceOf[Double]
    @scala.inline
    def descending(a: Unit, b: Primitive): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("descending")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[Double]
    @scala.inline
    def descending(a: Primitive): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("descending")(a.asInstanceOf[js.Any]).asInstanceOf[Double]
    @scala.inline
    def descending(a: Primitive, b: Primitive): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("descending")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    @scala.inline
    def deviation[T /* <: Numeric */](iterable: Iterable[js.UndefOr[T | Null]]): js.UndefOr[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("deviation")(iterable.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[Double]]
    @scala.inline
    def deviation[T](
      iterable: Iterable[T],
      accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[Double | Null]]
    ): js.UndefOr[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("deviation")(iterable.asInstanceOf[js.Any], accessor.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[Double]]
    
    @scala.inline
    def difference[T](iterable: Iterable[T], others: Iterable[T]*): Set[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("difference")(iterable.asInstanceOf[js.Any], others.asInstanceOf[js.Any])).asInstanceOf[Set[T]]
    
    @scala.inline
    def disjoint[T](a: Iterable[T], b: Iterable[T]): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("disjoint")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[Boolean]
    
    @scala.inline
    def dispatch[T /* <: js.Object */](types: String*): Dispatch_[T] = ^.asInstanceOf[js.Dynamic].applyDynamic("dispatch")(types.asInstanceOf[js.Any]).asInstanceOf[Dispatch_[T]]
    
    @scala.inline
    def drag[GElement /* <: DraggedElementBaseType */, Datum](): DragBehavior[GElement, Datum, Datum | SubjectPosition] = ^.asInstanceOf[js.Dynamic].applyDynamic("drag")().asInstanceOf[DragBehavior[GElement, Datum, Datum | SubjectPosition]]
    
    @scala.inline
    def dragDisable(window: Window): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("dragDisable")(window.asInstanceOf[js.Any]).asInstanceOf[Unit]
    
    @scala.inline
    def dragEnable(window: Window): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("dragEnable")(window.asInstanceOf[js.Any]).asInstanceOf[Unit]
    @scala.inline
    def dragEnable(window: Window, noClick: Boolean): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("dragEnable")(window.asInstanceOf[js.Any], noClick.asInstanceOf[js.Any])).asInstanceOf[Unit]
    
    @scala.inline
    def drag_GElement_DraggedElementBaseTypeDatumSubject[GElement /* <: DraggedElementBaseType */, Datum, Subject](): DragBehavior[GElement, Datum, Subject] = ^.asInstanceOf[js.Dynamic].applyDynamic("drag")().asInstanceOf[DragBehavior[GElement, Datum, Subject]]
    
    @scala.inline
    def dsv[Columns /* <: String */](delimiter: String, url: String): js.Promise[DSVRowArray[Columns]] = (^.asInstanceOf[js.Dynamic].applyDynamic("dsv")(delimiter.asInstanceOf[js.Any], url.asInstanceOf[js.Any])).asInstanceOf[js.Promise[DSVRowArray[Columns]]]
    @scala.inline
    def dsv[Columns /* <: String */](delimiter: String, url: String, init: RequestInit): js.Promise[DSVRowArray[Columns]] = (^.asInstanceOf[js.Dynamic].applyDynamic("dsv")(delimiter.asInstanceOf[js.Any], url.asInstanceOf[js.Any], init.asInstanceOf[js.Any])).asInstanceOf[js.Promise[DSVRowArray[Columns]]]
    @scala.inline
    def dsv[ParsedRow /* <: js.Object */, Columns /* <: String */](
      delimiter: String,
      url: String,
      init: RequestInit,
      row: js.Function3[
          /* rawRow */ DSVRowString[Columns], 
          /* index */ Double, 
          /* columns */ js.Array[Columns], 
          js.UndefOr[ParsedRow | Null]
        ]
    ): js.Promise[DSVParsedArray[ParsedRow]] = (^.asInstanceOf[js.Dynamic].applyDynamic("dsv")(delimiter.asInstanceOf[js.Any], url.asInstanceOf[js.Any], init.asInstanceOf[js.Any], row.asInstanceOf[js.Any])).asInstanceOf[js.Promise[DSVParsedArray[ParsedRow]]]
    @scala.inline
    def dsv[ParsedRow /* <: js.Object */, Columns /* <: String */](
      delimiter: String,
      url: String,
      row: js.Function3[
          /* rawRow */ DSVRowString[Columns], 
          /* index */ Double, 
          /* columns */ js.Array[Columns], 
          js.UndefOr[ParsedRow | Null]
        ]
    ): js.Promise[DSVParsedArray[ParsedRow]] = (^.asInstanceOf[js.Dynamic].applyDynamic("dsv")(delimiter.asInstanceOf[js.Any], url.asInstanceOf[js.Any], row.asInstanceOf[js.Any])).asInstanceOf[js.Promise[DSVParsedArray[ParsedRow]]]
    
    @scala.inline
    def dsvFormat(delimiter: String): DSV = ^.asInstanceOf[js.Dynamic].applyDynamic("dsvFormat")(delimiter.asInstanceOf[js.Any]).asInstanceOf[DSV]
    
    @JSImport("plotly.js/lib/core", "d3.easeBack")
    @js.native
    val easeBack: BackEasingFactory = js.native
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    @scala.inline
    def easeBack(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeBack")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @JSImport("plotly.js/lib/core", "d3.easeBackIn")
    @js.native
    val easeBackIn: BackEasingFactory = js.native
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    @scala.inline
    def easeBackIn(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeBackIn")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @JSImport("plotly.js/lib/core", "d3.easeBackInOut")
    @js.native
    val easeBackInOut: BackEasingFactory = js.native
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    @scala.inline
    def easeBackInOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeBackInOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @JSImport("plotly.js/lib/core", "d3.easeBackOut")
    @js.native
    val easeBackOut: BackEasingFactory = js.native
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    @scala.inline
    def easeBackOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeBackOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def easeBounce(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeBounce")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def easeBounceIn(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeBounceIn")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def easeBounceInOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeBounceInOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def easeBounceOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeBounceOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def easeCircle(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeCircle")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def easeCircleIn(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeCircleIn")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def easeCircleInOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeCircleInOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def easeCircleOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeCircleOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def easeCubic(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeCubic")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def easeCubicIn(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeCubicIn")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def easeCubicInOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeCubicInOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def easeCubicOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeCubicOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @JSImport("plotly.js/lib/core", "d3.easeElastic")
    @js.native
    val easeElastic: ElasticEasingFactory = js.native
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    @scala.inline
    def easeElastic(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeElastic")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @JSImport("plotly.js/lib/core", "d3.easeElasticIn")
    @js.native
    val easeElasticIn: ElasticEasingFactory = js.native
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    @scala.inline
    def easeElasticIn(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeElasticIn")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @JSImport("plotly.js/lib/core", "d3.easeElasticInOut")
    @js.native
    val easeElasticInOut: ElasticEasingFactory = js.native
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    @scala.inline
    def easeElasticInOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeElasticInOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @JSImport("plotly.js/lib/core", "d3.easeElasticOut")
    @js.native
    val easeElasticOut: ElasticEasingFactory = js.native
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    @scala.inline
    def easeElasticOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeElasticOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def easeExp(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeExp")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def easeExpIn(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeExpIn")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def easeExpInOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeExpInOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def easeExpOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeExpOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def easeLinear(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeLinear")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @JSImport("plotly.js/lib/core", "d3.easePoly")
    @js.native
    val easePoly: PolynomialEasingFactory = js.native
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    @scala.inline
    def easePoly(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easePoly")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @JSImport("plotly.js/lib/core", "d3.easePolyIn")
    @js.native
    val easePolyIn: PolynomialEasingFactory = js.native
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    @scala.inline
    def easePolyIn(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easePolyIn")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @JSImport("plotly.js/lib/core", "d3.easePolyInOut")
    @js.native
    val easePolyInOut: PolynomialEasingFactory = js.native
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    @scala.inline
    def easePolyInOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easePolyInOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @JSImport("plotly.js/lib/core", "d3.easePolyOut")
    @js.native
    val easePolyOut: PolynomialEasingFactory = js.native
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    @scala.inline
    def easePolyOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easePolyOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def easeQuad(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeQuad")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def easeQuadIn(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeQuadIn")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def easeQuadInOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeQuadInOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def easeQuadOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeQuadOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def easeSin(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeSin")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def easeSinIn(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeSinIn")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def easeSinInOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeSinInOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def easeSinOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeSinOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def every[T](
      iterable: Iterable[T],
      test: js.Function3[/* value */ T, /* index */ Double, /* iterable */ Iterable[T], js.Any]
    ): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("every")(iterable.asInstanceOf[js.Any], test.asInstanceOf[js.Any])).asInstanceOf[Boolean]
    
    @scala.inline
    def extent(iterable: Iterable[String]): js.Tuple2[String | Unit, String | Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("extent")(iterable.asInstanceOf[js.Any]).asInstanceOf[js.Tuple2[String | Unit, String | Unit]]
    @scala.inline
    def extent[T](
      iterable: Iterable[T],
      accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[String | Null]]
    ): js.Tuple2[String | Unit, String | Unit] = (^.asInstanceOf[js.Dynamic].applyDynamic("extent")(iterable.asInstanceOf[js.Any], accessor.asInstanceOf[js.Any])).asInstanceOf[js.Tuple2[String | Unit, String | Unit]]
    
    @scala.inline
    def extent_TU_Numeric[T, U /* <: Numeric */](
      iterable: Iterable[T],
      accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[U | Null]]
    ): js.Tuple2[U | Unit, U | Unit] = (^.asInstanceOf[js.Dynamic].applyDynamic("extent")(iterable.asInstanceOf[js.Any], accessor.asInstanceOf[js.Any])).asInstanceOf[js.Tuple2[U | Unit, U | Unit]]
    
    @scala.inline
    def extent_T_Numeric[T /* <: Numeric */](iterable: Iterable[T]): js.Tuple2[T | Unit, T | Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("extent")(iterable.asInstanceOf[js.Any]).asInstanceOf[js.Tuple2[T | Unit, T | Unit]]
    
    @scala.inline
    def filter[T](
      iterable: Iterable[T],
      test: js.Function3[/* value */ T, /* index */ Double, /* iterable */ Iterable[T], js.Any]
    ): js.Array[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("filter")(iterable.asInstanceOf[js.Any], test.asInstanceOf[js.Any])).asInstanceOf[js.Array[T]]
    
    @scala.inline
    def forceCenter[NodeDatum /* <: SimulationNodeDatum */](): ForceCenter_[NodeDatum] = ^.asInstanceOf[js.Dynamic].applyDynamic("forceCenter")().asInstanceOf[ForceCenter_[NodeDatum]]
    @scala.inline
    def forceCenter[NodeDatum /* <: SimulationNodeDatum */](x: Double): ForceCenter_[NodeDatum] = ^.asInstanceOf[js.Dynamic].applyDynamic("forceCenter")(x.asInstanceOf[js.Any]).asInstanceOf[ForceCenter_[NodeDatum]]
    @scala.inline
    def forceCenter[NodeDatum /* <: SimulationNodeDatum */](x: Double, y: Double): ForceCenter_[NodeDatum] = (^.asInstanceOf[js.Dynamic].applyDynamic("forceCenter")(x.asInstanceOf[js.Any], y.asInstanceOf[js.Any])).asInstanceOf[ForceCenter_[NodeDatum]]
    @scala.inline
    def forceCenter[NodeDatum /* <: SimulationNodeDatum */](x: Unit, y: Double): ForceCenter_[NodeDatum] = (^.asInstanceOf[js.Dynamic].applyDynamic("forceCenter")(x.asInstanceOf[js.Any], y.asInstanceOf[js.Any])).asInstanceOf[ForceCenter_[NodeDatum]]
    
    @scala.inline
    def forceCollide[NodeDatum /* <: SimulationNodeDatum */](): ForceCollide_[NodeDatum] = ^.asInstanceOf[js.Dynamic].applyDynamic("forceCollide")().asInstanceOf[ForceCollide_[NodeDatum]]
    @scala.inline
    def forceCollide[NodeDatum /* <: SimulationNodeDatum */](
      radius: js.Function3[/* node */ NodeDatum, /* i */ Double, /* nodes */ js.Array[NodeDatum], Double]
    ): ForceCollide_[NodeDatum] = ^.asInstanceOf[js.Dynamic].applyDynamic("forceCollide")(radius.asInstanceOf[js.Any]).asInstanceOf[ForceCollide_[NodeDatum]]
    @scala.inline
    def forceCollide[NodeDatum /* <: SimulationNodeDatum */](radius: Double): ForceCollide_[NodeDatum] = ^.asInstanceOf[js.Dynamic].applyDynamic("forceCollide")(radius.asInstanceOf[js.Any]).asInstanceOf[ForceCollide_[NodeDatum]]
    
    @scala.inline
    def forceLink[NodeDatum /* <: SimulationNodeDatum */, LinksDatum /* <: SimulationLinkDatum[NodeDatum] */](): ForceLink_[NodeDatum, LinksDatum] = ^.asInstanceOf[js.Dynamic].applyDynamic("forceLink")().asInstanceOf[ForceLink_[NodeDatum, LinksDatum]]
    @scala.inline
    def forceLink[NodeDatum /* <: SimulationNodeDatum */, LinksDatum /* <: SimulationLinkDatum[NodeDatum] */](links: js.Array[LinksDatum]): ForceLink_[NodeDatum, LinksDatum] = ^.asInstanceOf[js.Dynamic].applyDynamic("forceLink")(links.asInstanceOf[js.Any]).asInstanceOf[ForceLink_[NodeDatum, LinksDatum]]
    
    @scala.inline
    def forceManyBody[NodeDatum /* <: SimulationNodeDatum */](): ForceManyBody_[NodeDatum] = ^.asInstanceOf[js.Dynamic].applyDynamic("forceManyBody")().asInstanceOf[ForceManyBody_[NodeDatum]]
    
    @scala.inline
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]): ForceRadial_[NodeDatum] = ^.asInstanceOf[js.Dynamic].applyDynamic("forceRadial")(radius.asInstanceOf[js.Any]).asInstanceOf[ForceRadial_[NodeDatum]]
    @scala.inline
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
      radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
      x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
    ): ForceRadial_[NodeDatum] = (^.asInstanceOf[js.Dynamic].applyDynamic("forceRadial")(radius.asInstanceOf[js.Any], x.asInstanceOf[js.Any])).asInstanceOf[ForceRadial_[NodeDatum]]
    @scala.inline
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
      radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
      x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
      y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
    ): ForceRadial_[NodeDatum] = (^.asInstanceOf[js.Dynamic].applyDynamic("forceRadial")(radius.asInstanceOf[js.Any], x.asInstanceOf[js.Any], y.asInstanceOf[js.Any])).asInstanceOf[ForceRadial_[NodeDatum]]
    @scala.inline
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
      radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
      x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
      y: Double
    ): ForceRadial_[NodeDatum] = (^.asInstanceOf[js.Dynamic].applyDynamic("forceRadial")(radius.asInstanceOf[js.Any], x.asInstanceOf[js.Any], y.asInstanceOf[js.Any])).asInstanceOf[ForceRadial_[NodeDatum]]
    @scala.inline
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
      radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
      x: Double
    ): ForceRadial_[NodeDatum] = (^.asInstanceOf[js.Dynamic].applyDynamic("forceRadial")(radius.asInstanceOf[js.Any], x.asInstanceOf[js.Any])).asInstanceOf[ForceRadial_[NodeDatum]]
    @scala.inline
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
      radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
      x: Double,
      y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
    ): ForceRadial_[NodeDatum] = (^.asInstanceOf[js.Dynamic].applyDynamic("forceRadial")(radius.asInstanceOf[js.Any], x.asInstanceOf[js.Any], y.asInstanceOf[js.Any])).asInstanceOf[ForceRadial_[NodeDatum]]
    @scala.inline
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
      radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
      x: Double,
      y: Double
    ): ForceRadial_[NodeDatum] = (^.asInstanceOf[js.Dynamic].applyDynamic("forceRadial")(radius.asInstanceOf[js.Any], x.asInstanceOf[js.Any], y.asInstanceOf[js.Any])).asInstanceOf[ForceRadial_[NodeDatum]]
    @scala.inline
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
      radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
      x: Unit,
      y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
    ): ForceRadial_[NodeDatum] = (^.asInstanceOf[js.Dynamic].applyDynamic("forceRadial")(radius.asInstanceOf[js.Any], x.asInstanceOf[js.Any], y.asInstanceOf[js.Any])).asInstanceOf[ForceRadial_[NodeDatum]]
    @scala.inline
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
      radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
      x: Unit,
      y: Double
    ): ForceRadial_[NodeDatum] = (^.asInstanceOf[js.Dynamic].applyDynamic("forceRadial")(radius.asInstanceOf[js.Any], x.asInstanceOf[js.Any], y.asInstanceOf[js.Any])).asInstanceOf[ForceRadial_[NodeDatum]]
    @scala.inline
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](radius: Double): ForceRadial_[NodeDatum] = ^.asInstanceOf[js.Dynamic].applyDynamic("forceRadial")(radius.asInstanceOf[js.Any]).asInstanceOf[ForceRadial_[NodeDatum]]
    @scala.inline
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
      radius: Double,
      x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
    ): ForceRadial_[NodeDatum] = (^.asInstanceOf[js.Dynamic].applyDynamic("forceRadial")(radius.asInstanceOf[js.Any], x.asInstanceOf[js.Any])).asInstanceOf[ForceRadial_[NodeDatum]]
    @scala.inline
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
      radius: Double,
      x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
      y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
    ): ForceRadial_[NodeDatum] = (^.asInstanceOf[js.Dynamic].applyDynamic("forceRadial")(radius.asInstanceOf[js.Any], x.asInstanceOf[js.Any], y.asInstanceOf[js.Any])).asInstanceOf[ForceRadial_[NodeDatum]]
    @scala.inline
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
      radius: Double,
      x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
      y: Double
    ): ForceRadial_[NodeDatum] = (^.asInstanceOf[js.Dynamic].applyDynamic("forceRadial")(radius.asInstanceOf[js.Any], x.asInstanceOf[js.Any], y.asInstanceOf[js.Any])).asInstanceOf[ForceRadial_[NodeDatum]]
    @scala.inline
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](radius: Double, x: Double): ForceRadial_[NodeDatum] = (^.asInstanceOf[js.Dynamic].applyDynamic("forceRadial")(radius.asInstanceOf[js.Any], x.asInstanceOf[js.Any])).asInstanceOf[ForceRadial_[NodeDatum]]
    @scala.inline
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
      radius: Double,
      x: Double,
      y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
    ): ForceRadial_[NodeDatum] = (^.asInstanceOf[js.Dynamic].applyDynamic("forceRadial")(radius.asInstanceOf[js.Any], x.asInstanceOf[js.Any], y.asInstanceOf[js.Any])).asInstanceOf[ForceRadial_[NodeDatum]]
    @scala.inline
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](radius: Double, x: Double, y: Double): ForceRadial_[NodeDatum] = (^.asInstanceOf[js.Dynamic].applyDynamic("forceRadial")(radius.asInstanceOf[js.Any], x.asInstanceOf[js.Any], y.asInstanceOf[js.Any])).asInstanceOf[ForceRadial_[NodeDatum]]
    @scala.inline
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
      radius: Double,
      x: Unit,
      y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
    ): ForceRadial_[NodeDatum] = (^.asInstanceOf[js.Dynamic].applyDynamic("forceRadial")(radius.asInstanceOf[js.Any], x.asInstanceOf[js.Any], y.asInstanceOf[js.Any])).asInstanceOf[ForceRadial_[NodeDatum]]
    @scala.inline
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](radius: Double, x: Unit, y: Double): ForceRadial_[NodeDatum] = (^.asInstanceOf[js.Dynamic].applyDynamic("forceRadial")(radius.asInstanceOf[js.Any], x.asInstanceOf[js.Any], y.asInstanceOf[js.Any])).asInstanceOf[ForceRadial_[NodeDatum]]
    
    @scala.inline
    def forceSimulation[NodeDatum /* <: SimulationNodeDatum */](): Simulation[NodeDatum, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("forceSimulation")().asInstanceOf[Simulation[NodeDatum, Unit]]
    @scala.inline
    def forceSimulation[NodeDatum /* <: SimulationNodeDatum */](nodesData: js.Array[NodeDatum]): Simulation[NodeDatum, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("forceSimulation")(nodesData.asInstanceOf[js.Any]).asInstanceOf[Simulation[NodeDatum, Unit]]
    
    @scala.inline
    def forceSimulation_NodeDatum_SimulationNodeDatumLinkDatum_SimulationLinkDatumNodeDatum[NodeDatum /* <: SimulationNodeDatum */, LinkDatum /* <: SimulationLinkDatum[NodeDatum] */](): Simulation[NodeDatum, LinkDatum] = ^.asInstanceOf[js.Dynamic].applyDynamic("forceSimulation")().asInstanceOf[Simulation[NodeDatum, LinkDatum]]
    @scala.inline
    def forceSimulation_NodeDatum_SimulationNodeDatumLinkDatum_SimulationLinkDatumNodeDatum[NodeDatum /* <: SimulationNodeDatum */, LinkDatum /* <: SimulationLinkDatum[NodeDatum] */](nodesData: js.Array[NodeDatum]): Simulation[NodeDatum, LinkDatum] = ^.asInstanceOf[js.Dynamic].applyDynamic("forceSimulation")(nodesData.asInstanceOf[js.Any]).asInstanceOf[Simulation[NodeDatum, LinkDatum]]
    
    @scala.inline
    def forceX[NodeDatum /* <: SimulationNodeDatum */](): ForceX_[NodeDatum] = ^.asInstanceOf[js.Dynamic].applyDynamic("forceX")().asInstanceOf[ForceX_[NodeDatum]]
    @scala.inline
    def forceX[NodeDatum /* <: SimulationNodeDatum */](x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]): ForceX_[NodeDatum] = ^.asInstanceOf[js.Dynamic].applyDynamic("forceX")(x.asInstanceOf[js.Any]).asInstanceOf[ForceX_[NodeDatum]]
    @scala.inline
    def forceX[NodeDatum /* <: SimulationNodeDatum */](x: Double): ForceX_[NodeDatum] = ^.asInstanceOf[js.Dynamic].applyDynamic("forceX")(x.asInstanceOf[js.Any]).asInstanceOf[ForceX_[NodeDatum]]
    
    @scala.inline
    def forceY[NodeDatum /* <: SimulationNodeDatum */](): ForceY_[NodeDatum] = ^.asInstanceOf[js.Dynamic].applyDynamic("forceY")().asInstanceOf[ForceY_[NodeDatum]]
    @scala.inline
    def forceY[NodeDatum /* <: SimulationNodeDatum */](y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]): ForceY_[NodeDatum] = ^.asInstanceOf[js.Dynamic].applyDynamic("forceY")(y.asInstanceOf[js.Any]).asInstanceOf[ForceY_[NodeDatum]]
    @scala.inline
    def forceY[NodeDatum /* <: SimulationNodeDatum */](y: Double): ForceY_[NodeDatum] = ^.asInstanceOf[js.Dynamic].applyDynamic("forceY")(y.asInstanceOf[js.Any]).asInstanceOf[ForceY_[NodeDatum]]
    
    @scala.inline
    def format(specifier: String): js.Function1[/* n */ Double | ValueOf, String] = ^.asInstanceOf[js.Dynamic].applyDynamic("format")(specifier.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* n */ Double | ValueOf, String]]
    
    @scala.inline
    def formatDefaultLocale(defaultLocale: FormatLocaleDefinition): FormatLocaleObject = ^.asInstanceOf[js.Dynamic].applyDynamic("formatDefaultLocale")(defaultLocale.asInstanceOf[js.Any]).asInstanceOf[FormatLocaleObject]
    
    @scala.inline
    def formatLocale(locale: FormatLocaleDefinition): FormatLocaleObject = ^.asInstanceOf[js.Dynamic].applyDynamic("formatLocale")(locale.asInstanceOf[js.Any]).asInstanceOf[FormatLocaleObject]
    
    @scala.inline
    def formatPrefix(specifier: String, value: Double): js.Function1[/* n */ Double | ValueOf, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("formatPrefix")(specifier.asInstanceOf[js.Any], value.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* n */ Double | ValueOf, String]]
    
    @scala.inline
    def formatSpecifier(specifier: String): typings.d3Format.mod.FormatSpecifier_ = ^.asInstanceOf[js.Dynamic].applyDynamic("formatSpecifier")(specifier.asInstanceOf[js.Any]).asInstanceOf[typings.d3Format.mod.FormatSpecifier_]
    
    @scala.inline
    def fsum[T /* <: Numeric */](values: Iterable[js.UndefOr[T | Null]]): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("fsum")(values.asInstanceOf[js.Any]).asInstanceOf[Double]
    @scala.inline
    def fsum[T](
      values: Iterable[T],
      accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[Double | Null]]
    ): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("fsum")(values.asInstanceOf[js.Any], accessor.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    @scala.inline
    def geoAlbers(): GeoConicProjection = ^.asInstanceOf[js.Dynamic].applyDynamic("geoAlbers")().asInstanceOf[GeoConicProjection]
    
    @scala.inline
    def geoAlbersUsa(): GeoProjection_ = ^.asInstanceOf[js.Dynamic].applyDynamic("geoAlbersUsa")().asInstanceOf[GeoProjection_]
    
    @scala.inline
    def geoArea(`object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("geoArea")(`object`.asInstanceOf[js.Any]).asInstanceOf[Double]
    @scala.inline
    def geoArea(`object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]]): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("geoArea")(`object`.asInstanceOf[js.Any]).asInstanceOf[Double]
    @scala.inline
    def geoArea(`object`: ExtendedGeometryCollection[GeoGeometryObjects]): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("geoArea")(`object`.asInstanceOf[js.Any]).asInstanceOf[Double]
    @scala.inline
    def geoArea(`object`: GeoGeometryObjects): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("geoArea")(`object`.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def geoAzimuthalEqualArea(): GeoProjection_ = ^.asInstanceOf[js.Dynamic].applyDynamic("geoAzimuthalEqualArea")().asInstanceOf[GeoProjection_]
    
    @scala.inline
    def geoAzimuthalEqualAreaRaw(): GeoRawProjection = ^.asInstanceOf[js.Dynamic].applyDynamic("geoAzimuthalEqualAreaRaw")().asInstanceOf[GeoRawProjection]
    
    @scala.inline
    def geoAzimuthalEquidistant(): GeoProjection_ = ^.asInstanceOf[js.Dynamic].applyDynamic("geoAzimuthalEquidistant")().asInstanceOf[GeoProjection_]
    
    @scala.inline
    def geoAzimuthalEquidistantRaw(): GeoRawProjection = ^.asInstanceOf[js.Dynamic].applyDynamic("geoAzimuthalEquidistantRaw")().asInstanceOf[GeoRawProjection]
    
    @scala.inline
    def geoBounds(`object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]): js.Tuple2[js.Tuple2[Double, Double], js.Tuple2[Double, Double]] = ^.asInstanceOf[js.Dynamic].applyDynamic("geoBounds")(`object`.asInstanceOf[js.Any]).asInstanceOf[js.Tuple2[js.Tuple2[Double, Double], js.Tuple2[Double, Double]]]
    @scala.inline
    def geoBounds(`object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]]): js.Tuple2[js.Tuple2[Double, Double], js.Tuple2[Double, Double]] = ^.asInstanceOf[js.Dynamic].applyDynamic("geoBounds")(`object`.asInstanceOf[js.Any]).asInstanceOf[js.Tuple2[js.Tuple2[Double, Double], js.Tuple2[Double, Double]]]
    @scala.inline
    def geoBounds(`object`: ExtendedGeometryCollection[GeoGeometryObjects]): js.Tuple2[js.Tuple2[Double, Double], js.Tuple2[Double, Double]] = ^.asInstanceOf[js.Dynamic].applyDynamic("geoBounds")(`object`.asInstanceOf[js.Any]).asInstanceOf[js.Tuple2[js.Tuple2[Double, Double], js.Tuple2[Double, Double]]]
    @scala.inline
    def geoBounds(`object`: GeoGeometryObjects): js.Tuple2[js.Tuple2[Double, Double], js.Tuple2[Double, Double]] = ^.asInstanceOf[js.Dynamic].applyDynamic("geoBounds")(`object`.asInstanceOf[js.Any]).asInstanceOf[js.Tuple2[js.Tuple2[Double, Double], js.Tuple2[Double, Double]]]
    
    @scala.inline
    def geoCentroid(`object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]): js.Tuple2[Double, Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("geoCentroid")(`object`.asInstanceOf[js.Any]).asInstanceOf[js.Tuple2[Double, Double]]
    @scala.inline
    def geoCentroid(`object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]]): js.Tuple2[Double, Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("geoCentroid")(`object`.asInstanceOf[js.Any]).asInstanceOf[js.Tuple2[Double, Double]]
    @scala.inline
    def geoCentroid(`object`: ExtendedGeometryCollection[GeoGeometryObjects]): js.Tuple2[Double, Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("geoCentroid")(`object`.asInstanceOf[js.Any]).asInstanceOf[js.Tuple2[Double, Double]]
    @scala.inline
    def geoCentroid(`object`: GeoGeometryObjects): js.Tuple2[Double, Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("geoCentroid")(`object`.asInstanceOf[js.Any]).asInstanceOf[js.Tuple2[Double, Double]]
    
    @scala.inline
    def geoCircle(): GeoCircleGenerator[js.Any, js.Any] = ^.asInstanceOf[js.Dynamic].applyDynamic("geoCircle")().asInstanceOf[GeoCircleGenerator[js.Any, js.Any]]
    
    @scala.inline
    def geoCircle_Datum[Datum](): GeoCircleGenerator[js.Any, Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("geoCircle")().asInstanceOf[GeoCircleGenerator[js.Any, Datum]]
    
    @scala.inline
    def geoCircle_ThisDatum[This, Datum](): GeoCircleGenerator[This, Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("geoCircle")().asInstanceOf[GeoCircleGenerator[This, Datum]]
    
    @scala.inline
    def geoClipAntimeridian(stream: GeoStream_): GeoStream_ = ^.asInstanceOf[js.Dynamic].applyDynamic("geoClipAntimeridian")(stream.asInstanceOf[js.Any]).asInstanceOf[GeoStream_]
    
    @scala.inline
    def geoClipCircle(angle: Double): js.Function1[/* stream */ GeoStream_, GeoStream_] = ^.asInstanceOf[js.Dynamic].applyDynamic("geoClipCircle")(angle.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* stream */ GeoStream_, GeoStream_]]
    
    @scala.inline
    def geoClipRectangle(x0: Double, y0: Double, x1: Double, y1: Double): js.Function1[/* stream */ GeoStream_, GeoStream_] = (^.asInstanceOf[js.Dynamic].applyDynamic("geoClipRectangle")(x0.asInstanceOf[js.Any], y0.asInstanceOf[js.Any], x1.asInstanceOf[js.Any], y1.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* stream */ GeoStream_, GeoStream_]]
    
    @scala.inline
    def geoConicConformal(): GeoConicProjection = ^.asInstanceOf[js.Dynamic].applyDynamic("geoConicConformal")().asInstanceOf[GeoConicProjection]
    
    @scala.inline
    def geoConicConformalRaw(phi0: Double, phi1: Double): GeoRawProjection = (^.asInstanceOf[js.Dynamic].applyDynamic("geoConicConformalRaw")(phi0.asInstanceOf[js.Any], phi1.asInstanceOf[js.Any])).asInstanceOf[GeoRawProjection]
    
    @scala.inline
    def geoConicEqualArea(): GeoConicProjection = ^.asInstanceOf[js.Dynamic].applyDynamic("geoConicEqualArea")().asInstanceOf[GeoConicProjection]
    
    @scala.inline
    def geoConicEqualAreaRaw(phi0: Double, phi1: Double): GeoRawProjection = (^.asInstanceOf[js.Dynamic].applyDynamic("geoConicEqualAreaRaw")(phi0.asInstanceOf[js.Any], phi1.asInstanceOf[js.Any])).asInstanceOf[GeoRawProjection]
    
    @scala.inline
    def geoConicEquidistant(): GeoConicProjection = ^.asInstanceOf[js.Dynamic].applyDynamic("geoConicEquidistant")().asInstanceOf[GeoConicProjection]
    
    @scala.inline
    def geoConicEquidistantRaw(phi0: Double, phi1: Double): GeoRawProjection = (^.asInstanceOf[js.Dynamic].applyDynamic("geoConicEquidistantRaw")(phi0.asInstanceOf[js.Any], phi1.asInstanceOf[js.Any])).asInstanceOf[GeoRawProjection]
    
    @scala.inline
    def geoContains(
      `object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]],
      point: js.Tuple2[Double, Double]
    ): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("geoContains")(`object`.asInstanceOf[js.Any], point.asInstanceOf[js.Any])).asInstanceOf[Boolean]
    @scala.inline
    def geoContains(
      `object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties],
      point: js.Tuple2[Double, Double]
    ): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("geoContains")(`object`.asInstanceOf[js.Any], point.asInstanceOf[js.Any])).asInstanceOf[Boolean]
    @scala.inline
    def geoContains(`object`: ExtendedGeometryCollection[GeoGeometryObjects], point: js.Tuple2[Double, Double]): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("geoContains")(`object`.asInstanceOf[js.Any], point.asInstanceOf[js.Any])).asInstanceOf[Boolean]
    @scala.inline
    def geoContains(`object`: GeoGeometryObjects, point: js.Tuple2[Double, Double]): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("geoContains")(`object`.asInstanceOf[js.Any], point.asInstanceOf[js.Any])).asInstanceOf[Boolean]
    
    @scala.inline
    def geoDistance(a: js.Tuple2[Double, Double], b: js.Tuple2[Double, Double]): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("geoDistance")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    @scala.inline
    def geoEqualEarth(): GeoProjection_ = ^.asInstanceOf[js.Dynamic].applyDynamic("geoEqualEarth")().asInstanceOf[GeoProjection_]
    
    @scala.inline
    def geoEqualEarthRaw(): GeoRawProjection = ^.asInstanceOf[js.Dynamic].applyDynamic("geoEqualEarthRaw")().asInstanceOf[GeoRawProjection]
    
    @scala.inline
    def geoEquirectangular(): GeoProjection_ = ^.asInstanceOf[js.Dynamic].applyDynamic("geoEquirectangular")().asInstanceOf[GeoProjection_]
    
    @scala.inline
    def geoEquirectangularRaw(): GeoRawProjection = ^.asInstanceOf[js.Dynamic].applyDynamic("geoEquirectangularRaw")().asInstanceOf[GeoRawProjection]
    
    @scala.inline
    def geoGnomonic(): GeoProjection_ = ^.asInstanceOf[js.Dynamic].applyDynamic("geoGnomonic")().asInstanceOf[GeoProjection_]
    
    @scala.inline
    def geoGnomonicRaw(): GeoRawProjection = ^.asInstanceOf[js.Dynamic].applyDynamic("geoGnomonicRaw")().asInstanceOf[GeoRawProjection]
    
    @scala.inline
    def geoGraticule(): GeoGraticuleGenerator = ^.asInstanceOf[js.Dynamic].applyDynamic("geoGraticule")().asInstanceOf[GeoGraticuleGenerator]
    
    @scala.inline
    def geoGraticule10(): MultiLineString = ^.asInstanceOf[js.Dynamic].applyDynamic("geoGraticule10")().asInstanceOf[MultiLineString]
    
    @scala.inline
    def geoIdentity(): GeoIdentityTransform = ^.asInstanceOf[js.Dynamic].applyDynamic("geoIdentity")().asInstanceOf[GeoIdentityTransform]
    
    @scala.inline
    def geoInterpolate(a: js.Tuple2[Double, Double], b: js.Tuple2[Double, Double]): js.Function1[/* t */ Double, js.Tuple2[Double, Double]] = (^.asInstanceOf[js.Dynamic].applyDynamic("geoInterpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, js.Tuple2[Double, Double]]]
    
    @scala.inline
    def geoLength(`object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("geoLength")(`object`.asInstanceOf[js.Any]).asInstanceOf[Double]
    @scala.inline
    def geoLength(`object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]]): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("geoLength")(`object`.asInstanceOf[js.Any]).asInstanceOf[Double]
    @scala.inline
    def geoLength(`object`: ExtendedGeometryCollection[GeoGeometryObjects]): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("geoLength")(`object`.asInstanceOf[js.Any]).asInstanceOf[Double]
    @scala.inline
    def geoLength(`object`: GeoGeometryObjects): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("geoLength")(`object`.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def geoMercator(): GeoProjection_ = ^.asInstanceOf[js.Dynamic].applyDynamic("geoMercator")().asInstanceOf[GeoProjection_]
    
    @scala.inline
    def geoMercatorRaw(): GeoRawProjection = ^.asInstanceOf[js.Dynamic].applyDynamic("geoMercatorRaw")().asInstanceOf[GeoRawProjection]
    
    @scala.inline
    def geoNaturalEarth1(): GeoProjection_ = ^.asInstanceOf[js.Dynamic].applyDynamic("geoNaturalEarth1")().asInstanceOf[GeoProjection_]
    
    @scala.inline
    def geoNaturalEarth1Raw(): GeoRawProjection = ^.asInstanceOf[js.Dynamic].applyDynamic("geoNaturalEarth1Raw")().asInstanceOf[GeoRawProjection]
    
    @scala.inline
    def geoOrthographic(): GeoProjection_ = ^.asInstanceOf[js.Dynamic].applyDynamic("geoOrthographic")().asInstanceOf[GeoProjection_]
    
    @scala.inline
    def geoOrthographicRaw(): GeoRawProjection = ^.asInstanceOf[js.Dynamic].applyDynamic("geoOrthographicRaw")().asInstanceOf[GeoRawProjection]
    
    @scala.inline
    def geoPath(): GeoPath_[js.Any, GeoPermissibleObjects] = ^.asInstanceOf[js.Dynamic].applyDynamic("geoPath")().asInstanceOf[GeoPath_[js.Any, GeoPermissibleObjects]]
    @scala.inline
    def geoPath(projection: Null, context: GeoContext): GeoPath_[js.Any, GeoPermissibleObjects] = (^.asInstanceOf[js.Dynamic].applyDynamic("geoPath")(projection.asInstanceOf[js.Any], context.asInstanceOf[js.Any])).asInstanceOf[GeoPath_[js.Any, GeoPermissibleObjects]]
    @scala.inline
    def geoPath(projection: Unit, context: GeoContext): GeoPath_[js.Any, GeoPermissibleObjects] = (^.asInstanceOf[js.Dynamic].applyDynamic("geoPath")(projection.asInstanceOf[js.Any], context.asInstanceOf[js.Any])).asInstanceOf[GeoPath_[js.Any, GeoPermissibleObjects]]
    @scala.inline
    def geoPath(projection: GeoProjection_): GeoPath_[js.Any, GeoPermissibleObjects] = ^.asInstanceOf[js.Dynamic].applyDynamic("geoPath")(projection.asInstanceOf[js.Any]).asInstanceOf[GeoPath_[js.Any, GeoPermissibleObjects]]
    @scala.inline
    def geoPath(projection: GeoProjection_, context: GeoContext): GeoPath_[js.Any, GeoPermissibleObjects] = (^.asInstanceOf[js.Dynamic].applyDynamic("geoPath")(projection.asInstanceOf[js.Any], context.asInstanceOf[js.Any])).asInstanceOf[GeoPath_[js.Any, GeoPermissibleObjects]]
    @scala.inline
    def geoPath(projection: GeoStreamWrapper): GeoPath_[js.Any, GeoPermissibleObjects] = ^.asInstanceOf[js.Dynamic].applyDynamic("geoPath")(projection.asInstanceOf[js.Any]).asInstanceOf[GeoPath_[js.Any, GeoPermissibleObjects]]
    @scala.inline
    def geoPath(projection: GeoStreamWrapper, context: GeoContext): GeoPath_[js.Any, GeoPermissibleObjects] = (^.asInstanceOf[js.Dynamic].applyDynamic("geoPath")(projection.asInstanceOf[js.Any], context.asInstanceOf[js.Any])).asInstanceOf[GeoPath_[js.Any, GeoPermissibleObjects]]
    
    @scala.inline
    def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](): GeoPath_[js.Any, DatumObject] = ^.asInstanceOf[js.Dynamic].applyDynamic("geoPath")().asInstanceOf[GeoPath_[js.Any, DatumObject]]
    @scala.inline
    def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: Null, context: GeoContext): GeoPath_[js.Any, DatumObject] = (^.asInstanceOf[js.Dynamic].applyDynamic("geoPath")(projection.asInstanceOf[js.Any], context.asInstanceOf[js.Any])).asInstanceOf[GeoPath_[js.Any, DatumObject]]
    @scala.inline
    def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: Unit, context: GeoContext): GeoPath_[js.Any, DatumObject] = (^.asInstanceOf[js.Dynamic].applyDynamic("geoPath")(projection.asInstanceOf[js.Any], context.asInstanceOf[js.Any])).asInstanceOf[GeoPath_[js.Any, DatumObject]]
    @scala.inline
    def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: GeoProjection_): GeoPath_[js.Any, DatumObject] = ^.asInstanceOf[js.Dynamic].applyDynamic("geoPath")(projection.asInstanceOf[js.Any]).asInstanceOf[GeoPath_[js.Any, DatumObject]]
    @scala.inline
    def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: GeoProjection_, context: GeoContext): GeoPath_[js.Any, DatumObject] = (^.asInstanceOf[js.Dynamic].applyDynamic("geoPath")(projection.asInstanceOf[js.Any], context.asInstanceOf[js.Any])).asInstanceOf[GeoPath_[js.Any, DatumObject]]
    @scala.inline
    def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: GeoStreamWrapper): GeoPath_[js.Any, DatumObject] = ^.asInstanceOf[js.Dynamic].applyDynamic("geoPath")(projection.asInstanceOf[js.Any]).asInstanceOf[GeoPath_[js.Any, DatumObject]]
    @scala.inline
    def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: GeoStreamWrapper, context: GeoContext): GeoPath_[js.Any, DatumObject] = (^.asInstanceOf[js.Dynamic].applyDynamic("geoPath")(projection.asInstanceOf[js.Any], context.asInstanceOf[js.Any])).asInstanceOf[GeoPath_[js.Any, DatumObject]]
    
    @scala.inline
    def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](): GeoPath_[This, DatumObject] = ^.asInstanceOf[js.Dynamic].applyDynamic("geoPath")().asInstanceOf[GeoPath_[This, DatumObject]]
    @scala.inline
    def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: Null, context: GeoContext): GeoPath_[This, DatumObject] = (^.asInstanceOf[js.Dynamic].applyDynamic("geoPath")(projection.asInstanceOf[js.Any], context.asInstanceOf[js.Any])).asInstanceOf[GeoPath_[This, DatumObject]]
    @scala.inline
    def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: Unit, context: GeoContext): GeoPath_[This, DatumObject] = (^.asInstanceOf[js.Dynamic].applyDynamic("geoPath")(projection.asInstanceOf[js.Any], context.asInstanceOf[js.Any])).asInstanceOf[GeoPath_[This, DatumObject]]
    @scala.inline
    def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: GeoProjection_): GeoPath_[This, DatumObject] = ^.asInstanceOf[js.Dynamic].applyDynamic("geoPath")(projection.asInstanceOf[js.Any]).asInstanceOf[GeoPath_[This, DatumObject]]
    @scala.inline
    def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: GeoProjection_, context: GeoContext): GeoPath_[This, DatumObject] = (^.asInstanceOf[js.Dynamic].applyDynamic("geoPath")(projection.asInstanceOf[js.Any], context.asInstanceOf[js.Any])).asInstanceOf[GeoPath_[This, DatumObject]]
    @scala.inline
    def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: GeoStreamWrapper): GeoPath_[This, DatumObject] = ^.asInstanceOf[js.Dynamic].applyDynamic("geoPath")(projection.asInstanceOf[js.Any]).asInstanceOf[GeoPath_[This, DatumObject]]
    @scala.inline
    def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: GeoStreamWrapper, context: GeoContext): GeoPath_[This, DatumObject] = (^.asInstanceOf[js.Dynamic].applyDynamic("geoPath")(projection.asInstanceOf[js.Any], context.asInstanceOf[js.Any])).asInstanceOf[GeoPath_[This, DatumObject]]
    
    @scala.inline
    def geoProjection(project: GeoRawProjection): GeoProjection_ = ^.asInstanceOf[js.Dynamic].applyDynamic("geoProjection")(project.asInstanceOf[js.Any]).asInstanceOf[GeoProjection_]
    
    @scala.inline
    def geoProjectionMutator(factory: js.Function1[/* repeated */ js.Any, GeoRawProjection]): js.Function0[GeoProjection_] = ^.asInstanceOf[js.Dynamic].applyDynamic("geoProjectionMutator")(factory.asInstanceOf[js.Any]).asInstanceOf[js.Function0[GeoProjection_]]
    
    @scala.inline
    def geoRotation(angles: js.Tuple2[Double, Double]): GeoRotation_ = ^.asInstanceOf[js.Dynamic].applyDynamic("geoRotation")(angles.asInstanceOf[js.Any]).asInstanceOf[GeoRotation_]
    @scala.inline
    def geoRotation(angles: js.Tuple3[Double, Double, Double]): GeoRotation_ = ^.asInstanceOf[js.Dynamic].applyDynamic("geoRotation")(angles.asInstanceOf[js.Any]).asInstanceOf[GeoRotation_]
    
    @scala.inline
    def geoStereographic(): GeoProjection_ = ^.asInstanceOf[js.Dynamic].applyDynamic("geoStereographic")().asInstanceOf[GeoProjection_]
    
    @scala.inline
    def geoStereographicRaw(): GeoRawProjection = ^.asInstanceOf[js.Dynamic].applyDynamic("geoStereographicRaw")().asInstanceOf[GeoRawProjection]
    
    @scala.inline
    def geoStream(
      `object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]],
      stream: GeoStream_
    ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("geoStream")(`object`.asInstanceOf[js.Any], stream.asInstanceOf[js.Any])).asInstanceOf[Unit]
    @scala.inline
    def geoStream(`object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties], stream: GeoStream_): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("geoStream")(`object`.asInstanceOf[js.Any], stream.asInstanceOf[js.Any])).asInstanceOf[Unit]
    @scala.inline
    def geoStream(`object`: ExtendedGeometryCollection[GeoGeometryObjects], stream: GeoStream_): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("geoStream")(`object`.asInstanceOf[js.Any], stream.asInstanceOf[js.Any])).asInstanceOf[Unit]
    @scala.inline
    def geoStream(`object`: GeoGeometryObjects, stream: GeoStream_): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("geoStream")(`object`.asInstanceOf[js.Any], stream.asInstanceOf[js.Any])).asInstanceOf[Unit]
    
    @scala.inline
    def geoTransform[T /* <: GeoTransformPrototype */](methods: T): `0`[T] = ^.asInstanceOf[js.Dynamic].applyDynamic("geoTransform")(methods.asInstanceOf[js.Any]).asInstanceOf[`0`[T]]
    
    @scala.inline
    def geoTransverseMercator(): GeoProjection_ = ^.asInstanceOf[js.Dynamic].applyDynamic("geoTransverseMercator")().asInstanceOf[GeoProjection_]
    
    @scala.inline
    def geoTransverseMercatorRaw(): GeoRawProjection = ^.asInstanceOf[js.Dynamic].applyDynamic("geoTransverseMercatorRaw")().asInstanceOf[GeoRawProjection]
    
    /**
      * Constructs a new CIELAB color with the specified l value and a = b = 0.
      *
      * @param l Lightness typically in the range [0, 100].
      * @param opacity Optional opacity value, defaults to 1.
      */
    @scala.inline
    def gray(l: Double): LabColor = ^.asInstanceOf[js.Dynamic].applyDynamic("gray")(l.asInstanceOf[js.Any]).asInstanceOf[LabColor]
    /**
      * Constructs a new CIELAB color with the specified l value and a = b = 0.
      *
      * @param l Lightness typically in the range [0, 100].
      * @param opacity Optional opacity value, defaults to 1.
      */
    @scala.inline
    def gray(l: Double, opacity: Double): LabColor = (^.asInstanceOf[js.Dynamic].applyDynamic("gray")(l.asInstanceOf[js.Any], opacity.asInstanceOf[js.Any])).asInstanceOf[LabColor]
    
    @scala.inline
    def greatest[T](iterable: Iterable[T]): js.UndefOr[T] = ^.asInstanceOf[js.Dynamic].applyDynamic("greatest")(iterable.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[T]]
    @scala.inline
    def greatest[T](iterable: Iterable[T], comparator: js.Function2[/* a */ T, /* b */ T, Double]): js.UndefOr[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("greatest")(iterable.asInstanceOf[js.Any], comparator.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[T]]
    @scala.inline
    def greatest[T, U](iterable: Iterable[T], accessor: js.Function1[/* a */ T, U]): js.UndefOr[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("greatest")(iterable.asInstanceOf[js.Any], accessor.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[T]]
    
    @scala.inline
    def greatestIndex[T](iterable: Iterable[T]): js.UndefOr[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("greatestIndex")(iterable.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[Double]]
    @scala.inline
    def greatestIndex[T](iterable: Iterable[T], comparator: js.Function2[/* a */ T, /* b */ T, Double]): js.UndefOr[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("greatestIndex")(iterable.asInstanceOf[js.Any], comparator.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[Double]]
    @scala.inline
    def greatestIndex[T, U](iterable: Iterable[T], accessor: js.Function1[/* a */ T, U]): js.UndefOr[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("greatestIndex")(iterable.asInstanceOf[js.Any], accessor.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[Double]]
    
    @scala.inline
    def group[TObject, TKey](iterable: Iterable[TObject], key: js.Function1[/* value */ TObject, TKey]): Map[TKey, js.Array[TObject]] = (^.asInstanceOf[js.Dynamic].applyDynamic("group")(iterable.asInstanceOf[js.Any], key.asInstanceOf[js.Any])).asInstanceOf[Map[TKey, js.Array[TObject]]]
    @scala.inline
    def group[TObject, TKey1, TKey2](
      iterable: Iterable[TObject],
      key1: js.Function1[/* value */ TObject, TKey1],
      key2: js.Function1[/* value */ TObject, TKey2]
    ): Map[TKey1, Map[TKey2, js.Array[TObject]]] = (^.asInstanceOf[js.Dynamic].applyDynamic("group")(iterable.asInstanceOf[js.Any], key1.asInstanceOf[js.Any], key2.asInstanceOf[js.Any])).asInstanceOf[Map[TKey1, Map[TKey2, js.Array[TObject]]]]
    @scala.inline
    def group[TObject, TKey1, TKey2, TKey3](
      iterable: Iterable[TObject],
      key1: js.Function1[/* value */ TObject, TKey1],
      key2: js.Function1[/* value */ TObject, TKey2],
      key3: js.Function1[/* value */ TObject, TKey3]
    ): Map[TKey1, Map[TKey2, Map[TKey3, js.Array[TObject]]]] = (^.asInstanceOf[js.Dynamic].applyDynamic("group")(iterable.asInstanceOf[js.Any], key1.asInstanceOf[js.Any], key2.asInstanceOf[js.Any], key3.asInstanceOf[js.Any])).asInstanceOf[Map[TKey1, Map[TKey2, Map[TKey3, js.Array[TObject]]]]]
    
    @scala.inline
    def groups[TObject, TKey](iterable: Iterable[TObject], key: js.Function1[/* value */ TObject, TKey]): js.Array[js.Tuple2[TKey, js.Array[TObject]]] = (^.asInstanceOf[js.Dynamic].applyDynamic("groups")(iterable.asInstanceOf[js.Any], key.asInstanceOf[js.Any])).asInstanceOf[js.Array[js.Tuple2[TKey, js.Array[TObject]]]]
    @scala.inline
    def groups[TObject, TKey1, TKey2](
      iterable: Iterable[TObject],
      key1: js.Function1[/* value */ TObject, TKey1],
      key2: js.Function1[/* value */ TObject, TKey2]
    ): js.Array[js.Tuple2[TKey1, js.Array[js.Tuple2[TKey2, js.Array[TObject]]]]] = (^.asInstanceOf[js.Dynamic].applyDynamic("groups")(iterable.asInstanceOf[js.Any], key1.asInstanceOf[js.Any], key2.asInstanceOf[js.Any])).asInstanceOf[js.Array[js.Tuple2[TKey1, js.Array[js.Tuple2[TKey2, js.Array[TObject]]]]]]
    @scala.inline
    def groups[TObject, TKey1, TKey2, TKey3](
      iterable: Iterable[TObject],
      key1: js.Function1[/* value */ TObject, TKey1],
      key2: js.Function1[/* value */ TObject, TKey2],
      key3: js.Function1[/* value */ TObject, TKey3]
    ): js.Array[
        js.Tuple2[TKey1, js.Array[js.Tuple2[TKey2, js.Array[js.Tuple2[TKey3, js.Array[TObject]]]]]]
      ] = (^.asInstanceOf[js.Dynamic].applyDynamic("groups")(iterable.asInstanceOf[js.Any], key1.asInstanceOf[js.Any], key2.asInstanceOf[js.Any], key3.asInstanceOf[js.Any])).asInstanceOf[js.Array[
        js.Tuple2[TKey1, js.Array[js.Tuple2[TKey2, js.Array[js.Tuple2[TKey3, js.Array[TObject]]]]]]
      ]]
    
    @JSImport("plotly.js/lib/core", "d3.hcl")
    @js.native
    val hcl: HCLColorFactory = js.native
    @scala.inline
    def hcl(color: ColorCommonInstance): HCLColor = ^.asInstanceOf[js.Dynamic].applyDynamic("hcl")(color.asInstanceOf[js.Any]).asInstanceOf[HCLColor]
    /**
      * Converts the provided color instance and returns an HCL color.
      * The color instance is converted to the RGB color space using color.rgb and then converted to HCL.
      * (Colors already in the HCL color space skip the conversion to RGB,
      * and colors in the Lab color space are converted directly to HCL.)
      *
      * @param color A permissible color space instance.
      */
    @scala.inline
    def hcl(color: ColorSpaceObject): HCLColor = ^.asInstanceOf[js.Dynamic].applyDynamic("hcl")(color.asInstanceOf[js.Any]).asInstanceOf[HCLColor]
    /**
      * Parses the specified CSS Color Module Level 3 specifier string, returning an HCL color.
      * If the specifier was not valid, null is returned.
      *
      * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
      */
    @scala.inline
    def hcl(cssColorSpecifier: String): HCLColor = ^.asInstanceOf[js.Dynamic].applyDynamic("hcl")(cssColorSpecifier.asInstanceOf[js.Any]).asInstanceOf[HCLColor]
    /**
      * Constructs a new HCL color based on the specified channel values and opacity.
      *
      * @param h Hue channel value typically in [0, 360).
      * @param c Chroma channel value typically in [0, 230].
      * @param l Luminance channel value typically in the range [0, 100].
      * @param opacity Optional opacity value, defaults to 1.
      */
    @scala.inline
    def hcl(h: Double, c: Double, l: Double): HCLColor = (^.asInstanceOf[js.Dynamic].applyDynamic("hcl")(h.asInstanceOf[js.Any], c.asInstanceOf[js.Any], l.asInstanceOf[js.Any])).asInstanceOf[HCLColor]
    @scala.inline
    def hcl(h: Double, c: Double, l: Double, opacity: Double): HCLColor = (^.asInstanceOf[js.Dynamic].applyDynamic("hcl")(h.asInstanceOf[js.Any], c.asInstanceOf[js.Any], l.asInstanceOf[js.Any], opacity.asInstanceOf[js.Any])).asInstanceOf[HCLColor]
    
    @scala.inline
    def hierarchy[Datum](data: Datum): HierarchyNode[Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("hierarchy")(data.asInstanceOf[js.Any]).asInstanceOf[HierarchyNode[Datum]]
    @scala.inline
    def hierarchy[Datum](data: Datum, children: js.Function1[/* d */ Datum, js.UndefOr[Iterable[Datum] | Null]]): HierarchyNode[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("hierarchy")(data.asInstanceOf[js.Any], children.asInstanceOf[js.Any])).asInstanceOf[HierarchyNode[Datum]]
    
    @scala.inline
    def histogram(): HistogramGeneratorNumber[Double, Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("histogram")().asInstanceOf[HistogramGeneratorNumber[Double, Double]]
    
    @scala.inline
    def `histogram_DatumValue_UnionDate<undefined>_HistogramGeneratorDate`[Datum, Value /* <: js.UndefOr[Date] */](): HistogramGeneratorDate[Datum, Value] = ^.asInstanceOf[js.Dynamic].applyDynamic("histogram")().asInstanceOf[HistogramGeneratorDate[Datum, Value]]
    
    @scala.inline
    def `histogram_DatumValue_UnionDouble<undefined>`[Datum, Value /* <: js.UndefOr[Double] */](): HistogramGeneratorNumber[Datum, Value] = ^.asInstanceOf[js.Dynamic].applyDynamic("histogram")().asInstanceOf[HistogramGeneratorNumber[Datum, Value]]
    
    @JSImport("plotly.js/lib/core", "d3.hsl")
    @js.native
    val hsl: HSLColorFactory = js.native
    @scala.inline
    def hsl(color: ColorCommonInstance): HSLColor = ^.asInstanceOf[js.Dynamic].applyDynamic("hsl")(color.asInstanceOf[js.Any]).asInstanceOf[HSLColor]
    /**
      * Converts the provided color instance and returns an HSL color.
      * The color instance is converted to the RGB color space using color.rgb and then converted to HSL.
      * (Colors already in the HSL color space skip the conversion to RGB.)
      *
      * @param color A permissible color space instance.
      */
    @scala.inline
    def hsl(color: ColorSpaceObject): HSLColor = ^.asInstanceOf[js.Dynamic].applyDynamic("hsl")(color.asInstanceOf[js.Any]).asInstanceOf[HSLColor]
    /**
      * Parses the specified CSS Color Module Level 3 specifier string, returning an HSL color.
      * If the specifier was not valid, null is returned.
      *
      * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
      */
    @scala.inline
    def hsl(cssColorSpecifier: String): HSLColor = ^.asInstanceOf[js.Dynamic].applyDynamic("hsl")(cssColorSpecifier.asInstanceOf[js.Any]).asInstanceOf[HSLColor]
    /**
      * Constructs a new HSL color based on the specified channel values and opacity.
      *
      * @param h Hue channel value.
      * @param s Saturation channel value.
      * @param l Lightness channel value.
      * @param opacity Optional opacity value, defaults to 1.
      */
    @scala.inline
    def hsl(h: Double, s: Double, l: Double): HSLColor = (^.asInstanceOf[js.Dynamic].applyDynamic("hsl")(h.asInstanceOf[js.Any], s.asInstanceOf[js.Any], l.asInstanceOf[js.Any])).asInstanceOf[HSLColor]
    @scala.inline
    def hsl(h: Double, s: Double, l: Double, opacity: Double): HSLColor = (^.asInstanceOf[js.Dynamic].applyDynamic("hsl")(h.asInstanceOf[js.Any], s.asInstanceOf[js.Any], l.asInstanceOf[js.Any], opacity.asInstanceOf[js.Any])).asInstanceOf[HSLColor]
    
    @scala.inline
    def html(url: String): js.Promise[Document] = ^.asInstanceOf[js.Dynamic].applyDynamic("html")(url.asInstanceOf[js.Any]).asInstanceOf[js.Promise[Document]]
    @scala.inline
    def html(url: String, init: RequestInit): js.Promise[Document] = (^.asInstanceOf[js.Dynamic].applyDynamic("html")(url.asInstanceOf[js.Any], init.asInstanceOf[js.Any])).asInstanceOf[js.Promise[Document]]
    
    @scala.inline
    def image(url: String): js.Promise[HTMLImageElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("image")(url.asInstanceOf[js.Any]).asInstanceOf[js.Promise[HTMLImageElement]]
    @scala.inline
    def image(url: String, init: PartialHTMLImageElement): js.Promise[HTMLImageElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("image")(url.asInstanceOf[js.Any], init.asInstanceOf[js.Any])).asInstanceOf[js.Promise[HTMLImageElement]]
    
    @scala.inline
    def index[TObject, TKey](iterable: Iterable[TObject], key: js.Function1[/* value */ TObject, TKey]): Map[TKey, TObject] = (^.asInstanceOf[js.Dynamic].applyDynamic("index")(iterable.asInstanceOf[js.Any], key.asInstanceOf[js.Any])).asInstanceOf[Map[TKey, TObject]]
    @scala.inline
    def index[TObject, TKey1, TKey2](
      iterable: Iterable[TObject],
      key1: js.Function1[/* value */ TObject, TKey1],
      key2: js.Function1[/* value */ TObject, TKey2]
    ): Map[TKey1, Map[TKey2, TObject]] = (^.asInstanceOf[js.Dynamic].applyDynamic("index")(iterable.asInstanceOf[js.Any], key1.asInstanceOf[js.Any], key2.asInstanceOf[js.Any])).asInstanceOf[Map[TKey1, Map[TKey2, TObject]]]
    @scala.inline
    def index[TObject, TKey1, TKey2, TKey3](
      iterable: Iterable[TObject],
      key1: js.Function1[/* value */ TObject, TKey1],
      key2: js.Function1[/* value */ TObject, TKey2],
      key3: js.Function1[/* value */ TObject, TKey3]
    ): Map[TKey1, Map[TKey2, Map[TKey3, TObject]]] = (^.asInstanceOf[js.Dynamic].applyDynamic("index")(iterable.asInstanceOf[js.Any], key1.asInstanceOf[js.Any], key2.asInstanceOf[js.Any], key3.asInstanceOf[js.Any])).asInstanceOf[Map[TKey1, Map[TKey2, Map[TKey3, TObject]]]]
    
    @scala.inline
    def indexes[TObject, TKey](iterable: Iterable[TObject], key: js.Function1[/* value */ TObject, TKey]): js.Array[js.Tuple2[TKey, TObject]] = (^.asInstanceOf[js.Dynamic].applyDynamic("indexes")(iterable.asInstanceOf[js.Any], key.asInstanceOf[js.Any])).asInstanceOf[js.Array[js.Tuple2[TKey, TObject]]]
    @scala.inline
    def indexes[TObject, TKey1, TKey2](
      iterable: Iterable[TObject],
      key1: js.Function1[/* value */ TObject, TKey1],
      key2: js.Function1[/* value */ TObject, TKey2]
    ): js.Array[js.Tuple2[TKey1, js.Array[js.Tuple2[TKey2, TObject]]]] = (^.asInstanceOf[js.Dynamic].applyDynamic("indexes")(iterable.asInstanceOf[js.Any], key1.asInstanceOf[js.Any], key2.asInstanceOf[js.Any])).asInstanceOf[js.Array[js.Tuple2[TKey1, js.Array[js.Tuple2[TKey2, TObject]]]]]
    @scala.inline
    def indexes[TObject, TKey1, TKey2, TKey3](
      iterable: Iterable[TObject],
      key1: js.Function1[/* value */ TObject, TKey1],
      key2: js.Function1[/* value */ TObject, TKey2],
      key3: js.Function1[/* value */ TObject, TKey3]
    ): js.Array[
        js.Tuple2[TKey1, js.Array[js.Tuple2[TKey2, js.Array[js.Tuple2[TKey3, TObject]]]]]
      ] = (^.asInstanceOf[js.Dynamic].applyDynamic("indexes")(iterable.asInstanceOf[js.Any], key1.asInstanceOf[js.Any], key2.asInstanceOf[js.Any], key3.asInstanceOf[js.Any])).asInstanceOf[js.Array[
        js.Tuple2[TKey1, js.Array[js.Tuple2[TKey2, js.Array[js.Tuple2[TKey3, TObject]]]]]
      ]]
    
    @scala.inline
    def interpolate(a: String, b: String): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolate(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolate(a: js.Any, b: Boolean): js.Function1[/* t */ Double, Boolean] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Boolean]]
    @scala.inline
    def interpolate(a: js.Any, b: Null): js.Function1[/* t */ Double, Null] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Null]]
    @scala.inline
    def interpolate(a: js.Array[Double], b: DataView): js.Function1[/* t */ Double, DataView] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, DataView]]
    @scala.inline
    def interpolate(a: js.Array[Double], b: Float32Array): js.Function1[/* t */ Double, Float32Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Float32Array]]
    @scala.inline
    def interpolate(a: js.Array[Double], b: Float64Array): js.Function1[/* t */ Double, Float64Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Float64Array]]
    @scala.inline
    def interpolate(a: js.Array[Double], b: Int16Array): js.Function1[/* t */ Double, Int16Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Int16Array]]
    @scala.inline
    def interpolate(a: js.Array[Double], b: Int32Array): js.Function1[/* t */ Double, Int32Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Int32Array]]
    @scala.inline
    def interpolate(a: js.Array[Double], b: Int8Array): js.Function1[/* t */ Double, Int8Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Int8Array]]
    @scala.inline
    def interpolate(a: js.Array[Double], b: Uint16Array): js.Function1[/* t */ Double, Uint16Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Uint16Array]]
    @scala.inline
    def interpolate(a: js.Array[Double], b: Uint32Array): js.Function1[/* t */ Double, Uint32Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Uint32Array]]
    @scala.inline
    def interpolate(a: js.Array[Double], b: Uint8Array): js.Function1[/* t */ Double, Uint8Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Uint8Array]]
    @scala.inline
    def interpolate(a: js.Array[Double], b: Uint8ClampedArray): js.Function1[/* t */ Double, Uint8ClampedArray] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Uint8ClampedArray]]
    @scala.inline
    def interpolate(a: Double, b: Double): js.Function1[/* t */ Double, Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Double]]
    @scala.inline
    def interpolate(a: Double, b: typings.d3Interpolate.anon.ValueOf): js.Function1[/* t */ Double, Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Double]]
    @scala.inline
    def interpolate(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolate(a: ToString, b: String): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolate(a: typings.d3Interpolate.anon.ValueOf, b: Double): js.Function1[/* t */ Double, Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Double]]
    @scala.inline
    def interpolate(a: typings.d3Interpolate.anon.ValueOf, b: typings.d3Interpolate.anon.ValueOf): js.Function1[/* t */ Double, Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Double]]
    @scala.inline
    def interpolate(a: NumberArray, b: DataView): js.Function1[/* t */ Double, DataView] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, DataView]]
    @scala.inline
    def interpolate(a: NumberArray, b: Float32Array): js.Function1[/* t */ Double, Float32Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Float32Array]]
    @scala.inline
    def interpolate(a: NumberArray, b: Float64Array): js.Function1[/* t */ Double, Float64Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Float64Array]]
    @scala.inline
    def interpolate(a: NumberArray, b: Int16Array): js.Function1[/* t */ Double, Int16Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Int16Array]]
    @scala.inline
    def interpolate(a: NumberArray, b: Int32Array): js.Function1[/* t */ Double, Int32Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Int32Array]]
    @scala.inline
    def interpolate(a: NumberArray, b: Int8Array): js.Function1[/* t */ Double, Int8Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Int8Array]]
    @scala.inline
    def interpolate(a: NumberArray, b: Uint16Array): js.Function1[/* t */ Double, Uint16Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Uint16Array]]
    @scala.inline
    def interpolate(a: NumberArray, b: Uint32Array): js.Function1[/* t */ Double, Uint32Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Uint32Array]]
    @scala.inline
    def interpolate(a: NumberArray, b: Uint8Array): js.Function1[/* t */ Double, Uint8Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Uint8Array]]
    @scala.inline
    def interpolate(a: NumberArray, b: Uint8ClampedArray): js.Function1[/* t */ Double, Uint8ClampedArray] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Uint8ClampedArray]]
    @scala.inline
    def interpolate(a: Date, b: Date): js.Function1[/* t */ Double, Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Date]]
    @scala.inline
    def interpolate[U /* <: js.Object */](a: js.Any, b: U): js.Function1[/* t */ Double, U] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, U]]
    @scala.inline
    def interpolate[U /* <: js.Array[js.Any] */](a: js.Array[js.Any], b: U): js.Function1[/* t */ Double, U] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, U]]
    
    @scala.inline
    def interpolateArray(a: js.Array[Double], b: DataView): js.Function1[/* t */ Double, DataView] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, DataView]]
    @scala.inline
    def interpolateArray(a: js.Array[Double], b: Float32Array): js.Function1[/* t */ Double, Float32Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Float32Array]]
    @scala.inline
    def interpolateArray(a: js.Array[Double], b: Float64Array): js.Function1[/* t */ Double, Float64Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Float64Array]]
    @scala.inline
    def interpolateArray(a: js.Array[Double], b: Int16Array): js.Function1[/* t */ Double, Int16Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Int16Array]]
    @scala.inline
    def interpolateArray(a: js.Array[Double], b: Int32Array): js.Function1[/* t */ Double, Int32Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Int32Array]]
    @scala.inline
    def interpolateArray(a: js.Array[Double], b: Int8Array): js.Function1[/* t */ Double, Int8Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Int8Array]]
    @scala.inline
    def interpolateArray(a: js.Array[Double], b: Uint16Array): js.Function1[/* t */ Double, Uint16Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Uint16Array]]
    @scala.inline
    def interpolateArray(a: js.Array[Double], b: Uint32Array): js.Function1[/* t */ Double, Uint32Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Uint32Array]]
    @scala.inline
    def interpolateArray(a: js.Array[Double], b: Uint8Array): js.Function1[/* t */ Double, Uint8Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Uint8Array]]
    @scala.inline
    def interpolateArray(a: js.Array[Double], b: Uint8ClampedArray): js.Function1[/* t */ Double, Uint8ClampedArray] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Uint8ClampedArray]]
    @scala.inline
    def interpolateArray(a: NumberArray, b: DataView): js.Function1[/* t */ Double, DataView] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, DataView]]
    @scala.inline
    def interpolateArray(a: NumberArray, b: Float32Array): js.Function1[/* t */ Double, Float32Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Float32Array]]
    @scala.inline
    def interpolateArray(a: NumberArray, b: Float64Array): js.Function1[/* t */ Double, Float64Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Float64Array]]
    @scala.inline
    def interpolateArray(a: NumberArray, b: Int16Array): js.Function1[/* t */ Double, Int16Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Int16Array]]
    @scala.inline
    def interpolateArray(a: NumberArray, b: Int32Array): js.Function1[/* t */ Double, Int32Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Int32Array]]
    @scala.inline
    def interpolateArray(a: NumberArray, b: Int8Array): js.Function1[/* t */ Double, Int8Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Int8Array]]
    @scala.inline
    def interpolateArray(a: NumberArray, b: Uint16Array): js.Function1[/* t */ Double, Uint16Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Uint16Array]]
    @scala.inline
    def interpolateArray(a: NumberArray, b: Uint32Array): js.Function1[/* t */ Double, Uint32Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Uint32Array]]
    @scala.inline
    def interpolateArray(a: NumberArray, b: Uint8Array): js.Function1[/* t */ Double, Uint8Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Uint8Array]]
    @scala.inline
    def interpolateArray(a: NumberArray, b: Uint8ClampedArray): js.Function1[/* t */ Double, Uint8ClampedArray] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Uint8ClampedArray]]
    @scala.inline
    def interpolateArray[A /* <: js.Array[js.Any] */](a: js.Array[js.Any], b: A): ArrayInterpolator[A] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[ArrayInterpolator[A]]
    
    @scala.inline
    def interpolateBasis(splineNodes: js.Array[Double]): js.Function1[/* t */ Double, Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateBasis")(splineNodes.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* t */ Double, Double]]
    
    @scala.inline
    def interpolateBasisClosed(splineNodes: js.Array[Double]): js.Function1[/* t */ Double, Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateBasisClosed")(splineNodes.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* t */ Double, Double]]
    
    @scala.inline
    def interpolateBlues(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateBlues")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateBrBG(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateBrBG")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateBuGn(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateBuGn")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateBuPu(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateBuPu")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateCividis(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateCividis")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateCool(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateCool")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @JSImport("plotly.js/lib/core", "d3.interpolateCubehelix")
    @js.native
    val interpolateCubehelix: ColorGammaInterpolationFactory = js.native
    @scala.inline
    def interpolateCubehelix(a: String, b: String): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateCubehelix")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateCubehelix(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateCubehelix")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateCubehelix(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateCubehelix")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateCubehelix(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateCubehelix")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    
    @scala.inline
    def interpolateCubehelixDefault(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateCubehelixDefault")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @JSImport("plotly.js/lib/core", "d3.interpolateCubehelixLong")
    @js.native
    val interpolateCubehelixLong: ColorGammaInterpolationFactory = js.native
    @scala.inline
    def interpolateCubehelixLong(a: String, b: String): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateCubehelixLong")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateCubehelixLong(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateCubehelixLong")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateCubehelixLong(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateCubehelixLong")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateCubehelixLong(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateCubehelixLong")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    
    @scala.inline
    def interpolateDate(a: Date, b: Date): js.Function1[/* t */ Double, Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateDate")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Date]]
    
    @scala.inline
    def interpolateDiscrete[T](values: js.Array[T]): js.Function1[/* t */ Double, T] = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateDiscrete")(values.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* t */ Double, T]]
    
    @scala.inline
    def interpolateGnBu(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateGnBu")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateGreens(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateGreens")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateGreys(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateGreys")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateHcl(a: String, b: String): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateHcl")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateHcl(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateHcl")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateHcl(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateHcl")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateHcl(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateHcl")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    
    @scala.inline
    def interpolateHclLong(a: String, b: String): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateHclLong")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateHclLong(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateHclLong")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateHclLong(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateHclLong")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateHclLong(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateHclLong")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    
    @scala.inline
    def interpolateHsl(a: String, b: String): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateHsl")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateHsl(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateHsl")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateHsl(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateHsl")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateHsl(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateHsl")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    
    @scala.inline
    def interpolateHslLong(a: String, b: String): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateHslLong")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateHslLong(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateHslLong")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateHslLong(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateHslLong")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateHslLong(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateHslLong")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    
    @scala.inline
    def interpolateHue(a: Double, b: Double): js.Function1[/* t */ Double, Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateHue")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Double]]
    
    @scala.inline
    def interpolateInferno(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateInferno")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateLab(a: String, b: String): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateLab")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateLab(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateLab")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateLab(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateLab")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateLab(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateLab")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    
    @scala.inline
    def interpolateMagma(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateMagma")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateNumber(a: Double, b: Double): js.Function1[/* t */ Double, Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateNumber")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Double]]
    @scala.inline
    def interpolateNumber(a: Double, b: typings.d3Interpolate.anon.ValueOf): js.Function1[/* t */ Double, Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateNumber")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Double]]
    @scala.inline
    def interpolateNumber(a: typings.d3Interpolate.anon.ValueOf, b: Double): js.Function1[/* t */ Double, Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateNumber")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Double]]
    @scala.inline
    def interpolateNumber(a: typings.d3Interpolate.anon.ValueOf, b: typings.d3Interpolate.anon.ValueOf): js.Function1[/* t */ Double, Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateNumber")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Double]]
    
    @scala.inline
    def interpolateNumberArray(a: js.Array[Double], b: js.Array[Double]): js.Function1[/* t */ Double, js.Array[Double]] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateNumberArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, js.Array[Double]]]
    @scala.inline
    def interpolateNumberArray(a: js.Array[Double], b: DataView): js.Function1[/* t */ Double, DataView] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateNumberArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, DataView]]
    @scala.inline
    def interpolateNumberArray(a: js.Array[Double], b: Float32Array): js.Function1[/* t */ Double, Float32Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateNumberArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Float32Array]]
    @scala.inline
    def interpolateNumberArray(a: js.Array[Double], b: Float64Array): js.Function1[/* t */ Double, Float64Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateNumberArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Float64Array]]
    @scala.inline
    def interpolateNumberArray(a: js.Array[Double], b: Int16Array): js.Function1[/* t */ Double, Int16Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateNumberArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Int16Array]]
    @scala.inline
    def interpolateNumberArray(a: js.Array[Double], b: Int32Array): js.Function1[/* t */ Double, Int32Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateNumberArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Int32Array]]
    @scala.inline
    def interpolateNumberArray(a: js.Array[Double], b: Int8Array): js.Function1[/* t */ Double, Int8Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateNumberArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Int8Array]]
    @scala.inline
    def interpolateNumberArray(a: js.Array[Double], b: Uint16Array): js.Function1[/* t */ Double, Uint16Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateNumberArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Uint16Array]]
    @scala.inline
    def interpolateNumberArray(a: js.Array[Double], b: Uint32Array): js.Function1[/* t */ Double, Uint32Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateNumberArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Uint32Array]]
    @scala.inline
    def interpolateNumberArray(a: js.Array[Double], b: Uint8Array): js.Function1[/* t */ Double, Uint8Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateNumberArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Uint8Array]]
    @scala.inline
    def interpolateNumberArray(a: js.Array[Double], b: Uint8ClampedArray): js.Function1[/* t */ Double, Uint8ClampedArray] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateNumberArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Uint8ClampedArray]]
    @scala.inline
    def interpolateNumberArray(a: NumberArray, b: js.Array[Double]): js.Function1[/* t */ Double, js.Array[Double]] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateNumberArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, js.Array[Double]]]
    @scala.inline
    def interpolateNumberArray(a: NumberArray, b: DataView): js.Function1[/* t */ Double, DataView] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateNumberArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, DataView]]
    @scala.inline
    def interpolateNumberArray(a: NumberArray, b: Float32Array): js.Function1[/* t */ Double, Float32Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateNumberArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Float32Array]]
    @scala.inline
    def interpolateNumberArray(a: NumberArray, b: Float64Array): js.Function1[/* t */ Double, Float64Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateNumberArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Float64Array]]
    @scala.inline
    def interpolateNumberArray(a: NumberArray, b: Int16Array): js.Function1[/* t */ Double, Int16Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateNumberArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Int16Array]]
    @scala.inline
    def interpolateNumberArray(a: NumberArray, b: Int32Array): js.Function1[/* t */ Double, Int32Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateNumberArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Int32Array]]
    @scala.inline
    def interpolateNumberArray(a: NumberArray, b: Int8Array): js.Function1[/* t */ Double, Int8Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateNumberArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Int8Array]]
    @scala.inline
    def interpolateNumberArray(a: NumberArray, b: Uint16Array): js.Function1[/* t */ Double, Uint16Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateNumberArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Uint16Array]]
    @scala.inline
    def interpolateNumberArray(a: NumberArray, b: Uint32Array): js.Function1[/* t */ Double, Uint32Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateNumberArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Uint32Array]]
    @scala.inline
    def interpolateNumberArray(a: NumberArray, b: Uint8Array): js.Function1[/* t */ Double, Uint8Array] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateNumberArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Uint8Array]]
    @scala.inline
    def interpolateNumberArray(a: NumberArray, b: Uint8ClampedArray): js.Function1[/* t */ Double, Uint8ClampedArray] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateNumberArray")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Uint8ClampedArray]]
    
    @scala.inline
    def interpolateObject[U /* <: js.Object */](a: js.Any, b: U): js.Function1[/* t */ Double, U] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateObject")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, U]]
    
    @scala.inline
    def interpolateOrRd(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateOrRd")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateOranges(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateOranges")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolatePRGn(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolatePRGn")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolatePiYG(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolatePiYG")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolatePlasma(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolatePlasma")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolatePuBu(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolatePuBu")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolatePuBuGn(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolatePuBuGn")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolatePuOr(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolatePuOr")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolatePuRd(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolatePuRd")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolatePurples(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolatePurples")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateRainbow(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateRainbow")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateRdBu(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateRdBu")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateRdGy(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateRdGy")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateRdPu(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateRdPu")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateRdYlBu(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateRdYlBu")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateRdYlGn(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateRdYlGn")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateReds(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateReds")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @JSImport("plotly.js/lib/core", "d3.interpolateRgb")
    @js.native
    val interpolateRgb: ColorGammaInterpolationFactory = js.native
    @scala.inline
    def interpolateRgb(a: String, b: String): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateRgb")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateRgb(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateRgb")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateRgb(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateRgb")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateRgb(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateRgb")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    
    @scala.inline
    def interpolateRgbBasis(colors: js.Array[String | ColorCommonInstance]): js.Function1[/* t */ Double, String] = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateRgbBasis")(colors.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* t */ Double, String]]
    
    @scala.inline
    def interpolateRgbBasisClosed(colors: js.Array[String | ColorCommonInstance]): js.Function1[/* t */ Double, String] = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateRgbBasisClosed")(colors.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* t */ Double, String]]
    
    @scala.inline
    def interpolateRound(a: Double, b: Double): js.Function1[/* t */ Double, Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateRound")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Double]]
    @scala.inline
    def interpolateRound(a: Double, b: typings.d3Interpolate.anon.ValueOf): js.Function1[/* t */ Double, Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateRound")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Double]]
    @scala.inline
    def interpolateRound(a: typings.d3Interpolate.anon.ValueOf, b: Double): js.Function1[/* t */ Double, Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateRound")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Double]]
    @scala.inline
    def interpolateRound(a: typings.d3Interpolate.anon.ValueOf, b: typings.d3Interpolate.anon.ValueOf): js.Function1[/* t */ Double, Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateRound")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, Double]]
    
    @scala.inline
    def interpolateSinebow(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateSinebow")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateSpectral(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateSpectral")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateString(a: String, b: String): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateString")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateString(a: String, b: ToString): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateString")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateString(a: ToString, b: String): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateString")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    @scala.inline
    def interpolateString(a: ToString, b: ToString): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateString")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    
    @scala.inline
    def interpolateTransformCss(a: String, b: String): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateTransformCss")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    
    @scala.inline
    def interpolateTransformSvg(a: String, b: String): js.Function1[/* t */ Double, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateTransformSvg")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, String]]
    
    @scala.inline
    def interpolateTurbo(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateTurbo")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateViridis(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateViridis")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateWarm(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateWarm")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateYlGn(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateYlGn")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateYlGnBu(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateYlGnBu")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateYlOrBr(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateYlOrBr")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateYlOrRd(t: Double): String = ^.asInstanceOf[js.Dynamic].applyDynamic("interpolateYlOrRd")(t.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def interpolateZoom(a: ZoomView, b: ZoomView): ZoomInterpolator = (^.asInstanceOf[js.Dynamic].applyDynamic("interpolateZoom")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[ZoomInterpolator]
    
    @scala.inline
    def interrupt(node: BaseType): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("interrupt")(node.asInstanceOf[js.Any]).asInstanceOf[Unit]
    @scala.inline
    def interrupt(node: BaseType, name: String): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("interrupt")(node.asInstanceOf[js.Any], name.asInstanceOf[js.Any])).asInstanceOf[Unit]
    
    @scala.inline
    def intersection[T](iterables: Iterable[T]*): Set[T] = ^.asInstanceOf[js.Dynamic].applyDynamic("intersection")(iterables.asInstanceOf[js.Any]).asInstanceOf[Set[T]]
    
    @scala.inline
    def interval(callback: js.Function1[/* elapsed */ Double, Unit]): Timer_ = ^.asInstanceOf[js.Dynamic].applyDynamic("interval")(callback.asInstanceOf[js.Any]).asInstanceOf[Timer_]
    @scala.inline
    def interval(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double): Timer_ = (^.asInstanceOf[js.Dynamic].applyDynamic("interval")(callback.asInstanceOf[js.Any], delay.asInstanceOf[js.Any])).asInstanceOf[Timer_]
    @scala.inline
    def interval(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double, time: Double): Timer_ = (^.asInstanceOf[js.Dynamic].applyDynamic("interval")(callback.asInstanceOf[js.Any], delay.asInstanceOf[js.Any], time.asInstanceOf[js.Any])).asInstanceOf[Timer_]
    @scala.inline
    def interval(callback: js.Function1[/* elapsed */ Double, Unit], delay: Unit, time: Double): Timer_ = (^.asInstanceOf[js.Dynamic].applyDynamic("interval")(callback.asInstanceOf[js.Any], delay.asInstanceOf[js.Any], time.asInstanceOf[js.Any])).asInstanceOf[Timer_]
    
    @scala.inline
    def isoFormat(date: Date): String = ^.asInstanceOf[js.Dynamic].applyDynamic("isoFormat")(date.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def isoParse(dateString: String): Date | Null = ^.asInstanceOf[js.Dynamic].applyDynamic("isoParse")(dateString.asInstanceOf[js.Any]).asInstanceOf[Date | Null]
    
    @scala.inline
    def json[ParsedJSONObject /* <: js.Any */](url: String): js.Promise[js.UndefOr[ParsedJSONObject]] = ^.asInstanceOf[js.Dynamic].applyDynamic("json")(url.asInstanceOf[js.Any]).asInstanceOf[js.Promise[js.UndefOr[ParsedJSONObject]]]
    @scala.inline
    def json[ParsedJSONObject /* <: js.Any */](url: String, init: RequestInit): js.Promise[js.UndefOr[ParsedJSONObject]] = (^.asInstanceOf[js.Dynamic].applyDynamic("json")(url.asInstanceOf[js.Any], init.asInstanceOf[js.Any])).asInstanceOf[js.Promise[js.UndefOr[ParsedJSONObject]]]
    
    @JSImport("plotly.js/lib/core", "d3.lab")
    @js.native
    val lab: LabColorFactory = js.native
    @scala.inline
    def lab(color: ColorCommonInstance): LabColor = ^.asInstanceOf[js.Dynamic].applyDynamic("lab")(color.asInstanceOf[js.Any]).asInstanceOf[LabColor]
    /**
      * Converts the provided color instance and returns a Lab color.
      * The color instance is converted to the RGB color space using color.rgb and then converted to CIELAB.
      * (Colors already in the Lab color space skip the conversion to RGB,
      * and colors in the HCL color space are converted directly to CIELAB.)
      *
      * @param color A permissible color space instance.
      */
    @scala.inline
    def lab(color: ColorSpaceObject): LabColor = ^.asInstanceOf[js.Dynamic].applyDynamic("lab")(color.asInstanceOf[js.Any]).asInstanceOf[LabColor]
    /**
      * Parses the specified CSS Color Module Level 3 specifier string, returning a Lab color.
      * If the specifier was not valid, null is returned.
      *
      * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
      */
    @scala.inline
    def lab(cssColorSpecifier: String): LabColor = ^.asInstanceOf[js.Dynamic].applyDynamic("lab")(cssColorSpecifier.asInstanceOf[js.Any]).asInstanceOf[LabColor]
    /**
      * Constructs a new CIELAB color based on the specified channel values and opacity.
      *
      * @param l Lightness typically in the range [0, 100].
      * @param a Position between red/magenta and green typically in [-160, +160].
      * @param b Position between yellow and blue typically in [-160, +160].
      * @param opacity Optional opacity value, defaults to 1.
      */
    @scala.inline
    def lab(l: Double, a: Double, b: Double): LabColor = (^.asInstanceOf[js.Dynamic].applyDynamic("lab")(l.asInstanceOf[js.Any], a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[LabColor]
    @scala.inline
    def lab(l: Double, a: Double, b: Double, opacity: Double): LabColor = (^.asInstanceOf[js.Dynamic].applyDynamic("lab")(l.asInstanceOf[js.Any], a.asInstanceOf[js.Any], b.asInstanceOf[js.Any], opacity.asInstanceOf[js.Any])).asInstanceOf[LabColor]
    
    @scala.inline
    def lch(color: ColorCommonInstance): HCLColor = ^.asInstanceOf[js.Dynamic].applyDynamic("lch")(color.asInstanceOf[js.Any]).asInstanceOf[HCLColor]
    /**
      * Converts the provided color instance and returns an HCL color.
      * The color instance is converted to the RGB color space using color.rgb and then converted to HCL.
      * (Colors already in the HCL color space skip the conversion to RGB,
      * and colors in the Lab color space are converted directly to HCL.)
      *
      * @param color A permissible color space instance.
      */
    @scala.inline
    def lch(color: ColorSpaceObject): HCLColor = ^.asInstanceOf[js.Dynamic].applyDynamic("lch")(color.asInstanceOf[js.Any]).asInstanceOf[HCLColor]
    /**
      * Parses the specified CSS Color Module Level 3 specifier string, returning an HCL color.
      * If the specifier was not valid, null is returned.
      *
      * @param cssColorSpecifier A CSS color Module Level 3 specifier string.
      */
    @scala.inline
    def lch(cssColorSpecifier: String): HCLColor = ^.asInstanceOf[js.Dynamic].applyDynamic("lch")(cssColorSpecifier.asInstanceOf[js.Any]).asInstanceOf[HCLColor]
    /**
      * Constructs a new HCL color based on the specified channel values and opacity.
      *
      * @param l Luminance channel value typically in the range [0, 100].
      * @param c Chroma channel value typically in [0, 230].
      * @param h Hue channel value typically in [0, 360).
      * @param opacity Optional opacity value, defaults to 1.
      */
    @scala.inline
    def lch(l: Double, c: Double, h: Double): HCLColor = (^.asInstanceOf[js.Dynamic].applyDynamic("lch")(l.asInstanceOf[js.Any], c.asInstanceOf[js.Any], h.asInstanceOf[js.Any])).asInstanceOf[HCLColor]
    @scala.inline
    def lch(l: Double, c: Double, h: Double, opacity: Double): HCLColor = (^.asInstanceOf[js.Dynamic].applyDynamic("lch")(l.asInstanceOf[js.Any], c.asInstanceOf[js.Any], h.asInstanceOf[js.Any], opacity.asInstanceOf[js.Any])).asInstanceOf[HCLColor]
    
    @scala.inline
    def least[T](iterable: Iterable[T]): js.UndefOr[T] = ^.asInstanceOf[js.Dynamic].applyDynamic("least")(iterable.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[T]]
    @scala.inline
    def least[T](iterable: Iterable[T], comparator: js.Function2[/* a */ T, /* b */ T, Double]): js.UndefOr[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("least")(iterable.asInstanceOf[js.Any], comparator.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[T]]
    @scala.inline
    def least[T, U](iterable: Iterable[T], accessor: js.Function1[/* a */ T, U]): js.UndefOr[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("least")(iterable.asInstanceOf[js.Any], accessor.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[T]]
    
    @scala.inline
    def leastIndex[T](iterable: Iterable[T]): js.UndefOr[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("leastIndex")(iterable.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[Double]]
    @scala.inline
    def leastIndex[T](iterable: Iterable[T], comparator: js.Function2[/* a */ T, /* b */ T, Double]): js.UndefOr[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("leastIndex")(iterable.asInstanceOf[js.Any], comparator.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[Double]]
    @scala.inline
    def leastIndex[T, U](iterable: Iterable[T], accessor: js.Function1[/* a */ T, U]): js.UndefOr[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("leastIndex")(iterable.asInstanceOf[js.Any], accessor.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[Double]]
    
    @scala.inline
    def line[Datum](): Line_[Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("line")().asInstanceOf[Line_[Datum]]
    @scala.inline
    def line[Datum](x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]): Line_[Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("line")(x.asInstanceOf[js.Any]).asInstanceOf[Line_[Datum]]
    @scala.inline
    def line[Datum](
      x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
      y: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
    ): Line_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("line")(x.asInstanceOf[js.Any], y.asInstanceOf[js.Any])).asInstanceOf[Line_[Datum]]
    @scala.inline
    def line[Datum](x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double], y: Double): Line_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("line")(x.asInstanceOf[js.Any], y.asInstanceOf[js.Any])).asInstanceOf[Line_[Datum]]
    @scala.inline
    def line[Datum](x: Double): Line_[Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("line")(x.asInstanceOf[js.Any]).asInstanceOf[Line_[Datum]]
    @scala.inline
    def line[Datum](x: Double, y: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]): Line_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("line")(x.asInstanceOf[js.Any], y.asInstanceOf[js.Any])).asInstanceOf[Line_[Datum]]
    @scala.inline
    def line[Datum](x: Double, y: Double): Line_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("line")(x.asInstanceOf[js.Any], y.asInstanceOf[js.Any])).asInstanceOf[Line_[Datum]]
    @scala.inline
    def line[Datum](x: Unit, y: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]): Line_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("line")(x.asInstanceOf[js.Any], y.asInstanceOf[js.Any])).asInstanceOf[Line_[Datum]]
    @scala.inline
    def line[Datum](x: Unit, y: Double): Line_[Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("line")(x.asInstanceOf[js.Any], y.asInstanceOf[js.Any])).asInstanceOf[Line_[Datum]]
    
    @scala.inline
    def lineRadial(): LineRadial_[js.Tuple2[Double, Double]] = ^.asInstanceOf[js.Dynamic].applyDynamic("lineRadial")().asInstanceOf[LineRadial_[js.Tuple2[Double, Double]]]
    
    @scala.inline
    def lineRadial_Datum[Datum](): LineRadial_[Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("lineRadial")().asInstanceOf[LineRadial_[Datum]]
    
    @scala.inline
    def linkHorizontal(): Link[js.Any, DefaultLinkObject, js.Tuple2[Double, Double]] = ^.asInstanceOf[js.Dynamic].applyDynamic("linkHorizontal")().asInstanceOf[Link[js.Any, DefaultLinkObject, js.Tuple2[Double, Double]]]
    
    @scala.inline
    def linkHorizontal_LinkDatumNodeDatum[LinkDatum, NodeDatum](): Link[js.Any, LinkDatum, NodeDatum] = ^.asInstanceOf[js.Dynamic].applyDynamic("linkHorizontal")().asInstanceOf[Link[js.Any, LinkDatum, NodeDatum]]
    
    @scala.inline
    def linkHorizontal_ThisLinkDatumNodeDatum[This, LinkDatum, NodeDatum](): Link[This, LinkDatum, NodeDatum] = ^.asInstanceOf[js.Dynamic].applyDynamic("linkHorizontal")().asInstanceOf[Link[This, LinkDatum, NodeDatum]]
    
    @scala.inline
    def linkRadial(): LinkRadial_[js.Any, DefaultLinkObject, js.Tuple2[Double, Double]] = ^.asInstanceOf[js.Dynamic].applyDynamic("linkRadial")().asInstanceOf[LinkRadial_[js.Any, DefaultLinkObject, js.Tuple2[Double, Double]]]
    
    @scala.inline
    def linkRadial_LinkDatumNodeDatum[LinkDatum, NodeDatum](): LinkRadial_[js.Any, LinkDatum, NodeDatum] = ^.asInstanceOf[js.Dynamic].applyDynamic("linkRadial")().asInstanceOf[LinkRadial_[js.Any, LinkDatum, NodeDatum]]
    
    @scala.inline
    def linkRadial_ThisLinkDatumNodeDatum[This, LinkDatum, NodeDatum](): LinkRadial_[This, LinkDatum, NodeDatum] = ^.asInstanceOf[js.Dynamic].applyDynamic("linkRadial")().asInstanceOf[LinkRadial_[This, LinkDatum, NodeDatum]]
    
    @scala.inline
    def linkVertical(): Link[js.Any, DefaultLinkObject, js.Tuple2[Double, Double]] = ^.asInstanceOf[js.Dynamic].applyDynamic("linkVertical")().asInstanceOf[Link[js.Any, DefaultLinkObject, js.Tuple2[Double, Double]]]
    
    @scala.inline
    def linkVertical_LinkDatumNodeDatum[LinkDatum, NodeDatum](): Link[js.Any, LinkDatum, NodeDatum] = ^.asInstanceOf[js.Dynamic].applyDynamic("linkVertical")().asInstanceOf[Link[js.Any, LinkDatum, NodeDatum]]
    
    @scala.inline
    def linkVertical_ThisLinkDatumNodeDatum[This, LinkDatum, NodeDatum](): Link[This, LinkDatum, NodeDatum] = ^.asInstanceOf[js.Dynamic].applyDynamic("linkVertical")().asInstanceOf[Link[This, LinkDatum, NodeDatum]]
    
    @scala.inline
    def local[T](): Local_[T] = ^.asInstanceOf[js.Dynamic].applyDynamic("local")().asInstanceOf[Local_[T]]
    
    @scala.inline
    def map[T, U](
      iterable: Iterable[T],
      mapper: js.Function3[/* value */ T, /* index */ Double, /* iterable */ Iterable[T], U]
    ): js.Array[U] = (^.asInstanceOf[js.Dynamic].applyDynamic("map")(iterable.asInstanceOf[js.Any], mapper.asInstanceOf[js.Any])).asInstanceOf[js.Array[U]]
    
    @scala.inline
    def matcher(selector: String): js.ThisFunction0[/* this */ BaseType, Boolean] = ^.asInstanceOf[js.Dynamic].applyDynamic("matcher")(selector.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, Boolean]]
    
    @scala.inline
    def max(iterable: Iterable[String]): js.UndefOr[String] = ^.asInstanceOf[js.Dynamic].applyDynamic("max")(iterable.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[String]]
    @scala.inline
    def max[T](
      iterable: Iterable[T],
      accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[String | Null]]
    ): js.UndefOr[String] = (^.asInstanceOf[js.Dynamic].applyDynamic("max")(iterable.asInstanceOf[js.Any], accessor.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[String]]
    
    @scala.inline
    def maxIndex[T](iterable: Iterable[T]): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("maxIndex")(iterable.asInstanceOf[js.Any]).asInstanceOf[Double]
    @scala.inline
    def maxIndex[TDatum, U](
      iterable: Iterable[TDatum],
      accessor: js.Function3[
          /* datum */ TDatum, 
          /* index */ Double, 
          /* array */ Iterable[TDatum], 
          js.UndefOr[U | Null]
        ]
    ): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("maxIndex")(iterable.asInstanceOf[js.Any], accessor.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    @scala.inline
    def max_TU_Numeric[T, U /* <: Numeric */](
      iterable: Iterable[T],
      accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[U | Null]]
    ): js.UndefOr[U] = (^.asInstanceOf[js.Dynamic].applyDynamic("max")(iterable.asInstanceOf[js.Any], accessor.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[U]]
    
    @scala.inline
    def max_T_Numeric[T /* <: Numeric */](iterable: Iterable[T]): js.UndefOr[T] = ^.asInstanceOf[js.Dynamic].applyDynamic("max")(iterable.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[T]]
    
    @scala.inline
    def mean[T /* <: Numeric */](iterable: Iterable[js.UndefOr[T | Null]]): js.UndefOr[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("mean")(iterable.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[Double]]
    @scala.inline
    def mean[T](
      iterable: Iterable[T],
      accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[Double | Null]]
    ): js.UndefOr[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("mean")(iterable.asInstanceOf[js.Any], accessor.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[Double]]
    
    @scala.inline
    def median[T /* <: Numeric */](iterable: Iterable[js.UndefOr[T | Null]]): js.UndefOr[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("median")(iterable.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[Double]]
    @scala.inline
    def median[T](
      iterable: Iterable[T],
      accessor: js.Function3[/* element */ T, /* i */ Double, /* array */ Iterable[T], js.UndefOr[Double | Null]]
    ): js.UndefOr[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("median")(iterable.asInstanceOf[js.Any], accessor.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[Double]]
    
    @scala.inline
    def merge[T](iterables: Iterable[Iterable[T]]): js.Array[T] = ^.asInstanceOf[js.Dynamic].applyDynamic("merge")(iterables.asInstanceOf[js.Any]).asInstanceOf[js.Array[T]]
    
    @scala.inline
    def min(iterable: Iterable[String]): js.UndefOr[String] = ^.asInstanceOf[js.Dynamic].applyDynamic("min")(iterable.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[String]]
    @scala.inline
    def min[T](
      iterable: Iterable[T],
      accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[String | Null]]
    ): js.UndefOr[String] = (^.asInstanceOf[js.Dynamic].applyDynamic("min")(iterable.asInstanceOf[js.Any], accessor.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[String]]
    
    @scala.inline
    def minIndex[T](iterable: Iterable[T]): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("minIndex")(iterable.asInstanceOf[js.Any]).asInstanceOf[Double]
    @scala.inline
    def minIndex[TDatum, U](
      iterable: Iterable[TDatum],
      accessor: js.Function3[
          /* datum */ TDatum, 
          /* index */ Double, 
          /* array */ Iterable[TDatum], 
          js.UndefOr[U | Null]
        ]
    ): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("minIndex")(iterable.asInstanceOf[js.Any], accessor.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    @scala.inline
    def min_TU_Numeric[T, U /* <: Numeric */](
      iterable: Iterable[T],
      accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[U | Null]]
    ): js.UndefOr[U] = (^.asInstanceOf[js.Dynamic].applyDynamic("min")(iterable.asInstanceOf[js.Any], accessor.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[U]]
    
    @scala.inline
    def min_T_Numeric[T /* <: Numeric */](iterable: Iterable[T]): js.UndefOr[T] = ^.asInstanceOf[js.Dynamic].applyDynamic("min")(iterable.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[T]]
    
    @scala.inline
    def namespace(prefixedLocal: String): NamespaceLocalObject | String = ^.asInstanceOf[js.Dynamic].applyDynamic("namespace")(prefixedLocal.asInstanceOf[js.Any]).asInstanceOf[NamespaceLocalObject | String]
    
    @JSImport("plotly.js/lib/core", "d3.namespaces")
    @js.native
    val namespaces: NamespaceMap = js.native
    
    @scala.inline
    def nice(start: Double, stop: Double, count: Double): js.Tuple2[Double, Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("nice")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], count.asInstanceOf[js.Any])).asInstanceOf[js.Tuple2[Double, Double]]
    
    @scala.inline
    def now(): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("now")().asInstanceOf[Double]
    
    @scala.inline
    def pack[Datum](): PackLayout[Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("pack")().asInstanceOf[PackLayout[Datum]]
    
    @scala.inline
    def packEnclose[Datum /* <: PackCircle */](circles: js.Array[Datum]): PackCircle = ^.asInstanceOf[js.Dynamic].applyDynamic("packEnclose")(circles.asInstanceOf[js.Any]).asInstanceOf[PackCircle]
    
    @scala.inline
    def packSiblings[Datum /* <: PackRadius */](circles: js.Array[Datum]): js.Array[Datum & PackCircle] = ^.asInstanceOf[js.Dynamic].applyDynamic("packSiblings")(circles.asInstanceOf[js.Any]).asInstanceOf[js.Array[Datum & PackCircle]]
    
    @scala.inline
    def pairs[T](iterable: Iterable[T]): js.Array[js.Tuple2[T, T]] = ^.asInstanceOf[js.Dynamic].applyDynamic("pairs")(iterable.asInstanceOf[js.Any]).asInstanceOf[js.Array[js.Tuple2[T, T]]]
    @scala.inline
    def pairs[T, U](iterable: Iterable[T], reducer: js.Function2[/* a */ T, /* b */ T, U]): js.Array[U] = (^.asInstanceOf[js.Dynamic].applyDynamic("pairs")(iterable.asInstanceOf[js.Any], reducer.asInstanceOf[js.Any])).asInstanceOf[js.Array[U]]
    
    @scala.inline
    def partition[Datum](): PartitionLayout[Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("partition")().asInstanceOf[PartitionLayout[Datum]]
    
    @scala.inline
    def path(): Path_ = ^.asInstanceOf[js.Dynamic].applyDynamic("path")().asInstanceOf[Path_]
    
    @scala.inline
    def permute[T](source: NumberDictionary[T], keys: Iterable[Double]): js.Array[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("permute")(source.asInstanceOf[js.Any], keys.asInstanceOf[js.Any])).asInstanceOf[js.Array[T]]
    @scala.inline
    def permute[T, K /* <: /* keyof T */ String */](source: T, keys: Iterable[K]): js.Array[
        /* import warning: importer.ImportType#apply Failed type conversion: T[K] */ js.Any
      ] = (^.asInstanceOf[js.Dynamic].applyDynamic("permute")(source.asInstanceOf[js.Any], keys.asInstanceOf[js.Any])).asInstanceOf[js.Array[
        /* import warning: importer.ImportType#apply Failed type conversion: T[K] */ js.Any
      ]]
    
    @scala.inline
    def pie(): Pie_[js.Any, Double | typings.d3Shape.anon.ValueOf] = ^.asInstanceOf[js.Dynamic].applyDynamic("pie")().asInstanceOf[Pie_[js.Any, Double | typings.d3Shape.anon.ValueOf]]
    
    @scala.inline
    def pie_Datum[Datum](): Pie_[js.Any, Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("pie")().asInstanceOf[Pie_[js.Any, Datum]]
    
    @scala.inline
    def pie_ThisDatum[This, Datum](): Pie_[This, Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("pie")().asInstanceOf[Pie_[This, Datum]]
    
    @scala.inline
    def piecewise(
      interpolate: js.Function2[/* a */ ZoomView, /* b */ ZoomView, ZoomInterpolator],
      values: js.Array[ZoomView]
    ): ZoomInterpolator = (^.asInstanceOf[js.Dynamic].applyDynamic("piecewise")(interpolate.asInstanceOf[js.Any], values.asInstanceOf[js.Any])).asInstanceOf[ZoomInterpolator]
    @scala.inline
    def piecewise(values: js.Array[ZoomView]): ZoomInterpolator = ^.asInstanceOf[js.Dynamic].applyDynamic("piecewise")(values.asInstanceOf[js.Any]).asInstanceOf[ZoomInterpolator]
    
    @scala.inline
    def piecewise_A_ArrayAny_ArrayInterpolator[A /* <: js.Array[js.Any] */](
      interpolate: js.Function2[/* a */ js.Array[js.Any], /* b */ A, ArrayInterpolator[A]],
      values: js.Array[A]
    ): ArrayInterpolator[A] = (^.asInstanceOf[js.Dynamic].applyDynamic("piecewise")(interpolate.asInstanceOf[js.Any], values.asInstanceOf[js.Any])).asInstanceOf[ArrayInterpolator[A]]
    @scala.inline
    def piecewise_A_ArrayAny_ArrayInterpolator[A /* <: js.Array[js.Any] */](values: js.Array[A]): ArrayInterpolator[A] = ^.asInstanceOf[js.Dynamic].applyDynamic("piecewise")(values.asInstanceOf[js.Any]).asInstanceOf[ArrayInterpolator[A]]
    
    @scala.inline
    def piecewise_TDataInterpolator_Function1[TData, Interpolator](interpolate: js.Function2[/* a */ TData, /* b */ TData, Interpolator], values: js.Array[TData]): js.Function1[/* t */ Double, js.Any] = (^.asInstanceOf[js.Dynamic].applyDynamic("piecewise")(interpolate.asInstanceOf[js.Any], values.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* t */ Double, js.Any]]
    
    @scala.inline
    def piecewise_TData_Function1[TData](values: js.Array[TData]): js.Function1[/* t */ Double, js.Any] = ^.asInstanceOf[js.Dynamic].applyDynamic("piecewise")(values.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* t */ Double, js.Any]]
    
    @scala.inline
    def pointRadial(angle: Double, radius: Double): js.Tuple2[Double, Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("pointRadial")(angle.asInstanceOf[js.Any], radius.asInstanceOf[js.Any])).asInstanceOf[js.Tuple2[Double, Double]]
    
    @scala.inline
    def pointer(event: js.Any): js.Tuple2[Double, Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("pointer")(event.asInstanceOf[js.Any]).asInstanceOf[js.Tuple2[Double, Double]]
    @scala.inline
    def pointer(event: js.Any, target: js.Any): js.Tuple2[Double, Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("pointer")(event.asInstanceOf[js.Any], target.asInstanceOf[js.Any])).asInstanceOf[js.Tuple2[Double, Double]]
    
    @scala.inline
    def pointers(event: js.Any): js.Array[js.Tuple2[Double, Double]] = ^.asInstanceOf[js.Dynamic].applyDynamic("pointers")(event.asInstanceOf[js.Any]).asInstanceOf[js.Array[js.Tuple2[Double, Double]]]
    @scala.inline
    def pointers(event: js.Any, target: js.Any): js.Array[js.Tuple2[Double, Double]] = (^.asInstanceOf[js.Dynamic].applyDynamic("pointers")(event.asInstanceOf[js.Any], target.asInstanceOf[js.Any])).asInstanceOf[js.Array[js.Tuple2[Double, Double]]]
    
    @scala.inline
    def polygonArea(polygon: js.Array[js.Tuple2[Double, Double]]): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("polygonArea")(polygon.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def polygonCentroid(polygon: js.Array[js.Tuple2[Double, Double]]): js.Tuple2[Double, Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("polygonCentroid")(polygon.asInstanceOf[js.Any]).asInstanceOf[js.Tuple2[Double, Double]]
    
    @scala.inline
    def polygonContains(polygon: js.Array[js.Tuple2[Double, Double]], point: js.Tuple2[Double, Double]): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("polygonContains")(polygon.asInstanceOf[js.Any], point.asInstanceOf[js.Any])).asInstanceOf[Boolean]
    
    @scala.inline
    def polygonHull(points: js.Array[js.Tuple2[Double, Double]]): (js.Array[js.Tuple2[Double, Double]]) | Null = ^.asInstanceOf[js.Dynamic].applyDynamic("polygonHull")(points.asInstanceOf[js.Any]).asInstanceOf[(js.Array[js.Tuple2[Double, Double]]) | Null]
    
    @scala.inline
    def polygonLength(polygon: js.Array[js.Tuple2[Double, Double]]): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("polygonLength")(polygon.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def precisionFixed(step: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("precisionFixed")(step.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def precisionPrefix(step: Double, value: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("precisionPrefix")(step.asInstanceOf[js.Any], value.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    @scala.inline
    def precisionRound(step: Double, max: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("precisionRound")(step.asInstanceOf[js.Any], max.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    @scala.inline
    def quadtree[T](): Quadtree_[T] = ^.asInstanceOf[js.Dynamic].applyDynamic("quadtree")().asInstanceOf[Quadtree_[T]]
    @scala.inline
    def quadtree[T](data: js.Array[T]): Quadtree_[T] = ^.asInstanceOf[js.Dynamic].applyDynamic("quadtree")(data.asInstanceOf[js.Any]).asInstanceOf[Quadtree_[T]]
    @scala.inline
    def quadtree[T](data: js.Array[T], x: js.Function1[/* d */ T, Double]): Quadtree_[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("quadtree")(data.asInstanceOf[js.Any], x.asInstanceOf[js.Any])).asInstanceOf[Quadtree_[T]]
    @scala.inline
    def quadtree[T](data: js.Array[T], x: js.Function1[/* d */ T, Double], y: js.Function1[/* d */ T, Double]): Quadtree_[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("quadtree")(data.asInstanceOf[js.Any], x.asInstanceOf[js.Any], y.asInstanceOf[js.Any])).asInstanceOf[Quadtree_[T]]
    @scala.inline
    def quadtree[T](data: js.Array[T], x: Unit, y: js.Function1[/* d */ T, Double]): Quadtree_[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("quadtree")(data.asInstanceOf[js.Any], x.asInstanceOf[js.Any], y.asInstanceOf[js.Any])).asInstanceOf[Quadtree_[T]]
    
    @scala.inline
    def quantile[T /* <: Numeric */](iterable: Iterable[js.UndefOr[T | Null]], p: Double): js.UndefOr[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("quantile")(iterable.asInstanceOf[js.Any], p.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[Double]]
    @scala.inline
    def quantile[T](
      iterable: Iterable[T],
      p: Double,
      accessor: js.Function3[/* element */ T, /* i */ Double, /* array */ Iterable[T], js.UndefOr[Double | Null]]
    ): js.UndefOr[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("quantile")(iterable.asInstanceOf[js.Any], p.asInstanceOf[js.Any], accessor.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[Double]]
    
    @scala.inline
    def quantileSorted[T /* <: Numeric */](array: js.Array[js.UndefOr[T | Null]], p: Double): js.UndefOr[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("quantileSorted")(array.asInstanceOf[js.Any], p.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[Double]]
    @scala.inline
    def quantileSorted[T](
      array: js.Array[T],
      p: Double,
      accessor: js.Function3[/* element */ T, /* i */ Double, /* array */ js.Array[T], js.UndefOr[Double | Null]]
    ): js.UndefOr[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("quantileSorted")(array.asInstanceOf[js.Any], p.asInstanceOf[js.Any], accessor.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[Double]]
    
    @scala.inline
    def quantize[T](interpolator: js.Function1[/* t */ Double, T], n: Double): js.Array[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("quantize")(interpolator.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[js.Array[T]]
    
    @scala.inline
    def quickselect[T](array: ArrayLike[T], k: Double): js.Array[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("quickselect")(array.asInstanceOf[js.Any], k.asInstanceOf[js.Any])).asInstanceOf[js.Array[T]]
    @scala.inline
    def quickselect[T](array: ArrayLike[T], k: Double, left: Double): js.Array[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("quickselect")(array.asInstanceOf[js.Any], k.asInstanceOf[js.Any], left.asInstanceOf[js.Any])).asInstanceOf[js.Array[T]]
    @scala.inline
    def quickselect[T](array: ArrayLike[T], k: Double, left: Double, right: Double): js.Array[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("quickselect")(array.asInstanceOf[js.Any], k.asInstanceOf[js.Any], left.asInstanceOf[js.Any], right.asInstanceOf[js.Any])).asInstanceOf[js.Array[T]]
    @scala.inline
    def quickselect[T](
      array: ArrayLike[T],
      k: Double,
      left: Double,
      right: Double,
      compare: js.Function2[/* a */ js.UndefOr[Primitive], /* b */ js.UndefOr[Primitive], Double]
    ): js.Array[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("quickselect")(array.asInstanceOf[js.Any], k.asInstanceOf[js.Any], left.asInstanceOf[js.Any], right.asInstanceOf[js.Any], compare.asInstanceOf[js.Any])).asInstanceOf[js.Array[T]]
    
    @scala.inline
    def radialArea(): RadialArea_[js.Tuple2[Double, Double]] = ^.asInstanceOf[js.Dynamic].applyDynamic("radialArea")().asInstanceOf[RadialArea_[js.Tuple2[Double, Double]]]
    
    @scala.inline
    def radialArea_Datum[Datum](): RadialArea_[Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("radialArea")().asInstanceOf[RadialArea_[Datum]]
    
    @scala.inline
    def radialLine(): RadialLine_[js.Tuple2[Double, Double]] = ^.asInstanceOf[js.Dynamic].applyDynamic("radialLine")().asInstanceOf[RadialLine_[js.Tuple2[Double, Double]]]
    
    @scala.inline
    def radialLine_Datum[Datum](): RadialLine_[Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("radialLine")().asInstanceOf[RadialLine_[Datum]]
    
    @JSImport("plotly.js/lib/core", "d3.randomBates")
    @js.native
    val randomBates: RandomBates_ = js.native
    /**
      * Returns a function for generating random numbers with a Bates distribution with n independent variables.
      * The case of fractional n is handled as with d3.randomIrwinHall, and d3.randomBates(0) is equivalent to d3.randomUniform().
      *
      * @param n Number of independent random variables to use.
      */
    @scala.inline
    def randomBates(n: Double): js.Function0[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("randomBates")(n.asInstanceOf[js.Any]).asInstanceOf[js.Function0[Double]]
    
    @JSImport("plotly.js/lib/core", "d3.randomBernoulli")
    @js.native
    val randomBernoulli: RandomBernoulli_ = js.native
    /**
      * Returns a function for generating either 1 or 0 according to a Bernoulli distribution with 1 being returned with success probability p and 0 with failure probability q = 1 - p.
      * The value p is in the range [0, 1].
      *
      * @param p p
      */
    @scala.inline
    def randomBernoulli(p: Double): js.Function0[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("randomBernoulli")(p.asInstanceOf[js.Any]).asInstanceOf[js.Function0[Double]]
    
    @JSImport("plotly.js/lib/core", "d3.randomBeta")
    @js.native
    val randomBeta: RandomBeta_ = js.native
    /**
      * Returns a function for generating random numbers with a beta distribution with alpha and beta shape parameters, which must both be positive.
      *
      * @param alpha Shape parameter
      * @param beta Shape paramter
      */
    @scala.inline
    def randomBeta(alpha: Double, beta: Double): js.Function0[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("randomBeta")(alpha.asInstanceOf[js.Any], beta.asInstanceOf[js.Any])).asInstanceOf[js.Function0[Double]]
    
    @JSImport("plotly.js/lib/core", "d3.randomBinomial")
    @js.native
    val randomBinomial: RandomBinomial_ = js.native
    /**
      * Returns a function for generating numbers with a geometric distribution with success probability p.
      * The value p is in the range (0, 1].
      *
      * @param p Success probability
      */
    @scala.inline
    def randomBinomial(p: Double): js.Function0[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("randomBinomial")(p.asInstanceOf[js.Any]).asInstanceOf[js.Function0[Double]]
    
    /**
      * Returns a function for generating random numbers with a Cauchy distribution.
      * a and b have the same meanings and default values as in d3.randomWeibull.
      *
      * @param a Location parameter
      * @param b Scale parameter
      */
    @scala.inline
    def randomCauchy(): js.Function0[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("randomCauchy")().asInstanceOf[js.Function0[Double]]
    @scala.inline
    def randomCauchy(a: Double): js.Function0[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("randomCauchy")(a.asInstanceOf[js.Any]).asInstanceOf[js.Function0[Double]]
    @scala.inline
    def randomCauchy(a: Double, b: Double): js.Function0[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("randomCauchy")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function0[Double]]
    @scala.inline
    def randomCauchy(a: Unit, b: Double): js.Function0[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("randomCauchy")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function0[Double]]
    @JSImport("plotly.js/lib/core", "d3.randomCauchy")
    @js.native
    val randomCauchy_Fd3: RandomCauchy_ = js.native
    
    @JSImport("plotly.js/lib/core", "d3.randomExponential")
    @js.native
    val randomExponential: RandomExponential_ = js.native
    /**
      * Returns a function for generating random numbers with an exponential distribution with the rate lambda;
      * equivalent to time between events in a Poisson process with a mean of 1 / lambda.
      *
      * @param lambda Expected time between events.
      */
    @scala.inline
    def randomExponential(lambda: Double): js.Function0[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("randomExponential")(lambda.asInstanceOf[js.Any]).asInstanceOf[js.Function0[Double]]
    
    @JSImport("plotly.js/lib/core", "d3.randomGamma")
    @js.native
    val randomGamma: RandomGamma_ = js.native
    /**
      * Returns a function for generating random numbers with a gamma distribution with k the shape parameter and theta the scale parameter.
      * The value k must be a positive value; if theta is not specified, it defaults to 1.
      *
      * @param k Shape parameter
      * @param theta Scale paramter
      */
    @scala.inline
    def randomGamma(k: Double): js.Function0[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("randomGamma")(k.asInstanceOf[js.Any]).asInstanceOf[js.Function0[Double]]
    @scala.inline
    def randomGamma(k: Double, theta: Double): js.Function0[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("randomGamma")(k.asInstanceOf[js.Any], theta.asInstanceOf[js.Any])).asInstanceOf[js.Function0[Double]]
    
    @JSImport("plotly.js/lib/core", "d3.randomGeometric")
    @js.native
    val randomGeometric: RandomGeometric_ = js.native
    /**
      * Returns a function for generating numbers with a geometric distribution with success probability p.
      * The value p is in the range [0, 1].
      *
      * @param p Success probability
      */
    @scala.inline
    def randomGeometric(p: Double): js.Function0[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("randomGeometric")(p.asInstanceOf[js.Any]).asInstanceOf[js.Function0[Double]]
    
    @JSImport("plotly.js/lib/core", "d3.randomInt")
    @js.native
    val randomInt: RandomInt_ = js.native
    /**
      * Returns a function for generating random integers with a uniform distribution.
      * The minimum allowed value of a returned number is ⌊min⌋ (inclusive), and the maximum is ⌊max - 1⌋ (inclusive)
      * Min defaults to 0.
      *
      * @param max The maximum allowed value of a returned number.
      */
    @scala.inline
    def randomInt(max: Double): js.Function0[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("randomInt")(max.asInstanceOf[js.Any]).asInstanceOf[js.Function0[Double]]
    /**
      * Returns a function for generating random integers with a uniform distribution.
      * The minimum allowed value of a returned number is ⌊min⌋ (inclusive), and the maximum is ⌊max - 1⌋ (inclusive)
      *
      * @param min The minimum allowed value of a returned number.
      * @param max The maximum allowed value of a returned number.
      */
    // tslint:disable-next-line:unified-signatures
    @scala.inline
    def randomInt(min: Double, max: Double): js.Function0[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("randomInt")(min.asInstanceOf[js.Any], max.asInstanceOf[js.Any])).asInstanceOf[js.Function0[Double]]
    
    @JSImport("plotly.js/lib/core", "d3.randomIrwinHall")
    @js.native
    val randomIrwinHall: RandomIrwinHall_ = js.native
    /**
      * Returns a function for generating random numbers with an Irwin–Hall distribution with n independent variables.
      * If the fractional part of n is non-zero, this is treated as adding d3.randomUniform() times that fractional part to the integral part.
      *
      * @param n Number of independent random variables to use.
      */
    @scala.inline
    def randomIrwinHall(n: Double): js.Function0[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("randomIrwinHall")(n.asInstanceOf[js.Any]).asInstanceOf[js.Function0[Double]]
    
    @scala.inline
    def randomLcg(): js.Function0[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("randomLcg")().asInstanceOf[js.Function0[Double]]
    @scala.inline
    def randomLcg(seed: Double): js.Function0[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("randomLcg")(seed.asInstanceOf[js.Any]).asInstanceOf[js.Function0[Double]]
    
    /**
      * Returns a function for generating random numbers with a log-normal distribution. The expected value of the random variable’s natural logarithm is mu,
      * with the given standard deviation sigma. If mu is not specified, it defaults to 0; if sigma is not specified, it defaults to 1.
      *
      * @param mu Expected value, defaults to 0.
      * @param sigma Standard deviation, defaults to 1.
      */
    @scala.inline
    def randomLogNormal(): js.Function0[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("randomLogNormal")().asInstanceOf[js.Function0[Double]]
    @scala.inline
    def randomLogNormal(mu: Double): js.Function0[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("randomLogNormal")(mu.asInstanceOf[js.Any]).asInstanceOf[js.Function0[Double]]
    @scala.inline
    def randomLogNormal(mu: Double, sigma: Double): js.Function0[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("randomLogNormal")(mu.asInstanceOf[js.Any], sigma.asInstanceOf[js.Any])).asInstanceOf[js.Function0[Double]]
    @scala.inline
    def randomLogNormal(mu: Unit, sigma: Double): js.Function0[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("randomLogNormal")(mu.asInstanceOf[js.Any], sigma.asInstanceOf[js.Any])).asInstanceOf[js.Function0[Double]]
    @JSImport("plotly.js/lib/core", "d3.randomLogNormal")
    @js.native
    val randomLogNormal_Fd3: RandomLogNormal_ = js.native
    
    /**
      * Returns a function for generating random numbers with a logistic distribution.
      * a and b have the same meanings and default values as in d3.randomWeibull.
      *
      * @param a Location parameter
      * @param b Scale parameter
      */
    @scala.inline
    def randomLogistic(): js.Function0[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("randomLogistic")().asInstanceOf[js.Function0[Double]]
    @scala.inline
    def randomLogistic(a: Double): js.Function0[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("randomLogistic")(a.asInstanceOf[js.Any]).asInstanceOf[js.Function0[Double]]
    @scala.inline
    def randomLogistic(a: Double, b: Double): js.Function0[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("randomLogistic")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function0[Double]]
    @scala.inline
    def randomLogistic(a: Unit, b: Double): js.Function0[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("randomLogistic")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function0[Double]]
    @JSImport("plotly.js/lib/core", "d3.randomLogistic")
    @js.native
    val randomLogistic_Fd3: RandomLogistic_ = js.native
    
    /**
      * Returns a function for generating random numbers with a normal (Gaussian) distribution.
      * The expected value of the generated numbers is mu, with the given standard deviation sigma.
      * If mu is not specified, it defaults to 0; if sigma is not specified, it defaults to 1.
      *
      * @param mu Expected value, defaults to 0.
      * @param sigma Standard deviation, defaults to 1.
      */
    @scala.inline
    def randomNormal(): js.Function0[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("randomNormal")().asInstanceOf[js.Function0[Double]]
    @scala.inline
    def randomNormal(mu: Double): js.Function0[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("randomNormal")(mu.asInstanceOf[js.Any]).asInstanceOf[js.Function0[Double]]
    @scala.inline
    def randomNormal(mu: Double, sigma: Double): js.Function0[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("randomNormal")(mu.asInstanceOf[js.Any], sigma.asInstanceOf[js.Any])).asInstanceOf[js.Function0[Double]]
    @scala.inline
    def randomNormal(mu: Unit, sigma: Double): js.Function0[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("randomNormal")(mu.asInstanceOf[js.Any], sigma.asInstanceOf[js.Any])).asInstanceOf[js.Function0[Double]]
    @JSImport("plotly.js/lib/core", "d3.randomNormal")
    @js.native
    val randomNormal_Fd3: RandomNormal_ = js.native
    
    @JSImport("plotly.js/lib/core", "d3.randomPareto")
    @js.native
    val randomPareto: RandomPareto_ = js.native
    /**
      * Returns a function for generating random numbers with a Pareto distribution with the shape alpha.
      * The value alpha must be a positive value.
      *
      * @param alpha alpha
      */
    @scala.inline
    def randomPareto(alpha: Double): js.Function0[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("randomPareto")(alpha.asInstanceOf[js.Any]).asInstanceOf[js.Function0[Double]]
    
    @JSImport("plotly.js/lib/core", "d3.randomPoisson")
    @js.native
    val randomPoisson: RandomPoisson_ = js.native
    /**
      * Returns a function for generating random numbers with a Poisson distribution with mean lambda.
      *
      * @param lambda Mean
      */
    @scala.inline
    def randomPoisson(lambda: Double): js.Function0[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("randomPoisson")(lambda.asInstanceOf[js.Any]).asInstanceOf[js.Function0[Double]]
    
    /**
      * Returns a function for generating random numbers with a uniform distribution.
      * The minimum allowed value of a returned number is min (inclusive), and the maximum is max (exclusive).
      * Min defaults to 0; if max is not specified, it defaults to 1.
      *
      * @param max The maximum allowed value of a returned number, defaults to 1.
      */
    @scala.inline
    def randomUniform(): js.Function0[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("randomUniform")().asInstanceOf[js.Function0[Double]]
    @scala.inline
    def randomUniform(max: Double): js.Function0[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("randomUniform")(max.asInstanceOf[js.Any]).asInstanceOf[js.Function0[Double]]
    /**
      * Returns a function for generating random numbers with a uniform distribution.
      * The minimum allowed value of a returned number is min (inclusive), and the maximum is max (exclusive).
      *
      * @param min The minimum allowed value of a returned number.
      * @param max The maximum allowed value of a returned number.
      */
    // tslint:disable-next-line:unified-signatures
    @scala.inline
    def randomUniform(min: Double, max: Double): js.Function0[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("randomUniform")(min.asInstanceOf[js.Any], max.asInstanceOf[js.Any])).asInstanceOf[js.Function0[Double]]
    @JSImport("plotly.js/lib/core", "d3.randomUniform")
    @js.native
    val randomUniform_Fd3: RandomUniform_ = js.native
    
    @JSImport("plotly.js/lib/core", "d3.randomWeibull")
    @js.native
    val randomWeibull: RandomWeibull_ = js.native
    /**
      * Returns a function for generating random numbers with one of the generalized extreme value distributions, depending on k:
      * If k is positive, the Weibull distribution with shape parameter k
      * If k is zero, the Gumbel distribution
      * If k is negative, the Fréchet distribution with shape parameter −k
      * In all three cases, a is the location parameter and b is the scale parameter.
      * If a is not specified, it defaults to 0; if b is not specified, it defaults to 1.
      *
      * @param k Shape parameter
      * @param a Location parameter
      * @param b Scale parameter
      */
    @scala.inline
    def randomWeibull(k: Double): js.Function0[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("randomWeibull")(k.asInstanceOf[js.Any]).asInstanceOf[js.Function0[Double]]
    @scala.inline
    def randomWeibull(k: Double, a: Double): js.Function0[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("randomWeibull")(k.asInstanceOf[js.Any], a.asInstanceOf[js.Any])).asInstanceOf[js.Function0[Double]]
    @scala.inline
    def randomWeibull(k: Double, a: Double, b: Double): js.Function0[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("randomWeibull")(k.asInstanceOf[js.Any], a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function0[Double]]
    @scala.inline
    def randomWeibull(k: Double, a: Unit, b: Double): js.Function0[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("randomWeibull")(k.asInstanceOf[js.Any], a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[js.Function0[Double]]
    
    @scala.inline
    def range(start: Double, stop: Double): js.Array[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("range")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Double]]
    @scala.inline
    def range(start: Double, stop: Double, step: Double): js.Array[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("range")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Double]]
    @scala.inline
    def range(stop: Double): js.Array[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("range")(stop.asInstanceOf[js.Any]).asInstanceOf[js.Array[Double]]
    
    @scala.inline
    def reduce[T](
      iterable: Iterable[T],
      reducer: js.Function4[
          /* previousValue */ T, 
          /* currentValue */ T, 
          /* currentIndex */ Double, 
          /* iterable */ Iterable[T], 
          T
        ]
    ): T = (^.asInstanceOf[js.Dynamic].applyDynamic("reduce")(iterable.asInstanceOf[js.Any], reducer.asInstanceOf[js.Any])).asInstanceOf[T]
    @scala.inline
    def reduce[T](
      iterable: Iterable[T],
      reducer: js.Function4[
          /* previousValue */ T, 
          /* currentValue */ T, 
          /* currentIndex */ Double, 
          /* iterable */ Iterable[T], 
          T
        ],
      initialValue: T
    ): T = (^.asInstanceOf[js.Dynamic].applyDynamic("reduce")(iterable.asInstanceOf[js.Any], reducer.asInstanceOf[js.Any], initialValue.asInstanceOf[js.Any])).asInstanceOf[T]
    
    @scala.inline
    def reduce_TU_U[T, U](
      iterable: Iterable[T],
      reducer: js.Function4[
          /* previousValue */ U, 
          /* currentValue */ T, 
          /* currentIndex */ Double, 
          /* iterable */ Iterable[T], 
          U
        ],
      initialValue: U
    ): U = (^.asInstanceOf[js.Dynamic].applyDynamic("reduce")(iterable.asInstanceOf[js.Any], reducer.asInstanceOf[js.Any], initialValue.asInstanceOf[js.Any])).asInstanceOf[U]
    
    @scala.inline
    def reverse[T](iterable: Iterable[T]): js.Array[T] = ^.asInstanceOf[js.Dynamic].applyDynamic("reverse")(iterable.asInstanceOf[js.Any]).asInstanceOf[js.Array[T]]
    
    @JSImport("plotly.js/lib/core", "d3.rgb")
    @js.native
    val rgb: RGBColorFactory = js.native
    @scala.inline
    def rgb(color: ColorCommonInstance): RGBColor = ^.asInstanceOf[js.Dynamic].applyDynamic("rgb")(color.asInstanceOf[js.Any]).asInstanceOf[RGBColor]
    /**
      * Converts the provided color instance and returns an RGB color. The color instance is converted to the RGB color space using color.rgb.
      * Note that unlike color.rgb this method always returns a new instance, even if color is already an RGB color.
      *
      * @param color A permissible color space instance.
      */
    @scala.inline
    def rgb(color: ColorSpaceObject): RGBColor = ^.asInstanceOf[js.Dynamic].applyDynamic("rgb")(color.asInstanceOf[js.Any]).asInstanceOf[RGBColor]
    /**
      * Parses the specified CSS Color Module Level 3 specifier string, returning an RGB color.
      * If the specifier was not valid, null is returned.
      *
      * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
      */
    @scala.inline
    def rgb(cssColorSpecifier: String): RGBColor = ^.asInstanceOf[js.Dynamic].applyDynamic("rgb")(cssColorSpecifier.asInstanceOf[js.Any]).asInstanceOf[RGBColor]
    /**
      * Constructs a new RGB color based on the specified channel values and opacity.
      *
      * @param r Red channel value.
      * @param g Green channel value.
      * @param b Blue channel value.
      * @param opacity Optional opacity value, defaults to 1.
      */
    @scala.inline
    def rgb(r: Double, g: Double, b: Double): RGBColor = (^.asInstanceOf[js.Dynamic].applyDynamic("rgb")(r.asInstanceOf[js.Any], g.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[RGBColor]
    @scala.inline
    def rgb(r: Double, g: Double, b: Double, opacity: Double): RGBColor = (^.asInstanceOf[js.Dynamic].applyDynamic("rgb")(r.asInstanceOf[js.Any], g.asInstanceOf[js.Any], b.asInstanceOf[js.Any], opacity.asInstanceOf[js.Any])).asInstanceOf[RGBColor]
    
    @scala.inline
    def ribbon(): RibbonGenerator[js.Any, Ribbon_, RibbonSubgroup] = ^.asInstanceOf[js.Dynamic].applyDynamic("ribbon")().asInstanceOf[RibbonGenerator[js.Any, Ribbon_, RibbonSubgroup]]
    
    @scala.inline
    def ribbon_DatumSubgroupDatum[Datum, SubgroupDatum](): RibbonGenerator[js.Any, Datum, SubgroupDatum] = ^.asInstanceOf[js.Dynamic].applyDynamic("ribbon")().asInstanceOf[RibbonGenerator[js.Any, Datum, SubgroupDatum]]
    
    @scala.inline
    def ribbon_ThisDatumSubgroupDatum[This, Datum, SubgroupDatum](): RibbonGenerator[This, Datum, SubgroupDatum] = ^.asInstanceOf[js.Dynamic].applyDynamic("ribbon")().asInstanceOf[RibbonGenerator[This, Datum, SubgroupDatum]]
    
    @scala.inline
    def rollup[TObject, TReduce, TKey](
      iterable: Iterable[TObject],
      reduce: js.Function1[/* value */ js.Array[TObject], TReduce],
      key: js.Function1[/* value */ TObject, TKey]
    ): Map[TKey, TReduce] = (^.asInstanceOf[js.Dynamic].applyDynamic("rollup")(iterable.asInstanceOf[js.Any], reduce.asInstanceOf[js.Any], key.asInstanceOf[js.Any])).asInstanceOf[Map[TKey, TReduce]]
    @scala.inline
    def rollup[TObject, TReduce, TKey1, TKey2](
      iterable: Iterable[TObject],
      reduce: js.Function1[/* value */ js.Array[TObject], TReduce],
      key1: js.Function1[/* value */ TObject, TKey1],
      key2: js.Function1[/* value */ TObject, TKey2]
    ): Map[TKey1, Map[TKey2, TReduce]] = (^.asInstanceOf[js.Dynamic].applyDynamic("rollup")(iterable.asInstanceOf[js.Any], reduce.asInstanceOf[js.Any], key1.asInstanceOf[js.Any], key2.asInstanceOf[js.Any])).asInstanceOf[Map[TKey1, Map[TKey2, TReduce]]]
    @scala.inline
    def rollup[TObject, TReduce, TKey1, TKey2, TKey3](
      iterable: Iterable[TObject],
      reduce: js.Function1[/* value */ js.Array[TObject], TReduce],
      key1: js.Function1[/* value */ TObject, TKey1],
      key2: js.Function1[/* value */ TObject, TKey2],
      key3: js.Function1[/* value */ TObject, TKey3]
    ): Map[TKey1, Map[TKey2, Map[TKey3, TReduce]]] = (^.asInstanceOf[js.Dynamic].applyDynamic("rollup")(iterable.asInstanceOf[js.Any], reduce.asInstanceOf[js.Any], key1.asInstanceOf[js.Any], key2.asInstanceOf[js.Any], key3.asInstanceOf[js.Any])).asInstanceOf[Map[TKey1, Map[TKey2, Map[TKey3, TReduce]]]]
    
    @scala.inline
    def rollups[TObject, TReduce, TKey](
      iterable: Iterable[TObject],
      reduce: js.Function1[/* value */ js.Array[TObject], TReduce],
      key: js.Function1[/* value */ TObject, TKey]
    ): js.Array[js.Tuple2[TKey, TReduce]] = (^.asInstanceOf[js.Dynamic].applyDynamic("rollups")(iterable.asInstanceOf[js.Any], reduce.asInstanceOf[js.Any], key.asInstanceOf[js.Any])).asInstanceOf[js.Array[js.Tuple2[TKey, TReduce]]]
    @scala.inline
    def rollups[TObject, TReduce, TKey1, TKey2](
      iterable: Iterable[TObject],
      reduce: js.Function1[/* value */ js.Array[TObject], TReduce],
      key1: js.Function1[/* value */ TObject, TKey1],
      key2: js.Function1[/* value */ TObject, TKey2]
    ): js.Array[js.Tuple2[TKey1, js.Array[js.Tuple2[TKey2, TReduce]]]] = (^.asInstanceOf[js.Dynamic].applyDynamic("rollups")(iterable.asInstanceOf[js.Any], reduce.asInstanceOf[js.Any], key1.asInstanceOf[js.Any], key2.asInstanceOf[js.Any])).asInstanceOf[js.Array[js.Tuple2[TKey1, js.Array[js.Tuple2[TKey2, TReduce]]]]]
    @scala.inline
    def rollups[TObject, TReduce, TKey1, TKey2, TKey3](
      iterable: Iterable[TObject],
      reduce: js.Function1[/* value */ js.Array[TObject], TReduce],
      key1: js.Function1[/* value */ TObject, TKey1],
      key2: js.Function1[/* value */ TObject, TKey2],
      key3: js.Function1[/* value */ TObject, TKey3]
    ): js.Array[
        js.Tuple2[TKey1, js.Array[js.Tuple2[TKey2, js.Array[js.Tuple2[TKey3, TReduce]]]]]
      ] = (^.asInstanceOf[js.Dynamic].applyDynamic("rollups")(iterable.asInstanceOf[js.Any], reduce.asInstanceOf[js.Any], key1.asInstanceOf[js.Any], key2.asInstanceOf[js.Any], key3.asInstanceOf[js.Any])).asInstanceOf[js.Array[
        js.Tuple2[TKey1, js.Array[js.Tuple2[TKey2, js.Array[js.Tuple2[TKey3, TReduce]]]]]
      ]]
    
    @scala.inline
    def scaleBand[Domain /* <: typings.d3Scale.anon.ToString */](): ScaleBand_[Domain] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleBand")().asInstanceOf[ScaleBand_[Domain]]
    @scala.inline
    def scaleBand[Domain /* <: typings.d3Scale.anon.ToString */](domain: Iterable[Domain], range: Iterable[NumberValue]): ScaleBand_[Domain] = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleBand")(domain.asInstanceOf[js.Any], range.asInstanceOf[js.Any])).asInstanceOf[ScaleBand_[Domain]]
    @scala.inline
    def scaleBand[Domain /* <: typings.d3Scale.anon.ToString */](range: Iterable[NumberValue]): ScaleBand_[Domain] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleBand")(range.asInstanceOf[js.Any]).asInstanceOf[ScaleBand_[Domain]]
    
    @scala.inline
    def scaleDiverging[Output, Unknown](): ScaleDiverging_[Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleDiverging")().asInstanceOf[ScaleDiverging_[Output, Unknown]]
    @scala.inline
    def scaleDiverging[Output, Unknown](domain: Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleDiverging")(domain.asInstanceOf[js.Any], interpolator.asInstanceOf[js.Any])).asInstanceOf[ScaleDiverging_[Output, Unknown]]
    @scala.inline
    def scaleDiverging[Output, Unknown](domain: Iterable[NumberValue], interpolator: Iterable[Output]): ScaleDiverging_[Output, Unknown] = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleDiverging")(domain.asInstanceOf[js.Any], interpolator.asInstanceOf[js.Any])).asInstanceOf[ScaleDiverging_[Output, Unknown]]
    @scala.inline
    def scaleDiverging[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleDiverging")(interpolator.asInstanceOf[js.Any]).asInstanceOf[ScaleDiverging_[Output, Unknown]]
    @scala.inline
    def scaleDiverging[Output, Unknown](interpolator: Iterable[Output]): ScaleDiverging_[Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleDiverging")(interpolator.asInstanceOf[js.Any]).asInstanceOf[ScaleDiverging_[Output, Unknown]]
    
    @scala.inline
    def scaleDivergingLog[Output, Unknown](): ScaleDiverging_[Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleDivergingLog")().asInstanceOf[ScaleDiverging_[Output, Unknown]]
    @scala.inline
    def scaleDivergingLog[Output, Unknown](domain: Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleDivergingLog")(domain.asInstanceOf[js.Any], interpolator.asInstanceOf[js.Any])).asInstanceOf[ScaleDiverging_[Output, Unknown]]
    @scala.inline
    def scaleDivergingLog[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleDivergingLog")(interpolator.asInstanceOf[js.Any]).asInstanceOf[ScaleDiverging_[Output, Unknown]]
    
    @scala.inline
    def scaleDivergingPow[Output, Unknown](): ScaleDiverging_[Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleDivergingPow")().asInstanceOf[ScaleDiverging_[Output, Unknown]]
    @scala.inline
    def scaleDivergingPow[Output, Unknown](domain: Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleDivergingPow")(domain.asInstanceOf[js.Any], interpolator.asInstanceOf[js.Any])).asInstanceOf[ScaleDiverging_[Output, Unknown]]
    @scala.inline
    def scaleDivergingPow[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleDivergingPow")(interpolator.asInstanceOf[js.Any]).asInstanceOf[ScaleDiverging_[Output, Unknown]]
    
    @scala.inline
    def scaleDivergingSqrt[Output, Unknown](): ScaleDiverging_[Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleDivergingSqrt")().asInstanceOf[ScaleDiverging_[Output, Unknown]]
    @scala.inline
    def scaleDivergingSqrt[Output, Unknown](domain: Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleDivergingSqrt")(domain.asInstanceOf[js.Any], interpolator.asInstanceOf[js.Any])).asInstanceOf[ScaleDiverging_[Output, Unknown]]
    @scala.inline
    def scaleDivergingSqrt[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleDivergingSqrt")(interpolator.asInstanceOf[js.Any]).asInstanceOf[ScaleDiverging_[Output, Unknown]]
    
    @scala.inline
    def scaleDivergingSymlog[Output, Unknown](): ScaleDiverging_[Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleDivergingSymlog")().asInstanceOf[ScaleDiverging_[Output, Unknown]]
    @scala.inline
    def scaleDivergingSymlog[Output, Unknown](domain: Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleDivergingSymlog")(domain.asInstanceOf[js.Any], interpolator.asInstanceOf[js.Any])).asInstanceOf[ScaleDiverging_[Output, Unknown]]
    @scala.inline
    def scaleDivergingSymlog[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleDivergingSymlog")(interpolator.asInstanceOf[js.Any]).asInstanceOf[ScaleDiverging_[Output, Unknown]]
    
    @scala.inline
    def scaleIdentity[Unknown](): ScaleIdentity_[Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleIdentity")().asInstanceOf[ScaleIdentity_[Unknown]]
    @scala.inline
    def scaleIdentity[Unknown](range: Iterable[NumberValue]): ScaleIdentity_[Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleIdentity")(range.asInstanceOf[js.Any]).asInstanceOf[ScaleIdentity_[Unknown]]
    
    @JSImport("plotly.js/lib/core", "d3.scaleImplicit")
    @js.native
    val scaleImplicit: TypeofscaleImplicit = js.native
    
    @scala.inline
    def scaleLinear[Range, Output, Unknown](): ScaleLinear_[Range, Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleLinear")().asInstanceOf[ScaleLinear_[Range, Output, Unknown]]
    @scala.inline
    def scaleLinear[Range, Output, Unknown](domain: Iterable[NumberValue], range: Iterable[Range]): ScaleLinear_[Range, Output, Unknown] = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleLinear")(domain.asInstanceOf[js.Any], range.asInstanceOf[js.Any])).asInstanceOf[ScaleLinear_[Range, Output, Unknown]]
    @scala.inline
    def scaleLinear[Range, Output, Unknown](range: Iterable[Range]): ScaleLinear_[Range, Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleLinear")(range.asInstanceOf[js.Any]).asInstanceOf[ScaleLinear_[Range, Output, Unknown]]
    
    @scala.inline
    def scaleLog[Range, Output, Unknown](): ScaleLogarithmic[Range, Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleLog")().asInstanceOf[ScaleLogarithmic[Range, Output, Unknown]]
    @scala.inline
    def scaleLog[Range, Output, Unknown](domain: Iterable[NumberValue], range: Iterable[Range]): ScaleLogarithmic[Range, Output, Unknown] = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleLog")(domain.asInstanceOf[js.Any], range.asInstanceOf[js.Any])).asInstanceOf[ScaleLogarithmic[Range, Output, Unknown]]
    @scala.inline
    def scaleLog[Range, Output, Unknown](range: Iterable[Range]): ScaleLogarithmic[Range, Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleLog")(range.asInstanceOf[js.Any]).asInstanceOf[ScaleLogarithmic[Range, Output, Unknown]]
    
    @scala.inline
    def scaleOrdinal[Range](): ScaleOrdinal_[String, Range, scala.Nothing] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleOrdinal")().asInstanceOf[ScaleOrdinal_[String, Range, scala.Nothing]]
    @scala.inline
    def scaleOrdinal[Range](range: Iterable[Range]): ScaleOrdinal_[String, Range, scala.Nothing] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleOrdinal")(range.asInstanceOf[js.Any]).asInstanceOf[ScaleOrdinal_[String, Range, scala.Nothing]]
    @scala.inline
    def scaleOrdinal[Domain /* <: typings.d3Scale.anon.ToString */, Range, Unknown](domain: Iterable[Domain], range: Iterable[Range]): ScaleOrdinal_[Domain, Range, Unknown] = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleOrdinal")(domain.asInstanceOf[js.Any], range.asInstanceOf[js.Any])).asInstanceOf[ScaleOrdinal_[Domain, Range, Unknown]]
    
    @scala.inline
    def scaleOrdinal_Domain_ToStringRangeUnknown[Domain /* <: typings.d3Scale.anon.ToString */, Range, Unknown](): ScaleOrdinal_[Domain, Range, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleOrdinal")().asInstanceOf[ScaleOrdinal_[Domain, Range, Unknown]]
    @scala.inline
    def scaleOrdinal_Domain_ToStringRangeUnknown[Domain /* <: typings.d3Scale.anon.ToString */, Range, Unknown](range: Iterable[Range]): ScaleOrdinal_[Domain, Range, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleOrdinal")(range.asInstanceOf[js.Any]).asInstanceOf[ScaleOrdinal_[Domain, Range, Unknown]]
    
    @scala.inline
    def scalePoint[Domain /* <: typings.d3Scale.anon.ToString */](): ScalePoint_[Domain] = ^.asInstanceOf[js.Dynamic].applyDynamic("scalePoint")().asInstanceOf[ScalePoint_[Domain]]
    @scala.inline
    def scalePoint[Domain /* <: typings.d3Scale.anon.ToString */](domain: Iterable[Domain], range: Iterable[NumberValue]): ScalePoint_[Domain] = (^.asInstanceOf[js.Dynamic].applyDynamic("scalePoint")(domain.asInstanceOf[js.Any], range.asInstanceOf[js.Any])).asInstanceOf[ScalePoint_[Domain]]
    @scala.inline
    def scalePoint[Domain /* <: typings.d3Scale.anon.ToString */](range: Iterable[NumberValue]): ScalePoint_[Domain] = ^.asInstanceOf[js.Dynamic].applyDynamic("scalePoint")(range.asInstanceOf[js.Any]).asInstanceOf[ScalePoint_[Domain]]
    
    @scala.inline
    def scalePow[Range, Output, Unknown](): ScalePower[Range, Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scalePow")().asInstanceOf[ScalePower[Range, Output, Unknown]]
    @scala.inline
    def scalePow[Range, Output, Unknown](domain: Iterable[NumberValue], range: Iterable[Range]): ScalePower[Range, Output, Unknown] = (^.asInstanceOf[js.Dynamic].applyDynamic("scalePow")(domain.asInstanceOf[js.Any], range.asInstanceOf[js.Any])).asInstanceOf[ScalePower[Range, Output, Unknown]]
    @scala.inline
    def scalePow[Range, Output, Unknown](range: Iterable[Range]): ScalePower[Range, Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scalePow")(range.asInstanceOf[js.Any]).asInstanceOf[ScalePower[Range, Output, Unknown]]
    
    @scala.inline
    def scaleQuantile[Range, Unknown](): ScaleQuantile_[Range, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleQuantile")().asInstanceOf[ScaleQuantile_[Range, Unknown]]
    @scala.inline
    def scaleQuantile[Range, Unknown](domain: Iterable[js.UndefOr[NumberValue | Null]], range: Iterable[Range]): ScaleQuantile_[Range, Unknown] = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleQuantile")(domain.asInstanceOf[js.Any], range.asInstanceOf[js.Any])).asInstanceOf[ScaleQuantile_[Range, Unknown]]
    @scala.inline
    def scaleQuantile[Range, Unknown](range: Iterable[Range]): ScaleQuantile_[Range, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleQuantile")(range.asInstanceOf[js.Any]).asInstanceOf[ScaleQuantile_[Range, Unknown]]
    
    @scala.inline
    def scaleQuantize[Range, Unknown](): ScaleQuantize_[Range, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleQuantize")().asInstanceOf[ScaleQuantize_[Range, Unknown]]
    @scala.inline
    def scaleQuantize[Range, Unknown](domain: Iterable[NumberValue], range: Iterable[Range]): ScaleQuantize_[Range, Unknown] = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleQuantize")(domain.asInstanceOf[js.Any], range.asInstanceOf[js.Any])).asInstanceOf[ScaleQuantize_[Range, Unknown]]
    @scala.inline
    def scaleQuantize[Range, Unknown](range: Iterable[Range]): ScaleQuantize_[Range, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleQuantize")(range.asInstanceOf[js.Any]).asInstanceOf[ScaleQuantize_[Range, Unknown]]
    
    @scala.inline
    def scaleRadial[Range, Unknown](): ScaleRadial_[Range, Range, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleRadial")().asInstanceOf[ScaleRadial_[Range, Range, Unknown]]
    @scala.inline
    def scaleRadial[Range, Unknown](domain: Iterable[NumberValue], range: Iterable[Range]): ScaleRadial_[Range, Range, Unknown] = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleRadial")(domain.asInstanceOf[js.Any], range.asInstanceOf[js.Any])).asInstanceOf[ScaleRadial_[Range, Range, Unknown]]
    @scala.inline
    def scaleRadial[Range, Unknown](range: Iterable[Range]): ScaleRadial_[Range, Range, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleRadial")(range.asInstanceOf[js.Any]).asInstanceOf[ScaleRadial_[Range, Range, Unknown]]
    
    @scala.inline
    def scaleSequential[Output, Unknown](): ScaleSequential_[Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleSequential")().asInstanceOf[ScaleSequential_[Output, Unknown]]
    @scala.inline
    def scaleSequential[Output, Unknown](domain: Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleSequential")(domain.asInstanceOf[js.Any], interpolator.asInstanceOf[js.Any])).asInstanceOf[ScaleSequential_[Output, Unknown]]
    @scala.inline
    def scaleSequential[Output, Unknown](domain: Iterable[NumberValue], interpolator: Iterable[Output]): ScaleSequential_[Output, Unknown] = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleSequential")(domain.asInstanceOf[js.Any], interpolator.asInstanceOf[js.Any])).asInstanceOf[ScaleSequential_[Output, Unknown]]
    @scala.inline
    def scaleSequential[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleSequential")(interpolator.asInstanceOf[js.Any]).asInstanceOf[ScaleSequential_[Output, Unknown]]
    @scala.inline
    def scaleSequential[Output, Unknown](interpolator: Iterable[Output]): ScaleSequential_[Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleSequential")(interpolator.asInstanceOf[js.Any]).asInstanceOf[ScaleSequential_[Output, Unknown]]
    
    @scala.inline
    def scaleSequentialLog[Output, Unknown](): ScaleSequential_[Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleSequentialLog")().asInstanceOf[ScaleSequential_[Output, Unknown]]
    @scala.inline
    def scaleSequentialLog[Output, Unknown](domain: Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleSequentialLog")(domain.asInstanceOf[js.Any], interpolator.asInstanceOf[js.Any])).asInstanceOf[ScaleSequential_[Output, Unknown]]
    @scala.inline
    def scaleSequentialLog[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleSequentialLog")(interpolator.asInstanceOf[js.Any]).asInstanceOf[ScaleSequential_[Output, Unknown]]
    
    @scala.inline
    def scaleSequentialPow[Output, Unknown](): ScaleSequential_[Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleSequentialPow")().asInstanceOf[ScaleSequential_[Output, Unknown]]
    @scala.inline
    def scaleSequentialPow[Output, Unknown](domain: Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleSequentialPow")(domain.asInstanceOf[js.Any], interpolator.asInstanceOf[js.Any])).asInstanceOf[ScaleSequential_[Output, Unknown]]
    @scala.inline
    def scaleSequentialPow[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleSequentialPow")(interpolator.asInstanceOf[js.Any]).asInstanceOf[ScaleSequential_[Output, Unknown]]
    
    @scala.inline
    def scaleSequentialQuantile[Output, Unknown](): ScaleSequentialQuantile_[Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleSequentialQuantile")().asInstanceOf[ScaleSequentialQuantile_[Output, Unknown]]
    @scala.inline
    def scaleSequentialQuantile[Output, Unknown](domain: Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleSequentialQuantile_[Output, Unknown] = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleSequentialQuantile")(domain.asInstanceOf[js.Any], interpolator.asInstanceOf[js.Any])).asInstanceOf[ScaleSequentialQuantile_[Output, Unknown]]
    @scala.inline
    def scaleSequentialQuantile[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleSequentialQuantile_[Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleSequentialQuantile")(interpolator.asInstanceOf[js.Any]).asInstanceOf[ScaleSequentialQuantile_[Output, Unknown]]
    
    @scala.inline
    def scaleSequentialSqrt[Output, Unknown](): ScaleSequential_[Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleSequentialSqrt")().asInstanceOf[ScaleSequential_[Output, Unknown]]
    @scala.inline
    def scaleSequentialSqrt[Output, Unknown](domain: Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleSequentialSqrt")(domain.asInstanceOf[js.Any], interpolator.asInstanceOf[js.Any])).asInstanceOf[ScaleSequential_[Output, Unknown]]
    @scala.inline
    def scaleSequentialSqrt[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleSequentialSqrt")(interpolator.asInstanceOf[js.Any]).asInstanceOf[ScaleSequential_[Output, Unknown]]
    
    @scala.inline
    def scaleSequentialSymlog[Output, Unknown](): ScaleSequential_[Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleSequentialSymlog")().asInstanceOf[ScaleSequential_[Output, Unknown]]
    @scala.inline
    def scaleSequentialSymlog[Output, Unknown](domain: Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleSequentialSymlog")(domain.asInstanceOf[js.Any], interpolator.asInstanceOf[js.Any])).asInstanceOf[ScaleSequential_[Output, Unknown]]
    @scala.inline
    def scaleSequentialSymlog[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleSequentialSymlog")(interpolator.asInstanceOf[js.Any]).asInstanceOf[ScaleSequential_[Output, Unknown]]
    
    @scala.inline
    def scaleSqrt[Range, Output, Unknown](): ScalePower[Range, Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleSqrt")().asInstanceOf[ScalePower[Range, Output, Unknown]]
    @scala.inline
    def scaleSqrt[Range, Output, Unknown](domain: Iterable[NumberValue], range: Iterable[Range]): ScalePower[Range, Output, Unknown] = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleSqrt")(domain.asInstanceOf[js.Any], range.asInstanceOf[js.Any])).asInstanceOf[ScalePower[Range, Output, Unknown]]
    @scala.inline
    def scaleSqrt[Range, Output, Unknown](range: Iterable[Range]): ScalePower[Range, Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleSqrt")(range.asInstanceOf[js.Any]).asInstanceOf[ScalePower[Range, Output, Unknown]]
    
    @scala.inline
    def scaleSymlog[Range, Output, Unknown](): ScaleSymLog_[Range, Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleSymlog")().asInstanceOf[ScaleSymLog_[Range, Output, Unknown]]
    @scala.inline
    def scaleSymlog[Range, Output, Unknown](domain: Iterable[NumberValue], range: Iterable[Range]): ScaleSymLog_[Range, Output, Unknown] = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleSymlog")(domain.asInstanceOf[js.Any], range.asInstanceOf[js.Any])).asInstanceOf[ScaleSymLog_[Range, Output, Unknown]]
    @scala.inline
    def scaleSymlog[Range, Output, Unknown](range: Iterable[Range]): ScaleSymLog_[Range, Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleSymlog")(range.asInstanceOf[js.Any]).asInstanceOf[ScaleSymLog_[Range, Output, Unknown]]
    
    @scala.inline
    def scaleThreshold[Domain /* <: Double | String | Date */, Range, Unknown](): ScaleThreshold_[Domain, Range, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleThreshold")().asInstanceOf[ScaleThreshold_[Domain, Range, Unknown]]
    @scala.inline
    def scaleThreshold[Domain /* <: Double | String | Date */, Range, Unknown](domain: Iterable[Domain], range: Iterable[Range]): ScaleThreshold_[Domain, Range, Unknown] = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleThreshold")(domain.asInstanceOf[js.Any], range.asInstanceOf[js.Any])).asInstanceOf[ScaleThreshold_[Domain, Range, Unknown]]
    @scala.inline
    def scaleThreshold[Domain /* <: Double | String | Date */, Range, Unknown](range: Iterable[Range]): ScaleThreshold_[Domain, Range, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleThreshold")(range.asInstanceOf[js.Any]).asInstanceOf[ScaleThreshold_[Domain, Range, Unknown]]
    
    @scala.inline
    def scaleTime[Range, Output, Unknown](): ScaleTime_[Range, Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleTime")().asInstanceOf[ScaleTime_[Range, Output, Unknown]]
    @scala.inline
    def scaleTime[Range, Output, Unknown](domain: Iterable[Date | NumberValue], range: Iterable[Range]): ScaleTime_[Range, Output, Unknown] = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleTime")(domain.asInstanceOf[js.Any], range.asInstanceOf[js.Any])).asInstanceOf[ScaleTime_[Range, Output, Unknown]]
    @scala.inline
    def scaleTime[Range, Output, Unknown](range: Iterable[Range]): ScaleTime_[Range, Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleTime")(range.asInstanceOf[js.Any]).asInstanceOf[ScaleTime_[Range, Output, Unknown]]
    
    @scala.inline
    def scaleUtc[Range, Output, Unknown](): ScaleTime_[Range, Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleUtc")().asInstanceOf[ScaleTime_[Range, Output, Unknown]]
    @scala.inline
    def scaleUtc[Range, Output, Unknown](domain: Iterable[NumberValue], range: Iterable[Range]): ScaleTime_[Range, Output, Unknown] = (^.asInstanceOf[js.Dynamic].applyDynamic("scaleUtc")(domain.asInstanceOf[js.Any], range.asInstanceOf[js.Any])).asInstanceOf[ScaleTime_[Range, Output, Unknown]]
    @scala.inline
    def scaleUtc[Range, Output, Unknown](range: Iterable[Range]): ScaleTime_[Range, Output, Unknown] = ^.asInstanceOf[js.Dynamic].applyDynamic("scaleUtc")(range.asInstanceOf[js.Any]).asInstanceOf[ScaleTime_[Range, Output, Unknown]]
    
    @JSImport("plotly.js/lib/core", "d3.schemeAccent")
    @js.native
    val schemeAccent: js.Array[String] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemeBlues")
    @js.native
    val schemeBlues: js.Array[js.Array[String]] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemeBrBG")
    @js.native
    val schemeBrBG: js.Array[js.Array[String]] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemeBuGn")
    @js.native
    val schemeBuGn: js.Array[js.Array[String]] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemeBuPu")
    @js.native
    val schemeBuPu: js.Array[js.Array[String]] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemeCategory10")
    @js.native
    val schemeCategory10: js.Array[String] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemeDark2")
    @js.native
    val schemeDark2: js.Array[String] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemeGnBu")
    @js.native
    val schemeGnBu: js.Array[js.Array[String]] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemeGreens")
    @js.native
    val schemeGreens: js.Array[js.Array[String]] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemeGreys")
    @js.native
    val schemeGreys: js.Array[js.Array[String]] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemeOrRd")
    @js.native
    val schemeOrRd: js.Array[js.Array[String]] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemeOranges")
    @js.native
    val schemeOranges: js.Array[js.Array[String]] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemePRGn")
    @js.native
    val schemePRGn: js.Array[js.Array[String]] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemePaired")
    @js.native
    val schemePaired: js.Array[String] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemePastel1")
    @js.native
    val schemePastel1: js.Array[String] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemePastel2")
    @js.native
    val schemePastel2: js.Array[String] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemePiYG")
    @js.native
    val schemePiYG: js.Array[js.Array[String]] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemePuBu")
    @js.native
    val schemePuBu: js.Array[js.Array[String]] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemePuBuGn")
    @js.native
    val schemePuBuGn: js.Array[js.Array[String]] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemePuOr")
    @js.native
    val schemePuOr: js.Array[js.Array[String]] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemePuRd")
    @js.native
    val schemePuRd: js.Array[js.Array[String]] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemePurples")
    @js.native
    val schemePurples: js.Array[js.Array[String]] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemeRdBu")
    @js.native
    val schemeRdBu: js.Array[js.Array[String]] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemeRdGy")
    @js.native
    val schemeRdGy: js.Array[js.Array[String]] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemeRdPu")
    @js.native
    val schemeRdPu: js.Array[js.Array[String]] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemeRdYlBu")
    @js.native
    val schemeRdYlBu: js.Array[js.Array[String]] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemeRdYlGn")
    @js.native
    val schemeRdYlGn: js.Array[js.Array[String]] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemeReds")
    @js.native
    val schemeReds: js.Array[js.Array[String]] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemeSet1")
    @js.native
    val schemeSet1: js.Array[String] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemeSet2")
    @js.native
    val schemeSet2: js.Array[String] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemeSet3")
    @js.native
    val schemeSet3: js.Array[String] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemeSpectral")
    @js.native
    val schemeSpectral: js.Array[js.Array[String]] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemeTableau10")
    @js.native
    val schemeTableau10: js.Array[String] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemeYlGn")
    @js.native
    val schemeYlGn: js.Array[js.Array[String]] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemeYlGnBu")
    @js.native
    val schemeYlGnBu: js.Array[js.Array[String]] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemeYlOrBr")
    @js.native
    val schemeYlOrBr: js.Array[js.Array[String]] = js.native
    
    @JSImport("plotly.js/lib/core", "d3.schemeYlOrRd")
    @js.native
    val schemeYlOrRd: js.Array[js.Array[String]] = js.native
    
    @scala.inline
    def select[OldDatum](node: Null): Selection_[Null, OldDatum, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("select")(node.asInstanceOf[js.Any]).asInstanceOf[Selection_[Null, OldDatum, Null, Unit]]
    @scala.inline
    def select[OldDatum](node: EnterElement): Selection_[EnterElement, OldDatum, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("select")(node.asInstanceOf[js.Any]).asInstanceOf[Selection_[EnterElement, OldDatum, Null, Unit]]
    @scala.inline
    def select[OldDatum](node: Document): Selection_[Document, OldDatum, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("select")(node.asInstanceOf[js.Any]).asInstanceOf[Selection_[Document, OldDatum, Null, Unit]]
    @scala.inline
    def select[OldDatum](node: Element): Selection_[Element, OldDatum, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("select")(node.asInstanceOf[js.Any]).asInstanceOf[Selection_[Element, OldDatum, Null, Unit]]
    @scala.inline
    def select[OldDatum](node: Window): Selection_[Window, OldDatum, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("select")(node.asInstanceOf[js.Any]).asInstanceOf[Selection_[Window, OldDatum, Null, Unit]]
    @scala.inline
    def select[GElement /* <: BaseType */, OldDatum](selector: String): Selection_[GElement, OldDatum, HTMLElement, js.Any] = ^.asInstanceOf[js.Dynamic].applyDynamic("select")(selector.asInstanceOf[js.Any]).asInstanceOf[Selection_[GElement, OldDatum, HTMLElement, js.Any]]
    
    @scala.inline
    def selectAll(): Selection_[Null, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("selectAll")().asInstanceOf[Selection_[Null, Unit, Null, Unit]]
    @scala.inline
    def selectAll(selector: Null): Selection_[Null, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("selectAll")(selector.asInstanceOf[js.Any]).asInstanceOf[Selection_[Null, Unit, Null, Unit]]
    @scala.inline
    def selectAll(selector: Unit): Selection_[Null, Unit, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("selectAll")(selector.asInstanceOf[js.Any]).asInstanceOf[Selection_[Null, Unit, Null, Unit]]
    @scala.inline
    def selectAll[GElement /* <: BaseType */, OldDatum](nodes: js.Array[GElement]): Selection_[GElement, OldDatum, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("selectAll")(nodes.asInstanceOf[js.Any]).asInstanceOf[Selection_[GElement, OldDatum, Null, Unit]]
    @scala.inline
    def selectAll[GElement /* <: BaseType */, OldDatum](nodes: typings.d3Selection.mod.ArrayLike[GElement]): Selection_[GElement, OldDatum, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("selectAll")(nodes.asInstanceOf[js.Any]).asInstanceOf[Selection_[GElement, OldDatum, Null, Unit]]
    @scala.inline
    def selectAll[GElement /* <: BaseType */, OldDatum](nodes: Iterable[GElement]): Selection_[GElement, OldDatum, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("selectAll")(nodes.asInstanceOf[js.Any]).asInstanceOf[Selection_[GElement, OldDatum, Null, Unit]]
    @scala.inline
    def selectAll[GElement /* <: BaseType */, OldDatum](selector: String): Selection_[GElement, OldDatum, HTMLElement, js.Any] = ^.asInstanceOf[js.Dynamic].applyDynamic("selectAll")(selector.asInstanceOf[js.Any]).asInstanceOf[Selection_[GElement, OldDatum, HTMLElement, js.Any]]
    
    @scala.inline
    def selection(): Selection_[HTMLElement, js.Any, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("selection")().asInstanceOf[Selection_[HTMLElement, js.Any, Null, Unit]]
    
    @scala.inline
    def selector[DescElement /* <: Element */](selector: String): js.ThisFunction0[/* this */ BaseType, DescElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("selector")(selector.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, DescElement]]
    
    @scala.inline
    def selectorAll[DescElement /* <: Element */](selector: String): js.ThisFunction0[/* this */ BaseType, NodeListOf[DescElement]] = ^.asInstanceOf[js.Dynamic].applyDynamic("selectorAll")(selector.asInstanceOf[js.Any]).asInstanceOf[js.ThisFunction0[/* this */ BaseType, NodeListOf[DescElement]]]
    
    @scala.inline
    def shuffle(array: Float32Array): Float32Array = ^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any]).asInstanceOf[Float32Array]
    @scala.inline
    def shuffle(array: Float32Array, lo: Double): Float32Array = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any])).asInstanceOf[Float32Array]
    @scala.inline
    def shuffle(array: Float32Array, lo: Double, hi: Double): Float32Array = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Float32Array]
    @scala.inline
    def shuffle(array: Float32Array, lo: Unit, hi: Double): Float32Array = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Float32Array]
    @scala.inline
    def shuffle(array: Float64Array): Float64Array = ^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any]).asInstanceOf[Float64Array]
    @scala.inline
    def shuffle(array: Float64Array, lo: Double): Float64Array = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any])).asInstanceOf[Float64Array]
    @scala.inline
    def shuffle(array: Float64Array, lo: Double, hi: Double): Float64Array = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Float64Array]
    @scala.inline
    def shuffle(array: Float64Array, lo: Unit, hi: Double): Float64Array = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Float64Array]
    @scala.inline
    def shuffle(array: Int16Array): Int16Array = ^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any]).asInstanceOf[Int16Array]
    @scala.inline
    def shuffle(array: Int16Array, lo: Double): Int16Array = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any])).asInstanceOf[Int16Array]
    @scala.inline
    def shuffle(array: Int16Array, lo: Double, hi: Double): Int16Array = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Int16Array]
    @scala.inline
    def shuffle(array: Int16Array, lo: Unit, hi: Double): Int16Array = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Int16Array]
    @scala.inline
    def shuffle(array: Int32Array): Int32Array = ^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any]).asInstanceOf[Int32Array]
    @scala.inline
    def shuffle(array: Int32Array, lo: Double): Int32Array = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any])).asInstanceOf[Int32Array]
    @scala.inline
    def shuffle(array: Int32Array, lo: Double, hi: Double): Int32Array = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Int32Array]
    @scala.inline
    def shuffle(array: Int32Array, lo: Unit, hi: Double): Int32Array = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Int32Array]
    @scala.inline
    def shuffle(array: Int8Array): Int8Array = ^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any]).asInstanceOf[Int8Array]
    @scala.inline
    def shuffle(array: Int8Array, lo: Double): Int8Array = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any])).asInstanceOf[Int8Array]
    @scala.inline
    def shuffle(array: Int8Array, lo: Double, hi: Double): Int8Array = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Int8Array]
    @scala.inline
    def shuffle(array: Int8Array, lo: Unit, hi: Double): Int8Array = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Int8Array]
    @scala.inline
    def shuffle(array: Uint16Array): Uint16Array = ^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any]).asInstanceOf[Uint16Array]
    @scala.inline
    def shuffle(array: Uint16Array, lo: Double): Uint16Array = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any])).asInstanceOf[Uint16Array]
    @scala.inline
    def shuffle(array: Uint16Array, lo: Double, hi: Double): Uint16Array = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Uint16Array]
    @scala.inline
    def shuffle(array: Uint16Array, lo: Unit, hi: Double): Uint16Array = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Uint16Array]
    @scala.inline
    def shuffle(array: Uint32Array): Uint32Array = ^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any]).asInstanceOf[Uint32Array]
    @scala.inline
    def shuffle(array: Uint32Array, lo: Double): Uint32Array = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any])).asInstanceOf[Uint32Array]
    @scala.inline
    def shuffle(array: Uint32Array, lo: Double, hi: Double): Uint32Array = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Uint32Array]
    @scala.inline
    def shuffle(array: Uint32Array, lo: Unit, hi: Double): Uint32Array = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Uint32Array]
    @scala.inline
    def shuffle(array: Uint8Array): Uint8Array = ^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any]).asInstanceOf[Uint8Array]
    @scala.inline
    def shuffle(array: Uint8Array, lo: Double): Uint8Array = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any])).asInstanceOf[Uint8Array]
    @scala.inline
    def shuffle(array: Uint8Array, lo: Double, hi: Double): Uint8Array = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Uint8Array]
    @scala.inline
    def shuffle(array: Uint8Array, lo: Unit, hi: Double): Uint8Array = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Uint8Array]
    @scala.inline
    def shuffle(array: Uint8ClampedArray): Uint8ClampedArray = ^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any]).asInstanceOf[Uint8ClampedArray]
    @scala.inline
    def shuffle(array: Uint8ClampedArray, lo: Double): Uint8ClampedArray = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any])).asInstanceOf[Uint8ClampedArray]
    @scala.inline
    def shuffle(array: Uint8ClampedArray, lo: Double, hi: Double): Uint8ClampedArray = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Uint8ClampedArray]
    @scala.inline
    def shuffle(array: Uint8ClampedArray, lo: Unit, hi: Double): Uint8ClampedArray = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[Uint8ClampedArray]
    @scala.inline
    def shuffle[T](array: js.Array[T]): js.Array[T] = ^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any]).asInstanceOf[js.Array[T]]
    @scala.inline
    def shuffle[T](array: js.Array[T], lo: Double): js.Array[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any])).asInstanceOf[js.Array[T]]
    @scala.inline
    def shuffle[T](array: js.Array[T], lo: Double, hi: Double): js.Array[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[js.Array[T]]
    @scala.inline
    def shuffle[T](array: js.Array[T], lo: Unit, hi: Double): js.Array[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("shuffle")(array.asInstanceOf[js.Any], lo.asInstanceOf[js.Any], hi.asInstanceOf[js.Any])).asInstanceOf[js.Array[T]]
    
    @scala.inline
    def shuffler(random: js.Function0[Double]): FnCall = ^.asInstanceOf[js.Dynamic].applyDynamic("shuffler")(random.asInstanceOf[js.Any]).asInstanceOf[FnCall]
    
    @scala.inline
    def some[T](
      iterable: Iterable[T],
      test: js.Function3[/* value */ T, /* index */ Double, /* iterable */ Iterable[T], js.Any]
    ): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("some")(iterable.asInstanceOf[js.Any], test.asInstanceOf[js.Any])).asInstanceOf[Boolean]
    
    @scala.inline
    def sort[T](iterable: Iterable[T]): js.Array[T] = ^.asInstanceOf[js.Dynamic].applyDynamic("sort")(iterable.asInstanceOf[js.Any]).asInstanceOf[js.Array[T]]
    @scala.inline
    def sort[T](iterable: Iterable[T], comparator: js.Function2[/* a */ T, /* b */ T, Double]): js.Array[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("sort")(iterable.asInstanceOf[js.Any], comparator.asInstanceOf[js.Any])).asInstanceOf[js.Array[T]]
    
    @scala.inline
    def stack(): Stack_[js.Any, StringDictionary[Double], String] = ^.asInstanceOf[js.Dynamic].applyDynamic("stack")().asInstanceOf[Stack_[js.Any, StringDictionary[Double], String]]
    
    @scala.inline
    def stackOffsetDiverging(series: Series[js.Any, js.Any], order: Iterable[Double]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stackOffsetDiverging")(series.asInstanceOf[js.Any], order.asInstanceOf[js.Any])).asInstanceOf[Unit]
    
    @scala.inline
    def stackOffsetExpand(series: Series[js.Any, js.Any], order: Iterable[Double]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stackOffsetExpand")(series.asInstanceOf[js.Any], order.asInstanceOf[js.Any])).asInstanceOf[Unit]
    
    @scala.inline
    def stackOffsetNone(series: Series[js.Any, js.Any], order: Iterable[Double]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stackOffsetNone")(series.asInstanceOf[js.Any], order.asInstanceOf[js.Any])).asInstanceOf[Unit]
    
    @scala.inline
    def stackOffsetSilhouette(series: Series[js.Any, js.Any], order: Iterable[Double]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stackOffsetSilhouette")(series.asInstanceOf[js.Any], order.asInstanceOf[js.Any])).asInstanceOf[Unit]
    
    @scala.inline
    def stackOffsetWiggle(series: Series[js.Any, js.Any], order: Iterable[Double]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("stackOffsetWiggle")(series.asInstanceOf[js.Any], order.asInstanceOf[js.Any])).asInstanceOf[Unit]
    
    @scala.inline
    def stackOrderAppearance(series: Series[js.Any, js.Any]): js.Array[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("stackOrderAppearance")(series.asInstanceOf[js.Any]).asInstanceOf[js.Array[Double]]
    
    @scala.inline
    def stackOrderAscending(series: Series[js.Any, js.Any]): js.Array[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("stackOrderAscending")(series.asInstanceOf[js.Any]).asInstanceOf[js.Array[Double]]
    
    @scala.inline
    def stackOrderDescending(series: Series[js.Any, js.Any]): js.Array[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("stackOrderDescending")(series.asInstanceOf[js.Any]).asInstanceOf[js.Array[Double]]
    
    @scala.inline
    def stackOrderInsideOut(series: Series[js.Any, js.Any]): js.Array[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("stackOrderInsideOut")(series.asInstanceOf[js.Any]).asInstanceOf[js.Array[Double]]
    
    @scala.inline
    def stackOrderNone(series: Series[js.Any, js.Any]): js.Array[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("stackOrderNone")(series.asInstanceOf[js.Any]).asInstanceOf[js.Array[Double]]
    
    @scala.inline
    def stackOrderReverse(series: Series[js.Any, js.Any]): js.Array[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("stackOrderReverse")(series.asInstanceOf[js.Any]).asInstanceOf[js.Array[Double]]
    
    @scala.inline
    def stack_Datum[Datum](): Stack_[js.Any, Datum, String] = ^.asInstanceOf[js.Dynamic].applyDynamic("stack")().asInstanceOf[Stack_[js.Any, Datum, String]]
    
    @scala.inline
    def stack_DatumKey[Datum, Key](): Stack_[js.Any, Datum, Key] = ^.asInstanceOf[js.Dynamic].applyDynamic("stack")().asInstanceOf[Stack_[js.Any, Datum, Key]]
    
    @scala.inline
    def stack_ThisDatumKey[This, Datum, Key](): Stack_[This, Datum, Key] = ^.asInstanceOf[js.Dynamic].applyDynamic("stack")().asInstanceOf[Stack_[This, Datum, Key]]
    
    @scala.inline
    def stratify[Datum](): StratifyOperator[Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("stratify")().asInstanceOf[StratifyOperator[Datum]]
    
    @scala.inline
    def style(node: Element, name: String): String = (^.asInstanceOf[js.Dynamic].applyDynamic("style")(node.asInstanceOf[js.Any], name.asInstanceOf[js.Any])).asInstanceOf[String]
    
    @scala.inline
    def subset[T](a: Iterable[T], b: Iterable[T]): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("subset")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[Boolean]
    
    @scala.inline
    def sum[T /* <: Numeric */](iterable: Iterable[js.UndefOr[T | Null]]): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("sum")(iterable.asInstanceOf[js.Any]).asInstanceOf[Double]
    @scala.inline
    def sum[T](
      iterable: Iterable[T],
      accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[Double | Null]]
    ): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("sum")(iterable.asInstanceOf[js.Any], accessor.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    @scala.inline
    def superset[T](a: Iterable[T], b: Iterable[T]): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("superset")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[Boolean]
    
    @scala.inline
    def svg(url: String): js.Promise[Document] = ^.asInstanceOf[js.Dynamic].applyDynamic("svg")(url.asInstanceOf[js.Any]).asInstanceOf[js.Promise[Document]]
    @scala.inline
    def svg(url: String, init: RequestInit): js.Promise[Document] = (^.asInstanceOf[js.Dynamic].applyDynamic("svg")(url.asInstanceOf[js.Any], init.asInstanceOf[js.Any])).asInstanceOf[js.Promise[Document]]
    
    @scala.inline
    def symbol[Datum](): Symbol_[js.Any, Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("symbol")().asInstanceOf[Symbol_[js.Any, Datum]]
    @scala.inline
    def symbol[Datum](`type`: js.ThisFunction2[/* this */ js.Any, /* d */ Datum, /* repeated */ js.Any, SymbolType]): Symbol_[js.Any, Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("symbol")(`type`.asInstanceOf[js.Any]).asInstanceOf[Symbol_[js.Any, Datum]]
    @scala.inline
    def symbol[Datum](
      `type`: js.ThisFunction2[/* this */ js.Any, /* d */ Datum, /* repeated */ js.Any, SymbolType],
      size: js.ThisFunction2[/* this */ js.Any, /* d */ Datum, /* repeated */ js.Any, Double]
    ): Symbol_[js.Any, Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("symbol")(`type`.asInstanceOf[js.Any], size.asInstanceOf[js.Any])).asInstanceOf[Symbol_[js.Any, Datum]]
    @scala.inline
    def symbol[Datum](
      `type`: js.ThisFunction2[/* this */ js.Any, /* d */ Datum, /* repeated */ js.Any, SymbolType],
      size: Double
    ): Symbol_[js.Any, Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("symbol")(`type`.asInstanceOf[js.Any], size.asInstanceOf[js.Any])).asInstanceOf[Symbol_[js.Any, Datum]]
    @scala.inline
    def symbol[Datum](
      `type`: Unit,
      size: js.ThisFunction2[/* this */ js.Any, /* d */ Datum, /* repeated */ js.Any, Double]
    ): Symbol_[js.Any, Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("symbol")(`type`.asInstanceOf[js.Any], size.asInstanceOf[js.Any])).asInstanceOf[Symbol_[js.Any, Datum]]
    @scala.inline
    def symbol[Datum](`type`: Unit, size: Double): Symbol_[js.Any, Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("symbol")(`type`.asInstanceOf[js.Any], size.asInstanceOf[js.Any])).asInstanceOf[Symbol_[js.Any, Datum]]
    @scala.inline
    def symbol[Datum](`type`: SymbolType): Symbol_[js.Any, Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("symbol")(`type`.asInstanceOf[js.Any]).asInstanceOf[Symbol_[js.Any, Datum]]
    @scala.inline
    def symbol[Datum](
      `type`: SymbolType,
      size: js.ThisFunction2[/* this */ js.Any, /* d */ Datum, /* repeated */ js.Any, Double]
    ): Symbol_[js.Any, Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("symbol")(`type`.asInstanceOf[js.Any], size.asInstanceOf[js.Any])).asInstanceOf[Symbol_[js.Any, Datum]]
    @scala.inline
    def symbol[Datum](`type`: SymbolType, size: Double): Symbol_[js.Any, Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("symbol")(`type`.asInstanceOf[js.Any], size.asInstanceOf[js.Any])).asInstanceOf[Symbol_[js.Any, Datum]]
    
    @JSImport("plotly.js/lib/core", "d3.symbolCircle")
    @js.native
    val symbolCircle: SymbolType = js.native
    
    @JSImport("plotly.js/lib/core", "d3.symbolCross")
    @js.native
    val symbolCross: SymbolType = js.native
    
    @JSImport("plotly.js/lib/core", "d3.symbolDiamond")
    @js.native
    val symbolDiamond: SymbolType = js.native
    
    @JSImport("plotly.js/lib/core", "d3.symbolSquare")
    @js.native
    val symbolSquare: SymbolType = js.native
    
    @JSImport("plotly.js/lib/core", "d3.symbolStar")
    @js.native
    val symbolStar: SymbolType = js.native
    
    @JSImport("plotly.js/lib/core", "d3.symbolTriangle")
    @js.native
    val symbolTriangle: SymbolType = js.native
    
    @JSImport("plotly.js/lib/core", "d3.symbolWye")
    @js.native
    val symbolWye: SymbolType = js.native
    
    @scala.inline
    def symbol_ThisDatum[This, Datum](): Symbol_[This, Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("symbol")().asInstanceOf[Symbol_[This, Datum]]
    @scala.inline
    def symbol_ThisDatum[This, Datum](`type`: js.ThisFunction2[/* this */ This, /* d */ Datum, /* repeated */ js.Any, SymbolType]): Symbol_[This, Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("symbol")(`type`.asInstanceOf[js.Any]).asInstanceOf[Symbol_[This, Datum]]
    @scala.inline
    def symbol_ThisDatum[This, Datum](
      `type`: js.ThisFunction2[/* this */ This, /* d */ Datum, /* repeated */ js.Any, SymbolType],
      size: js.ThisFunction2[/* this */ This, /* d */ Datum, /* repeated */ js.Any, Double]
    ): Symbol_[This, Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("symbol")(`type`.asInstanceOf[js.Any], size.asInstanceOf[js.Any])).asInstanceOf[Symbol_[This, Datum]]
    @scala.inline
    def symbol_ThisDatum[This, Datum](
      `type`: js.ThisFunction2[/* this */ This, /* d */ Datum, /* repeated */ js.Any, SymbolType],
      size: Double
    ): Symbol_[This, Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("symbol")(`type`.asInstanceOf[js.Any], size.asInstanceOf[js.Any])).asInstanceOf[Symbol_[This, Datum]]
    @scala.inline
    def symbol_ThisDatum[This, Datum](
      `type`: Unit,
      size: js.ThisFunction2[/* this */ This, /* d */ Datum, /* repeated */ js.Any, Double]
    ): Symbol_[This, Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("symbol")(`type`.asInstanceOf[js.Any], size.asInstanceOf[js.Any])).asInstanceOf[Symbol_[This, Datum]]
    @scala.inline
    def symbol_ThisDatum[This, Datum](`type`: Unit, size: Double): Symbol_[This, Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("symbol")(`type`.asInstanceOf[js.Any], size.asInstanceOf[js.Any])).asInstanceOf[Symbol_[This, Datum]]
    @scala.inline
    def symbol_ThisDatum[This, Datum](`type`: SymbolType): Symbol_[This, Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("symbol")(`type`.asInstanceOf[js.Any]).asInstanceOf[Symbol_[This, Datum]]
    @scala.inline
    def symbol_ThisDatum[This, Datum](
      `type`: SymbolType,
      size: js.ThisFunction2[/* this */ This, /* d */ Datum, /* repeated */ js.Any, Double]
    ): Symbol_[This, Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("symbol")(`type`.asInstanceOf[js.Any], size.asInstanceOf[js.Any])).asInstanceOf[Symbol_[This, Datum]]
    @scala.inline
    def symbol_ThisDatum[This, Datum](`type`: SymbolType, size: Double): Symbol_[This, Datum] = (^.asInstanceOf[js.Dynamic].applyDynamic("symbol")(`type`.asInstanceOf[js.Any], size.asInstanceOf[js.Any])).asInstanceOf[Symbol_[This, Datum]]
    
    @JSImport("plotly.js/lib/core", "d3.symbols")
    @js.native
    val symbols: js.Array[SymbolType] = js.native
    
    @scala.inline
    def text(url: String): js.Promise[String] = ^.asInstanceOf[js.Dynamic].applyDynamic("text")(url.asInstanceOf[js.Any]).asInstanceOf[js.Promise[String]]
    @scala.inline
    def text(url: String, init: RequestInit): js.Promise[String] = (^.asInstanceOf[js.Dynamic].applyDynamic("text")(url.asInstanceOf[js.Any], init.asInstanceOf[js.Any])).asInstanceOf[js.Promise[String]]
    
    @scala.inline
    def thresholdFreedmanDiaconis(values: ArrayLike[js.UndefOr[Double]], min: Double, max: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("thresholdFreedmanDiaconis")(values.asInstanceOf[js.Any], min.asInstanceOf[js.Any], max.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    @scala.inline
    def thresholdScott(values: ArrayLike[js.UndefOr[Double]], min: Double, max: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("thresholdScott")(values.asInstanceOf[js.Any], min.asInstanceOf[js.Any], max.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    @scala.inline
    def thresholdSturges(values: ArrayLike[js.UndefOr[Double]]): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("thresholdSturges")(values.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    @scala.inline
    def tickFormat(start: Double, stop: Double, count: Double): js.Function1[/* d */ NumberValue, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("tickFormat")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], count.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* d */ NumberValue, String]]
    @scala.inline
    def tickFormat(start: Double, stop: Double, count: Double, specifier: String): js.Function1[/* d */ NumberValue, String] = (^.asInstanceOf[js.Dynamic].applyDynamic("tickFormat")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], count.asInstanceOf[js.Any], specifier.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* d */ NumberValue, String]]
    
    @scala.inline
    def tickIncrement(start: Double, stop: Double, count: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("tickIncrement")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], count.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    @scala.inline
    def tickStep(start: Double, stop: Double, count: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("tickStep")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], count.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    @scala.inline
    def ticks(start: Double, stop: Double, count: Double): js.Array[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("ticks")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], count.asInstanceOf[js.Any])).asInstanceOf[js.Array[Double]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def timeDay(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeDay")().asInstanceOf[Date]
    @scala.inline
    def timeDay(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeDay")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.timeDay")
    @js.native
    val timeDay_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def timeDays(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeDays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def timeDays(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeDays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    @scala.inline
    def timeFormat(specifier: String): js.Function1[/* date */ Date, String] = ^.asInstanceOf[js.Dynamic].applyDynamic("timeFormat")(specifier.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* date */ Date, String]]
    
    @scala.inline
    def timeFormatDefaultLocale(definition: TimeLocaleDefinition): TimeLocaleObject = ^.asInstanceOf[js.Dynamic].applyDynamic("timeFormatDefaultLocale")(definition.asInstanceOf[js.Any]).asInstanceOf[TimeLocaleObject]
    
    @scala.inline
    def timeFormatLocale(definition: TimeLocaleDefinition): TimeLocaleObject = ^.asInstanceOf[js.Dynamic].applyDynamic("timeFormatLocale")(definition.asInstanceOf[js.Any]).asInstanceOf[TimeLocaleObject]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def timeFriday(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeFriday")().asInstanceOf[Date]
    @scala.inline
    def timeFriday(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeFriday")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.timeFriday")
    @js.native
    val timeFriday_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def timeFridays(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeFridays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def timeFridays(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeFridays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def timeHour(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeHour")().asInstanceOf[Date]
    @scala.inline
    def timeHour(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeHour")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.timeHour")
    @js.native
    val timeHour_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def timeHours(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeHours")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def timeHours(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeHours")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    @scala.inline
    def timeInterval(
      floor: js.Function1[/* date */ Date, Unit],
      offset: js.Function2[/* date */ Date, /* step */ Double, Unit]
    ): TimeInterval_ = (^.asInstanceOf[js.Dynamic].applyDynamic("timeInterval")(floor.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[TimeInterval_]
    @scala.inline
    def timeInterval(
      floor: js.Function1[/* date */ Date, Unit],
      offset: js.Function2[/* date */ Date, /* step */ Double, Unit],
      count: js.Function2[/* start */ Date, /* end */ Date, Double]
    ): CountableTimeInterval = (^.asInstanceOf[js.Dynamic].applyDynamic("timeInterval")(floor.asInstanceOf[js.Any], offset.asInstanceOf[js.Any], count.asInstanceOf[js.Any])).asInstanceOf[CountableTimeInterval]
    @scala.inline
    def timeInterval(
      floor: js.Function1[/* date */ Date, Unit],
      offset: js.Function2[/* date */ Date, /* step */ Double, Unit],
      count: js.Function2[/* start */ Date, /* end */ Date, Double],
      field: js.Function1[/* date */ Date, Double]
    ): CountableTimeInterval = (^.asInstanceOf[js.Dynamic].applyDynamic("timeInterval")(floor.asInstanceOf[js.Any], offset.asInstanceOf[js.Any], count.asInstanceOf[js.Any], field.asInstanceOf[js.Any])).asInstanceOf[CountableTimeInterval]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def timeMillisecond(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeMillisecond")().asInstanceOf[Date]
    @scala.inline
    def timeMillisecond(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeMillisecond")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.timeMillisecond")
    @js.native
    val timeMillisecond_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def timeMilliseconds(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeMilliseconds")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def timeMilliseconds(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeMilliseconds")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def timeMinute(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeMinute")().asInstanceOf[Date]
    @scala.inline
    def timeMinute(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeMinute")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.timeMinute")
    @js.native
    val timeMinute_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def timeMinutes(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeMinutes")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def timeMinutes(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeMinutes")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def timeMonday(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeMonday")().asInstanceOf[Date]
    @scala.inline
    def timeMonday(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeMonday")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.timeMonday")
    @js.native
    val timeMonday_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def timeMondays(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeMondays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def timeMondays(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeMondays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def timeMonth(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeMonth")().asInstanceOf[Date]
    @scala.inline
    def timeMonth(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeMonth")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.timeMonth")
    @js.native
    val timeMonth_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def timeMonths(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeMonths")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def timeMonths(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeMonths")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    @scala.inline
    def timeParse(specifier: String): js.Function1[/* dateString */ String, Date | Null] = ^.asInstanceOf[js.Dynamic].applyDynamic("timeParse")(specifier.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* dateString */ String, Date | Null]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def timeSaturday(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeSaturday")().asInstanceOf[Date]
    @scala.inline
    def timeSaturday(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeSaturday")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.timeSaturday")
    @js.native
    val timeSaturday_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def timeSaturdays(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeSaturdays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def timeSaturdays(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeSaturdays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def timeSecond(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeSecond")().asInstanceOf[Date]
    @scala.inline
    def timeSecond(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeSecond")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.timeSecond")
    @js.native
    val timeSecond_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def timeSeconds(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeSeconds")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def timeSeconds(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeSeconds")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def timeSunday(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeSunday")().asInstanceOf[Date]
    @scala.inline
    def timeSunday(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeSunday")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.timeSunday")
    @js.native
    val timeSunday_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def timeSundays(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeSundays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def timeSundays(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeSundays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def timeThursday(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeThursday")().asInstanceOf[Date]
    @scala.inline
    def timeThursday(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeThursday")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.timeThursday")
    @js.native
    val timeThursday_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def timeThursdays(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeThursdays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def timeThursdays(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeThursdays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def timeTuesday(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeTuesday")().asInstanceOf[Date]
    @scala.inline
    def timeTuesday(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeTuesday")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.timeTuesday")
    @js.native
    val timeTuesday_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def timeTuesdays(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeTuesdays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def timeTuesdays(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeTuesdays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def timeWednesday(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeWednesday")().asInstanceOf[Date]
    @scala.inline
    def timeWednesday(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeWednesday")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.timeWednesday")
    @js.native
    val timeWednesday_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def timeWednesdays(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeWednesdays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def timeWednesdays(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeWednesdays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def timeWeek(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeWeek")().asInstanceOf[Date]
    @scala.inline
    def timeWeek(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeWeek")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.timeWeek")
    @js.native
    val timeWeek_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def timeWeeks(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeWeeks")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def timeWeeks(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeWeeks")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def timeYear(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeYear")().asInstanceOf[Date]
    @scala.inline
    def timeYear(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("timeYear")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.timeYear")
    @js.native
    val timeYear_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def timeYears(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeYears")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def timeYears(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("timeYears")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    @scala.inline
    def timeout(callback: js.Function1[/* elapsed */ Double, Unit]): Timer_ = ^.asInstanceOf[js.Dynamic].applyDynamic("timeout")(callback.asInstanceOf[js.Any]).asInstanceOf[Timer_]
    @scala.inline
    def timeout(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double): Timer_ = (^.asInstanceOf[js.Dynamic].applyDynamic("timeout")(callback.asInstanceOf[js.Any], delay.asInstanceOf[js.Any])).asInstanceOf[Timer_]
    @scala.inline
    def timeout(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double, time: Double): Timer_ = (^.asInstanceOf[js.Dynamic].applyDynamic("timeout")(callback.asInstanceOf[js.Any], delay.asInstanceOf[js.Any], time.asInstanceOf[js.Any])).asInstanceOf[Timer_]
    @scala.inline
    def timeout(callback: js.Function1[/* elapsed */ Double, Unit], delay: Unit, time: Double): Timer_ = (^.asInstanceOf[js.Dynamic].applyDynamic("timeout")(callback.asInstanceOf[js.Any], delay.asInstanceOf[js.Any], time.asInstanceOf[js.Any])).asInstanceOf[Timer_]
    
    @scala.inline
    def timer(callback: js.Function1[/* elapsed */ Double, Unit]): Timer_ = ^.asInstanceOf[js.Dynamic].applyDynamic("timer")(callback.asInstanceOf[js.Any]).asInstanceOf[Timer_]
    @scala.inline
    def timer(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double): Timer_ = (^.asInstanceOf[js.Dynamic].applyDynamic("timer")(callback.asInstanceOf[js.Any], delay.asInstanceOf[js.Any])).asInstanceOf[Timer_]
    @scala.inline
    def timer(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double, time: Double): Timer_ = (^.asInstanceOf[js.Dynamic].applyDynamic("timer")(callback.asInstanceOf[js.Any], delay.asInstanceOf[js.Any], time.asInstanceOf[js.Any])).asInstanceOf[Timer_]
    @scala.inline
    def timer(callback: js.Function1[/* elapsed */ Double, Unit], delay: Unit, time: Double): Timer_ = (^.asInstanceOf[js.Dynamic].applyDynamic("timer")(callback.asInstanceOf[js.Any], delay.asInstanceOf[js.Any], time.asInstanceOf[js.Any])).asInstanceOf[Timer_]
    
    @scala.inline
    def timerFlush(): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("timerFlush")().asInstanceOf[Unit]
    
    @scala.inline
    def transition[OldDatum](): Transition_[HTMLElement, OldDatum, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("transition")().asInstanceOf[Transition_[HTMLElement, OldDatum, Null, Unit]]
    @scala.inline
    def transition[OldDatum](name: String): Transition_[HTMLElement, OldDatum, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("transition")(name.asInstanceOf[js.Any]).asInstanceOf[Transition_[HTMLElement, OldDatum, Null, Unit]]
    @scala.inline
    def transition[OldDatum](transition: Transition_[BaseType, js.Any, BaseType, js.Any]): Transition_[HTMLElement, OldDatum, Null, Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("transition")(transition.asInstanceOf[js.Any]).asInstanceOf[Transition_[HTMLElement, OldDatum, Null, Unit]]
    
    @scala.inline
    def transpose[T](matrix: ArrayLike[ArrayLike[T]]): js.Array[js.Array[T]] = ^.asInstanceOf[js.Dynamic].applyDynamic("transpose")(matrix.asInstanceOf[js.Any]).asInstanceOf[js.Array[js.Array[T]]]
    
    @scala.inline
    def tree[Datum](): TreeLayout[Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("tree")().asInstanceOf[TreeLayout[Datum]]
    
    @scala.inline
    def treemap[Datum](): TreemapLayout[Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("treemap")().asInstanceOf[TreemapLayout[Datum]]
    
    @scala.inline
    def treemapBinary(node: HierarchyRectangularNode[js.Any], x0: Double, y0: Double, x1: Double, y1: Double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("treemapBinary")(node.asInstanceOf[js.Any], x0.asInstanceOf[js.Any], y0.asInstanceOf[js.Any], x1.asInstanceOf[js.Any], y1.asInstanceOf[js.Any])).asInstanceOf[Unit]
    
    @scala.inline
    def treemapDice(node: HierarchyRectangularNode[js.Any], x0: Double, y0: Double, x1: Double, y1: Double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("treemapDice")(node.asInstanceOf[js.Any], x0.asInstanceOf[js.Any], y0.asInstanceOf[js.Any], x1.asInstanceOf[js.Any], y1.asInstanceOf[js.Any])).asInstanceOf[Unit]
    
    @JSImport("plotly.js/lib/core", "d3.treemapResquarify")
    @js.native
    val treemapResquarify: RatioSquarifyTilingFactory = js.native
    @scala.inline
    def treemapResquarify(node: HierarchyRectangularNode[js.Any], x0: Double, y0: Double, x1: Double, y1: Double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("treemapResquarify")(node.asInstanceOf[js.Any], x0.asInstanceOf[js.Any], y0.asInstanceOf[js.Any], x1.asInstanceOf[js.Any], y1.asInstanceOf[js.Any])).asInstanceOf[Unit]
    
    @scala.inline
    def treemapSlice(node: HierarchyRectangularNode[js.Any], x0: Double, y0: Double, x1: Double, y1: Double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("treemapSlice")(node.asInstanceOf[js.Any], x0.asInstanceOf[js.Any], y0.asInstanceOf[js.Any], x1.asInstanceOf[js.Any], y1.asInstanceOf[js.Any])).asInstanceOf[Unit]
    
    @scala.inline
    def treemapSliceDice(node: HierarchyRectangularNode[js.Any], x0: Double, y0: Double, x1: Double, y1: Double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("treemapSliceDice")(node.asInstanceOf[js.Any], x0.asInstanceOf[js.Any], y0.asInstanceOf[js.Any], x1.asInstanceOf[js.Any], y1.asInstanceOf[js.Any])).asInstanceOf[Unit]
    
    @JSImport("plotly.js/lib/core", "d3.treemapSquarify")
    @js.native
    val treemapSquarify: RatioSquarifyTilingFactory = js.native
    @scala.inline
    def treemapSquarify(node: HierarchyRectangularNode[js.Any], x0: Double, y0: Double, x1: Double, y1: Double): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("treemapSquarify")(node.asInstanceOf[js.Any], x0.asInstanceOf[js.Any], y0.asInstanceOf[js.Any], x1.asInstanceOf[js.Any], y1.asInstanceOf[js.Any])).asInstanceOf[Unit]
    
    @scala.inline
    def tsv[Columns /* <: String */](url: String): js.Promise[DSVRowArray[Columns]] = ^.asInstanceOf[js.Dynamic].applyDynamic("tsv")(url.asInstanceOf[js.Any]).asInstanceOf[js.Promise[DSVRowArray[Columns]]]
    @scala.inline
    def tsv[Columns /* <: String */](url: String, init: RequestInit): js.Promise[DSVRowArray[Columns]] = (^.asInstanceOf[js.Dynamic].applyDynamic("tsv")(url.asInstanceOf[js.Any], init.asInstanceOf[js.Any])).asInstanceOf[js.Promise[DSVRowArray[Columns]]]
    @scala.inline
    def tsv[ParsedRow /* <: js.Object */, Columns /* <: String */](
      url: String,
      init: RequestInit,
      row: js.Function3[
          /* rawRow */ DSVRowString[Columns], 
          /* index */ Double, 
          /* columns */ js.Array[Columns], 
          js.UndefOr[ParsedRow | Null]
        ]
    ): js.Promise[DSVParsedArray[ParsedRow]] = (^.asInstanceOf[js.Dynamic].applyDynamic("tsv")(url.asInstanceOf[js.Any], init.asInstanceOf[js.Any], row.asInstanceOf[js.Any])).asInstanceOf[js.Promise[DSVParsedArray[ParsedRow]]]
    @scala.inline
    def tsv[ParsedRow /* <: js.Object */, Columns /* <: String */](
      url: String,
      row: js.Function3[
          /* rawRow */ DSVRowString[Columns], 
          /* index */ Double, 
          /* columns */ js.Array[Columns], 
          js.UndefOr[ParsedRow | Null]
        ]
    ): js.Promise[DSVParsedArray[ParsedRow]] = (^.asInstanceOf[js.Dynamic].applyDynamic("tsv")(url.asInstanceOf[js.Any], row.asInstanceOf[js.Any])).asInstanceOf[js.Promise[DSVParsedArray[ParsedRow]]]
    
    @scala.inline
    def tsvFormat[T /* <: js.Object */](rows: js.Array[T]): String = ^.asInstanceOf[js.Dynamic].applyDynamic("tsvFormat")(rows.asInstanceOf[js.Any]).asInstanceOf[String]
    @scala.inline
    def tsvFormat[T /* <: js.Object */](rows: js.Array[T], columns: js.Array[/* keyof T */ String]): String = (^.asInstanceOf[js.Dynamic].applyDynamic("tsvFormat")(rows.asInstanceOf[js.Any], columns.asInstanceOf[js.Any])).asInstanceOf[String]
    
    @scala.inline
    def tsvFormatBody[T /* <: js.Object */](rows: js.Array[T]): String = ^.asInstanceOf[js.Dynamic].applyDynamic("tsvFormatBody")(rows.asInstanceOf[js.Any]).asInstanceOf[String]
    @scala.inline
    def tsvFormatBody[T /* <: js.Object */](rows: js.Array[T], columns: js.Array[/* keyof T */ String]): String = (^.asInstanceOf[js.Dynamic].applyDynamic("tsvFormatBody")(rows.asInstanceOf[js.Any], columns.asInstanceOf[js.Any])).asInstanceOf[String]
    
    @scala.inline
    def tsvFormatRow(row: js.Array[String]): String = ^.asInstanceOf[js.Dynamic].applyDynamic("tsvFormatRow")(row.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def tsvFormatRows(rows: js.Array[js.Array[String]]): String = ^.asInstanceOf[js.Dynamic].applyDynamic("tsvFormatRows")(rows.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def tsvFormatValue(value: String): String = ^.asInstanceOf[js.Dynamic].applyDynamic("tsvFormatValue")(value.asInstanceOf[js.Any]).asInstanceOf[String]
    
    @scala.inline
    def tsvParse[Columns /* <: String */](tsvString: String): DSVRowArray[Columns] = ^.asInstanceOf[js.Dynamic].applyDynamic("tsvParse")(tsvString.asInstanceOf[js.Any]).asInstanceOf[DSVRowArray[Columns]]
    @scala.inline
    def tsvParse[ParsedRow /* <: js.Object */, Columns /* <: String */](
      tsvString: String,
      row: js.Function3[
          /* rawRow */ DSVRowString[Columns], 
          /* index */ Double, 
          /* columns */ js.Array[Columns], 
          js.UndefOr[ParsedRow | Null]
        ]
    ): DSVParsedArray[ParsedRow] = (^.asInstanceOf[js.Dynamic].applyDynamic("tsvParse")(tsvString.asInstanceOf[js.Any], row.asInstanceOf[js.Any])).asInstanceOf[DSVParsedArray[ParsedRow]]
    
    @scala.inline
    def tsvParseRows(tsvString: String): js.Array[js.Array[String]] = ^.asInstanceOf[js.Dynamic].applyDynamic("tsvParseRows")(tsvString.asInstanceOf[js.Any]).asInstanceOf[js.Array[js.Array[String]]]
    @scala.inline
    def tsvParseRows[ParsedRow /* <: js.Object */](
      tsvString: String,
      row: js.Function2[/* rawRow */ js.Array[String], /* index */ Double, js.UndefOr[ParsedRow | Null]]
    ): js.Array[ParsedRow] = (^.asInstanceOf[js.Dynamic].applyDynamic("tsvParseRows")(tsvString.asInstanceOf[js.Any], row.asInstanceOf[js.Any])).asInstanceOf[js.Array[ParsedRow]]
    
    @scala.inline
    def union[T](iterables: Iterable[T]*): Set[T] = ^.asInstanceOf[js.Dynamic].applyDynamic("union")(iterables.asInstanceOf[js.Any]).asInstanceOf[Set[T]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def utcDay(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcDay")().asInstanceOf[Date]
    @scala.inline
    def utcDay(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcDay")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.utcDay")
    @js.native
    val utcDay_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def utcDays(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcDays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def utcDays(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcDays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    @scala.inline
    def utcFormat(specifier: String): js.Function1[/* date */ Date, String] = ^.asInstanceOf[js.Dynamic].applyDynamic("utcFormat")(specifier.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* date */ Date, String]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def utcFriday(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcFriday")().asInstanceOf[Date]
    @scala.inline
    def utcFriday(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcFriday")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.utcFriday")
    @js.native
    val utcFriday_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def utcFridays(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcFridays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def utcFridays(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcFridays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def utcHour(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcHour")().asInstanceOf[Date]
    @scala.inline
    def utcHour(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcHour")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.utcHour")
    @js.native
    val utcHour_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def utcHours(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcHours")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def utcHours(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcHours")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def utcMillisecond(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcMillisecond")().asInstanceOf[Date]
    @scala.inline
    def utcMillisecond(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcMillisecond")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.utcMillisecond")
    @js.native
    val utcMillisecond_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def utcMilliseconds(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcMilliseconds")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def utcMilliseconds(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcMilliseconds")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def utcMinute(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcMinute")().asInstanceOf[Date]
    @scala.inline
    def utcMinute(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcMinute")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.utcMinute")
    @js.native
    val utcMinute_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def utcMinutes(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcMinutes")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def utcMinutes(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcMinutes")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def utcMonday(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcMonday")().asInstanceOf[Date]
    @scala.inline
    def utcMonday(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcMonday")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.utcMonday")
    @js.native
    val utcMonday_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def utcMondays(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcMondays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def utcMondays(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcMondays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def utcMonth(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcMonth")().asInstanceOf[Date]
    @scala.inline
    def utcMonth(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcMonth")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.utcMonth")
    @js.native
    val utcMonth_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def utcMonths(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcMonths")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def utcMonths(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcMonths")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    @scala.inline
    def utcParse(specifier: String): js.Function1[/* dateString */ String, Date | Null] = ^.asInstanceOf[js.Dynamic].applyDynamic("utcParse")(specifier.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* dateString */ String, Date | Null]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def utcSaturday(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcSaturday")().asInstanceOf[Date]
    @scala.inline
    def utcSaturday(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcSaturday")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.utcSaturday")
    @js.native
    val utcSaturday_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def utcSaturdays(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcSaturdays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def utcSaturdays(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcSaturdays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def utcSecond(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcSecond")().asInstanceOf[Date]
    @scala.inline
    def utcSecond(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcSecond")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.utcSecond")
    @js.native
    val utcSecond_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def utcSeconds(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcSeconds")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def utcSeconds(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcSeconds")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def utcSunday(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcSunday")().asInstanceOf[Date]
    @scala.inline
    def utcSunday(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcSunday")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.utcSunday")
    @js.native
    val utcSunday_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def utcSundays(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcSundays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def utcSundays(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcSundays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def utcThursday(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcThursday")().asInstanceOf[Date]
    @scala.inline
    def utcThursday(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcThursday")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.utcThursday")
    @js.native
    val utcThursday_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def utcThursdays(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcThursdays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def utcThursdays(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcThursdays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def utcTuesday(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcTuesday")().asInstanceOf[Date]
    @scala.inline
    def utcTuesday(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcTuesday")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.utcTuesday")
    @js.native
    val utcTuesday_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def utcTuesdays(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcTuesdays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def utcTuesdays(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcTuesdays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def utcWednesday(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcWednesday")().asInstanceOf[Date]
    @scala.inline
    def utcWednesday(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcWednesday")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.utcWednesday")
    @js.native
    val utcWednesday_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def utcWednesdays(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcWednesdays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def utcWednesdays(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcWednesdays")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def utcWeek(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcWeek")().asInstanceOf[Date]
    @scala.inline
    def utcWeek(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcWeek")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.utcWeek")
    @js.native
    val utcWeek_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def utcWeeks(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcWeeks")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def utcWeeks(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcWeeks")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
      * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    @scala.inline
    def utcYear(): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcYear")().asInstanceOf[Date]
    @scala.inline
    def utcYear(date: Date): Date = ^.asInstanceOf[js.Dynamic].applyDynamic("utcYear")(date.asInstanceOf[js.Any]).asInstanceOf[Date]
    @JSImport("plotly.js/lib/core", "d3.utcYear")
    @js.native
    val utcYear_Fd3: CountableTimeInterval = js.native
    
    @scala.inline
    def utcYears(start: Date, stop: Date): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcYears")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    @scala.inline
    def utcYears(start: Date, stop: Date, step: Double): js.Array[Date] = (^.asInstanceOf[js.Dynamic].applyDynamic("utcYears")(start.asInstanceOf[js.Any], stop.asInstanceOf[js.Any], step.asInstanceOf[js.Any])).asInstanceOf[js.Array[Date]]
    
    @scala.inline
    def variance[T /* <: Numeric */](iterable: Iterable[js.UndefOr[T | Null]]): js.UndefOr[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("variance")(iterable.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[Double]]
    @scala.inline
    def variance[T](
      iterable: Iterable[T],
      accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[Double | Null]]
    ): js.UndefOr[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("variance")(iterable.asInstanceOf[js.Any], accessor.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[Double]]
    
    @JSImport("plotly.js/lib/core", "d3.version")
    @js.native
    val version: String = js.native
    
    @scala.inline
    def window(DOMNode: Document): Window = ^.asInstanceOf[js.Dynamic].applyDynamic("window")(DOMNode.asInstanceOf[js.Any]).asInstanceOf[Window]
    @scala.inline
    def window(DOMNode: Element): Window = ^.asInstanceOf[js.Dynamic].applyDynamic("window")(DOMNode.asInstanceOf[js.Any]).asInstanceOf[Window]
    @scala.inline
    def window(DOMNode: Window): Window = ^.asInstanceOf[js.Dynamic].applyDynamic("window")(DOMNode.asInstanceOf[js.Any]).asInstanceOf[Window]
    
    @scala.inline
    def xml(url: String): js.Promise[XMLDocument] = ^.asInstanceOf[js.Dynamic].applyDynamic("xml")(url.asInstanceOf[js.Any]).asInstanceOf[js.Promise[XMLDocument]]
    @scala.inline
    def xml(url: String, init: RequestInit): js.Promise[XMLDocument] = (^.asInstanceOf[js.Dynamic].applyDynamic("xml")(url.asInstanceOf[js.Any], init.asInstanceOf[js.Any])).asInstanceOf[js.Promise[XMLDocument]]
    
    @scala.inline
    def zip[T](arrays: ArrayLike[T]*): js.Array[js.Array[T]] = ^.asInstanceOf[js.Dynamic].applyDynamic("zip")(arrays.asInstanceOf[js.Any]).asInstanceOf[js.Array[js.Array[T]]]
    
    @scala.inline
    def zoom[ZoomRefElement /* <: ZoomedElementBaseType */, Datum](): ZoomBehavior[ZoomRefElement, Datum] = ^.asInstanceOf[js.Dynamic].applyDynamic("zoom")().asInstanceOf[ZoomBehavior[ZoomRefElement, Datum]]
    
    @JSImport("plotly.js/lib/core", "d3.zoomIdentity")
    @js.native
    val zoomIdentity: ZoomTransform_ = js.native
    
    @scala.inline
    def zoomTransform(node: ZoomedElementBaseType): ZoomTransform_ = ^.asInstanceOf[js.Dynamic].applyDynamic("zoomTransform")(node.asInstanceOf[js.Any]).asInstanceOf[ZoomTransform_]
  }
  
  @scala.inline
  def deleteFrames(root: Root, frames: js.Array[Double]): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("deleteFrames")(root.asInstanceOf[js.Any], frames.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  
  @scala.inline
  def deleteTraces(root: Root, indices: js.Array[Double]): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("deleteTraces")(root.asInstanceOf[js.Any], indices.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def deleteTraces(root: Root, indices: Double): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("deleteTraces")(root.asInstanceOf[js.Any], indices.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  
  @scala.inline
  def downloadImage(root: Root, opts: DownloadImgopts): js.Promise[String] = (^.asInstanceOf[js.Dynamic].applyDynamic("downloadImage")(root.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[js.Promise[String]]
  
  @scala.inline
  def extendTraces(root: Root, update: js.Array[Data], indices: js.Array[Double]): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("extendTraces")(root.asInstanceOf[js.Any], update.asInstanceOf[js.Any], indices.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def extendTraces(root: Root, update: js.Array[Data], indices: js.Array[Double], maxPoints: Double): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("extendTraces")(root.asInstanceOf[js.Any], update.asInstanceOf[js.Any], indices.asInstanceOf[js.Any], maxPoints.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def extendTraces(root: Root, update: js.Array[Data], indices: Double): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("extendTraces")(root.asInstanceOf[js.Any], update.asInstanceOf[js.Any], indices.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def extendTraces(root: Root, update: js.Array[Data], indices: Double, maxPoints: Double): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("extendTraces")(root.asInstanceOf[js.Any], update.asInstanceOf[js.Any], indices.asInstanceOf[js.Any], maxPoints.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def extendTraces(root: Root, update: Data, indices: js.Array[Double]): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("extendTraces")(root.asInstanceOf[js.Any], update.asInstanceOf[js.Any], indices.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def extendTraces(root: Root, update: Data, indices: js.Array[Double], maxPoints: Double): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("extendTraces")(root.asInstanceOf[js.Any], update.asInstanceOf[js.Any], indices.asInstanceOf[js.Any], maxPoints.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def extendTraces(root: Root, update: Data, indices: Double): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("extendTraces")(root.asInstanceOf[js.Any], update.asInstanceOf[js.Any], indices.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def extendTraces(root: Root, update: Data, indices: Double, maxPoints: Double): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("extendTraces")(root.asInstanceOf[js.Any], update.asInstanceOf[js.Any], indices.asInstanceOf[js.Any], maxPoints.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  
  @scala.inline
  def moveTraces(root: Root, currentIndices: js.Array[Double]): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("moveTraces")(root.asInstanceOf[js.Any], currentIndices.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def moveTraces(root: Root, currentIndices: js.Array[Double], newIndices: js.Array[Double]): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("moveTraces")(root.asInstanceOf[js.Any], currentIndices.asInstanceOf[js.Any], newIndices.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def moveTraces(root: Root, currentIndices: js.Array[Double], newIndices: Double): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("moveTraces")(root.asInstanceOf[js.Any], currentIndices.asInstanceOf[js.Any], newIndices.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def moveTraces(root: Root, currentIndices: Double): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("moveTraces")(root.asInstanceOf[js.Any], currentIndices.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def moveTraces(root: Root, currentIndices: Double, newIndices: js.Array[Double]): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("moveTraces")(root.asInstanceOf[js.Any], currentIndices.asInstanceOf[js.Any], newIndices.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def moveTraces(root: Root, currentIndices: Double, newIndices: Double): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("moveTraces")(root.asInstanceOf[js.Any], currentIndices.asInstanceOf[js.Any], newIndices.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  
  @scala.inline
  def newPlot(root: Root, data: js.Array[Data]): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("newPlot")(root.asInstanceOf[js.Any], data.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def newPlot(root: Root, data: js.Array[Data], layout: Unit, config: PartialConfig): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("newPlot")(root.asInstanceOf[js.Any], data.asInstanceOf[js.Any], layout.asInstanceOf[js.Any], config.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def newPlot(root: Root, data: js.Array[Data], layout: PartialLayout): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("newPlot")(root.asInstanceOf[js.Any], data.asInstanceOf[js.Any], layout.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def newPlot(root: Root, data: js.Array[Data], layout: PartialLayout, config: PartialConfig): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("newPlot")(root.asInstanceOf[js.Any], data.asInstanceOf[js.Any], layout.asInstanceOf[js.Any], config.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  
  @scala.inline
  def plot(root: Root, data: js.Array[Data]): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("plot")(root.asInstanceOf[js.Any], data.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def plot(root: Root, data: js.Array[Data], layout: Unit, config: PartialConfig): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("plot")(root.asInstanceOf[js.Any], data.asInstanceOf[js.Any], layout.asInstanceOf[js.Any], config.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def plot(root: Root, data: js.Array[Data], layout: PartialLayout): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("plot")(root.asInstanceOf[js.Any], data.asInstanceOf[js.Any], layout.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def plot(root: Root, data: js.Array[Data], layout: PartialLayout, config: PartialConfig): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("plot")(root.asInstanceOf[js.Any], data.asInstanceOf[js.Any], layout.asInstanceOf[js.Any], config.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  
  @scala.inline
  def prependTraces(root: Root, update: js.Array[Data], indices: js.Array[Double]): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("prependTraces")(root.asInstanceOf[js.Any], update.asInstanceOf[js.Any], indices.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def prependTraces(root: Root, update: js.Array[Data], indices: Double): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("prependTraces")(root.asInstanceOf[js.Any], update.asInstanceOf[js.Any], indices.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def prependTraces(root: Root, update: Data, indices: js.Array[Double]): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("prependTraces")(root.asInstanceOf[js.Any], update.asInstanceOf[js.Any], indices.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def prependTraces(root: Root, update: Data, indices: Double): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("prependTraces")(root.asInstanceOf[js.Any], update.asInstanceOf[js.Any], indices.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  
  @scala.inline
  def purge(root: Root): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("purge")(root.asInstanceOf[js.Any]).asInstanceOf[Unit]
  
  @scala.inline
  def react(root: Root, data: js.Array[Data]): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("react")(root.asInstanceOf[js.Any], data.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def react(root: Root, data: js.Array[Data], layout: Unit, config: PartialConfig): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("react")(root.asInstanceOf[js.Any], data.asInstanceOf[js.Any], layout.asInstanceOf[js.Any], config.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def react(root: Root, data: js.Array[Data], layout: PartialLayout): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("react")(root.asInstanceOf[js.Any], data.asInstanceOf[js.Any], layout.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def react(root: Root, data: js.Array[Data], layout: PartialLayout, config: PartialConfig): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("react")(root.asInstanceOf[js.Any], data.asInstanceOf[js.Any], layout.asInstanceOf[js.Any], config.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  
  @scala.inline
  def redraw(root: Root): js.Promise[PlotlyHTMLElement] = ^.asInstanceOf[js.Dynamic].applyDynamic("redraw")(root.asInstanceOf[js.Any]).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  
  @scala.inline
  def relayout(root: Root, layout: PartialLayout): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("relayout")(root.asInstanceOf[js.Any], layout.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  
  @scala.inline
  def restyle(root: Root, aobj: Data): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("restyle")(root.asInstanceOf[js.Any], aobj.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def restyle(root: Root, aobj: Data, traces: js.Array[Double]): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("restyle")(root.asInstanceOf[js.Any], aobj.asInstanceOf[js.Any], traces.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def restyle(root: Root, aobj: Data, traces: Double): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("restyle")(root.asInstanceOf[js.Any], aobj.asInstanceOf[js.Any], traces.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  
  @scala.inline
  def toImage(root: Root, opts: ToImgopts): js.Promise[String] = (^.asInstanceOf[js.Dynamic].applyDynamic("toImage")(root.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[js.Promise[String]]
  
  @scala.inline
  def update(root: Root, traceUpdate: Data, layoutUpdate: PartialLayout): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("update")(root.asInstanceOf[js.Any], traceUpdate.asInstanceOf[js.Any], layoutUpdate.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def update(root: Root, traceUpdate: Data, layoutUpdate: PartialLayout, traces: js.Array[Double]): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("update")(root.asInstanceOf[js.Any], traceUpdate.asInstanceOf[js.Any], layoutUpdate.asInstanceOf[js.Any], traces.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
  @scala.inline
  def update(root: Root, traceUpdate: Data, layoutUpdate: PartialLayout, traces: Double): js.Promise[PlotlyHTMLElement] = (^.asInstanceOf[js.Dynamic].applyDynamic("update")(root.asInstanceOf[js.Any], traceUpdate.asInstanceOf[js.Any], layoutUpdate.asInstanceOf[js.Any], traces.asInstanceOf[js.Any])).asInstanceOf[js.Promise[PlotlyHTMLElement]]
}
