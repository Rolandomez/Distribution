package typings.playcanvas.mod

import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

/**
  * A material determines how a particular mesh instance is rendered. It specifies the shader and
  * render state that is set before the mesh instance is submitted to the graphics device.
  */
@JSImport("playcanvas", "Material")
@js.native
open class Material () extends StObject {
  
  /** @ignore */
  var _blendState: BlendState = js.native
  
  /** @ignore */
  var _depthState: DepthState = js.native
  
  var _dirtyBlend: Boolean = js.native
  
  def _markBlendDirty(): Unit = js.native
  
  var _scene: Any = js.native
  
  /**
    * A shader used to render the material. Note that this is used only by materials where the
    * user specifies the shader. Most material types generate multiple shader variants, and do not
    * set this.
    *
    * @type {import('../../platform/graphics/shader.js').Shader}
    * @private
    */
  /* private */ var _shader: Any = js.native
  
  var _shaderVersion: Double = js.native
  
  def _updateMeshInstanceKeys(): Unit = js.native
  
  /**
    * Registers mesh instance as referencing the material.
    *
    * @param {import('../mesh-instance.js').MeshInstance} meshInstance - The mesh instance to
    * de-register.
    * @ignore
    */
  def addMeshInstanceRef(meshInstance: MeshInstance): Unit = js.native
  
  /**
    * The alpha test reference value to control which fragments are written to the currently
    * active render target based on alpha value. All fragments with an alpha value of less than
    * the alphaTest reference value will be discarded. alphaTest defaults to 0 (all fragments
    * pass).
    *
    * @type {number}
    */
  var alphaTest: Double = js.native
  
  /**
    * Enables or disables alpha to coverage (WebGL2 only). When enabled, and if hardware
    * anti-aliasing is on, limited order-independent transparency can be achieved. Quality depends
    * on the number of MSAA samples of the current render target. It can nicely soften edges of
    * otherwise sharp alpha cutouts, but isn't recommended for large area semi-transparent
    * surfaces. Note, that you don't need to enable blending to make alpha to coverage work. It
    * will work without it, just like alphaTest.
    *
    * @type {boolean}
    */
  var alphaToCoverage: Boolean = js.native
  
  def alphaWrite: Boolean = js.native
  /**
    * If true, the alpha component of fragments generated by the shader of this material is
    * written to the color buffer of the currently active render target. If false, the alpha
    * component will not be written. Defaults to true.
    *
    * @type {boolean}
    */
  def alphaWrite_=(arg: Boolean): Unit = js.native
  
  def blendState: BlendState = js.native
  /**
    * Controls how fragment shader outputs are blended when being written to the currently active
    * render target. This overwrites blending type set using {@link Material#blendType}, and
    * offers more control over blending.
    *
    * @type { BlendState }
    */
  def blendState_=(arg: BlendState): Unit = js.native
  
  def blendType: Double = js.native
  /**
    * Controls how fragment shader outputs are blended when being written to the currently active
    * render target. Can be:
    *
    * - {@link BLEND_SUBTRACTIVE}: Subtract the color of the source fragment from the destination
    * fragment and write the result to the frame buffer.
    * - {@link BLEND_ADDITIVE}: Add the color of the source fragment to the destination fragment
    * and write the result to the frame buffer.
    * - {@link BLEND_NORMAL}: Enable simple translucency for materials such as glass. This is
    * equivalent to enabling a source blend mode of {@link BLENDMODE_SRC_ALPHA} and a destination
    * blend mode of {@link BLENDMODE_ONE_MINUS_SRC_ALPHA}.
    * - {@link BLEND_NONE}: Disable blending.
    * - {@link BLEND_PREMULTIPLIED}: Similar to {@link BLEND_NORMAL} expect the source fragment is
    * assumed to have already been multiplied by the source alpha value.
    * - {@link BLEND_MULTIPLICATIVE}: Multiply the color of the source fragment by the color of the
    * destination fragment and write the result to the frame buffer.
    * - {@link BLEND_ADDITIVEALPHA}: Same as {@link BLEND_ADDITIVE} except the source RGB is
    * multiplied by the source alpha.
    * - {@link BLEND_MULTIPLICATIVE2X}: Multiplies colors and doubles the result.
    * - {@link BLEND_SCREEN}: Softer version of additive.
    * - {@link BLEND_MIN}: Minimum color. Check app.graphicsDevice.extBlendMinmax for support.
    * - {@link BLEND_MAX}: Maximum color. Check app.graphicsDevice.extBlendMinmax for support.
    *
    * Defaults to {@link BLEND_NONE}.
    *
    * @type {number}
    */
  def blendType_=(arg: Double): Unit = js.native
  
  def blueWrite: Boolean = js.native
  /**
    * If true, the blue component of fragments generated by the shader of this material is
    * written to the color buffer of the currently active render target. If false, the blue
    * component will not be written. Defaults to true.
    *
    * @type {boolean}
    */
  def blueWrite_=(arg: Boolean): Unit = js.native
  
  def clearParameters(): Unit = js.native
  
  def clearVariants(): Unit = js.native
  
  /**
    * Copy a material.
    *
    * @param {Material} source - The material to copy.
    * @returns {Material} The destination material.
    */
  def copy(source: Material): Material = js.native
  
  /**
    * Controls how triangles are culled based on their face direction with respect to the
    * viewpoint. Can be:
    *
    * - {@link CULLFACE_NONE}: Do not cull triangles based on face direction.
    * - {@link CULLFACE_BACK}: Cull the back faces of triangles (do not render triangles facing
    * away from the view point).
    * - {@link CULLFACE_FRONT}: Cull the front faces of triangles (do not render triangles facing
    * towards the view point).
    *
    * Defaults to {@link CULLFACE_BACK}.
    *
    * @type {number}
    */
  var cull: Double = js.native
  
  /**
    * Deletes a shader parameter on a material.
    *
    * @param {string} name - The name of the parameter to delete.
    */
  def deleteParameter(name: String): Unit = js.native
  
  /**
    * Offsets the output depth buffer value. Useful for decals to prevent z-fighting.
    *
    * @type {number}
    */
  var depthBias: Double = js.native
  
  def depthFunc: Double = js.native
  /**
    * Controls how the depth of new fragments is compared against the current depth contained in
    * the depth buffer. Can be:
    *
    * - {@link FUNC_NEVER}: don't draw
    * - {@link FUNC_LESS}: draw if new depth < depth buffer
    * - {@link FUNC_EQUAL}: draw if new depth == depth buffer
    * - {@link FUNC_LESSEQUAL}: draw if new depth <= depth buffer
    * - {@link FUNC_GREATER}: draw if new depth > depth buffer
    * - {@link FUNC_NOTEQUAL}: draw if new depth != depth buffer
    * - {@link FUNC_GREATEREQUAL}: draw if new depth >= depth buffer
    * - {@link FUNC_ALWAYS}: always draw
    *
    * Defaults to {@link FUNC_LESSEQUAL}.
    *
    * @type {number}
    */
  def depthFunc_=(arg: Double): Unit = js.native
  
  def depthState: DepthState = js.native
  /**
    * Sets the depth state. Note that this can also be done by using {@link Material#depthTest},
    * {@link Material#depthFunc} and {@link Material#depthWrite}.
    *
    * @type { DepthState }
    */
  def depthState_=(arg: DepthState): Unit = js.native
  
  def depthTest: Boolean = js.native
  /**
    * If true, fragments generated by the shader of this material are only written to the current
    * render target if they pass the depth test. If false, fragments generated by the shader of
    * this material are written to the current render target regardless of what is in the depth
    * buffer. Defaults to true.
    *
    * @type {boolean}
    */
  def depthTest_=(arg: Boolean): Unit = js.native
  
  def depthWrite: Boolean = js.native
  /**
    * If true, fragments generated by the shader of this material write a depth value to the depth
    * buffer of the currently active render target. If false, no depth value is written. Defaults
    * to true.
    *
    * @type {boolean}
    */
  def depthWrite_=(arg: Boolean): Unit = js.native
  
  /**
    * Removes this material from the scene and possibly frees up memory from its shaders (if there
    * are no other materials using it).
    */
  def destroy(): Unit = js.native
  
  var dirty: Boolean = js.native
  
  /**
    * Retrieves the specified shader parameter from a material.
    *
    * @param {string} name - The name of the parameter to query.
    * @returns {object} The named parameter.
    */
  def getParameter(name: String): js.Object = js.native
  
  def getParameters(): js.Object = js.native
  
  def getShaderVariant(
    device: Any,
    scene: Any,
    objDefs: Any,
    staticLightList: Any,
    pass: Any,
    sortedLights: Any,
    viewUniformFormat: Any,
    viewBindGroupFormat: Any,
    vertexFormat: Any
  ): Shader = js.native
  
  def greenWrite: Boolean = js.native
  /**
    * If true, the green component of fragments generated by the shader of this material is
    * written to the color buffer of the currently active render target. If false, the green
    * component will not be written. Defaults to true.
    *
    * @type {boolean}
    */
  def greenWrite_=(arg: Boolean): Unit = js.native
  
  var id: Double = js.native
  
  /**
    * The mesh instances referencing this material
    *
    * @type {import('../mesh-instance.js').MeshInstance[]}
    * @private
    */
  /* private */ var meshInstances: Any = js.native
  
  /**
    * The name of the material.
    *
    * @type {string}
    */
  var name: String = js.native
  
  def redWrite: Boolean = js.native
  /**
    * If true, the red component of fragments generated by the shader of this material is written
    * to the color buffer of the currently active render target. If false, the red component will
    * not be written. Defaults to true.
    *
    * @type {boolean}
    */
  def redWrite_=(arg: Boolean): Unit = js.native
  
  /**
    * De-registers mesh instance as referencing the material.
    *
    * @param {import('../mesh-instance.js').MeshInstance} meshInstance - The mesh instance to
    * de-register.
    * @ignore
    */
  def removeMeshInstanceRef(meshInstance: MeshInstance): Unit = js.native
  
  def setParameter(name: String, data: js.Array[Double]): Unit = js.native
  def setParameter(name: String, data: js.typedarray.Float32Array): Unit = js.native
  /**
    * Sets a shader parameter on a material.
    *
    * @param {string} name - The name of the parameter to set.
    * @param {number|number[]|Float32Array|import('../../platform/graphics/texture.js').Texture} data -
    * The value for the specified parameter.
    */
  def setParameter(name: String, data: Double): Unit = js.native
  def setParameter(name: String, data: Texture): Unit = js.native
  
  def setParameters(device: Any, names: Any): Unit = js.native
  
  def shader: Shader = js.native
  /**
    * The shader used by this material to render mesh instances (default is null).
    *
    * @type {import('../../platform/graphics/shader.js').Shader|null}
    */
  def shader_=(arg: Shader): Unit = js.native
  
  /**
    * Same as {@link Material#depthBias}, but also depends on the slope of the triangle relative
    * to the camera.
    *
    * @type {number}
    */
  var slopeDepthBias: Double = js.native
  
  /**
    * Stencil parameters for back faces (default is null).
    *
    * @type {import('../../platform/graphics/stencil-parameters.js').StencilParameters|null}
    */
  var stencilBack: StencilParameters | Null = js.native
  
  /**
    * Stencil parameters for front faces (default is null).
    *
    * @type {import('../../platform/graphics/stencil-parameters.js').StencilParameters|null}
    */
  var stencilFront: StencilParameters | Null = js.native
  
  def transparent: Boolean = js.native
  
  /**
    * Applies any changes made to the material's properties.
    */
  def update(): Unit = js.native
  
  def updateUniforms(device: Any, scene: Any): Unit = js.native
}
