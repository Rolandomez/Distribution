package typings.peerjs

import typings.peerjs.peerjsStrings.call
import typings.peerjs.peerjsStrings.close
import typings.peerjs.peerjsStrings.connection
import typings.peerjs.peerjsStrings.data
import typings.peerjs.peerjsStrings.disconnected
import typings.peerjs.peerjsStrings.error
import typings.peerjs.peerjsStrings.open
import typings.peerjs.peerjsStrings.stream
import typings.std.MediaStream
import typings.std.RTCConfiguration
import typings.std.RTCDataChannel
import typings.std.RTCPeerConnection
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object mod {
  
  @JSImport("peerjs", JSImport.Namespace)
  @js.native
  /**
    * A peer can connect to other peers and listen for connections.
    * @param id Other peers can connect to this peer using the provided ID.
    *     If no ID is given, one will be generated by the brokering server.
    * @param options for specifying details about PeerServer
    */
  class ^ ()
    extends StObject
       with Peer {
    def this(id: String) = this()
    /**
      * A peer can connect to other peers and listen for connections.
      * @param options for specifying details about PeerServer
      */
    def this(options: PeerJSOption) = this()
    def this(id: String, options: PeerJSOption) = this()
    def this(id: Unit, options: PeerJSOption) = this()
  }
  
  trait AnswerOption extends StObject {
    
    var sdpTransform: js.UndefOr[js.Function] = js.undefined
  }
  object AnswerOption {
    
    inline def apply(): AnswerOption = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[AnswerOption]
    }
    
    extension [Self <: AnswerOption](x: Self) {
      
      inline def setSdpTransform(value: js.Function): Self = StObject.set(x, "sdpTransform", value.asInstanceOf[js.Any])
      
      inline def setSdpTransformUndefined: Self = StObject.set(x, "sdpTransform", js.undefined)
    }
  }
  
  trait CallOption extends StObject {
    
    var metadata: js.UndefOr[js.Any] = js.undefined
    
    var sdpTransform: js.UndefOr[js.Function] = js.undefined
  }
  object CallOption {
    
    inline def apply(): CallOption = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[CallOption]
    }
    
    extension [Self <: CallOption](x: Self) {
      
      inline def setMetadata(value: js.Any): Self = StObject.set(x, "metadata", value.asInstanceOf[js.Any])
      
      inline def setMetadataUndefined: Self = StObject.set(x, "metadata", js.undefined)
      
      inline def setSdpTransform(value: js.Function): Self = StObject.set(x, "sdpTransform", value.asInstanceOf[js.Any])
      
      inline def setSdpTransformUndefined: Self = StObject.set(x, "sdpTransform", js.undefined)
    }
  }
  
  @js.native
  trait DataConnection extends StObject {
    
    var bufferSize: Double = js.native
    
    def close(): Unit = js.native
    
    var dataChannel: RTCDataChannel = js.native
    
    var label: String = js.native
    
    var metadata: js.Any = js.native
    
    def off(event: String, fn: js.Function): Unit = js.native
    def off(event: String, fn: js.Function, once: Boolean): Unit = js.native
    
    def on(event: String, cb: js.Function0[Unit]): Unit = js.native
    @JSName("on")
    def on_close(event: close, cb: js.Function0[Unit]): Unit = js.native
    @JSName("on")
    def on_data(event: data, cb: js.Function1[/* data */ js.Any, Unit]): Unit = js.native
    @JSName("on")
    def on_error(event: error, cb: js.Function1[/* err */ js.Any, Unit]): Unit = js.native
    @JSName("on")
    def on_open(event: open, cb: js.Function0[Unit]): Unit = js.native
    
    var open: Boolean = js.native
    
    def parse(data: String): js.Any = js.native
    
    var peer: String = js.native
    
    var peerConnection: RTCPeerConnection = js.native
    
    var reliable: Boolean = js.native
    
    def send(data: js.Any): Unit = js.native
    
    var serialization: String = js.native
    
    def stringify(data: js.Any): String = js.native
    
    var `type`: String = js.native
  }
  
  @js.native
  trait MediaConnection extends StObject {
    
    def answer(): Unit = js.native
    def answer(stream: Unit, options: AnswerOption): Unit = js.native
    def answer(stream: MediaStream): Unit = js.native
    def answer(stream: MediaStream, options: AnswerOption): Unit = js.native
    
    def close(): Unit = js.native
    
    var metadata: js.Any = js.native
    
    def off(event: String, fn: js.Function): Unit = js.native
    def off(event: String, fn: js.Function, once: Boolean): Unit = js.native
    
    def on(event: String, cb: js.Function0[Unit]): Unit = js.native
    @JSName("on")
    def on_close(event: close, cb: js.Function0[Unit]): Unit = js.native
    @JSName("on")
    def on_error(event: error, cb: js.Function1[/* err */ js.Any, Unit]): Unit = js.native
    @JSName("on")
    def on_stream(event: stream, cb: js.Function1[/* stream */ MediaStream, Unit]): Unit = js.native
    
    var open: Boolean = js.native
    
    var peer: String = js.native
    
    var peerConnection: RTCPeerConnection = js.native
    
    var `type`: String = js.native
  }
  
  @js.native
  trait Peer extends StObject {
    
    /**
      * Calls the remote peer specified by id and returns a media connection.
      * @param id The brokering ID of the remote peer (their peer.id).
      * @param stream The caller's media stream
      * @param options Metadata associated with the connection, passed in by whoever initiated the connection.
      */
    def call(id: String, stream: MediaStream): MediaConnection = js.native
    def call(id: String, stream: MediaStream, options: CallOption): MediaConnection = js.native
    
    /**
      * Connects to the remote peer specified by id and returns a data connection.
      * @param id The brokering ID of the remote peer (their peer.id).
      * @param options for specifying details about Peer Connection
      */
    def connect(id: String): DataConnection = js.native
    def connect(id: String, options: PeerConnectOption): DataConnection = js.native
    
    /**
      * A hash of all connections associated with this peer, keyed by the remote peer's ID.
      */
    var connections: js.Any = js.native
    
    /**
      * Close the connection to the server and terminate all existing connections.
      */
    def destroy(): Unit = js.native
    
    /**
      * true if this peer and all of its connections can no longer be used.
      */
    var destroyed: Boolean = js.native
    
    /**
      * Close the connection to the server, leaving all existing data and media connections intact.
      */
    def disconnect(): Unit = js.native
    
    /**
      * false if there is an active connection to the PeerServer.
      */
    var disconnected: Boolean = js.native
    
    /**
      * Retrieve a data/media connection for this peer.
      * @param peerId
      * @param connectionId
      */
    def getConnection(peerId: String, connectionId: String): MediaConnection | DataConnection | Null = js.native
    
    /**
      * The brokering ID of this peer
      */
    var id: String = js.native
    
    /**
      * Get a list of available peer IDs
      * @param callback
      */
    def listAllPeers(callback: js.Function1[/* peerIds */ js.Array[String], Unit]): Unit = js.native
    
    /**
      * Remove event listeners.(EventEmitter3)
      * @param {String} event The event we want to remove.
      * @param {Function} fn The listener that we need to find.
      * @param {Boolean} once Only remove once listeners.
      */
    def off(event: String, fn: js.Function): Unit = js.native
    def off(event: String, fn: js.Function, once: Boolean): Unit = js.native
    
    /**
      * Set listeners for peer events.
      * @param event Event name
      * @param cb Callback Function
      */
    def on(event: String, cb: js.Function0[Unit]): Unit = js.native
    /**
      * Emitted when a remote peer attempts to call you.
      * @param event Event name
      * @param cb Callback Function
      */
    @JSName("on")
    def on_call(event: call, cb: js.Function1[/* mediaConnection */ MediaConnection, Unit]): Unit = js.native
    /**
      * Emitted when the peer is destroyed and can no longer accept or create any new connections.
      * @param event Event name
      * @param cb Callback Function
      */
    @JSName("on")
    def on_close(event: close, cb: js.Function0[Unit]): Unit = js.native
    /**
      * Emitted when a new data connection is established from a remote peer.
      * @param event Event name
      * @param cb Callback Function
      */
    @JSName("on")
    def on_connection(event: connection, cb: js.Function1[/* dataConnection */ DataConnection, Unit]): Unit = js.native
    /**
      * Emitted when the peer is disconnected from the signalling server
      * @param event Event name
      * @param cb Callback Function
      */
    @JSName("on")
    def on_disconnected(event: disconnected, cb: js.Function0[Unit]): Unit = js.native
    /**
      * Errors on the peer are almost always fatal and will destroy the peer.
      * @param event Event name
      * @param cb Callback Function
      */
    @JSName("on")
    def on_error(event: error, cb: js.Function1[/* err */ js.Any, Unit]): Unit = js.native
    /**
      * Emitted when a connection to the PeerServer is established.
      * @param event Event name
      * @param cb id is the brokering ID of the peer
      */
    @JSName("on")
    def on_open(event: open, cb: js.Function1[/* id */ String, Unit]): Unit = js.native
    
    /**
      * Attempt to reconnect to the server with the peer's old ID
      */
    def reconnect(): Unit = js.native
  }
  
  trait PeerConnectOption extends StObject {
    
    var label: js.UndefOr[String] = js.undefined
    
    var metadata: js.UndefOr[js.Any] = js.undefined
    
    var reliable: js.UndefOr[Boolean] = js.undefined
    
    var serialization: js.UndefOr[String] = js.undefined
  }
  object PeerConnectOption {
    
    inline def apply(): PeerConnectOption = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[PeerConnectOption]
    }
    
    extension [Self <: PeerConnectOption](x: Self) {
      
      inline def setLabel(value: String): Self = StObject.set(x, "label", value.asInstanceOf[js.Any])
      
      inline def setLabelUndefined: Self = StObject.set(x, "label", js.undefined)
      
      inline def setMetadata(value: js.Any): Self = StObject.set(x, "metadata", value.asInstanceOf[js.Any])
      
      inline def setMetadataUndefined: Self = StObject.set(x, "metadata", js.undefined)
      
      inline def setReliable(value: Boolean): Self = StObject.set(x, "reliable", value.asInstanceOf[js.Any])
      
      inline def setReliableUndefined: Self = StObject.set(x, "reliable", js.undefined)
      
      inline def setSerialization(value: String): Self = StObject.set(x, "serialization", value.asInstanceOf[js.Any])
      
      inline def setSerializationUndefined: Self = StObject.set(x, "serialization", js.undefined)
    }
  }
  
  trait PeerJSOption extends StObject {
    
    var config: js.UndefOr[RTCConfiguration] = js.undefined
    
    var debug: js.UndefOr[Double] = js.undefined
    
    var host: js.UndefOr[String] = js.undefined
    
    var key: js.UndefOr[String] = js.undefined
    
    var path: js.UndefOr[String] = js.undefined
    
    var port: js.UndefOr[Double] = js.undefined
    
    var secure: js.UndefOr[Boolean] = js.undefined
  }
  object PeerJSOption {
    
    inline def apply(): PeerJSOption = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[PeerJSOption]
    }
    
    extension [Self <: PeerJSOption](x: Self) {
      
      inline def setConfig(value: RTCConfiguration): Self = StObject.set(x, "config", value.asInstanceOf[js.Any])
      
      inline def setConfigUndefined: Self = StObject.set(x, "config", js.undefined)
      
      inline def setDebug(value: Double): Self = StObject.set(x, "debug", value.asInstanceOf[js.Any])
      
      inline def setDebugUndefined: Self = StObject.set(x, "debug", js.undefined)
      
      inline def setHost(value: String): Self = StObject.set(x, "host", value.asInstanceOf[js.Any])
      
      inline def setHostUndefined: Self = StObject.set(x, "host", js.undefined)
      
      inline def setKey(value: String): Self = StObject.set(x, "key", value.asInstanceOf[js.Any])
      
      inline def setKeyUndefined: Self = StObject.set(x, "key", js.undefined)
      
      inline def setPath(value: String): Self = StObject.set(x, "path", value.asInstanceOf[js.Any])
      
      inline def setPathUndefined: Self = StObject.set(x, "path", js.undefined)
      
      inline def setPort(value: Double): Self = StObject.set(x, "port", value.asInstanceOf[js.Any])
      
      inline def setPortUndefined: Self = StObject.set(x, "port", js.undefined)
      
      inline def setSecure(value: Boolean): Self = StObject.set(x, "secure", value.asInstanceOf[js.Any])
      
      inline def setSecureUndefined: Self = StObject.set(x, "secure", js.undefined)
    }
  }
  
  trait UtilSupportsObj extends StObject {
    
    var audioVideo: Boolean
    
    var binaryBlob: Boolean
    
    var browser: Boolean
    
    var data: Boolean
    
    var reliable: Boolean
    
    var webRTC: Boolean
  }
  object UtilSupportsObj {
    
    inline def apply(
      audioVideo: Boolean,
      binaryBlob: Boolean,
      browser: Boolean,
      data: Boolean,
      reliable: Boolean,
      webRTC: Boolean
    ): UtilSupportsObj = {
      val __obj = js.Dynamic.literal(audioVideo = audioVideo.asInstanceOf[js.Any], binaryBlob = binaryBlob.asInstanceOf[js.Any], browser = browser.asInstanceOf[js.Any], data = data.asInstanceOf[js.Any], reliable = reliable.asInstanceOf[js.Any], webRTC = webRTC.asInstanceOf[js.Any])
      __obj.asInstanceOf[UtilSupportsObj]
    }
    
    extension [Self <: UtilSupportsObj](x: Self) {
      
      inline def setAudioVideo(value: Boolean): Self = StObject.set(x, "audioVideo", value.asInstanceOf[js.Any])
      
      inline def setBinaryBlob(value: Boolean): Self = StObject.set(x, "binaryBlob", value.asInstanceOf[js.Any])
      
      inline def setBrowser(value: Boolean): Self = StObject.set(x, "browser", value.asInstanceOf[js.Any])
      
      inline def setData(value: Boolean): Self = StObject.set(x, "data", value.asInstanceOf[js.Any])
      
      inline def setReliable(value: Boolean): Self = StObject.set(x, "reliable", value.asInstanceOf[js.Any])
      
      inline def setWebRTC(value: Boolean): Self = StObject.set(x, "webRTC", value.asInstanceOf[js.Any])
    }
  }
  
  trait util extends StObject {
    
    var browser: String
    
    var supports: UtilSupportsObj
  }
  object util {
    
    inline def apply(browser: String, supports: UtilSupportsObj): util = {
      val __obj = js.Dynamic.literal(browser = browser.asInstanceOf[js.Any], supports = supports.asInstanceOf[js.Any])
      __obj.asInstanceOf[util]
    }
    
    extension [Self <: util](x: Self) {
      
      inline def setBrowser(value: String): Self = StObject.set(x, "browser", value.asInstanceOf[js.Any])
      
      inline def setSupports(value: UtilSupportsObj): Self = StObject.set(x, "supports", value.asInstanceOf[js.Any])
    }
  }
}
