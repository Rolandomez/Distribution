package typings.pixiJs.global.PIXI

import typings.std.Uint16Array
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

/**
  * Renderer dedicated to drawing and batching sprites.
  *
  * This is the default batch renderer. It buffers objects
  * with texture-based geometries and renders them in
  * batches. It uploads multiple textures to the GPU to
  * reduce to the number of draw calls.
  *
  * @class
  * @protected
  * @memberof PIXI
  * @extends PIXI.ObjectRenderer
  */
@JSGlobal("PIXI.AbstractBatchRenderer")
@js.native
class AbstractBatchRenderer protected ()
  extends StObject
     with typings.pixiJs.PIXI.AbstractBatchRenderer {
  def this(renderer: typings.pixiJs.PIXI.Renderer) = this()
  
  /**
    * Maximum number of textures that can be uploaded to
    * the GPU under the current context. It is initialized
    * properly in `this.contextChange`.
    *
    * @member {number} PIXI.AbstractBatchRenderer#MAX_TEXTURES
    * @see PIXI.AbstractBatchRenderer#contextChange
    * @readonly
    */
  /* CompleteClass */
  override val MAX_TEXTURES: Double = js.native
  
  /**
    * This shader is generated by `this.shaderGenerator`.
    *
    * It is generated specifically to handle the required
    * number of textures being batched together.
    *
    * @member {PIXI.Shader} PIXI.AbstractBatchRenderer#_shader
    * @protected
    */
  /* protected */ /* CompleteClass */
  var _shader: typings.pixiJs.PIXI.Shader = js.native
  
  /**
    * Bind textures for current rendering
    *
    * @param {PIXI.BatchTextureArray} texArray
    */
  /* CompleteClass */
  override def bindAndClearTexArray(texArray: typings.pixiJs.PIXI.BatchTextureArray): Unit = js.native
  
  /**
    * Populating drawcalls for rendering
    *
    * @param {PIXI.BatchTextureArray} texArray
    * @param {number} start
    * @param {number} finish
    */
  /* CompleteClass */
  override def buildDrawCalls(texArray: typings.pixiJs.PIXI.BatchTextureArray, start: Double, finish: Double): Unit = js.native
  
  /**
    * Handles the `contextChange` signal.
    *
    * It calculates `this.MAX_TEXTURES` and allocating the
    * packed-geometry object pool.
    */
  /* CompleteClass */
  override def contextChange(): Unit = js.native
  
  /**
    * Generic destroy methods to be overridden by the subclass
    */
  /* CompleteClass */
  override def destroy(): Unit = js.native
  
  /**
    * Stub method that should be used to empty the current
    * batch by rendering objects now.
    */
  /* CompleteClass */
  override def flush(): Unit = js.native
  
  /**
    * The class that represents the geometry of objects
    * that are going to be batched with this.
    *
    * @member {object} PIXI.AbstractBatchRenderer#geometryClass
    * @default PIXI.BatchGeometry
    * @protected
    */
  /* protected */ /* CompleteClass */
  var geometryClass: js.Any = js.native
  
  /**
    * Makes sure that static and dynamic flush pooled objects have correct dimensions
    */
  /* CompleteClass */
  override def initFlushBuffers(): Unit = js.native
  
  /**
    * Handles the `prerender` signal.
    *
    * It ensures that flushes start from the first geometry
    * object again.
    */
  /* CompleteClass */
  override def onPrerender(): Unit = js.native
  
  /**
    * Takes the four batching parameters of `element`, interleaves
    * and pushes them into the batching attribute/index buffers given.
    *
    * It uses these properties: `vertexData` `uvs`, `textureId` and
    * `indicies`. It also uses the "tint" of the base-texture, if
    * present.
    *
    * @param {PIXI.Sprite} element - element being rendered
    * @param {PIXI.ViewableBuffer} attributeBuffer - attribute buffer.
    * @param {Uint16Array} indexBuffer - index buffer
    * @param {number} aIndex - number of floats already in the attribute buffer
    * @param {number} iIndex - number of indices already in `indexBuffer`
    */
  /* CompleteClass */
  override def packInterleavedGeometry(
    element: typings.pixiJs.PIXI.Sprite,
    attributeBuffer: typings.pixiJs.PIXI.ViewableBuffer,
    indexBuffer: Uint16Array,
    aIndex: Double,
    iIndex: Double
  ): Unit = js.native
  
  /**
    * Keeps the object to render. It doesn't have to be
    * rendered immediately.
    *
    * @param {PIXI.DisplayObject} object - The object to render.
    */
  /* CompleteClass */
  override def render(`object`: typings.pixiJs.PIXI.DisplayObject): Unit = js.native
  
  /**
    * The renderer this manager works for.
    *
    * @member {PIXI.Renderer} PIXI.System#renderer
    */
  /* CompleteClass */
  var renderer: typings.pixiJs.PIXI.Renderer = js.native
  
  /**
    * This is used to generate a shader that can
    * color each vertex based on a `aTextureId`
    * attribute that points to an texture in `uSampler`.
    *
    * This enables the objects with different textures
    * to be drawn in the same draw call.
    *
    * You can customize your shader by creating your
    * custom shader generator.
    *
    * @member {PIXI.BatchShaderGenerator} PIXI.AbstractBatchRenderer#shaderGenerator
    * @protected
    */
  /* protected */ /* CompleteClass */
  var shaderGenerator: typings.pixiJs.PIXI.BatchShaderGenerator = js.native
  
  /**
    * The number of bufferable objects before a flush
    * occurs automatically.
    *
    * @member {number} PIXI.AbstractBatchRenderer#size
    * @default settings.SPRITE_BATCH_SIZE * 4
    */
  /* CompleteClass */
  var size: Double = js.native
  
  /**
    * Stub method that initializes any state required before
    * rendering starts. It is different from the `prerender`
    * signal, which occurs every frame, in that it is called
    * whenever an object requests _this_ renderer specifically.
    */
  /* CompleteClass */
  override def start(): Unit = js.native
  
  /**
    * The WebGL state in which this renderer will work.
    *
    * @member {PIXI.State} PIXI.AbstractBatchRenderer#state
    * @readonly
    */
  /* CompleteClass */
  override val state: typings.pixiJs.PIXI.State = js.native
  
  /**
    * Stops the renderer. It should free up any state and
    * become dormant.
    */
  /* CompleteClass */
  override def stop(): Unit = js.native
  
  /**
    * Size of data being buffered per vertex in the
    * attribute buffers (in floats). By default, the
    * batch-renderer plugin uses 6:
    *
    * | aVertexPosition | 2 |
    * |-----------------|---|
    * | aTextureCoords  | 2 |
    * | aColor          | 1 |
    * | aTextureId      | 1 |
    *
    * @member {number} PIXI.AbstractBatchRenderer#vertexSize
    * @readonly
    */
  /* CompleteClass */
  override val vertexSize: Double = js.native
}
object AbstractBatchRenderer {
  
  @JSGlobal("PIXI.AbstractBatchRenderer")
  @js.native
  val ^ : js.Any = js.native
  
  /**
    * Pool of `BatchDrawCall` objects that `flush` used
    * to create "batches" of the objects being rendered.
    *
    * These are never re-allocated again.
    * Shared between all batch renderers because it can be only one "flush" working at the moment.
    *
    * @static
    * @member {PIXI.BatchDrawCall[]}
    */
  /* static member */
  @JSGlobal("PIXI.AbstractBatchRenderer._drawCallPool")
  @js.native
  def drawCallPool: js.Array[typings.pixiJs.PIXI.BatchDrawCall] = js.native
  
  inline def drawCallPool_=(x: js.Array[typings.pixiJs.PIXI.BatchDrawCall]): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("_drawCallPool")(x.asInstanceOf[js.Any])
  
  /**
    * Pool of `BatchDrawCall` objects that `flush` used
    * to create "batches" of the objects being rendered.
    *
    * These are never re-allocated again.
    * Shared between all batch renderers because it can be only one "flush" working at the moment.
    *
    * @static
    * @member {PIXI.BatchTextureArray[]}
    */
  /* static member */
  @JSGlobal("PIXI.AbstractBatchRenderer._textureArrayPool")
  @js.native
  def textureArrayPool: js.Array[typings.pixiJs.PIXI.BatchTextureArray] = js.native
  
  inline def textureArrayPool_=(x: js.Array[typings.pixiJs.PIXI.BatchTextureArray]): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("_textureArrayPool")(x.asInstanceOf[js.Any])
}
