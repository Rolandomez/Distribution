package typings.pixiJs.PIXI

import typings.std.Uint16Array
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

/**
  * Renderer dedicated to drawing and batching sprites.
  *
  * This is the default batch renderer. It buffers objects
  * with texture-based geometries and renders them in
  * batches. It uploads multiple textures to the GPU to
  * reduce to the number of draw calls.
  *
  * @class
  * @protected
  * @memberof PIXI
  * @extends PIXI.ObjectRenderer
  */
trait AbstractBatchRenderer
  extends StObject
     with ObjectRenderer {
  
  /**
    * Maximum number of textures that can be uploaded to
    * the GPU under the current context. It is initialized
    * properly in `this.contextChange`.
    *
    * @member {number} PIXI.AbstractBatchRenderer#MAX_TEXTURES
    * @see PIXI.AbstractBatchRenderer#contextChange
    * @readonly
    */
  val MAX_TEXTURES: Double
  
  /**
    * This shader is generated by `this.shaderGenerator`.
    *
    * It is generated specifically to handle the required
    * number of textures being batched together.
    *
    * @member {PIXI.Shader} PIXI.AbstractBatchRenderer#_shader
    * @protected
    */
  /* protected */ var _shader: Shader
  
  /**
    * Bind textures for current rendering
    *
    * @param {PIXI.BatchTextureArray} texArray
    */
  def bindAndClearTexArray(texArray: BatchTextureArray): Unit
  
  /**
    * Populating drawcalls for rendering
    *
    * @param {PIXI.BatchTextureArray} texArray
    * @param {number} start
    * @param {number} finish
    */
  def buildDrawCalls(texArray: BatchTextureArray, start: Double, finish: Double): Unit
  
  /**
    * Handles the `contextChange` signal.
    *
    * It calculates `this.MAX_TEXTURES` and allocating the
    * packed-geometry object pool.
    */
  def contextChange(): Unit
  
  /**
    * The class that represents the geometry of objects
    * that are going to be batched with this.
    *
    * @member {object} PIXI.AbstractBatchRenderer#geometryClass
    * @default PIXI.BatchGeometry
    * @protected
    */
  /* protected */ var geometryClass: js.Any
  
  /**
    * Makes sure that static and dynamic flush pooled objects have correct dimensions
    */
  def initFlushBuffers(): Unit
  
  /**
    * Handles the `prerender` signal.
    *
    * It ensures that flushes start from the first geometry
    * object again.
    */
  def onPrerender(): Unit
  
  /**
    * Takes the four batching parameters of `element`, interleaves
    * and pushes them into the batching attribute/index buffers given.
    *
    * It uses these properties: `vertexData` `uvs`, `textureId` and
    * `indicies`. It also uses the "tint" of the base-texture, if
    * present.
    *
    * @param {PIXI.Sprite} element - element being rendered
    * @param {PIXI.ViewableBuffer} attributeBuffer - attribute buffer.
    * @param {Uint16Array} indexBuffer - index buffer
    * @param {number} aIndex - number of floats already in the attribute buffer
    * @param {number} iIndex - number of indices already in `indexBuffer`
    */
  def packInterleavedGeometry(
    element: Sprite,
    attributeBuffer: ViewableBuffer,
    indexBuffer: Uint16Array,
    aIndex: Double,
    iIndex: Double
  ): Unit
  
  /**
    * This is used to generate a shader that can
    * color each vertex based on a `aTextureId`
    * attribute that points to an texture in `uSampler`.
    *
    * This enables the objects with different textures
    * to be drawn in the same draw call.
    *
    * You can customize your shader by creating your
    * custom shader generator.
    *
    * @member {PIXI.BatchShaderGenerator} PIXI.AbstractBatchRenderer#shaderGenerator
    * @protected
    */
  /* protected */ var shaderGenerator: BatchShaderGenerator
  
  /**
    * The number of bufferable objects before a flush
    * occurs automatically.
    *
    * @member {number} PIXI.AbstractBatchRenderer#size
    * @default settings.SPRITE_BATCH_SIZE * 4
    */
  var size: Double
  
  /**
    * The WebGL state in which this renderer will work.
    *
    * @member {PIXI.State} PIXI.AbstractBatchRenderer#state
    * @readonly
    */
  val state: State
  
  /**
    * Size of data being buffered per vertex in the
    * attribute buffers (in floats). By default, the
    * batch-renderer plugin uses 6:
    *
    * | aVertexPosition | 2 |
    * |-----------------|---|
    * | aTextureCoords  | 2 |
    * | aColor          | 1 |
    * | aTextureId      | 1 |
    *
    * @member {number} PIXI.AbstractBatchRenderer#vertexSize
    * @readonly
    */
  val vertexSize: Double
}
object AbstractBatchRenderer {
  
  inline def apply(
    MAX_TEXTURES: Double,
    _shader: Shader,
    bindAndClearTexArray: BatchTextureArray => Unit,
    buildDrawCalls: (BatchTextureArray, Double, Double) => Unit,
    contextChange: () => Unit,
    destroy: () => Unit,
    flush: () => Unit,
    geometryClass: js.Any,
    initFlushBuffers: () => Unit,
    onPrerender: () => Unit,
    packInterleavedGeometry: (Sprite, ViewableBuffer, Uint16Array, Double, Double) => Unit,
    render: DisplayObject => Unit,
    renderer: Renderer,
    shaderGenerator: BatchShaderGenerator,
    size: Double,
    start: () => Unit,
    state: State,
    stop: () => Unit,
    vertexSize: Double
  ): AbstractBatchRenderer = {
    val __obj = js.Dynamic.literal(MAX_TEXTURES = MAX_TEXTURES.asInstanceOf[js.Any], _shader = _shader.asInstanceOf[js.Any], bindAndClearTexArray = js.Any.fromFunction1(bindAndClearTexArray), buildDrawCalls = js.Any.fromFunction3(buildDrawCalls), contextChange = js.Any.fromFunction0(contextChange), destroy = js.Any.fromFunction0(destroy), flush = js.Any.fromFunction0(flush), geometryClass = geometryClass.asInstanceOf[js.Any], initFlushBuffers = js.Any.fromFunction0(initFlushBuffers), onPrerender = js.Any.fromFunction0(onPrerender), packInterleavedGeometry = js.Any.fromFunction5(packInterleavedGeometry), render = js.Any.fromFunction1(render), renderer = renderer.asInstanceOf[js.Any], shaderGenerator = shaderGenerator.asInstanceOf[js.Any], size = size.asInstanceOf[js.Any], start = js.Any.fromFunction0(start), state = state.asInstanceOf[js.Any], stop = js.Any.fromFunction0(stop), vertexSize = vertexSize.asInstanceOf[js.Any])
    __obj.asInstanceOf[AbstractBatchRenderer]
  }
  
  extension [Self <: AbstractBatchRenderer](x: Self) {
    
    inline def setBindAndClearTexArray(value: BatchTextureArray => Unit): Self = StObject.set(x, "bindAndClearTexArray", js.Any.fromFunction1(value))
    
    inline def setBuildDrawCalls(value: (BatchTextureArray, Double, Double) => Unit): Self = StObject.set(x, "buildDrawCalls", js.Any.fromFunction3(value))
    
    inline def setContextChange(value: () => Unit): Self = StObject.set(x, "contextChange", js.Any.fromFunction0(value))
    
    inline def setGeometryClass(value: js.Any): Self = StObject.set(x, "geometryClass", value.asInstanceOf[js.Any])
    
    inline def setInitFlushBuffers(value: () => Unit): Self = StObject.set(x, "initFlushBuffers", js.Any.fromFunction0(value))
    
    inline def setMAX_TEXTURES(value: Double): Self = StObject.set(x, "MAX_TEXTURES", value.asInstanceOf[js.Any])
    
    inline def setOnPrerender(value: () => Unit): Self = StObject.set(x, "onPrerender", js.Any.fromFunction0(value))
    
    inline def setPackInterleavedGeometry(value: (Sprite, ViewableBuffer, Uint16Array, Double, Double) => Unit): Self = StObject.set(x, "packInterleavedGeometry", js.Any.fromFunction5(value))
    
    inline def setShaderGenerator(value: BatchShaderGenerator): Self = StObject.set(x, "shaderGenerator", value.asInstanceOf[js.Any])
    
    inline def setSize(value: Double): Self = StObject.set(x, "size", value.asInstanceOf[js.Any])
    
    inline def setState(value: State): Self = StObject.set(x, "state", value.asInstanceOf[js.Any])
    
    inline def setVertexSize(value: Double): Self = StObject.set(x, "vertexSize", value.asInstanceOf[js.Any])
    
    inline def set_shader(value: Shader): Self = StObject.set(x, "_shader", value.asInstanceOf[js.Any])
  }
}
