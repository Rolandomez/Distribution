package typings.hyperformula.mod

import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

@JSImport("hyperformula", "FunctionArgumentType")
@js.native
object FunctionArgumentType extends StObject {
  
  @JSBracketAccess
  def apply(value: String): js.UndefOr[
    typings.hyperformula.typingsInterpreterPluginFunctionPluginMod.FunctionArgumentType & String
  ] = js.native
  
  /* "ANY" */ val ANY: typings.hyperformula.typingsInterpreterPluginFunctionPluginMod.FunctionArgumentType.ANY & String = js.native
  
  /* "BOOLEAN" */ val BOOLEAN: typings.hyperformula.typingsInterpreterPluginFunctionPluginMod.FunctionArgumentType.BOOLEAN & String = js.native
  
  /* "COMPLEX" */ val COMPLEX: typings.hyperformula.typingsInterpreterPluginFunctionPluginMod.FunctionArgumentType.COMPLEX & String = js.native
  
  /* "INTEGER" */ val INTEGER: typings.hyperformula.typingsInterpreterPluginFunctionPluginMod.FunctionArgumentType.INTEGER & String = js.native
  
  /* "NOERROR" */ val NOERROR: typings.hyperformula.typingsInterpreterPluginFunctionPluginMod.FunctionArgumentType.NOERROR & String = js.native
  
  /* "NUMBER" */ val NUMBER: typings.hyperformula.typingsInterpreterPluginFunctionPluginMod.FunctionArgumentType.NUMBER & String = js.native
  
  /* "RANGE" */ val RANGE: typings.hyperformula.typingsInterpreterPluginFunctionPluginMod.FunctionArgumentType.RANGE & String = js.native
  
  /* "SCALAR" */ val SCALAR: typings.hyperformula.typingsInterpreterPluginFunctionPluginMod.FunctionArgumentType.SCALAR & String = js.native
  
  /* "STRING" */ val STRING: typings.hyperformula.typingsInterpreterPluginFunctionPluginMod.FunctionArgumentType.STRING & String = js.native
}
