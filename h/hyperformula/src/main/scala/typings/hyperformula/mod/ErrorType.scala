package typings.hyperformula.mod

import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

@JSImport("hyperformula", "ErrorType")
@js.native
object ErrorType extends StObject {
  
  @JSBracketAccess
  def apply(value: String): js.UndefOr[typings.hyperformula.cellMod.ErrorType & String] = js.native
  
  /* "CYCLE" */ val CYCLE: typings.hyperformula.cellMod.ErrorType.CYCLE & String = js.native
  
  /* "DIV_BY_ZERO" */ val DIV_BY_ZERO: typings.hyperformula.cellMod.ErrorType.DIV_BY_ZERO & String = js.native
  
  /* "ERROR" */ val ERROR: typings.hyperformula.cellMod.ErrorType.ERROR & String = js.native
  
  /* "LIC" */ val LIC: typings.hyperformula.cellMod.ErrorType.LIC & String = js.native
  
  /* "NA" */ val NA: typings.hyperformula.cellMod.ErrorType.NA & String = js.native
  
  /* "NAME" */ val NAME: typings.hyperformula.cellMod.ErrorType.NAME & String = js.native
  
  /* "NUM" */ val NUM: typings.hyperformula.cellMod.ErrorType.NUM & String = js.native
  
  /* "REF" */ val REF: typings.hyperformula.cellMod.ErrorType.REF & String = js.native
  
  /* "SPILL" */ val SPILL: typings.hyperformula.cellMod.ErrorType.SPILL & String = js.native
  
  /* "VALUE" */ val VALUE: typings.hyperformula.cellMod.ErrorType.VALUE & String = js.native
}
