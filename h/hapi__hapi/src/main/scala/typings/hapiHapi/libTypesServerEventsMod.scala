package typings.hapiHapi

import org.scalablytyped.runtime.StringDictionary
import typings.hapiHapi.anon.All
import typings.hapiHapi.hapiHapiBooleans.`true`
import typings.hapiHapi.hapiHapiStrings.app
import typings.hapiHapi.hapiHapiStrings.error
import typings.hapiHapi.hapiHapiStrings.internal
import typings.hapiHapi.hapiHapiStrings.log
import typings.hapiHapi.hapiHapiStrings.request
import typings.hapiHapi.hapiHapiStrings.response
import typings.hapiHapi.hapiHapiStrings.route
import typings.hapiHapi.hapiHapiStrings.start
import typings.hapiHapi.hapiHapiStrings.stop
import typings.hapiHapi.libTypesRequestMod.ReqRefDefaults
import typings.hapiHapi.libTypesRequestMod.Request
import typings.hapiHapi.libTypesRequestMod.RequestRoute
import typings.hapiPodium.mod.Podium
import typings.hapiPodium.mod.Podium.Listener
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object libTypesServerEventsMod {
  
  trait LogEvent[T] extends StObject {
    
    /** set to 'internal' for internally generated events, otherwise 'app' for events generated by server.log() */
    var channel: internal | app
    
    /** event-specific information. Available when event data was provided and is not an error. Errors are passed via error. */
    var data: T
    
    /** the error object related to the event if applicable. Cannot appear together with data */
    var error: js.Object
    
    /** the request identifier. */
    var request: String
    
    /** an array of tags identifying the event (e.g. ['error', 'http']) */
    var tags: js.Array[String]
    
    /** the event timestamp. */
    var timestamp: String
  }
  object LogEvent {
    
    inline def apply[T](
      channel: internal | app,
      data: T,
      error: js.Object,
      request: String,
      tags: js.Array[String],
      timestamp: String
    ): LogEvent[T] = {
      val __obj = js.Dynamic.literal(channel = channel.asInstanceOf[js.Any], data = data.asInstanceOf[js.Any], error = error.asInstanceOf[js.Any], request = request.asInstanceOf[js.Any], tags = tags.asInstanceOf[js.Any], timestamp = timestamp.asInstanceOf[js.Any])
      __obj.asInstanceOf[LogEvent[T]]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: LogEvent[?], T] (val x: Self & LogEvent[T]) extends AnyVal {
      
      inline def setChannel(value: internal | app): Self = StObject.set(x, "channel", value.asInstanceOf[js.Any])
      
      inline def setData(value: T): Self = StObject.set(x, "data", value.asInstanceOf[js.Any])
      
      inline def setError(value: js.Object): Self = StObject.set(x, "error", value.asInstanceOf[js.Any])
      
      inline def setRequest(value: String): Self = StObject.set(x, "request", value.asInstanceOf[js.Any])
      
      inline def setTags(value: js.Array[String]): Self = StObject.set(x, "tags", value.asInstanceOf[js.Any])
      
      inline def setTagsVarargs(value: String*): Self = StObject.set(x, "tags", js.Array(value*))
      
      inline def setTimestamp(value: String): Self = StObject.set(x, "timestamp", value.asInstanceOf[js.Any])
    }
  }
  
  type LogEventHandler = js.Function2[/* event */ LogEvent[js.Object | String], /* tags */ StringDictionary[`true`], Unit]
  
  @js.native
  trait PodiumEvent[K /* <: String */, T] extends StObject {
    
    def emit(criteria: K, listener: js.Function1[/* value */ T, Unit]): Unit = js.native
    
    def hasListeners(criteria: K): this.type = js.native
    
    def on(criteria: K, listener: js.Function1[/* value */ T, Unit]): Unit = js.native
    
    def once(criteria: K): js.Promise[T] = js.native
    def once(criteria: K, listener: js.Function1[/* value */ T, Unit]): Unit = js.native
    
    def removeAllListeners(criteria: K): this.type = js.native
    
    def removeListener(criteria: K, listener: Listener[Any, js.Array[Any]]): this.type = js.native
  }
  
  trait RequestEvent extends StObject {
    
    /** set to 'internal' for internally generated events, otherwise 'app' for events generated by server.log() */
    var channel: internal | app | error
    
    /** event-specific information. Available when event data was provided and is not an error. Errors are passed via error. */
    var data: js.Object | String
    
    /** the error object related to the event if applicable. Cannot appear together with data */
    var error: js.Object
    
    /** an array of tags identifying the event (e.g. ['error', 'http']) */
    var tags: js.Array[String]
    
    /** the event timestamp. */
    var timestamp: String
  }
  object RequestEvent {
    
    inline def apply(
      channel: internal | app | error,
      data: js.Object | String,
      error: js.Object,
      tags: js.Array[String],
      timestamp: String
    ): RequestEvent = {
      val __obj = js.Dynamic.literal(channel = channel.asInstanceOf[js.Any], data = data.asInstanceOf[js.Any], error = error.asInstanceOf[js.Any], tags = tags.asInstanceOf[js.Any], timestamp = timestamp.asInstanceOf[js.Any])
      __obj.asInstanceOf[RequestEvent]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: RequestEvent] (val x: Self) extends AnyVal {
      
      inline def setChannel(value: internal | app | error): Self = StObject.set(x, "channel", value.asInstanceOf[js.Any])
      
      inline def setData(value: js.Object | String): Self = StObject.set(x, "data", value.asInstanceOf[js.Any])
      
      inline def setError(value: js.Object): Self = StObject.set(x, "error", value.asInstanceOf[js.Any])
      
      inline def setTags(value: js.Array[String]): Self = StObject.set(x, "tags", value.asInstanceOf[js.Any])
      
      inline def setTagsVarargs(value: String*): Self = StObject.set(x, "tags", js.Array(value*))
      
      inline def setTimestamp(value: String): Self = StObject.set(x, "timestamp", value.asInstanceOf[js.Any])
    }
  }
  
  type RequestEventHandler = js.Function3[
    /* request */ Request[ReqRefDefaults], 
    /* event */ RequestEvent, 
    /* tags */ StringDictionary[`true`], 
    Unit
  ]
  
  type ResponseEventHandler = js.Function1[/* request */ Request[ReqRefDefaults], Unit]
  
  type RouteEventHandler = js.Function1[/* route */ RequestRoute[ReqRefDefaults], Unit]
  
  trait ServerEventCriteria[T] extends StObject {
    
    /**
      * a string or array of strings specifying the event channels to subscribe to. If the event registration specified a list of allowed channels, the channels array must match the allowed
      * channels. If channels are specified, event updates without any channel designation will not be included in the subscription. Defaults to no channels filter.
      */
    var channels: js.UndefOr[String | js.Array[String]] = js.undefined
    
    /** if true, the data object passed to server.event.emit() is cloned before it is passed to the listener method. Defaults to the event registration option (which defaults to false). */
    @JSName("clone")
    var clone_FServerEventCriteria: js.UndefOr[Boolean] = js.undefined
    
    /**
      * a positive integer indicating the number of times the listener can be called after which the subscription is automatically removed. A count of 1 is the same as calling server.events.once().
      * Defaults to no limit.
      */
    var count: js.UndefOr[Double] = js.undefined
    
    /**
      * filter - the event tags (if present) to subscribe to which can be one of:
      * * a tag string.
      * * an array of tag strings.
      * * an object with the following:
      * * * tags - a tag string or array of tag strings.
      * * * all - if true, all tags must be present for the event update to match the subscription. Defaults to false (at least one matching tag).
      */
    var filter: js.UndefOr[String | js.Array[String] | All] = js.undefined
    
    /** (required) the event name string. */
    var name: T
    
    /**
      * if true, and the data object passed to server.event.emit() is an array, the listener method is called with each array element passed as a separate argument. This should only be used
      * when the emitted data structure is known and predictable. Defaults to the event registration option (which defaults to false).
      */
    var spread: js.UndefOr[Boolean] = js.undefined
    
    /**
      * if true and the criteria object passed to server.event.emit() includes tags, the tags are mapped to an object (where each tag string is the key and the value is true) which is appended
      * to the arguments list at the end. Defaults to the event registration option (which defaults to false).
      */
    var tags: js.UndefOr[Boolean] = js.undefined
  }
  object ServerEventCriteria {
    
    inline def apply[T](name: T): ServerEventCriteria[T] = {
      val __obj = js.Dynamic.literal(name = name.asInstanceOf[js.Any])
      __obj.asInstanceOf[ServerEventCriteria[T]]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: ServerEventCriteria[?], T] (val x: Self & ServerEventCriteria[T]) extends AnyVal {
      
      inline def setChannels(value: String | js.Array[String]): Self = StObject.set(x, "channels", value.asInstanceOf[js.Any])
      
      inline def setChannelsUndefined: Self = StObject.set(x, "channels", js.undefined)
      
      inline def setChannelsVarargs(value: String*): Self = StObject.set(x, "channels", js.Array(value*))
      
      inline def setClone_(value: Boolean): Self = StObject.set(x, "clone", value.asInstanceOf[js.Any])
      
      inline def setClone_Undefined: Self = StObject.set(x, "clone", js.undefined)
      
      inline def setCount(value: Double): Self = StObject.set(x, "count", value.asInstanceOf[js.Any])
      
      inline def setCountUndefined: Self = StObject.set(x, "count", js.undefined)
      
      inline def setFilter(value: String | js.Array[String] | All): Self = StObject.set(x, "filter", value.asInstanceOf[js.Any])
      
      inline def setFilterUndefined: Self = StObject.set(x, "filter", js.undefined)
      
      inline def setFilterVarargs(value: String*): Self = StObject.set(x, "filter", js.Array(value*))
      
      inline def setName(value: T): Self = StObject.set(x, "name", value.asInstanceOf[js.Any])
      
      inline def setSpread(value: Boolean): Self = StObject.set(x, "spread", value.asInstanceOf[js.Any])
      
      inline def setSpreadUndefined: Self = StObject.set(x, "spread", js.undefined)
      
      inline def setTags(value: Boolean): Self = StObject.set(x, "tags", value.asInstanceOf[js.Any])
      
      inline def setTagsUndefined: Self = StObject.set(x, "tags", js.undefined)
    }
  }
  
  @js.native
  trait ServerEvents extends Podium[Unit] {
    
    def on(criteria: String, listener: js.Function1[/* value */ Any, Unit]): this.type = js.native
    def on(criteria: ServerEventCriteria[String], listener: js.Function1[/* value */ Any, Unit]): this.type = js.native
    @JSName("on")
    def on_log(criteria: log, listener: LogEventHandler): this.type = js.native
    /**
      * Subscribe to an event where:
      * @param criteria - the subscription criteria which must be one of:
      * * event name string which can be any of the built-in server events
      * * a custom application event registered with server.event().
      * * a criteria object
      * @param listener - the handler method set to receive event updates. The function signature depends on the event argument, and the spread and tags options.
      * @return Return value: none.
      * [See docs](https://github.com/hapijs/hapi/blob/master/API.md#-servereventsoncriteria-listener)
      * See ['log' event](https://github.com/hapijs/hapi/blob/master/API.md#-log-event)
      * See ['request' event](https://github.com/hapijs/hapi/blob/master/API.md#-request-event)
      * See ['response' event](https://github.com/hapijs/hapi/blob/master/API.md#-response-event)
      * See ['route' event](https://github.com/hapijs/hapi/blob/master/API.md#-route-event)
      * See ['start' event](https://github.com/hapijs/hapi/blob/master/API.md#-start-event)
      * See ['stop' event](https://github.com/hapijs/hapi/blob/master/API.md#-stop-event)
      */
    @JSName("on")
    def on_log(criteria: ServerEventCriteria[log], listener: LogEventHandler): this.type = js.native
    @JSName("on")
    def on_request(criteria: request, listener: RequestEventHandler): this.type = js.native
    @JSName("on")
    def on_request(criteria: ServerEventCriteria[request], listener: RequestEventHandler): this.type = js.native
    @JSName("on")
    def on_response(criteria: response, listener: ResponseEventHandler): this.type = js.native
    @JSName("on")
    def on_response(criteria: ServerEventCriteria[response], listener: ResponseEventHandler): this.type = js.native
    @JSName("on")
    def on_route(criteria: route, listener: RouteEventHandler): this.type = js.native
    @JSName("on")
    def on_route(criteria: ServerEventCriteria[route], listener: RouteEventHandler): this.type = js.native
    @JSName("on")
    def on_start(criteria: start, listener: StartEventHandler): this.type = js.native
    @JSName("on")
    def on_start(criteria: ServerEventCriteria[start], listener: StartEventHandler): this.type = js.native
    @JSName("on")
    def on_stop(criteria: stop, listener: StopEventHandler): this.type = js.native
    @JSName("on")
    def on_stop(criteria: ServerEventCriteria[stop], listener: StopEventHandler): this.type = js.native
    
    /**
      * Same as calling server.events.on() with the count option set to 1.
      * @param criteria - the subscription criteria which must be one of:
      * * event name string which can be any of the built-in server events
      * * a custom application event registered with server.event().
      * * a criteria object
      * @return Return value: a promise that resolves when the event is emitted.
      * [See docs](https://github.com/hapijs/hapi/blob/master/API.md#-await-servereventsoncecriteria)
      */
    def once(criteria: String): js.Promise[Any] = js.native
    def once(criteria: ServerEventCriteria[String]): js.Promise[Any] = js.native
    @JSName("once")
    def once_log(criteria: log, listener: LogEventHandler): this.type = js.native
    /**
      * Same as calling [server.events.on()](https://github.com/hapijs/hapi/blob/master/API.md#server.events.on()) with the count option set to 1.
      * @param criteria - the subscription criteria which must be one of:
      * * event name string which can be any of the built-in server events
      * * a custom application event registered with server.event().
      * * a criteria object
      * @param listener - the handler method set to receive event updates. The function signature depends on the event argument, and the spread and tags options.
      * @return Return value: none.
      * [See docs](https://github.com/hapijs/hapi/blob/master/API.md#-servereventsoncecriteria-listener)
      */
    @JSName("once")
    def once_log(criteria: ServerEventCriteria[log], listener: LogEventHandler): this.type = js.native
    @JSName("once")
    def once_request(criteria: request, listener: RequestEventHandler): this.type = js.native
    @JSName("once")
    def once_request(criteria: ServerEventCriteria[request], listener: RequestEventHandler): this.type = js.native
    @JSName("once")
    def once_response(criteria: response, listener: ResponseEventHandler): this.type = js.native
    @JSName("once")
    def once_response(criteria: ServerEventCriteria[response], listener: ResponseEventHandler): this.type = js.native
    @JSName("once")
    def once_route(criteria: route, listener: RouteEventHandler): this.type = js.native
    @JSName("once")
    def once_route(criteria: ServerEventCriteria[route], listener: RouteEventHandler): this.type = js.native
    @JSName("once")
    def once_start(criteria: start, listener: StartEventHandler): this.type = js.native
    @JSName("once")
    def once_start(criteria: ServerEventCriteria[start], listener: StartEventHandler): this.type = js.native
    @JSName("once")
    def once_stop(criteria: stop, listener: StopEventHandler): this.type = js.native
    @JSName("once")
    def once_stop(criteria: ServerEventCriteria[stop], listener: StopEventHandler): this.type = js.native
  }
  
  type ServerEventsApplication = String | ServerEventsApplicationObject | Podium[Unit]
  
  trait ServerEventsApplicationObject extends StObject {
    
    /** a string or array of strings specifying the event channels available. Defaults to no channel restrictions (event updates can specify a channel or not). */
    var channels: js.UndefOr[String | js.Array[String]] = js.undefined
    
    /**
      * if true, the data object passed to server.events.emit() is cloned before it is passed to the listeners (unless an override specified by each listener). Defaults to false (data is passed as-is).
      */
    @JSName("clone")
    var clone_FServerEventsApplicationObject: js.UndefOr[Boolean] = js.undefined
    
    /** the event name string (required). */
    var name: String
    
    /**
      * if true, the same event name can be registered multiple times where the second registration is ignored. Note that if the registration config is changed between registrations, only the first
      * configuration is used. Defaults to false (a duplicate registration will throw an error).
      */
    var shared: js.UndefOr[Boolean] = js.undefined
    
    /**
      * if true, the data object passed to server.event.emit() must be an array and the listener method is called with each array element passed as a separate argument (unless an override specified
      * by each listener). This should only be used when the emitted data structure is known and predictable. Defaults to false (data is emitted as a single argument regardless of its type).
      */
    var spread: js.UndefOr[Boolean] = js.undefined
    
    /**
      * if true and the criteria object passed to server.event.emit() includes tags, the tags are mapped to an object (where each tag string is the key and the value is true) which is appended to
      * the arguments list at the end. A configuration override can be set by each listener. Defaults to false.
      */
    var tags: js.UndefOr[Boolean] = js.undefined
  }
  object ServerEventsApplicationObject {
    
    inline def apply(name: String): ServerEventsApplicationObject = {
      val __obj = js.Dynamic.literal(name = name.asInstanceOf[js.Any])
      __obj.asInstanceOf[ServerEventsApplicationObject]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: ServerEventsApplicationObject] (val x: Self) extends AnyVal {
      
      inline def setChannels(value: String | js.Array[String]): Self = StObject.set(x, "channels", value.asInstanceOf[js.Any])
      
      inline def setChannelsUndefined: Self = StObject.set(x, "channels", js.undefined)
      
      inline def setChannelsVarargs(value: String*): Self = StObject.set(x, "channels", js.Array(value*))
      
      inline def setClone_(value: Boolean): Self = StObject.set(x, "clone", value.asInstanceOf[js.Any])
      
      inline def setClone_Undefined: Self = StObject.set(x, "clone", js.undefined)
      
      inline def setName(value: String): Self = StObject.set(x, "name", value.asInstanceOf[js.Any])
      
      inline def setShared(value: Boolean): Self = StObject.set(x, "shared", value.asInstanceOf[js.Any])
      
      inline def setSharedUndefined: Self = StObject.set(x, "shared", js.undefined)
      
      inline def setSpread(value: Boolean): Self = StObject.set(x, "spread", value.asInstanceOf[js.Any])
      
      inline def setSpreadUndefined: Self = StObject.set(x, "spread", js.undefined)
      
      inline def setTags(value: Boolean): Self = StObject.set(x, "tags", value.asInstanceOf[js.Any])
      
      inline def setTagsUndefined: Self = StObject.set(x, "tags", js.undefined)
    }
  }
  
  type StartEventHandler = js.Function0[Unit]
  
  type StopEventHandler = js.Function0[Unit]
}
