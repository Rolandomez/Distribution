package typings.vueCompilerCore.mod

import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}


@scala.inline
def BASE_TRANSITION: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("BASE_TRANSITION").asInstanceOf[js.Symbol]

@scala.inline
def CAMELIZE: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("CAMELIZE").asInstanceOf[js.Symbol]

@scala.inline
def CAPITALIZE: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("CAPITALIZE").asInstanceOf[js.Symbol]

@scala.inline
def CREATE_BLOCK: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("CREATE_BLOCK").asInstanceOf[js.Symbol]

@scala.inline
def CREATE_COMMENT: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("CREATE_COMMENT").asInstanceOf[js.Symbol]

@scala.inline
def CREATE_SLOTS: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("CREATE_SLOTS").asInstanceOf[js.Symbol]

@scala.inline
def CREATE_STATIC: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("CREATE_STATIC").asInstanceOf[js.Symbol]

@scala.inline
def CREATE_TEXT: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("CREATE_TEXT").asInstanceOf[js.Symbol]

@scala.inline
def CREATE_VNODE: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("CREATE_VNODE").asInstanceOf[js.Symbol]

@scala.inline
def FRAGMENT: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("FRAGMENT").asInstanceOf[js.Symbol]

@scala.inline
def KEEP_ALIVE: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("KEEP_ALIVE").asInstanceOf[js.Symbol]

@scala.inline
def MERGE_PROPS: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("MERGE_PROPS").asInstanceOf[js.Symbol]

@scala.inline
def OPEN_BLOCK: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("OPEN_BLOCK").asInstanceOf[js.Symbol]

@scala.inline
def POP_SCOPE_ID: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("POP_SCOPE_ID").asInstanceOf[js.Symbol]

@scala.inline
def PUSH_SCOPE_ID: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("PUSH_SCOPE_ID").asInstanceOf[js.Symbol]

@scala.inline
def RENDER_LIST: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("RENDER_LIST").asInstanceOf[js.Symbol]

@scala.inline
def RENDER_SLOT: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("RENDER_SLOT").asInstanceOf[js.Symbol]

@scala.inline
def RESOLVE_COMPONENT: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("RESOLVE_COMPONENT").asInstanceOf[js.Symbol]

@scala.inline
def RESOLVE_DIRECTIVE: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("RESOLVE_DIRECTIVE").asInstanceOf[js.Symbol]

@scala.inline
def RESOLVE_DYNAMIC_COMPONENT: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("RESOLVE_DYNAMIC_COMPONENT").asInstanceOf[js.Symbol]

@scala.inline
def SET_BLOCK_TRACKING: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SET_BLOCK_TRACKING").asInstanceOf[js.Symbol]

@scala.inline
def SUSPENSE: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUSPENSE").asInstanceOf[js.Symbol]

@scala.inline
def TELEPORT: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("TELEPORT").asInstanceOf[js.Symbol]

@scala.inline
def TO_DISPLAY_STRING: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("TO_DISPLAY_STRING").asInstanceOf[js.Symbol]

@scala.inline
def TO_HANDLERS: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("TO_HANDLERS").asInstanceOf[js.Symbol]

@scala.inline
def TO_HANDLER_KEY: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("TO_HANDLER_KEY").asInstanceOf[js.Symbol]

@scala.inline
def WITH_CTX: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("WITH_CTX").asInstanceOf[js.Symbol]

@scala.inline
def WITH_DIRECTIVES: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("WITH_DIRECTIVES").asInstanceOf[js.Symbol]

@scala.inline
def WITH_SCOPE_ID: js.Symbol = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("WITH_SCOPE_ID").asInstanceOf[js.Symbol]

@scala.inline
def advancePositionWithClone(pos: typings.vueCompilerCore.mod.Position2, source: java.lang.String): typings.vueCompilerCore.mod.Position2 = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("advancePositionWithClone")(pos.asInstanceOf[js.Any], source.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.Position2]
@scala.inline
def advancePositionWithClone(
  pos: typings.vueCompilerCore.mod.Position2,
  source: java.lang.String,
  numberOfCharacters: scala.Double
): typings.vueCompilerCore.mod.Position2 = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("advancePositionWithClone")(pos.asInstanceOf[js.Any], source.asInstanceOf[js.Any], numberOfCharacters.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.Position2]

@scala.inline
def advancePositionWithMutation(pos: typings.vueCompilerCore.mod.Position2, source: java.lang.String): typings.vueCompilerCore.mod.Position2 = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("advancePositionWithMutation")(pos.asInstanceOf[js.Any], source.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.Position2]
@scala.inline
def advancePositionWithMutation(
  pos: typings.vueCompilerCore.mod.Position2,
  source: java.lang.String,
  numberOfCharacters: scala.Double
): typings.vueCompilerCore.mod.Position2 = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("advancePositionWithMutation")(pos.asInstanceOf[js.Any], source.asInstanceOf[js.Any], numberOfCharacters.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.Position2]

@scala.inline
def assert(condition: scala.Boolean): scala.Unit = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("assert")(condition.asInstanceOf[js.Any]).asInstanceOf[scala.Unit]
@scala.inline
def assert(condition: scala.Boolean, msg: java.lang.String): scala.Unit = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("assert")(condition.asInstanceOf[js.Any], msg.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]

@scala.inline
def baseCompile(template: java.lang.String): typings.vueCompilerCore.mod.CodegenResult = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("baseCompile")(template.asInstanceOf[js.Any]).asInstanceOf[typings.vueCompilerCore.mod.CodegenResult]
@scala.inline
def baseCompile(template: java.lang.String, options: typings.vueCompilerCore.mod.CompilerOptions): typings.vueCompilerCore.mod.CodegenResult = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("baseCompile")(template.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.CodegenResult]
@scala.inline
def baseCompile(template: typings.vueCompilerCore.mod.RootNode): typings.vueCompilerCore.mod.CodegenResult = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("baseCompile")(template.asInstanceOf[js.Any]).asInstanceOf[typings.vueCompilerCore.mod.CodegenResult]
@scala.inline
def baseCompile(
  template: typings.vueCompilerCore.mod.RootNode,
  options: typings.vueCompilerCore.mod.CompilerOptions
): typings.vueCompilerCore.mod.CodegenResult = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("baseCompile")(template.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.CodegenResult]

@scala.inline
def baseParse(content: java.lang.String): typings.vueCompilerCore.mod.RootNode = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("baseParse")(content.asInstanceOf[js.Any]).asInstanceOf[typings.vueCompilerCore.mod.RootNode]
@scala.inline
def baseParse(content: java.lang.String, options: typings.vueCompilerCore.mod.ParserOptions): typings.vueCompilerCore.mod.RootNode = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("baseParse")(content.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.RootNode]

@scala.inline
def buildProps(
  node: typings.vueCompilerCore.mod.ElementNode,
  context: typings.vueCompilerCore.mod.TransformContext
): typings.vueCompilerCore.anon.Directives = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("buildProps")(node.asInstanceOf[js.Any], context.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.anon.Directives]
@scala.inline
def buildProps(
  node: typings.vueCompilerCore.mod.ElementNode,
  context: typings.vueCompilerCore.mod.TransformContext,
  props: js.Array[
  typings.vueCompilerCore.mod.AttributeNode | typings.vueCompilerCore.mod.DirectiveNode
]
): typings.vueCompilerCore.anon.Directives = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("buildProps")(node.asInstanceOf[js.Any], context.asInstanceOf[js.Any], props.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.anon.Directives]
@scala.inline
def buildProps(
  node: typings.vueCompilerCore.mod.ElementNode,
  context: typings.vueCompilerCore.mod.TransformContext,
  props: js.Array[
  typings.vueCompilerCore.mod.AttributeNode | typings.vueCompilerCore.mod.DirectiveNode
],
  ssr: scala.Boolean
): typings.vueCompilerCore.anon.Directives = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("buildProps")(node.asInstanceOf[js.Any], context.asInstanceOf[js.Any], props.asInstanceOf[js.Any], ssr.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.anon.Directives]
@scala.inline
def buildProps(
  node: typings.vueCompilerCore.mod.ElementNode,
  context: typings.vueCompilerCore.mod.TransformContext,
  props: scala.Unit,
  ssr: scala.Boolean
): typings.vueCompilerCore.anon.Directives = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("buildProps")(node.asInstanceOf[js.Any], context.asInstanceOf[js.Any], props.asInstanceOf[js.Any], ssr.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.anon.Directives]

@scala.inline
def buildSlots(
  node: typings.vueCompilerCore.mod.ElementNode,
  context: typings.vueCompilerCore.mod.TransformContext
): typings.vueCompilerCore.anon.HasDynamicSlots = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("buildSlots")(node.asInstanceOf[js.Any], context.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.anon.HasDynamicSlots]
@scala.inline
def buildSlots(
  node: typings.vueCompilerCore.mod.ElementNode,
  context: typings.vueCompilerCore.mod.TransformContext,
  buildSlotFn: typings.vueCompilerCore.mod.SlotFnBuilder
): typings.vueCompilerCore.anon.HasDynamicSlots = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("buildSlots")(node.asInstanceOf[js.Any], context.asInstanceOf[js.Any], buildSlotFn.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.anon.HasDynamicSlots]

@scala.inline
def createArrayExpression(elements: js.Array[java.lang.String | typings.vueCompilerCore.mod.JSChildNode]): typings.vueCompilerCore.mod.ArrayExpression = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createArrayExpression")(elements.asInstanceOf[js.Any]).asInstanceOf[typings.vueCompilerCore.mod.ArrayExpression]
@scala.inline
def createArrayExpression(
  elements: js.Array[java.lang.String | typings.vueCompilerCore.mod.JSChildNode],
  loc: typings.vueCompilerCore.mod.SourceLocation
): typings.vueCompilerCore.mod.ArrayExpression = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createArrayExpression")(elements.asInstanceOf[js.Any], loc.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.ArrayExpression]

@scala.inline
def createAssignmentExpression(
  left: typings.vueCompilerCore.mod.SimpleExpressionNode,
  right: typings.vueCompilerCore.mod.JSChildNode
): typings.vueCompilerCore.mod.AssignmentExpression = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createAssignmentExpression")(left.asInstanceOf[js.Any], right.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.AssignmentExpression]

@scala.inline
def createBlockStatement(
  body: js.Array[
  typings.vueCompilerCore.mod.JSChildNode | typings.vueCompilerCore.mod.IfStatement
]
): typings.vueCompilerCore.mod.BlockStatement = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createBlockStatement")(body.asInstanceOf[js.Any]).asInstanceOf[typings.vueCompilerCore.mod.BlockStatement]

@scala.inline
def createCacheExpression(index: scala.Double, value: typings.vueCompilerCore.mod.JSChildNode): typings.vueCompilerCore.mod.CacheExpression = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createCacheExpression")(index.asInstanceOf[js.Any], value.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.CacheExpression]
@scala.inline
def createCacheExpression(index: scala.Double, value: typings.vueCompilerCore.mod.JSChildNode, isVNode: scala.Boolean): typings.vueCompilerCore.mod.CacheExpression = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createCacheExpression")(index.asInstanceOf[js.Any], value.asInstanceOf[js.Any], isVNode.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.CacheExpression]

@scala.inline
def createCallExpression[T /* <: java.lang.String | js.Symbol */](callee: T): typings.vueCompilerCore.mod.InferCodegenNodeType[T] = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createCallExpression")(callee.asInstanceOf[js.Any]).asInstanceOf[typings.vueCompilerCore.mod.InferCodegenNodeType[T]]
@scala.inline
def createCallExpression[T /* <: java.lang.String | js.Symbol */](
  callee: T,
  args: js.Array[
  java.lang.String | js.Symbol | typings.vueCompilerCore.mod.JSChildNode | typings.vueCompilerCore.mod.SSRCodegenNode | typings.vueCompilerCore.mod.TemplateChildNode | js.Array[typings.vueCompilerCore.mod.TemplateChildNode]
]
): typings.vueCompilerCore.mod.InferCodegenNodeType[T] = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createCallExpression")(callee.asInstanceOf[js.Any], args.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.InferCodegenNodeType[T]]
@scala.inline
def createCallExpression[T /* <: java.lang.String | js.Symbol */](
  callee: T,
  args: js.Array[
  java.lang.String | js.Symbol | typings.vueCompilerCore.mod.JSChildNode | typings.vueCompilerCore.mod.SSRCodegenNode | typings.vueCompilerCore.mod.TemplateChildNode | js.Array[typings.vueCompilerCore.mod.TemplateChildNode]
],
  loc: typings.vueCompilerCore.mod.SourceLocation
): typings.vueCompilerCore.mod.InferCodegenNodeType[T] = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createCallExpression")(callee.asInstanceOf[js.Any], args.asInstanceOf[js.Any], loc.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.InferCodegenNodeType[T]]
@scala.inline
def createCallExpression[T /* <: java.lang.String | js.Symbol */](callee: T, args: scala.Unit, loc: typings.vueCompilerCore.mod.SourceLocation): typings.vueCompilerCore.mod.InferCodegenNodeType[T] = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createCallExpression")(callee.asInstanceOf[js.Any], args.asInstanceOf[js.Any], loc.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.InferCodegenNodeType[T]]

@scala.inline
def createCompilerError[T /* <: scala.Double */](code: T): typings.vueCompilerCore.mod.CompilerError | typings.vueCompilerCore.mod.CoreCompilerError = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createCompilerError")(code.asInstanceOf[js.Any]).asInstanceOf[typings.vueCompilerCore.mod.CompilerError | typings.vueCompilerCore.mod.CoreCompilerError]
@scala.inline
def createCompilerError[T /* <: scala.Double */](code: T, loc: scala.Unit, messages: org.scalablytyped.runtime.NumberDictionary[java.lang.String]): typings.vueCompilerCore.mod.CompilerError | typings.vueCompilerCore.mod.CoreCompilerError = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createCompilerError")(code.asInstanceOf[js.Any], loc.asInstanceOf[js.Any], messages.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.CompilerError | typings.vueCompilerCore.mod.CoreCompilerError]
@scala.inline
def createCompilerError[T /* <: scala.Double */](
  code: T,
  loc: scala.Unit,
  messages: org.scalablytyped.runtime.NumberDictionary[java.lang.String],
  additionalMessage: java.lang.String
): typings.vueCompilerCore.mod.CompilerError | typings.vueCompilerCore.mod.CoreCompilerError = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createCompilerError")(code.asInstanceOf[js.Any], loc.asInstanceOf[js.Any], messages.asInstanceOf[js.Any], additionalMessage.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.CompilerError | typings.vueCompilerCore.mod.CoreCompilerError]
@scala.inline
def createCompilerError[T /* <: scala.Double */](code: T, loc: scala.Unit, messages: scala.Unit, additionalMessage: java.lang.String): typings.vueCompilerCore.mod.CompilerError | typings.vueCompilerCore.mod.CoreCompilerError = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createCompilerError")(code.asInstanceOf[js.Any], loc.asInstanceOf[js.Any], messages.asInstanceOf[js.Any], additionalMessage.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.CompilerError | typings.vueCompilerCore.mod.CoreCompilerError]
@scala.inline
def createCompilerError[T /* <: scala.Double */](code: T, loc: typings.vueCompilerCore.mod.SourceLocation): typings.vueCompilerCore.mod.CompilerError | typings.vueCompilerCore.mod.CoreCompilerError = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createCompilerError")(code.asInstanceOf[js.Any], loc.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.CompilerError | typings.vueCompilerCore.mod.CoreCompilerError]
@scala.inline
def createCompilerError[T /* <: scala.Double */](
  code: T,
  loc: typings.vueCompilerCore.mod.SourceLocation,
  messages: org.scalablytyped.runtime.NumberDictionary[java.lang.String]
): typings.vueCompilerCore.mod.CompilerError | typings.vueCompilerCore.mod.CoreCompilerError = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createCompilerError")(code.asInstanceOf[js.Any], loc.asInstanceOf[js.Any], messages.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.CompilerError | typings.vueCompilerCore.mod.CoreCompilerError]
@scala.inline
def createCompilerError[T /* <: scala.Double */](
  code: T,
  loc: typings.vueCompilerCore.mod.SourceLocation,
  messages: org.scalablytyped.runtime.NumberDictionary[java.lang.String],
  additionalMessage: java.lang.String
): typings.vueCompilerCore.mod.CompilerError | typings.vueCompilerCore.mod.CoreCompilerError = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createCompilerError")(code.asInstanceOf[js.Any], loc.asInstanceOf[js.Any], messages.asInstanceOf[js.Any], additionalMessage.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.CompilerError | typings.vueCompilerCore.mod.CoreCompilerError]
@scala.inline
def createCompilerError[T /* <: scala.Double */](
  code: T,
  loc: typings.vueCompilerCore.mod.SourceLocation,
  messages: scala.Unit,
  additionalMessage: java.lang.String
): typings.vueCompilerCore.mod.CompilerError | typings.vueCompilerCore.mod.CoreCompilerError = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createCompilerError")(code.asInstanceOf[js.Any], loc.asInstanceOf[js.Any], messages.asInstanceOf[js.Any], additionalMessage.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.CompilerError | typings.vueCompilerCore.mod.CoreCompilerError]

@scala.inline
def createCompoundExpression(
  children: js.Array[
  typings.vueCompilerCore.mod.SimpleExpressionNode | typings.vueCompilerCore.mod.CompoundExpressionNode | typings.vueCompilerCore.mod.InterpolationNode | typings.vueCompilerCore.mod.TextNode | java.lang.String | js.Symbol
]
): typings.vueCompilerCore.mod.CompoundExpressionNode = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createCompoundExpression")(children.asInstanceOf[js.Any]).asInstanceOf[typings.vueCompilerCore.mod.CompoundExpressionNode]
@scala.inline
def createCompoundExpression(
  children: js.Array[
  typings.vueCompilerCore.mod.SimpleExpressionNode | typings.vueCompilerCore.mod.CompoundExpressionNode | typings.vueCompilerCore.mod.InterpolationNode | typings.vueCompilerCore.mod.TextNode | java.lang.String | js.Symbol
],
  loc: typings.vueCompilerCore.mod.SourceLocation
): typings.vueCompilerCore.mod.CompoundExpressionNode = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createCompoundExpression")(children.asInstanceOf[js.Any], loc.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.CompoundExpressionNode]

@scala.inline
def createConditionalExpression(
  test: typings.vueCompilerCore.mod.JSChildNode,
  consequent: typings.vueCompilerCore.mod.JSChildNode,
  alternate: typings.vueCompilerCore.mod.JSChildNode
): typings.vueCompilerCore.mod.ConditionalExpression = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createConditionalExpression")(test.asInstanceOf[js.Any], consequent.asInstanceOf[js.Any], alternate.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.ConditionalExpression]
@scala.inline
def createConditionalExpression(
  test: typings.vueCompilerCore.mod.JSChildNode,
  consequent: typings.vueCompilerCore.mod.JSChildNode,
  alternate: typings.vueCompilerCore.mod.JSChildNode,
  newline: scala.Boolean
): typings.vueCompilerCore.mod.ConditionalExpression = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createConditionalExpression")(test.asInstanceOf[js.Any], consequent.asInstanceOf[js.Any], alternate.asInstanceOf[js.Any], newline.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.ConditionalExpression]

@scala.inline
def createForLoopParams(hasValueKeyIndex: typings.vueCompilerCore.mod.ForParseResult): js.Array[typings.vueCompilerCore.mod.ExpressionNode] = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createForLoopParams")(hasValueKeyIndex.asInstanceOf[js.Any]).asInstanceOf[js.Array[typings.vueCompilerCore.mod.ExpressionNode]]

@scala.inline
def createFunctionExpression(
  params: js.UndefOr[
  typings.vueCompilerCore.mod.ExpressionNode | java.lang.String | (js.Array[typings.vueCompilerCore.mod.ExpressionNode | java.lang.String])
],
  returns: js.UndefOr[
  typings.vueCompilerCore.mod.TemplateChildNode | js.Array[typings.vueCompilerCore.mod.TemplateChildNode] | typings.vueCompilerCore.mod.JSChildNode
],
  newline: js.UndefOr[scala.Boolean],
  isSlot: js.UndefOr[scala.Boolean],
  loc: js.UndefOr[typings.vueCompilerCore.mod.SourceLocation]
): typings.vueCompilerCore.mod.FunctionExpression = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createFunctionExpression")(params.asInstanceOf[js.Any], returns.asInstanceOf[js.Any], newline.asInstanceOf[js.Any], isSlot.asInstanceOf[js.Any], loc.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.FunctionExpression]

@scala.inline
def createIfStatement(
  test: typings.vueCompilerCore.mod.ExpressionNode,
  consequent: typings.vueCompilerCore.mod.BlockStatement
): typings.vueCompilerCore.mod.IfStatement = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createIfStatement")(test.asInstanceOf[js.Any], consequent.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.IfStatement]
@scala.inline
def createIfStatement(
  test: typings.vueCompilerCore.mod.ExpressionNode,
  consequent: typings.vueCompilerCore.mod.BlockStatement,
  alternate: js.UndefOr[
  typings.vueCompilerCore.mod.IfStatement | typings.vueCompilerCore.mod.BlockStatement | typings.vueCompilerCore.mod.ReturnStatement
]
): typings.vueCompilerCore.mod.IfStatement = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createIfStatement")(test.asInstanceOf[js.Any], consequent.asInstanceOf[js.Any], alternate.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.IfStatement]

@scala.inline
def createInterpolation(content: java.lang.String, loc: typings.vueCompilerCore.mod.SourceLocation): typings.vueCompilerCore.mod.InterpolationNode = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createInterpolation")(content.asInstanceOf[js.Any], loc.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.InterpolationNode]
@scala.inline
def createInterpolation(
  content: typings.vueCompilerCore.mod.ExpressionNode,
  loc: typings.vueCompilerCore.mod.SourceLocation
): typings.vueCompilerCore.mod.InterpolationNode = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createInterpolation")(content.asInstanceOf[js.Any], loc.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.InterpolationNode]

@scala.inline
def createObjectExpression(properties: js.Array[typings.vueCompilerCore.mod.Property]): typings.vueCompilerCore.mod.ObjectExpression = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createObjectExpression")(properties.asInstanceOf[js.Any]).asInstanceOf[typings.vueCompilerCore.mod.ObjectExpression]
@scala.inline
def createObjectExpression(
  properties: js.Array[typings.vueCompilerCore.mod.Property],
  loc: typings.vueCompilerCore.mod.SourceLocation
): typings.vueCompilerCore.mod.ObjectExpression = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createObjectExpression")(properties.asInstanceOf[js.Any], loc.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.ObjectExpression]

@scala.inline
def createObjectProperty(key: java.lang.String, value: typings.vueCompilerCore.mod.JSChildNode): typings.vueCompilerCore.mod.Property = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createObjectProperty")(key.asInstanceOf[js.Any], value.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.Property]
@scala.inline
def createObjectProperty(key: typings.vueCompilerCore.mod.ExpressionNode, value: typings.vueCompilerCore.mod.JSChildNode): typings.vueCompilerCore.mod.Property = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createObjectProperty")(key.asInstanceOf[js.Any], value.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.Property]

@scala.inline
def createReturnStatement(returns: js.Array[typings.vueCompilerCore.mod.TemplateChildNode]): typings.vueCompilerCore.mod.ReturnStatement = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createReturnStatement")(returns.asInstanceOf[js.Any]).asInstanceOf[typings.vueCompilerCore.mod.ReturnStatement]
@scala.inline
def createReturnStatement(returns: typings.vueCompilerCore.mod.JSChildNode): typings.vueCompilerCore.mod.ReturnStatement = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createReturnStatement")(returns.asInstanceOf[js.Any]).asInstanceOf[typings.vueCompilerCore.mod.ReturnStatement]
@scala.inline
def createReturnStatement(returns: typings.vueCompilerCore.mod.TemplateChildNode): typings.vueCompilerCore.mod.ReturnStatement = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createReturnStatement")(returns.asInstanceOf[js.Any]).asInstanceOf[typings.vueCompilerCore.mod.ReturnStatement]

@scala.inline
def createRoot(children: js.Array[typings.vueCompilerCore.mod.TemplateChildNode]): typings.vueCompilerCore.mod.RootNode = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createRoot")(children.asInstanceOf[js.Any]).asInstanceOf[typings.vueCompilerCore.mod.RootNode]
@scala.inline
def createRoot(
  children: js.Array[typings.vueCompilerCore.mod.TemplateChildNode],
  loc: typings.vueCompilerCore.mod.SourceLocation
): typings.vueCompilerCore.mod.RootNode = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createRoot")(children.asInstanceOf[js.Any], loc.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.RootNode]

@scala.inline
def createSequenceExpression(expressions: js.Array[typings.vueCompilerCore.mod.JSChildNode]): typings.vueCompilerCore.mod.SequenceExpression = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createSequenceExpression")(expressions.asInstanceOf[js.Any]).asInstanceOf[typings.vueCompilerCore.mod.SequenceExpression]

@scala.inline
def createSimpleExpression(content: java.lang.String, isStatic: scala.Boolean): typings.vueCompilerCore.mod.SimpleExpressionNode = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createSimpleExpression")(content.asInstanceOf[js.Any], isStatic.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.SimpleExpressionNode]
@scala.inline
def createSimpleExpression(content: java.lang.String, isStatic: scala.Boolean, loc: scala.Unit, isConstant: scala.Boolean): typings.vueCompilerCore.mod.SimpleExpressionNode = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createSimpleExpression")(content.asInstanceOf[js.Any], isStatic.asInstanceOf[js.Any], loc.asInstanceOf[js.Any], isConstant.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.SimpleExpressionNode]
@scala.inline
def createSimpleExpression(
  content: java.lang.String,
  isStatic: scala.Boolean,
  loc: typings.vueCompilerCore.mod.SourceLocation
): typings.vueCompilerCore.mod.SimpleExpressionNode = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createSimpleExpression")(content.asInstanceOf[js.Any], isStatic.asInstanceOf[js.Any], loc.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.SimpleExpressionNode]
@scala.inline
def createSimpleExpression(
  content: java.lang.String,
  isStatic: scala.Boolean,
  loc: typings.vueCompilerCore.mod.SourceLocation,
  isConstant: scala.Boolean
): typings.vueCompilerCore.mod.SimpleExpressionNode = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createSimpleExpression")(content.asInstanceOf[js.Any], isStatic.asInstanceOf[js.Any], loc.asInstanceOf[js.Any], isConstant.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.SimpleExpressionNode]

@scala.inline
def createStructuralDirectiveTransform(name: java.lang.String, fn: typings.vueCompilerCore.mod.StructuralDirectiveTransform): typings.vueCompilerCore.mod.NodeTransform = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createStructuralDirectiveTransform")(name.asInstanceOf[js.Any], fn.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.NodeTransform]
@scala.inline
def createStructuralDirectiveTransform(name: typings.std.RegExp, fn: typings.vueCompilerCore.mod.StructuralDirectiveTransform): typings.vueCompilerCore.mod.NodeTransform = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createStructuralDirectiveTransform")(name.asInstanceOf[js.Any], fn.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.NodeTransform]

@scala.inline
def createTemplateLiteral(elements: js.Array[java.lang.String | typings.vueCompilerCore.mod.JSChildNode]): typings.vueCompilerCore.mod.TemplateLiteral = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createTemplateLiteral")(elements.asInstanceOf[js.Any]).asInstanceOf[typings.vueCompilerCore.mod.TemplateLiteral]

@scala.inline
def createTransformContext(
  root: typings.vueCompilerCore.mod.RootNode,
  hasPrefixIdentifiersHoistStaticCacheHandlersNodeTransformsDirectiveTransformsTransformHoistIsBuiltInComponentIsCustomElementExpressionPluginsScopeIdSsrSsrCssVarsBindingMetadataOnError: typings.vueCompilerCore.mod.TransformOptions
): typings.vueCompilerCore.mod.TransformContext = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createTransformContext")(root.asInstanceOf[js.Any], hasPrefixIdentifiersHoistStaticCacheHandlersNodeTransformsDirectiveTransformsTransformHoistIsBuiltInComponentIsCustomElementExpressionPluginsScopeIdSsrSsrCssVarsBindingMetadataOnError.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.TransformContext]

@scala.inline
def createVNodeCall(
  context: typings.vueCompilerCore.mod.TransformContext | scala.Null,
  tag: java.lang.String | js.Symbol | typings.vueCompilerCore.mod.CallExpression,
  props: js.UndefOr[typings.vueCompilerCore.mod.PropsExpression],
  children: js.UndefOr[
  js.Array[typings.vueCompilerCore.mod.TemplateChildNode] | typings.vueCompilerCore.mod.TemplateTextChildNode | typings.vueCompilerCore.mod.SlotsExpression | typings.vueCompilerCore.mod.ForRenderListExpression
],
  patchFlag: js.UndefOr[java.lang.String],
  dynamicProps: js.UndefOr[java.lang.String],
  directives: js.UndefOr[typings.vueCompilerCore.mod.DirectiveArguments],
  isBlock: js.UndefOr[scala.Boolean],
  disableTracking: js.UndefOr[scala.Boolean],
  loc: js.UndefOr[typings.vueCompilerCore.mod.SourceLocation]
): typings.vueCompilerCore.mod.VNodeCall = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createVNodeCall")(context.asInstanceOf[js.Any], tag.asInstanceOf[js.Any], props.asInstanceOf[js.Any], children.asInstanceOf[js.Any], patchFlag.asInstanceOf[js.Any], dynamicProps.asInstanceOf[js.Any], directives.asInstanceOf[js.Any], isBlock.asInstanceOf[js.Any], disableTracking.asInstanceOf[js.Any], loc.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.VNodeCall]

@scala.inline
def findDir(node: typings.vueCompilerCore.mod.ElementNode, name: java.lang.String): js.UndefOr[typings.vueCompilerCore.mod.DirectiveNode] = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("findDir")(node.asInstanceOf[js.Any], name.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[typings.vueCompilerCore.mod.DirectiveNode]]
@scala.inline
def findDir(node: typings.vueCompilerCore.mod.ElementNode, name: java.lang.String, allowEmpty: scala.Boolean): js.UndefOr[typings.vueCompilerCore.mod.DirectiveNode] = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("findDir")(node.asInstanceOf[js.Any], name.asInstanceOf[js.Any], allowEmpty.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[typings.vueCompilerCore.mod.DirectiveNode]]
@scala.inline
def findDir(node: typings.vueCompilerCore.mod.ElementNode, name: typings.std.RegExp): js.UndefOr[typings.vueCompilerCore.mod.DirectiveNode] = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("findDir")(node.asInstanceOf[js.Any], name.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[typings.vueCompilerCore.mod.DirectiveNode]]
@scala.inline
def findDir(node: typings.vueCompilerCore.mod.ElementNode, name: typings.std.RegExp, allowEmpty: scala.Boolean): js.UndefOr[typings.vueCompilerCore.mod.DirectiveNode] = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("findDir")(node.asInstanceOf[js.Any], name.asInstanceOf[js.Any], allowEmpty.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[typings.vueCompilerCore.mod.DirectiveNode]]

@scala.inline
def findProp(node: typings.vueCompilerCore.mod.ElementNode, name: java.lang.String): js.UndefOr[
/* import warning: importer.ImportType#apply Failed type conversion: std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode>[0] */ js.Any] = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("findProp")(node.asInstanceOf[js.Any], name.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[
/* import warning: importer.ImportType#apply Failed type conversion: std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode>[0] */ js.Any]]
@scala.inline
def findProp(node: typings.vueCompilerCore.mod.ElementNode, name: java.lang.String, dynamicOnly: scala.Boolean): js.UndefOr[
/* import warning: importer.ImportType#apply Failed type conversion: std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode>[0] */ js.Any] = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("findProp")(node.asInstanceOf[js.Any], name.asInstanceOf[js.Any], dynamicOnly.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[
/* import warning: importer.ImportType#apply Failed type conversion: std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode>[0] */ js.Any]]
@scala.inline
def findProp(
  node: typings.vueCompilerCore.mod.ElementNode,
  name: java.lang.String,
  dynamicOnly: scala.Boolean,
  allowEmpty: scala.Boolean
): js.UndefOr[
/* import warning: importer.ImportType#apply Failed type conversion: std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode>[0] */ js.Any] = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("findProp")(node.asInstanceOf[js.Any], name.asInstanceOf[js.Any], dynamicOnly.asInstanceOf[js.Any], allowEmpty.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[
/* import warning: importer.ImportType#apply Failed type conversion: std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode>[0] */ js.Any]]
@scala.inline
def findProp(
  node: typings.vueCompilerCore.mod.ElementNode,
  name: java.lang.String,
  dynamicOnly: scala.Unit,
  allowEmpty: scala.Boolean
): js.UndefOr[
/* import warning: importer.ImportType#apply Failed type conversion: std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode>[0] */ js.Any] = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("findProp")(node.asInstanceOf[js.Any], name.asInstanceOf[js.Any], dynamicOnly.asInstanceOf[js.Any], allowEmpty.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[
/* import warning: importer.ImportType#apply Failed type conversion: std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode>[0] */ js.Any]]

@scala.inline
def generate(ast: typings.vueCompilerCore.mod.RootNode): typings.vueCompilerCore.mod.CodegenResult = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("generate")(ast.asInstanceOf[js.Any]).asInstanceOf[typings.vueCompilerCore.mod.CodegenResult]
@scala.inline
def generate(
  ast: typings.vueCompilerCore.mod.RootNode,
  options: typings.vueCompilerCore.anon.CodegenOptionsonContextCr
): typings.vueCompilerCore.mod.CodegenResult = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("generate")(ast.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.CodegenResult]

@scala.inline
def generateCodeFrame(source: java.lang.String): java.lang.String = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("generateCodeFrame")(source.asInstanceOf[js.Any]).asInstanceOf[java.lang.String]
@scala.inline
def generateCodeFrame(source: java.lang.String, start: scala.Double): java.lang.String = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("generateCodeFrame")(source.asInstanceOf[js.Any], start.asInstanceOf[js.Any])).asInstanceOf[java.lang.String]
@scala.inline
def generateCodeFrame(source: java.lang.String, start: scala.Double, end: scala.Double): java.lang.String = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("generateCodeFrame")(source.asInstanceOf[js.Any], start.asInstanceOf[js.Any], end.asInstanceOf[js.Any])).asInstanceOf[java.lang.String]
@scala.inline
def generateCodeFrame(source: java.lang.String, start: scala.Unit, end: scala.Double): java.lang.String = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("generateCodeFrame")(source.asInstanceOf[js.Any], start.asInstanceOf[js.Any], end.asInstanceOf[js.Any])).asInstanceOf[java.lang.String]

@scala.inline
def getBaseTransformPreset(): typings.vueCompilerCore.mod.TransformPreset = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("getBaseTransformPreset")().asInstanceOf[typings.vueCompilerCore.mod.TransformPreset]
@scala.inline
def getBaseTransformPreset(prefixIdentifiers: scala.Boolean): typings.vueCompilerCore.mod.TransformPreset = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("getBaseTransformPreset")(prefixIdentifiers.asInstanceOf[js.Any]).asInstanceOf[typings.vueCompilerCore.mod.TransformPreset]

@scala.inline
def getInnerRange(loc: typings.vueCompilerCore.mod.SourceLocation, offset: scala.Double): typings.vueCompilerCore.mod.SourceLocation = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("getInnerRange")(loc.asInstanceOf[js.Any], offset.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.SourceLocation]
@scala.inline
def getInnerRange(loc: typings.vueCompilerCore.mod.SourceLocation, offset: scala.Double, length: scala.Double): typings.vueCompilerCore.mod.SourceLocation = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("getInnerRange")(loc.asInstanceOf[js.Any], offset.asInstanceOf[js.Any], length.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.SourceLocation]

@scala.inline
def hasDynamicKeyVBind(node: typings.vueCompilerCore.mod.ElementNode): scala.Boolean = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("hasDynamicKeyVBind")(node.asInstanceOf[js.Any]).asInstanceOf[scala.Boolean]

@scala.inline
def hasScopeRef(node: scala.Unit, ids: org.scalablytyped.runtime.StringDictionary[js.UndefOr[scala.Double]]): scala.Boolean = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("hasScopeRef")(node.asInstanceOf[js.Any], ids.asInstanceOf[js.Any])).asInstanceOf[scala.Boolean]
@scala.inline
def hasScopeRef(
  node: typings.vueCompilerCore.mod.ExpressionNode,
  ids: org.scalablytyped.runtime.StringDictionary[js.UndefOr[scala.Double]]
): scala.Boolean = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("hasScopeRef")(node.asInstanceOf[js.Any], ids.asInstanceOf[js.Any])).asInstanceOf[scala.Boolean]
@scala.inline
def hasScopeRef(
  node: typings.vueCompilerCore.mod.IfBranchNode,
  ids: org.scalablytyped.runtime.StringDictionary[js.UndefOr[scala.Double]]
): scala.Boolean = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("hasScopeRef")(node.asInstanceOf[js.Any], ids.asInstanceOf[js.Any])).asInstanceOf[scala.Boolean]
@scala.inline
def hasScopeRef(
  node: typings.vueCompilerCore.mod.TemplateChildNode,
  ids: org.scalablytyped.runtime.StringDictionary[js.UndefOr[scala.Double]]
): scala.Boolean = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("hasScopeRef")(node.asInstanceOf[js.Any], ids.asInstanceOf[js.Any])).asInstanceOf[scala.Boolean]

@scala.inline
def helperNameMap: js.Any = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("helperNameMap").asInstanceOf[js.Any]

@scala.inline
def injectProp(
  node: typings.vueCompilerCore.mod.RenderSlotCall,
  prop: typings.vueCompilerCore.mod.Property,
  context: typings.vueCompilerCore.mod.TransformContext
): scala.Unit = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("injectProp")(node.asInstanceOf[js.Any], prop.asInstanceOf[js.Any], context.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def injectProp(
  node: typings.vueCompilerCore.mod.VNodeCall,
  prop: typings.vueCompilerCore.mod.Property,
  context: typings.vueCompilerCore.mod.TransformContext
): scala.Unit = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("injectProp")(node.asInstanceOf[js.Any], prop.asInstanceOf[js.Any], context.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]

@scala.inline
def isBindKey(arg: scala.Unit, name: java.lang.String): scala.Boolean = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("isBindKey")(arg.asInstanceOf[js.Any], name.asInstanceOf[js.Any])).asInstanceOf[scala.Boolean]
@scala.inline
def isBindKey(arg: typings.vueCompilerCore.mod.ExpressionNode, name: java.lang.String): scala.Boolean = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("isBindKey")(arg.asInstanceOf[js.Any], name.asInstanceOf[js.Any])).asInstanceOf[scala.Boolean]

@scala.inline
def isBuiltInType(tag: java.lang.String, expected: java.lang.String): scala.Boolean = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("isBuiltInType")(tag.asInstanceOf[js.Any], expected.asInstanceOf[js.Any])).asInstanceOf[scala.Boolean]

@scala.inline
def isCoreComponent(tag: java.lang.String): js.Symbol | scala.Unit = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("isCoreComponent")(tag.asInstanceOf[js.Any]).asInstanceOf[js.Symbol | scala.Unit]

@scala.inline
def isMemberExpression(path: java.lang.String): scala.Boolean = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("isMemberExpression")(path.asInstanceOf[js.Any]).asInstanceOf[scala.Boolean]

@scala.inline
def isSimpleIdentifier(name: java.lang.String): scala.Boolean = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("isSimpleIdentifier")(name.asInstanceOf[js.Any]).asInstanceOf[scala.Boolean]

@scala.inline
def isSlotOutlet(node: typings.vueCompilerCore.mod.RootNode): /* is @vue/compiler-core.@vue/compiler-core.SlotOutletNode */ scala.Boolean = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("isSlotOutlet")(node.asInstanceOf[js.Any]).asInstanceOf[/* is @vue/compiler-core.@vue/compiler-core.SlotOutletNode */ scala.Boolean]
@scala.inline
def isSlotOutlet(node: typings.vueCompilerCore.mod.TemplateChildNode): /* is @vue/compiler-core.@vue/compiler-core.SlotOutletNode */ scala.Boolean = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("isSlotOutlet")(node.asInstanceOf[js.Any]).asInstanceOf[/* is @vue/compiler-core.@vue/compiler-core.SlotOutletNode */ scala.Boolean]

@scala.inline
def isStaticExp(p: typings.vueCompilerCore.mod.JSChildNode): /* is @vue/compiler-core.@vue/compiler-core.SimpleExpressionNode */ scala.Boolean = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("isStaticExp")(p.asInstanceOf[js.Any]).asInstanceOf[/* is @vue/compiler-core.@vue/compiler-core.SimpleExpressionNode */ scala.Boolean]

@scala.inline
def isTemplateNode(node: typings.vueCompilerCore.mod.RootNode): /* is @vue/compiler-core.@vue/compiler-core.TemplateNode */ scala.Boolean = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("isTemplateNode")(node.asInstanceOf[js.Any]).asInstanceOf[/* is @vue/compiler-core.@vue/compiler-core.TemplateNode */ scala.Boolean]
@scala.inline
def isTemplateNode(node: typings.vueCompilerCore.mod.TemplateChildNode): /* is @vue/compiler-core.@vue/compiler-core.TemplateNode */ scala.Boolean = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("isTemplateNode")(node.asInstanceOf[js.Any]).asInstanceOf[/* is @vue/compiler-core.@vue/compiler-core.TemplateNode */ scala.Boolean]

@scala.inline
def isText(node: typings.vueCompilerCore.mod.TemplateChildNode): scala.Boolean = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("isText")(node.asInstanceOf[js.Any]).asInstanceOf[scala.Boolean]

@scala.inline
def isVSlot_0(
  p: /* import warning: importer.ImportType#apply Failed type conversion: std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode> | std.Array<@vue/compiler-core.@vue/compiler-core.AttributeNode | @vue/compiler-core.@vue/compiler-core.DirectiveNode>[0] */ js.Any
): /* is @vue/compiler-core.@vue/compiler-core.DirectiveNode */ scala.Boolean = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("isVSlot")(p.asInstanceOf[js.Any]).asInstanceOf[/* is @vue/compiler-core.@vue/compiler-core.DirectiveNode */ scala.Boolean]

@scala.inline
def locStub: typings.vueCompilerCore.mod.SourceLocation = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("locStub").asInstanceOf[typings.vueCompilerCore.mod.SourceLocation]

@scala.inline
def noopDirectiveTransform: typings.vueCompilerCore.mod.DirectiveTransform = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("noopDirectiveTransform").asInstanceOf[typings.vueCompilerCore.mod.DirectiveTransform]

@scala.inline
def processExpression(
  node: typings.vueCompilerCore.mod.SimpleExpressionNode,
  context: typings.vueCompilerCore.mod.TransformContext
): typings.vueCompilerCore.mod.ExpressionNode = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("processExpression")(node.asInstanceOf[js.Any], context.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.ExpressionNode]
@scala.inline
def processExpression(
  node: typings.vueCompilerCore.mod.SimpleExpressionNode,
  context: typings.vueCompilerCore.mod.TransformContext,
  asParams: scala.Boolean
): typings.vueCompilerCore.mod.ExpressionNode = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("processExpression")(node.asInstanceOf[js.Any], context.asInstanceOf[js.Any], asParams.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.ExpressionNode]
@scala.inline
def processExpression(
  node: typings.vueCompilerCore.mod.SimpleExpressionNode,
  context: typings.vueCompilerCore.mod.TransformContext,
  asParams: scala.Boolean,
  asRawStatements: scala.Boolean
): typings.vueCompilerCore.mod.ExpressionNode = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("processExpression")(node.asInstanceOf[js.Any], context.asInstanceOf[js.Any], asParams.asInstanceOf[js.Any], asRawStatements.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.ExpressionNode]
@scala.inline
def processExpression(
  node: typings.vueCompilerCore.mod.SimpleExpressionNode,
  context: typings.vueCompilerCore.mod.TransformContext,
  asParams: scala.Unit,
  asRawStatements: scala.Boolean
): typings.vueCompilerCore.mod.ExpressionNode = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("processExpression")(node.asInstanceOf[js.Any], context.asInstanceOf[js.Any], asParams.asInstanceOf[js.Any], asRawStatements.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.ExpressionNode]

@scala.inline
def processFor(
  node: typings.vueCompilerCore.mod.ElementNode,
  dir: typings.vueCompilerCore.mod.DirectiveNode,
  context: typings.vueCompilerCore.mod.TransformContext
): js.UndefOr[js.Function0[scala.Unit]] = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("processFor")(node.asInstanceOf[js.Any], dir.asInstanceOf[js.Any], context.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[js.Function0[scala.Unit]]]
@scala.inline
def processFor(
  node: typings.vueCompilerCore.mod.ElementNode,
  dir: typings.vueCompilerCore.mod.DirectiveNode,
  context: typings.vueCompilerCore.mod.TransformContext,
  processCodegen: js.Function1[
  /* forNode */ typings.vueCompilerCore.mod.ForNode, 
  js.UndefOr[js.Function0[scala.Unit]]
]
): js.UndefOr[js.Function0[scala.Unit]] = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("processFor")(node.asInstanceOf[js.Any], dir.asInstanceOf[js.Any], context.asInstanceOf[js.Any], processCodegen.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[js.Function0[scala.Unit]]]

@scala.inline
def processIf(
  node: typings.vueCompilerCore.mod.ElementNode,
  dir: typings.vueCompilerCore.mod.DirectiveNode,
  context: typings.vueCompilerCore.mod.TransformContext
): js.UndefOr[js.Function0[scala.Unit]] = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("processIf")(node.asInstanceOf[js.Any], dir.asInstanceOf[js.Any], context.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[js.Function0[scala.Unit]]]
@scala.inline
def processIf(
  node: typings.vueCompilerCore.mod.ElementNode,
  dir: typings.vueCompilerCore.mod.DirectiveNode,
  context: typings.vueCompilerCore.mod.TransformContext,
  processCodegen: js.Function3[
  /* node */ typings.vueCompilerCore.mod.IfNode, 
  /* branch */ typings.vueCompilerCore.mod.IfBranchNode, 
  /* isRoot */ scala.Boolean, 
  js.UndefOr[js.Function0[scala.Unit]]
]
): js.UndefOr[js.Function0[scala.Unit]] = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("processIf")(node.asInstanceOf[js.Any], dir.asInstanceOf[js.Any], context.asInstanceOf[js.Any], processCodegen.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[js.Function0[scala.Unit]]]

@scala.inline
def processSlotOutlet(
  node: typings.vueCompilerCore.mod.SlotOutletNode,
  context: typings.vueCompilerCore.mod.TransformContext
): typings.vueCompilerCore.mod.SlotOutletProcessResult = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("processSlotOutlet")(node.asInstanceOf[js.Any], context.asInstanceOf[js.Any])).asInstanceOf[typings.vueCompilerCore.mod.SlotOutletProcessResult]

@scala.inline
def registerRuntimeHelpers(helpers: js.Any): scala.Unit = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("registerRuntimeHelpers")(helpers.asInstanceOf[js.Any]).asInstanceOf[scala.Unit]

@scala.inline
def resolveComponentType(
  node: typings.vueCompilerCore.mod.ComponentNode,
  context: typings.vueCompilerCore.mod.TransformContext
): java.lang.String | js.Symbol | typings.vueCompilerCore.mod.CallExpression = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("resolveComponentType")(node.asInstanceOf[js.Any], context.asInstanceOf[js.Any])).asInstanceOf[java.lang.String | js.Symbol | typings.vueCompilerCore.mod.CallExpression]
@scala.inline
def resolveComponentType(
  node: typings.vueCompilerCore.mod.ComponentNode,
  context: typings.vueCompilerCore.mod.TransformContext,
  ssr: scala.Boolean
): java.lang.String | js.Symbol | typings.vueCompilerCore.mod.CallExpression = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("resolveComponentType")(node.asInstanceOf[js.Any], context.asInstanceOf[js.Any], ssr.asInstanceOf[js.Any])).asInstanceOf[java.lang.String | js.Symbol | typings.vueCompilerCore.mod.CallExpression]

@scala.inline
def toValidAssetId_component(name: java.lang.String, `type`: typings.vueCompilerCore.vueCompilerCoreStrings.component): java.lang.String = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("toValidAssetId")(name.asInstanceOf[js.Any], `type`.asInstanceOf[js.Any])).asInstanceOf[java.lang.String]

@scala.inline
def toValidAssetId_directive(name: java.lang.String, `type`: typings.vueCompilerCore.vueCompilerCoreStrings.directive): java.lang.String = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("toValidAssetId")(name.asInstanceOf[js.Any], `type`.asInstanceOf[js.Any])).asInstanceOf[java.lang.String]

@scala.inline
def trackSlotScopes: typings.vueCompilerCore.mod.NodeTransform = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("trackSlotScopes").asInstanceOf[typings.vueCompilerCore.mod.NodeTransform]

@scala.inline
def trackVForSlotScopes: typings.vueCompilerCore.mod.NodeTransform = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("trackVForSlotScopes").asInstanceOf[typings.vueCompilerCore.mod.NodeTransform]

@scala.inline
def transform(root: typings.vueCompilerCore.mod.RootNode, options: typings.vueCompilerCore.mod.TransformOptions): scala.Unit = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("transform")(root.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]

@scala.inline
def transformBind: typings.vueCompilerCore.mod.DirectiveTransform = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("transformBind").asInstanceOf[typings.vueCompilerCore.mod.DirectiveTransform]

@scala.inline
def transformElement: typings.vueCompilerCore.mod.NodeTransform = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("transformElement").asInstanceOf[typings.vueCompilerCore.mod.NodeTransform]

@scala.inline
def transformExpression: typings.vueCompilerCore.mod.NodeTransform = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("transformExpression").asInstanceOf[typings.vueCompilerCore.mod.NodeTransform]

@scala.inline
def transformModel: typings.vueCompilerCore.mod.DirectiveTransform = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("transformModel").asInstanceOf[typings.vueCompilerCore.mod.DirectiveTransform]

@scala.inline
def transformOn: typings.vueCompilerCore.mod.DirectiveTransform = typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].selectDynamic("transformOn").asInstanceOf[typings.vueCompilerCore.mod.DirectiveTransform]

@scala.inline
def traverseNode(node: typings.vueCompilerCore.mod.RootNode, context: typings.vueCompilerCore.mod.TransformContext): scala.Unit = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("traverseNode")(node.asInstanceOf[js.Any], context.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def traverseNode(
  node: typings.vueCompilerCore.mod.TemplateChildNode,
  context: typings.vueCompilerCore.mod.TransformContext
): scala.Unit = (typings.vueCompilerCore.mod.^.asInstanceOf[js.Dynamic].applyDynamic("traverseNode")(node.asInstanceOf[js.Any], context.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]

type BindingMetadata = org.scalablytyped.runtime.StringDictionary[
typings.vueCompilerCore.vueCompilerCoreStrings.data | typings.vueCompilerCore.vueCompilerCoreStrings.props | typings.vueCompilerCore.vueCompilerCoreStrings.setup | typings.vueCompilerCore.vueCompilerCoreStrings.options]

type DirectiveTransform = js.Function4[
/* dir */ typings.vueCompilerCore.mod.DirectiveNode, 
/* node */ typings.vueCompilerCore.mod.ElementNode, 
/* context */ typings.vueCompilerCore.mod.TransformContext, 
/* augmentor */ js.UndefOr[
  js.Function1[
    /* ret */ typings.vueCompilerCore.mod.DirectiveTransformResult, 
    typings.vueCompilerCore.mod.DirectiveTransformResult
  ]
], 
typings.vueCompilerCore.mod.DirectiveTransformResult]

type HoistTransform = js.Function3[
/* children */ js.Array[typings.vueCompilerCore.mod.TemplateChildNode], 
/* context */ typings.vueCompilerCore.mod.TransformContext, 
/* parent */ typings.vueCompilerCore.mod.ParentNode2, 
scala.Unit]

type Namespace = scala.Double

type Namespaces = typings.vueCompilerCore.vueCompilerCoreNumbers.`0`

type NodeTransform = js.Function2[
/* node */ typings.vueCompilerCore.mod.RootNode | typings.vueCompilerCore.mod.TemplateChildNode, 
/* context */ typings.vueCompilerCore.mod.TransformContext, 
scala.Unit | js.Function0[scala.Unit] | js.Array[js.Function0[scala.Unit]]]

type SlotFnBuilder = js.Function3[
/* slotProps */ js.UndefOr[typings.vueCompilerCore.mod.ExpressionNode], 
/* slotChildren */ js.Array[typings.vueCompilerCore.mod.TemplateChildNode], 
/* loc */ typings.vueCompilerCore.mod.SourceLocation, 
typings.vueCompilerCore.mod.FunctionExpression]

type StructuralDirectiveTransform = js.Function3[
/* node */ typings.vueCompilerCore.mod.ElementNode, 
/* dir */ typings.vueCompilerCore.mod.DirectiveNode, 
/* context */ typings.vueCompilerCore.mod.TransformContext, 
scala.Unit | js.Function0[scala.Unit]]

type TransformPreset = js.Tuple2[
js.Array[typings.vueCompilerCore.mod.NodeTransform], 
typings.std.Record[java.lang.String, typings.vueCompilerCore.mod.DirectiveTransform]]
