package typings.antlr4

import typings.antlr4.antlr4Ints.`0`
import typings.std.Record
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object atnAtnMod {
  
  @JSImport("antlr4/atn/ATN", JSImport.Default)
  @js.native
  open class default protected ()
    extends StObject
       with ATN {
    def this(grammarType: Double, maxTokenType: Double) = this()
  }
  /* static members */
  object default {
    
    @JSImport("antlr4/atn/ATN", "default.INVALID_ALT_NUMBER")
    @js.native
    val INVALID_ALT_NUMBER: `0` = js.native
  }
  
  @js.native
  trait ATN extends StObject {
    
    def addState(state: typings.antlr4.stateAtnstateMod.default): Unit = js.native
    
    /**
      * Each subrule/rule is a decision point and we must track them so we
      * can go back later and build DFA predictors for them.  This includes
      * all the rules, subrules, optional blocks, ()+, ()* etc...
      */
    var decisionToState: js.Array[typings.antlr4.stateDecisionStateMod.default] = js.native
    
    def defineDecisionState(s: typings.antlr4.stateDecisionStateMod.default): Double = js.native
    
    def getDecisionState(decision: Double): typings.antlr4.stateDecisionStateMod.default = js.native
    
    /**
      * Computes the set of input symbols which could follow ATN state number
      * `stateNumber` in the specified full `context`. This method
      * considers the complete parser context, but does not evaluate semantic
      * predicates (i.e. all predicates encountered during the calculation are
      * assumed true). If a path in the ATN exists from the starting state to the
      * {@link RuleStopState} of the outermost context without matching any
      * symbols, {@link Token.EOF} is added to the returned set.
      *
      * If `context` is `null`, it is treated as {@link ParserRuleContext.EMPTY}.
      *
      * @param stateNumber the ATN state number
      * @param ctx the full parse context
      *
      * @return The set of potentially valid input symbols which could follow the
      * specified state in the specified context.
      */
    def getExpectedTokens(stateNumber: Double, ctx: typings.antlr4.contextRuleContextMod.default): typings.antlr4.miscIntervalSetMod.default = js.native
    
    /**
      * Used for runtime deserialization of ATNs from strings
      * The type of the ATN.
      */
    var grammarType: Double = js.native
    
    /**
      * For lexer ATNs, this is an array of {@link LexerAction} objects which may
      * be referenced by action transitions in the ATN
      */
    var lexerActions: js.Array[typings.antlr4.actionLexerActionMod.default] = js.native
    
    var maxTokenType: Double = js.native
    
    var modeNameToStartState: Record[String, typings.antlr4.stateTokensStartStateMod.default] = js.native
    
    var modeToStartState: js.Array[typings.antlr4.stateTokensStartStateMod.default] = js.native
    
    def nextTokens(s: typings.antlr4.stateAtnstateMod.default): typings.antlr4.miscIntervalSetMod.default = js.native
    def nextTokens(s: typings.antlr4.stateAtnstateMod.default, ctx: typings.antlr4.contextRuleContextMod.default): typings.antlr4.miscIntervalSetMod.default = js.native
    
    /**
      * Compute the set of valid tokens that can occur starting in state `s`.
      * If `ctx` is null, the set of tokens will not include what can follow
      * the rule surrounding `s`. In other words, the set will be
      * restricted to tokens reachable staying within `s`'s rule
      */
    def nextTokensInContext(s: typings.antlr4.stateAtnstateMod.default): typings.antlr4.miscIntervalSetMod.default = js.native
    def nextTokensInContext(s: typings.antlr4.stateAtnstateMod.default, ctx: typings.antlr4.contextRuleContextMod.default): typings.antlr4.miscIntervalSetMod.default = js.native
    
    /**
      * Compute the set of valid tokens that can occur starting in `s` and
      * staying in same rule. {@link Token.EPSILON} is in set if we reach end of
      * rule
      */
    def nextTokensNoContext(s: typings.antlr4.stateAtnstateMod.default): typings.antlr4.miscIntervalSetMod.default = js.native
    
    def removeState(state: typings.antlr4.stateAtnstateMod.default): Unit = js.native
    
    var ruleToStartState: js.Array[typings.antlr4.stateRuleStartStateMod.default] = js.native
    
    var ruleToStopState: js.Array[typings.antlr4.stateRuleStopStateMod.default] = js.native
    
    /**
      * For lexer ATNs, this maps the rule index to the resulting token type.
      * For parser ATNs, this maps the rule index to the generated bypass token
      * type if the {@link ATNDeserializationOptions.isGenerateRuleBypassTransitions}
      * deserialization option was specified; otherwise, this is `null`
      */
    var ruleToTokenType: js.Array[Double] = js.native
    
    var states: js.Array[Double] = js.native
  }
}
